var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = false;
$jscomp.ASSUME_NO_NATIVE_MAP = false;
$jscomp.ASSUME_NO_NATIVE_SET = false;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || typeof Object.defineProperties == 'function' ? Object.defineProperty : function(target, property, descriptor) {
  descriptor = descriptor;
  if (target == Array.prototype || target == Object.prototype) {
    return;
  }
  target[property] = descriptor.value;
};
$jscomp.getGlobal = function(maybeGlobal) {
  return typeof window != 'undefined' && window === maybeGlobal ? maybeGlobal : typeof global != 'undefined' && global != null ? global : maybeGlobal;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function(target, polyfill, fromLang, toLang) {
  if (!polyfill) {
    return;
  }
  var obj = $jscomp.global;
  var split = target.split('.');
  for (var i = 0; i < split.length - 1; i++) {
    var key = split[i];
    if (!(key in obj)) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  var property = split[split.length - 1];
  var orig = obj[property];
  var impl = polyfill(orig);
  if (impl == orig || impl == null) {
    return;
  }
  $jscomp.defineProperty(obj, property, {configurable:true, writable:true, value:impl});
};
$jscomp.polyfill('Array.prototype.copyWithin', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, start, opt_end) {
    var len = this.length;
    target = Number(target);
    start = Number(start);
    opt_end = Number(opt_end != null ? opt_end : len);
    if (target < start) {
      opt_end = Math.min(opt_end, len);
      while (start < opt_end) {
        if (start in this) {
          this[target++] = this[start++];
        } else {
          delete this[target++];
          start++;
        }
      }
    } else {
      opt_end = Math.min(opt_end, len + start - target);
      target += opt_end - start;
      while (opt_end > start) {
        if (--opt_end in this) {
          this[--target] = this[opt_end];
        } else {
          delete this[target];
        }
      }
    }
    return this;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.SYMBOL_PREFIX = 'jscomp_symbol_';
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  if (!$jscomp.global['Symbol']) {
    $jscomp.global['Symbol'] = $jscomp.Symbol;
  }
};
$jscomp.Symbol = function() {
  var counter = 0;
  function Symbol(opt_description) {
    return $jscomp.SYMBOL_PREFIX + (opt_description || '') + counter++;
  }
  return Symbol;
}();
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var symbolIterator = $jscomp.global['Symbol'].iterator;
  if (!symbolIterator) {
    symbolIterator = $jscomp.global['Symbol'].iterator = $jscomp.global['Symbol']('iterator');
  }
  if (typeof Array.prototype[symbolIterator] != 'function') {
    $jscomp.defineProperty(Array.prototype, symbolIterator, {configurable:true, writable:true, value:function() {
      return $jscomp.arrayIterator(this);
    }});
  }
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.arrayIterator = function(array) {
  var index = 0;
  return $jscomp.iteratorPrototype(function() {
    if (index < array.length) {
      return {done:false, value:array[index++]};
    } else {
      return {done:true};
    }
  });
};
$jscomp.iteratorPrototype = function(next) {
  $jscomp.initSymbolIterator();
  var iterator = {next:next};
  iterator[$jscomp.global['Symbol'].iterator] = function() {
    return this;
  };
  return iterator;
};
$jscomp.iteratorFromArray = function(array, transform) {
  $jscomp.initSymbolIterator();
  if (array instanceof String) {
    array = array + '';
  }
  var i = 0;
  var iter = {next:function() {
    if (i < array.length) {
      var index = i++;
      return {value:transform(index, array[index]), done:false};
    }
    iter.next = function() {
      return {done:true, value:void 0};
    };
    return iter.next();
  }};
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  iter[Symbol.iterator] = function() {
    return iter;
  };
  return iter;
};
$jscomp.polyfill('Array.prototype.entries', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(i, v) {
      return [i, v];
    });
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.fill', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(value, opt_start, opt_end) {
    var length = this.length || 0;
    if (opt_start < 0) {
      opt_start = Math.max(0, length + opt_start);
    }
    if (opt_end == null || opt_end > length) {
      opt_end = length;
    }
    opt_end = Number(opt_end);
    if (opt_end < 0) {
      opt_end = Math.max(0, length + opt_end);
    }
    for (var i = Number(opt_start || 0); i < opt_end; i++) {
      this[i] = value;
    }
    return this;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.findInternal = function(array, callback, thisArg) {
  if (array instanceof String) {
    array = String(array);
  }
  var len = array.length;
  for (var i = 0; i < len; i++) {
    var value = array[i];
    if (callback.call(thisArg, value, i, array)) {
      return {i:i, v:value};
    }
  }
  return {i:-1, v:void 0};
};
$jscomp.polyfill('Array.prototype.find', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(callback, opt_thisArg) {
    return $jscomp.findInternal(this, callback, opt_thisArg).v;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.findIndex', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(callback, opt_thisArg) {
    return $jscomp.findInternal(this, callback, opt_thisArg).i;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.from', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(arrayLike, opt_mapFn, opt_thisArg) {
    $jscomp.initSymbolIterator();
    opt_mapFn = opt_mapFn != null ? opt_mapFn : function(x) {
      return x;
    };
    var result = [];
    $jscomp.initSymbol();
    $jscomp.initSymbolIterator();
    var iteratorFunction = arrayLike[Symbol.iterator];
    if (typeof iteratorFunction == 'function') {
      arrayLike = iteratorFunction.call(arrayLike);
      var next;
      var k = 0;
      while (!(next = arrayLike.next()).done) {
        result.push(opt_mapFn.call(opt_thisArg, next.value, k++));
      }
    } else {
      var len = arrayLike.length;
      for (var i = 0; i < len; i++) {
        result.push(opt_mapFn.call(opt_thisArg, arrayLike[i], i));
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Object.is', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(left, right) {
    if (left === right) {
      return left !== 0 || 1 / left === 1 / right;
    } else {
      return left !== left && right !== right;
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.includes', function(orig) {
  if (orig) {
    return orig;
  }
  var includes = function(searchElement, opt_fromIndex) {
    var array = this;
    if (array instanceof String) {
      array = String(array);
    }
    var len = array.length;
    var i = opt_fromIndex || 0;
    if (i < 0) {
      i = Math.max(i + len, 0);
    }
    for (; i < len; i++) {
      var element = array[i];
      if (element === searchElement || Object.is(element, searchElement)) {
        return true;
      }
    }
    return false;
  };
  return includes;
}, 'es7', 'es3');
$jscomp.polyfill('Array.prototype.keys', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(i) {
      return i;
    });
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.of', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(var_args) {
    return Array.from(arguments);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.values', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(k, v) {
      return v;
    });
  };
  return polyfill;
}, 'es8', 'es3');
$jscomp.makeIterator = function(iterable) {
  $jscomp.initSymbolIterator();
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var iteratorFunction = iterable[Symbol.iterator];
  return iteratorFunction ? iteratorFunction.call(iterable) : $jscomp.arrayIterator(iterable);
};
$jscomp.FORCE_POLYFILL_PROMISE = false;
$jscomp.polyfill('Promise', function(NativePromise) {
  if (NativePromise && !$jscomp.FORCE_POLYFILL_PROMISE) {
    return NativePromise;
  }
  function AsyncExecutor() {
    this.batch_ = null;
  }
  AsyncExecutor.prototype.asyncExecute = function(f) {
    if (this.batch_ == null) {
      this.batch_ = [];
      this.asyncExecuteBatch_();
    }
    this.batch_.push(f);
    return this;
  };
  AsyncExecutor.prototype.asyncExecuteBatch_ = function() {
    var self = this;
    this.asyncExecuteFunction(function() {
      self.executeBatch_();
    });
  };
  var nativeSetTimeout = $jscomp.global['setTimeout'];
  AsyncExecutor.prototype.asyncExecuteFunction = function(f) {
    nativeSetTimeout(f, 0);
  };
  AsyncExecutor.prototype.executeBatch_ = function() {
    while (this.batch_ && this.batch_.length) {
      var executingBatch = this.batch_;
      this.batch_ = [];
      for (var i = 0; i < executingBatch.length; ++i) {
        var f = executingBatch[i];
        executingBatch[i] = null;
        try {
          f();
        } catch (error) {
          this.asyncThrow_(error);
        }
      }
    }
    this.batch_ = null;
  };
  AsyncExecutor.prototype.asyncThrow_ = function(exception) {
    this.asyncExecuteFunction(function() {
      throw exception;
    });
  };
  var PromiseState = {PENDING:0, FULFILLED:1, REJECTED:2};
  var PolyfillPromise = function(executor) {
    this.state_ = PromiseState.PENDING;
    this.result_ = undefined;
    this.onSettledCallbacks_ = [];
    var resolveAndReject = this.createResolveAndReject_();
    try {
      executor(resolveAndReject.resolve, resolveAndReject.reject);
    } catch (e) {
      resolveAndReject.reject(e);
    }
  };
  PolyfillPromise.prototype.createResolveAndReject_ = function() {
    var thisPromise = this;
    var alreadyCalled = false;
    function firstCallWins(method) {
      return function(x) {
        if (!alreadyCalled) {
          alreadyCalled = true;
          method.call(thisPromise, x);
        }
      };
    }
    return {resolve:firstCallWins(this.resolveTo_), reject:firstCallWins(this.reject_)};
  };
  PolyfillPromise.prototype.resolveTo_ = function(value) {
    if (value === this) {
      this.reject_(new TypeError('A Promise cannot resolve to itself'));
    } else {
      if (value instanceof PolyfillPromise) {
        this.settleSameAsPromise_(value);
      } else {
        if (isObject(value)) {
          this.resolveToNonPromiseObj_(value);
        } else {
          this.fulfill_(value);
        }
      }
    }
  };
  PolyfillPromise.prototype.resolveToNonPromiseObj_ = function(obj) {
    var thenMethod = undefined;
    try {
      thenMethod = obj.then;
    } catch (error) {
      this.reject_(error);
      return;
    }
    if (typeof thenMethod == 'function') {
      this.settleSameAsThenable_(thenMethod, obj);
    } else {
      this.fulfill_(obj);
    }
  };
  function isObject(value) {
    switch(typeof value) {
      case 'object':
        return value != null;
      case 'function':
        return true;
      default:
        return false;
    }
  }
  PolyfillPromise.prototype.reject_ = function(reason) {
    this.settle_(PromiseState.REJECTED, reason);
  };
  PolyfillPromise.prototype.fulfill_ = function(value) {
    this.settle_(PromiseState.FULFILLED, value);
  };
  PolyfillPromise.prototype.settle_ = function(settledState, valueOrReason) {
    if (this.state_ != PromiseState.PENDING) {
      throw new Error('Cannot settle(' + settledState + ', ' + valueOrReason + '): Promise already settled in state' + this.state_);
    }
    this.state_ = settledState;
    this.result_ = valueOrReason;
    this.executeOnSettledCallbacks_();
  };
  PolyfillPromise.prototype.executeOnSettledCallbacks_ = function() {
    if (this.onSettledCallbacks_ != null) {
      for (var i = 0; i < this.onSettledCallbacks_.length; ++i) {
        asyncExecutor.asyncExecute(this.onSettledCallbacks_[i]);
      }
      this.onSettledCallbacks_ = null;
    }
  };
  var asyncExecutor = new AsyncExecutor;
  PolyfillPromise.prototype.settleSameAsPromise_ = function(promise) {
    var methods = this.createResolveAndReject_();
    promise.callWhenSettled_(methods.resolve, methods.reject);
  };
  PolyfillPromise.prototype.settleSameAsThenable_ = function(thenMethod, thenable) {
    var methods = this.createResolveAndReject_();
    try {
      thenMethod.call(thenable, methods.resolve, methods.reject);
    } catch (error) {
      methods.reject(error);
    }
  };
  PolyfillPromise.prototype.then = function(onFulfilled, onRejected) {
    var resolveChild;
    var rejectChild;
    var childPromise = new PolyfillPromise(function(resolve, reject) {
      resolveChild = resolve;
      rejectChild = reject;
    });
    function createCallback(paramF, defaultF) {
      if (typeof paramF == 'function') {
        return function(x) {
          try {
            resolveChild(paramF(x));
          } catch (error) {
            rejectChild(error);
          }
        };
      } else {
        return defaultF;
      }
    }
    this.callWhenSettled_(createCallback(onFulfilled, resolveChild), createCallback(onRejected, rejectChild));
    return childPromise;
  };
  PolyfillPromise.prototype['catch'] = function(onRejected) {
    return this.then(undefined, onRejected);
  };
  PolyfillPromise.prototype.callWhenSettled_ = function(onFulfilled, onRejected) {
    var thisPromise = this;
    function callback() {
      switch(thisPromise.state_) {
        case PromiseState.FULFILLED:
          onFulfilled(thisPromise.result_);
          break;
        case PromiseState.REJECTED:
          onRejected(thisPromise.result_);
          break;
        default:
          throw new Error('Unexpected state: ' + thisPromise.state_);
      }
    }
    if (this.onSettledCallbacks_ == null) {
      asyncExecutor.asyncExecute(callback);
    } else {
      this.onSettledCallbacks_.push(callback);
    }
  };
  function resolvingPromise(opt_value) {
    if (opt_value instanceof PolyfillPromise) {
      return opt_value;
    } else {
      return new PolyfillPromise(function(resolve, reject) {
        resolve(opt_value);
      });
    }
  }
  PolyfillPromise['resolve'] = resolvingPromise;
  PolyfillPromise['reject'] = function(opt_reason) {
    return new PolyfillPromise(function(resolve, reject) {
      reject(opt_reason);
    });
  };
  PolyfillPromise['race'] = function(thenablesOrValues) {
    return new PolyfillPromise(function(resolve, reject) {
      var iterator = $jscomp.makeIterator(thenablesOrValues);
      for (var iterRec = iterator.next(); !iterRec.done; iterRec = iterator.next()) {
        resolvingPromise(iterRec.value).callWhenSettled_(resolve, reject);
      }
    });
  };
  PolyfillPromise['all'] = function(thenablesOrValues) {
    var iterator = $jscomp.makeIterator(thenablesOrValues);
    var iterRec = iterator.next();
    if (iterRec.done) {
      return resolvingPromise([]);
    } else {
      return new PolyfillPromise(function(resolveAll, rejectAll) {
        var resultsArray = [];
        var unresolvedCount = 0;
        function onFulfilled(i) {
          return function(ithResult) {
            resultsArray[i] = ithResult;
            unresolvedCount--;
            if (unresolvedCount == 0) {
              resolveAll(resultsArray);
            }
          };
        }
        do {
          resultsArray.push(undefined);
          unresolvedCount++;
          resolvingPromise(iterRec.value).callWhenSettled_(onFulfilled(resultsArray.length - 1), rejectAll);
          iterRec = iterator.next();
        } while (!iterRec.done);
      });
    }
  };
  return PolyfillPromise;
}, 'es6', 'es3');
$jscomp.polyfill('Promise.prototype.finally', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(onFinally) {
    return this.then(function(value) {
      var promise = Promise.resolve(onFinally());
      return promise.then(function() {
        return value;
      });
    }, function(reason) {
      var promise = Promise.resolve(onFinally());
      return promise.then(function() {
        throw reason;
      });
    });
  };
  return polyfill;
}, 'es9', 'es3');
$jscomp.underscoreProtoCanBeSet = function() {
  var x = {a:true};
  var y = {};
  try {
    y.__proto__ = x;
    return y.a;
  } catch (e) {
  }
  return false;
};
$jscomp.setPrototypeOf = typeof Object.setPrototypeOf == 'function' ? Object.setPrototypeOf : $jscomp.underscoreProtoCanBeSet() ? function(target, proto) {
  target.__proto__ = proto;
  if (target.__proto__ !== proto) {
    throw new TypeError(target + ' is not extensible');
  }
  return target;
} : null;
$jscomp.generator = {};
$jscomp.generator.ensureIteratorResultIsObject_ = function(result) {
  if (result instanceof Object) {
    return;
  }
  throw new TypeError('Iterator result ' + result + ' is not an object');
};
$jscomp.generator.Context = function() {
  this.isRunning_ = false;
  this.yieldAllIterator_ = null;
  this.yieldResult = undefined;
  this.nextAddress = 1;
  this.catchAddress_ = 0;
  this.finallyAddress_ = 0;
  this.abruptCompletion_ = null;
  this.finallyContexts_ = null;
};
$jscomp.generator.Context.prototype.start_ = function() {
  if (this.isRunning_) {
    throw new TypeError('Generator is already running');
  }
  this.isRunning_ = true;
};
$jscomp.generator.Context.prototype.stop_ = function() {
  this.isRunning_ = false;
};
$jscomp.generator.Context.prototype.jumpToErrorHandler_ = function() {
  this.nextAddress = this.catchAddress_ || this.finallyAddress_;
};
$jscomp.generator.Context.prototype.next_ = function(value) {
  this.yieldResult = value;
};
$jscomp.generator.Context.prototype.throw_ = function(e) {
  this.abruptCompletion_ = {exception:e, isException:true};
  this.jumpToErrorHandler_();
};
$jscomp.generator.Context.prototype['return'] = function(value) {
  this.abruptCompletion_ = {'return':value};
  this.nextAddress = this.finallyAddress_;
};
$jscomp.generator.Context.prototype.jumpThroughFinallyBlocks = function(nextAddress) {
  this.abruptCompletion_ = {jumpTo:nextAddress};
  this.nextAddress = this.finallyAddress_;
};
$jscomp.generator.Context.prototype.yield = function(value, resumeAddress) {
  this.nextAddress = resumeAddress;
  return {value:value};
};
$jscomp.generator.Context.prototype.yieldAll = function(iterable, resumeAddress) {
  var iterator = $jscomp.makeIterator(iterable);
  var result = iterator.next();
  $jscomp.generator.ensureIteratorResultIsObject_(result);
  if (result.done) {
    this.yieldResult = result.value;
    this.nextAddress = resumeAddress;
    return;
  }
  this.yieldAllIterator_ = iterator;
  return this.yield(result.value, resumeAddress);
};
$jscomp.generator.Context.prototype.jumpTo = function(nextAddress) {
  this.nextAddress = nextAddress;
};
$jscomp.generator.Context.prototype.jumpToEnd = function() {
  this.nextAddress = 0;
};
$jscomp.generator.Context.prototype.setCatchFinallyBlocks = function(catchAddress, finallyAddress) {
  this.catchAddress_ = catchAddress;
  if (finallyAddress != undefined) {
    this.finallyAddress_ = finallyAddress;
  }
};
$jscomp.generator.Context.prototype.setFinallyBlock = function(finallyAddress) {
  this.catchAddress_ = 0;
  this.finallyAddress_ = finallyAddress || 0;
};
$jscomp.generator.Context.prototype.leaveTryBlock = function(nextAddress, catchAddress) {
  this.nextAddress = nextAddress;
  this.catchAddress_ = catchAddress || 0;
};
$jscomp.generator.Context.prototype.enterCatchBlock = function(nextCatchBlockAddress) {
  this.catchAddress_ = nextCatchBlockAddress || 0;
  var exception = this.abruptCompletion_.exception;
  this.abruptCompletion_ = null;
  return exception;
};
$jscomp.generator.Context.prototype.enterFinallyBlock = function(nextCatchAddress, nextFinallyAddress, finallyDepth) {
  if (!finallyDepth) {
    this.finallyContexts_ = [this.abruptCompletion_];
  } else {
    this.finallyContexts_[finallyDepth] = this.abruptCompletion_;
  }
  this.catchAddress_ = nextCatchAddress || 0;
  this.finallyAddress_ = nextFinallyAddress || 0;
};
$jscomp.generator.Context.prototype.leaveFinallyBlock = function(nextAddress, finallyDepth) {
  var preservedContext = this.finallyContexts_.splice(finallyDepth || 0)[0];
  var abruptCompletion = this.abruptCompletion_ = this.abruptCompletion_ || preservedContext;
  if (abruptCompletion) {
    if (abruptCompletion.isException) {
      return this.jumpToErrorHandler_();
    }
    if (abruptCompletion.jumpTo != undefined && this.finallyAddress_ < abruptCompletion.jumpTo) {
      this.nextAddress = abruptCompletion.jumpTo;
      this.abruptCompletion_ = null;
    } else {
      this.nextAddress = this.finallyAddress_;
    }
  } else {
    this.nextAddress = nextAddress;
  }
};
$jscomp.generator.Context.prototype.forIn = function(object) {
  return new $jscomp.generator.Context.PropertyIterator(object);
};
$jscomp.generator.Context.PropertyIterator = function(object) {
  this.object_ = object;
  this.properties_ = [];
  for (var property in object) {
    this.properties_.push(property);
  }
  this.properties_.reverse();
};
$jscomp.generator.Context.PropertyIterator.prototype.getNext = function() {
  while (this.properties_.length > 0) {
    var property = this.properties_.pop();
    if (property in this.object_) {
      return property;
    }
  }
  return null;
};
$jscomp.generator.Engine_ = function(program) {
  this.context_ = new $jscomp.generator.Context;
  this.program_ = program;
};
$jscomp.generator.Engine_.prototype.next_ = function(value) {
  this.context_.start_();
  if (this.context_.yieldAllIterator_) {
    return this.yieldAllStep_(this.context_.yieldAllIterator_.next, value, this.context_.next_);
  }
  this.context_.next_(value);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.return_ = function(value) {
  this.context_.start_();
  var yieldAllIterator = this.context_.yieldAllIterator_;
  if (yieldAllIterator) {
    var returnFunction = 'return' in yieldAllIterator ? yieldAllIterator['return'] : function(v) {
      return {value:v, done:true};
    };
    return this.yieldAllStep_(returnFunction, value, this.context_['return']);
  }
  this.context_['return'](value);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.throw_ = function(exception) {
  this.context_.start_();
  if (this.context_.yieldAllIterator_) {
    return this.yieldAllStep_(this.context_.yieldAllIterator_['throw'], exception, this.context_.next_);
  }
  this.context_.throw_(exception);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.yieldAllStep_ = function(action, value, nextAction) {
  try {
    var result = action.call(this.context_.yieldAllIterator_, value);
    $jscomp.generator.ensureIteratorResultIsObject_(result);
    if (!result.done) {
      this.context_.stop_();
      return result;
    }
    var resultValue = result.value;
  } catch (e) {
    this.context_.yieldAllIterator_ = null;
    this.context_.throw_(e);
    return this.nextStep_();
  }
  this.context_.yieldAllIterator_ = null;
  nextAction.call(this.context_, resultValue);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.nextStep_ = function() {
  while (this.context_.nextAddress) {
    try {
      var yieldValue = this.program_(this.context_);
      if (yieldValue) {
        this.context_.stop_();
        return {value:yieldValue.value, done:false};
      }
    } catch (e) {
      this.context_.yieldResult = undefined;
      this.context_.throw_(e);
    }
  }
  this.context_.stop_();
  if (this.context_.abruptCompletion_) {
    var abruptCompletion = this.context_.abruptCompletion_;
    this.context_.abruptCompletion_ = null;
    if (abruptCompletion.isException) {
      throw abruptCompletion.exception;
    }
    return {value:abruptCompletion['return'], done:true};
  }
  return {value:undefined, done:true};
};
$jscomp.generator.Generator_ = function(engine) {
  this.next = function(opt_value) {
    return engine.next_(opt_value);
  };
  this['throw'] = function(exception) {
    return engine.throw_(exception);
  };
  this['return'] = function(value) {
    return engine.return_(value);
  };
  $jscomp.initSymbolIterator();
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  this[Symbol.iterator] = function() {
    return this;
  };
};
$jscomp.generator.createGenerator = function(generator, program) {
  var result = new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(program));
  if ($jscomp.setPrototypeOf) {
    $jscomp.setPrototypeOf(result, generator.prototype);
  }
  return result;
};
$jscomp.asyncExecutePromiseGenerator = function(generator) {
  function passValueToGenerator(value) {
    return generator.next(value);
  }
  function passErrorToGenerator(error) {
    return generator['throw'](error);
  }
  return new Promise(function(resolve, reject) {
    function handleGeneratorRecord(genRec) {
      if (genRec.done) {
        resolve(genRec.value);
      } else {
        Promise.resolve(genRec.value).then(passValueToGenerator, passErrorToGenerator).then(handleGeneratorRecord, reject);
      }
    }
    handleGeneratorRecord(generator.next());
  });
};
$jscomp.asyncExecutePromiseGeneratorFunction = function(generatorFunction) {
  return $jscomp.asyncExecutePromiseGenerator(generatorFunction());
};
$jscomp.asyncExecutePromiseGeneratorProgram = function(program) {
  return $jscomp.asyncExecutePromiseGenerator(new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(program)));
};
$jscomp.checkEs6ConformanceViaProxy = function() {
  try {
    var proxied = {};
    var proxy = Object.create(new $jscomp.global['Proxy'](proxied, {'get':function(target, key, receiver) {
      return target == proxied && key == 'q' && receiver == proxy;
    }}));
    return proxy['q'] === true;
  } catch (err) {
    return false;
  }
};
$jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS = false;
$jscomp.ES6_CONFORMANCE = $jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS && $jscomp.checkEs6ConformanceViaProxy();
$jscomp.owns = function(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};
$jscomp.polyfill('WeakMap', function(NativeWeakMap) {
  function isConformant() {
    if (!NativeWeakMap || !Object.seal) {
      return false;
    }
    try {
      var x = Object.seal({});
      var y = Object.seal({});
      var map = new NativeWeakMap([[x, 2], [y, 3]]);
      if (map.get(x) != 2 || map.get(y) != 3) {
        return false;
      }
      map['delete'](x);
      map.set(y, 4);
      return !map.has(x) && map.get(y) == 4;
    } catch (err) {
      return false;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (NativeWeakMap && $jscomp.ES6_CONFORMANCE) {
      return NativeWeakMap;
    }
  } else {
    if (isConformant()) {
      return NativeWeakMap;
    }
  }
  var prop = '$jscomp_hidden_' + Math.random();
  function insert(target) {
    if (!$jscomp.owns(target, prop)) {
      var obj = {};
      $jscomp.defineProperty(target, prop, {value:obj});
    }
  }
  function patch(name) {
    var prev = Object[name];
    if (prev) {
      Object[name] = function(target) {
        insert(target);
        return prev(target);
      };
    }
  }
  patch('freeze');
  patch('preventExtensions');
  patch('seal');
  var index = 0;
  var PolyfillWeakMap = function(opt_iterable) {
    this.id_ = (index += Math.random() + 1).toString();
    if (opt_iterable) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.set(item[0], item[1]);
      }
    }
  };
  PolyfillWeakMap.prototype.set = function(key, value) {
    insert(key);
    if (!$jscomp.owns(key, prop)) {
      throw new Error('WeakMap key fail: ' + key);
    }
    key[prop][this.id_] = value;
    return this;
  };
  PolyfillWeakMap.prototype.get = function(key) {
    return $jscomp.owns(key, prop) ? key[prop][this.id_] : undefined;
  };
  PolyfillWeakMap.prototype.has = function(key) {
    return $jscomp.owns(key, prop) && $jscomp.owns(key[prop], this.id_);
  };
  PolyfillWeakMap.prototype['delete'] = function(key) {
    if (!$jscomp.owns(key, prop) || !$jscomp.owns(key[prop], this.id_)) {
      return false;
    }
    return delete key[prop][this.id_];
  };
  return PolyfillWeakMap;
}, 'es6', 'es3');
$jscomp.MapEntry = function() {
  this.previous;
  this.next;
  this.head;
  this.key;
  this.value;
};
$jscomp.polyfill('Map', function(NativeMap) {
  function isConformant() {
    if ($jscomp.ASSUME_NO_NATIVE_MAP || !NativeMap || typeof NativeMap != 'function' || !NativeMap.prototype.entries || typeof Object.seal != 'function') {
      return false;
    }
    try {
      NativeMap = NativeMap;
      var key = Object.seal({x:4});
      var map = new NativeMap($jscomp.makeIterator([[key, 's']]));
      if (map.get(key) != 's' || map.size != 1 || map.get({x:4}) || map.set({x:4}, 't') != map || map.size != 2) {
        return false;
      }
      var iter = map.entries();
      var item = iter.next();
      if (item.done || item.value[0] != key || item.value[1] != 's') {
        return false;
      }
      item = iter.next();
      if (item.done || item.value[0].x != 4 || item.value[1] != 't' || !iter.next().done) {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (NativeMap && $jscomp.ES6_CONFORMANCE) {
      return NativeMap;
    }
  } else {
    if (isConformant()) {
      return NativeMap;
    }
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var idMap = new WeakMap;
  var PolyfillMap = function(opt_iterable) {
    this.data_ = {};
    this.head_ = createHead();
    this.size = 0;
    if (opt_iterable) {
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.set(item[0], item[1]);
      }
    }
  };
  PolyfillMap.prototype.set = function(key, value) {
    key = key === 0 ? 0 : key;
    var r = maybeGetEntry(this, key);
    if (!r.list) {
      r.list = this.data_[r.id] = [];
    }
    if (!r.entry) {
      r.entry = {next:this.head_, previous:this.head_.previous, head:this.head_, key:key, value:value};
      r.list.push(r.entry);
      this.head_.previous.next = r.entry;
      this.head_.previous = r.entry;
      this.size++;
    } else {
      r.entry.value = value;
    }
    return this;
  };
  PolyfillMap.prototype['delete'] = function(key) {
    var r = maybeGetEntry(this, key);
    if (r.entry && r.list) {
      r.list.splice(r.index, 1);
      if (!r.list.length) {
        delete this.data_[r.id];
      }
      r.entry.previous.next = r.entry.next;
      r.entry.next.previous = r.entry.previous;
      r.entry.head = null;
      this.size--;
      return true;
    }
    return false;
  };
  PolyfillMap.prototype.clear = function() {
    this.data_ = {};
    this.head_ = this.head_.previous = createHead();
    this.size = 0;
  };
  PolyfillMap.prototype.has = function(key) {
    return !!maybeGetEntry(this, key).entry;
  };
  PolyfillMap.prototype.get = function(key) {
    var entry = maybeGetEntry(this, key).entry;
    return entry && entry.value;
  };
  PolyfillMap.prototype.entries = function() {
    return makeIterator(this, function(entry) {
      return [entry.key, entry.value];
    });
  };
  PolyfillMap.prototype.keys = function() {
    return makeIterator(this, function(entry) {
      return entry.key;
    });
  };
  PolyfillMap.prototype.values = function() {
    return makeIterator(this, function(entry) {
      return entry.value;
    });
  };
  PolyfillMap.prototype.forEach = function(callback, opt_thisArg) {
    var iter = this.entries();
    var item;
    while (!(item = iter.next()).done) {
      var entry = item.value;
      callback.call(opt_thisArg, entry[1], entry[0], this);
    }
  };
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  PolyfillMap.prototype[Symbol.iterator] = PolyfillMap.prototype.entries;
  var maybeGetEntry = function(map, key) {
    var id = getId(key);
    var list = map.data_[id];
    if (list && $jscomp.owns(map.data_, id)) {
      for (var index = 0; index < list.length; index++) {
        var entry = list[index];
        if (key !== key && entry.key !== entry.key || key === entry.key) {
          return {id:id, list:list, index:index, entry:entry};
        }
      }
    }
    return {id:id, list:list, index:-1, entry:undefined};
  };
  var makeIterator = function(map, func) {
    var entry = map.head_;
    return $jscomp.iteratorPrototype(function() {
      if (entry) {
        while (entry.head != map.head_) {
          entry = entry.previous;
        }
        while (entry.next != entry.head) {
          entry = entry.next;
          return {done:false, value:func(entry)};
        }
        entry = null;
      }
      return {done:true, value:void 0};
    });
  };
  var createHead = function() {
    var head = {};
    head.previous = head.next = head.head = head;
    return head;
  };
  var mapIndex = 0;
  var getId = function(obj) {
    var type = obj && typeof obj;
    if (type == 'object' || type == 'function') {
      obj = obj;
      if (!idMap.has(obj)) {
        var id = '' + ++mapIndex;
        idMap.set(obj, id);
        return id;
      }
      return idMap.get(obj);
    }
    return 'p_' + obj;
  };
  return PolyfillMap;
}, 'es6', 'es3');
$jscomp.polyfill('Math.acosh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    return Math.log(x + Math.sqrt(x * x - 1));
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.asinh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    var y = Math.log(Math.abs(x) + Math.sqrt(x * x + 1));
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log1p', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x < 0.25 && x > -0.25) {
      var y = x;
      var d = 1;
      var z = x;
      var zPrev = 0;
      var s = 1;
      while (zPrev != z) {
        y *= x;
        s *= -1;
        z = (zPrev = z) + s * y / ++d;
      }
      return z;
    }
    return Math.log(1 + x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.atanh', function(orig) {
  if (orig) {
    return orig;
  }
  var log1p = Math.log1p;
  var polyfill = function(x) {
    x = Number(x);
    return (log1p(x) - log1p(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.cbrt', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (x === 0) {
      return x;
    }
    x = Number(x);
    var y = Math.pow(Math.abs(x), 1 / 3);
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.clz32', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x) >>> 0;
    if (x === 0) {
      return 32;
    }
    var result = 0;
    if ((x & 4294901760) === 0) {
      x <<= 16;
      result += 16;
    }
    if ((x & 4278190080) === 0) {
      x <<= 8;
      result += 8;
    }
    if ((x & 4026531840) === 0) {
      x <<= 4;
      result += 4;
    }
    if ((x & 3221225472) === 0) {
      x <<= 2;
      result += 2;
    }
    if ((x & 2147483648) === 0) {
      result++;
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.cosh', function(orig) {
  if (orig) {
    return orig;
  }
  var exp = Math.exp;
  var polyfill = function(x) {
    x = Number(x);
    return (exp(x) + exp(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.expm1', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x < .25 && x > -.25) {
      var y = x;
      var d = 1;
      var z = x;
      var zPrev = 0;
      while (zPrev != z) {
        y *= x / ++d;
        z = (zPrev = z) + y;
      }
      return z;
    }
    return Math.exp(x) - 1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.hypot', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x, y, var_args) {
    x = Number(x);
    y = Number(y);
    var i, z, sum;
    var max = Math.max(Math.abs(x), Math.abs(y));
    for (i = 2; i < arguments.length; i++) {
      max = Math.max(max, Math.abs(arguments[i]));
    }
    if (max > 1e100 || max < 1e-100) {
      if (!max) {
        return max;
      }
      x = x / max;
      y = y / max;
      sum = x * x + y * y;
      for (i = 2; i < arguments.length; i++) {
        z = Number(arguments[i]) / max;
        sum += z * z;
      }
      return Math.sqrt(sum) * max;
    } else {
      sum = x * x + y * y;
      for (i = 2; i < arguments.length; i++) {
        z = Number(arguments[i]);
        sum += z * z;
      }
      return Math.sqrt(sum);
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.imul', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(a, b) {
    a = Number(a);
    b = Number(b);
    var ah = a >>> 16 & 65535;
    var al = a & 65535;
    var bh = b >>> 16 & 65535;
    var bl = b & 65535;
    var lh = ah * bl + al * bh << 16 >>> 0;
    return al * bl + lh | 0;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log10', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Math.log(x) / Math.LN10;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log2', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Math.log(x) / Math.LN2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.sign', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    return x === 0 || isNaN(x) ? x : x > 0 ? 1 : -1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.sinh', function(orig) {
  if (orig) {
    return orig;
  }
  var exp = Math.exp;
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    return (exp(x) - exp(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.tanh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    var y = Math.exp(-2 * Math.abs(x));
    var z = (1 - y) / (1 + y);
    return x < 0 ? -z : z;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.trunc', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (isNaN(x) || x === Infinity || x === -Infinity || x === 0) {
      return x;
    }
    var y = Math.floor(Math.abs(x));
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.EPSILON', function(orig) {
  return Math.pow(2, -52);
}, 'es6', 'es3');
$jscomp.polyfill('Number.MAX_SAFE_INTEGER', function() {
  return 9007199254740991;
}, 'es6', 'es3');
$jscomp.polyfill('Number.MIN_SAFE_INTEGER', function() {
  return -9007199254740991;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isFinite', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (typeof x !== 'number') {
      return false;
    }
    return !isNaN(x) && x !== Infinity && x !== -Infinity;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isInteger', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (!Number.isFinite(x)) {
      return false;
    }
    return x === Math.floor(x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isNaN', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return typeof x === 'number' && isNaN(x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isSafeInteger', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Number.isInteger(x) && Math.abs(x) <= Number.MAX_SAFE_INTEGER;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.parseFloat', function(orig) {
  return orig || parseFloat;
}, 'es6', 'es3');
$jscomp.polyfill('Number.parseInt', function(orig) {
  return orig || parseInt;
}, 'es6', 'es3');
$jscomp.assign = typeof Object.assign == 'function' ? Object.assign : function(target, var_args) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    if (!source) {
      continue;
    }
    for (var key in source) {
      if ($jscomp.owns(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
$jscomp.polyfill('Object.assign', function(orig) {
  return orig || $jscomp.assign;
}, 'es6', 'es3');
$jscomp.polyfill('Object.entries', function(orig) {
  if (orig) {
    return orig;
  }
  var entries = function(obj) {
    var result = [];
    for (var key in obj) {
      if ($jscomp.owns(obj, key)) {
        result.push([key, obj[key]]);
      }
    }
    return result;
  };
  return entries;
}, 'es8', 'es3');
$jscomp.polyfill('Object.getOwnPropertySymbols', function(orig) {
  if (orig) {
    return orig;
  }
  return function() {
    return [];
  };
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.ownKeys', function(orig) {
  if (orig) {
    return orig;
  }
  var symbolPrefix = 'jscomp_symbol_';
  function isSymbol(key) {
    return key.substring(0, symbolPrefix.length) == symbolPrefix;
  }
  var polyfill = function(target) {
    var keys = [];
    var names = Object.getOwnPropertyNames(target);
    var symbols = Object.getOwnPropertySymbols(target);
    for (var i = 0; i < names.length; i++) {
      (isSymbol(names[i]) ? symbols : keys).push(names[i]);
    }
    return keys.concat(symbols);
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Object.getOwnPropertyDescriptors', function(orig) {
  if (orig) {
    return orig;
  }
  var getOwnPropertyDescriptors = function(obj) {
    var result = {};
    var keys = Reflect.ownKeys(obj);
    for (var i = 0; i < keys.length; i++) {
      result[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return result;
  };
  return getOwnPropertyDescriptors;
}, 'es8', 'es5');
$jscomp.polyfill('Object.setPrototypeOf', function(orig) {
  return orig || $jscomp.setPrototypeOf;
}, 'es6', 'es5');
$jscomp.polyfill('Object.values', function(orig) {
  if (orig) {
    return orig;
  }
  var values = function(obj) {
    var result = [];
    for (var key in obj) {
      if ($jscomp.owns(obj, key)) {
        result.push(obj[key]);
      }
    }
    return result;
  };
  return values;
}, 'es8', 'es3');
$jscomp.polyfill('Reflect.apply', function(orig) {
  if (orig) {
    return orig;
  }
  var apply = Function.prototype.apply;
  var polyfill = function(target, thisArg, argList) {
    return apply.call(target, thisArg, argList);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.objectCreate = $jscomp.ASSUME_ES5 || typeof Object.create == 'function' ? Object.create : function(prototype) {
  var ctor = function() {
  };
  ctor.prototype = prototype;
  return new ctor;
};
$jscomp.construct = function() {
  function reflectConstructWorks() {
    function Base() {
    }
    function Derived() {
    }
    new Base;
    Reflect.construct(Base, [], Derived);
    return new Base instanceof Base;
  }
  if (typeof Reflect != 'undefined' && Reflect.construct) {
    if (reflectConstructWorks()) {
      return Reflect.construct;
    }
    var brokenConstruct = Reflect.construct;
    var patchedConstruct = function(target, argList, opt_newTarget) {
      var out = brokenConstruct(target, argList);
      if (opt_newTarget) {
        Reflect.setPrototypeOf(out, opt_newTarget.prototype);
      }
      return out;
    };
    return patchedConstruct;
  }
  function construct(target, argList, opt_newTarget) {
    if (opt_newTarget === undefined) {
      opt_newTarget = target;
    }
    var proto = opt_newTarget.prototype || Object.prototype;
    var obj = $jscomp.objectCreate(proto);
    var apply = Function.prototype.apply;
    var out = apply.call(target, obj, argList);
    return out || obj;
  }
  return construct;
}();
$jscomp.polyfill('Reflect.construct', function(orig) {
  return $jscomp.construct;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.defineProperty', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, attributes) {
    try {
      Object.defineProperty(target, propertyKey, attributes);
      var desc = Object.getOwnPropertyDescriptor(target, propertyKey);
      if (!desc) {
        return false;
      }
      return desc.configurable === (attributes.configurable || false) && desc.enumerable === (attributes.enumerable || false) && ('value' in desc ? desc.value === attributes.value && desc.writable === (attributes.writable || false) : desc.get === attributes.get && desc.set === attributes.set);
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.deleteProperty', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey) {
    if (!$jscomp.owns(target, propertyKey)) {
      return true;
    }
    try {
      return delete target[propertyKey];
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.getOwnPropertyDescriptor', function(orig) {
  return orig || Object.getOwnPropertyDescriptor;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.getPrototypeOf', function(orig) {
  return orig || Object.getPrototypeOf;
}, 'es6', 'es5');
$jscomp.findDescriptor = function(target, propertyKey) {
  var obj = target;
  while (obj) {
    var property = Reflect.getOwnPropertyDescriptor(obj, propertyKey);
    if (property) {
      return property;
    }
    obj = Reflect.getPrototypeOf(obj);
  }
  return undefined;
};
$jscomp.polyfill('Reflect.get', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, opt_receiver) {
    if (arguments.length <= 2) {
      return target[propertyKey];
    }
    var property = $jscomp.findDescriptor(target, propertyKey);
    if (property) {
      return property.get ? property.get.call(opt_receiver) : property.value;
    }
    return undefined;
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.has', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey) {
    return propertyKey in target;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.isExtensible', function(orig) {
  if (orig) {
    return orig;
  }
  if ($jscomp.ASSUME_ES5 || typeof Object.isExtensible == 'function') {
    return Object.isExtensible;
  }
  return function() {
    return true;
  };
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.preventExtensions', function(orig) {
  if (orig) {
    return orig;
  }
  if (!($jscomp.ASSUME_ES5 || typeof Object.preventExtensions == 'function')) {
    return function() {
      return false;
    };
  }
  var polyfill = function(target) {
    Object.preventExtensions(target);
    return !Object.isExtensible(target);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.set', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, value, opt_receiver) {
    var property = $jscomp.findDescriptor(target, propertyKey);
    if (!property) {
      if (Reflect.isExtensible(target)) {
        target[propertyKey] = value;
        return true;
      }
      return false;
    }
    if (property.set) {
      property.set.call(arguments.length > 3 ? opt_receiver : target, value);
      return true;
    } else {
      if (property.writable && !Object.isFrozen(target)) {
        target[propertyKey] = value;
        return true;
      }
    }
    return false;
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.setPrototypeOf', function(orig) {
  if (orig) {
    return orig;
  } else {
    if ($jscomp.setPrototypeOf) {
      var setPrototypeOf = $jscomp.setPrototypeOf;
      var polyfill = function(target, proto) {
        try {
          setPrototypeOf(target, proto);
          return true;
        } catch (e) {
          return false;
        }
      };
      return polyfill;
    } else {
      return null;
    }
  }
}, 'es6', 'es5');
$jscomp.polyfill('Set', function(NativeSet) {
  function isConformant() {
    if ($jscomp.ASSUME_NO_NATIVE_SET || !NativeSet || typeof NativeSet != 'function' || !NativeSet.prototype.entries || typeof Object.seal != 'function') {
      return false;
    }
    try {
      NativeSet = NativeSet;
      var value = Object.seal({x:4});
      var set = new NativeSet($jscomp.makeIterator([value]));
      if (!set.has(value) || set.size != 1 || set.add(value) != set || set.size != 1 || set.add({x:4}) != set || set.size != 2) {
        return false;
      }
      var iter = set.entries();
      var item = iter.next();
      if (item.done || item.value[0] != value || item.value[1] != value) {
        return false;
      }
      item = iter.next();
      if (item.done || item.value[0] == value || item.value[0].x != 4 || item.value[1] != item.value[0]) {
        return false;
      }
      return iter.next().done;
    } catch (err) {
      return false;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (NativeSet && $jscomp.ES6_CONFORMANCE) {
      return NativeSet;
    }
  } else {
    if (isConformant()) {
      return NativeSet;
    }
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var PolyfillSet = function(opt_iterable) {
    this.map_ = new Map;
    if (opt_iterable) {
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.add(item);
      }
    }
    this.size = this.map_.size;
  };
  PolyfillSet.prototype.add = function(value) {
    value = value === 0 ? 0 : value;
    this.map_.set(value, value);
    this.size = this.map_.size;
    return this;
  };
  PolyfillSet.prototype['delete'] = function(value) {
    var result = this.map_['delete'](value);
    this.size = this.map_.size;
    return result;
  };
  PolyfillSet.prototype.clear = function() {
    this.map_.clear();
    this.size = 0;
  };
  PolyfillSet.prototype.has = function(value) {
    return this.map_.has(value);
  };
  PolyfillSet.prototype.entries = function() {
    return this.map_.entries();
  };
  PolyfillSet.prototype.values = function() {
    return this.map_.values();
  };
  PolyfillSet.prototype.keys = PolyfillSet.prototype.values;
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  PolyfillSet.prototype[Symbol.iterator] = PolyfillSet.prototype.values;
  PolyfillSet.prototype.forEach = function(callback, opt_thisArg) {
    var set = this;
    this.map_.forEach(function(value) {
      return callback.call(opt_thisArg, value, value, set);
    });
  };
  return PolyfillSet;
}, 'es6', 'es3');
$jscomp.checkStringArgs = function(thisArg, arg, func) {
  if (thisArg == null) {
    throw new TypeError("The 'this' value for String.prototype." + func + ' must not be null or undefined');
  }
  if (arg instanceof RegExp) {
    throw new TypeError('First argument to String.prototype.' + func + ' must not be a regular expression');
  }
  return thisArg + '';
};
$jscomp.polyfill('String.prototype.codePointAt', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(position) {
    var string = $jscomp.checkStringArgs(this, null, 'codePointAt');
    var size = string.length;
    position = Number(position) || 0;
    if (!(position >= 0 && position < size)) {
      return void 0;
    }
    position = position | 0;
    var first = string.charCodeAt(position);
    if (first < 55296 || first > 56319 || position + 1 === size) {
      return first;
    }
    var second = string.charCodeAt(position + 1);
    if (second < 56320 || second > 57343) {
      return first;
    }
    return (first - 55296) * 1024 + second + 9216;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.endsWith', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'endsWith');
    searchString = searchString + '';
    if (opt_position === void 0) {
      opt_position = string.length;
    }
    var i = Math.max(0, Math.min(opt_position | 0, string.length));
    var j = searchString.length;
    while (j > 0 && i > 0) {
      if (string[--i] != searchString[--j]) {
        return false;
      }
    }
    return j <= 0;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.fromCodePoint', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(var_args) {
    var result = '';
    for (var i = 0; i < arguments.length; i++) {
      var code = Number(arguments[i]);
      if (code < 0 || code > 1114111 || code !== Math.floor(code)) {
        throw new RangeError('invalid_code_point ' + code);
      }
      if (code <= 65535) {
        result += String.fromCharCode(code);
      } else {
        code -= 65536;
        result += String.fromCharCode(code >>> 10 & 1023 | 55296);
        result += String.fromCharCode(code & 1023 | 56320);
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.includes', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'includes');
    return string.indexOf(searchString, opt_position || 0) !== -1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.repeat', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(copies) {
    var string = $jscomp.checkStringArgs(this, null, 'repeat');
    if (copies < 0 || copies > 1342177279) {
      throw new RangeError('Invalid count value');
    }
    copies = copies | 0;
    var result = '';
    while (copies) {
      if (copies & 1) {
        result += string;
      }
      if (copies >>>= 1) {
        string += string;
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.stringPadding = function(padString, padLength) {
  var padding = padString !== undefined ? String(padString) : ' ';
  if (!(padLength > 0) || !padding) {
    return '';
  }
  var repeats = Math.ceil(padLength / padding.length);
  return padding.repeat(repeats).substring(0, padLength);
};
$jscomp.polyfill('String.prototype.padEnd', function(orig) {
  if (orig) {
    return orig;
  }
  var padEnd = function(targetLength, opt_padString) {
    var string = $jscomp.checkStringArgs(this, null, 'padStart');
    var padLength = targetLength - string.length;
    return string + $jscomp.stringPadding(opt_padString, padLength);
  };
  return padEnd;
}, 'es8', 'es3');
$jscomp.polyfill('String.prototype.padStart', function(orig) {
  if (orig) {
    return orig;
  }
  var padStart = function(targetLength, opt_padString) {
    var string = $jscomp.checkStringArgs(this, null, 'padStart');
    var padLength = targetLength - string.length;
    return $jscomp.stringPadding(opt_padString, padLength) + string;
  };
  return padStart;
}, 'es8', 'es3');
$jscomp.polyfill('String.prototype.startsWith', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'startsWith');
    searchString = searchString + '';
    var strLen = string.length;
    var searchLen = searchString.length;
    var i = Math.max(0, Math.min(opt_position | 0, string.length));
    var j = 0;
    while (j < searchLen && i < strLen) {
      if (string[i++] != searchString[j++]) {
        return false;
      }
    }
    return j >= searchLen;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.arrayFromIterator = function(iterator) {
  var i;
  var arr = [];
  while (!(i = iterator.next()).done) {
    arr.push(i.value);
  }
  return arr;
};
$jscomp.arrayFromIterable = function(iterable) {
  if (iterable instanceof Array) {
    return iterable;
  } else {
    return $jscomp.arrayFromIterator($jscomp.makeIterator(iterable));
  }
};
$jscomp.inherits = function(childCtor, parentCtor) {
  childCtor.prototype = $jscomp.objectCreate(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
  if ($jscomp.setPrototypeOf) {
    var setPrototypeOf = $jscomp.setPrototypeOf;
    setPrototypeOf(childCtor, parentCtor);
  } else {
    for (var p in parentCtor) {
      if (p == 'prototype') {
        continue;
      }
      if (Object.defineProperties) {
        var descriptor = Object.getOwnPropertyDescriptor(parentCtor, p);
        if (descriptor) {
          Object.defineProperty(childCtor, p, descriptor);
        }
      } else {
        childCtor[p] = parentCtor[p];
      }
    }
  }
  childCtor.superClass_ = parentCtor.prototype;
};
$jscomp.polyfill('WeakSet', function(NativeWeakSet) {
  function isConformant() {
    if (!NativeWeakSet || !Object.seal) {
      return false;
    }
    try {
      var x = Object.seal({});
      var y = Object.seal({});
      var set = new NativeWeakSet([x]);
      if (!set.has(x) || set.has(y)) {
        return false;
      }
      set['delete'](x);
      set.add(y);
      return !set.has(x) && set.has(y);
    } catch (err) {
      return false;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (NativeWeakSet && $jscomp.ES6_CONFORMANCE) {
      return NativeWeakSet;
    }
  } else {
    if (isConformant()) {
      return NativeWeakSet;
    }
  }
  var PolyfillWeakSet = function(opt_iterable) {
    this.map_ = new WeakMap;
    if (opt_iterable) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.add(item);
      }
    }
  };
  PolyfillWeakSet.prototype.add = function(elem) {
    this.map_.set(elem, true);
    return this;
  };
  PolyfillWeakSet.prototype.has = function(elem) {
    return this.map_.has(elem);
  };
  PolyfillWeakSet.prototype['delete'] = function(elem) {
    return this.map_['delete'](elem);
  };
  return PolyfillWeakSet;
}, 'es6', 'es3');
try {
  if (Array.prototype.values.toString().indexOf('[native code]') == -1) {
    delete Array.prototype.values;
  }
} catch (e) {
}
var Ext = Ext || {};
if (!Ext.Picker) {
  Ext.Picker = {};
}
if (!Ext.app) {
  Ext.app = {};
}
if (!Ext.behavior) {
  Ext.behavior = {};
}
if (!Ext.data) {
  Ext.data = {};
}
if (!Ext.data.association) {
  Ext.data.association = {};
}
if (!Ext.data.identifier) {
  Ext.data.identifier = {};
}
if (!Ext.data.proxy) {
  Ext.data.proxy = {};
}
if (!Ext.data.reader) {
  Ext.data.reader = {};
}
if (!Ext.data.writer) {
  Ext.data.writer = {};
}
if (!Ext.dataview) {
  Ext.dataview = {};
}
if (!Ext.dataview.component) {
  Ext.dataview.component = {};
}
if (!Ext.dataview.element) {
  Ext.dataview.element = {};
}
if (!Ext.direct) {
  Ext.direct = {};
}
if (!Ext.dom) {
  Ext.dom = {};
}
if (!Ext.draw) {
  Ext.draw = {};
}
if (!Ext.draw.engine) {
  Ext.draw.engine = {};
}
if (!Ext.draw.engine.SvgContext) {
  Ext.draw.engine.SvgContext = {};
}
if (!Ext.draw.gradient) {
  Ext.draw.gradient = {};
}
if (!Ext.draw.modifier) {
  Ext.draw.modifier = {};
}
if (!Ext.draw.sprite) {
  Ext.draw.sprite = {};
}
if (!Ext.env) {
  Ext.env = {};
}
if (!Ext.event) {
  Ext.event = {};
}
if (!Ext.event.publisher) {
  Ext.event.publisher = {};
}
if (!Ext.event.recognizer) {
  Ext.event.recognizer = {};
}
if (!Ext.field) {
  Ext.field = {};
}
if (!Ext.form) {
  Ext.form = {};
}
if (!Ext.fx) {
  Ext.fx = {};
}
if (!Ext.fx.animation) {
  Ext.fx.animation = {};
}
if (!Ext.fx.easing) {
  Ext.fx.easing = {};
}
if (!Ext.fx.layout) {
  Ext.fx.layout = {};
}
if (!Ext.fx.layout.card) {
  Ext.fx.layout.card = {};
}
if (!Ext.fx.runner) {
  Ext.fx.runner = {};
}
if (!Ext.layout) {
  Ext.layout = {};
}
if (!Ext.layout.wrapper) {
  Ext.layout.wrapper = {};
}
if (!Ext.lib) {
  Ext.lib = {};
}
if (!Ext.mixin) {
  Ext.mixin = {};
}
if (!Ext.navigation) {
  Ext.navigation = {};
}
if (!Ext.picker) {
  Ext.picker = {};
}
if (!Ext.plugin) {
  Ext.plugin = {};
}
if (!Ext.proxy) {
  Ext.proxy = {};
}
if (!Ext.scroll) {
  Ext.scroll = {};
}
if (!Ext.scroll.indicator) {
  Ext.scroll.indicator = {};
}
if (!Ext.slider) {
  Ext.slider = {};
}
if (!Ext.tab) {
  Ext.tab = {};
}
if (!Ext.util) {
  Ext.util = {};
}
if (!Ext.util.paintmonitor) {
  Ext.util.paintmonitor = {};
}
if (!Ext.util.sizemonitor) {
  Ext.util.sizemonitor = {};
}
if (!Ext.util.translatable) {
  Ext.util.translatable = {};
}
if (!Ext.viewport) {
  Ext.viewport = {};
}
var Xedu = Xedu || {};
if (!Xedu.controller) {
  Xedu.controller = {};
}
if (!Xedu.field) {
  Xedu.field = {};
}
if (!Xedu.model) {
  Xedu.model = {};
}
if (!Xedu.override) {
  Xedu.override = {};
}
if (!Xedu.store) {
  Xedu.store = {};
}
if (!Xedu.ux) {
  Xedu.ux = {};
}
if (!Xedu.ux.field) {
  Xedu.ux.field = {};
}
if (!Xedu.ux.picker) {
  Xedu.ux.picker = {};
}
if (!Xedu.view) {
  Xedu.view = {};
}
if (!Xedu.view.chapter) {
  Xedu.view.chapter = {};
}
if (!Xedu.view.classroom) {
  Xedu.view.classroom = {};
}
if (!Xedu.view.config) {
  Xedu.view.config = {};
}
if (!Xedu.view.course) {
  Xedu.view.course = {};
}
if (!Xedu.view.main) {
  Xedu.view.main = {};
}
if (!Xedu.view.schedule) {
  Xedu.view.schedule = {};
}
if (!Xedu.view.session) {
  Xedu.view.session = {};
}
if (!Xedu.view.slides) {
  Xedu.view.slides = {};
}
if (!Xedu.view.topic) {
  Xedu.view.topic = {};
}
if (!Xedu.view.users) {
  Xedu.view.users = {};
}
(function(ExtCmd) {
  var baseStaticMembers, enumerables = ['constructor', 'toString', 'valueOf', 'toLocaleString'], enumerablesMap = {}, enumerablesObj = {}, enumerablesMask = 0, baseStaticMember, Base, ClassManager, Class, configPreFn, cachedConfigPreFn, platformConfigPostFn, platformConfigPreFn, deprecatedPostFn, privatesPreFn, v5ClassSystem, thunk = function() {
    var i, mask;
    Base = Ext.Base;
    ClassManager = Ext.ClassManager;
    Class = Ext.Class;
    for (i = enumerables.length; i-- > 0;) {
      mask = 1 << i;
      enumerablesObj[enumerablesMap[mask] = enumerables[i]] = mask;
    }
    for (i in enumerablesObj) {
      enumerablesMask |= enumerablesObj[i];
    }
    enumerablesMask = ~enumerablesMask;
    Function.prototype.$isFunction = 1;
    v5ClassSystem = !!ClassManager.addAlias;
    configPreFn = Class.getPreprocessor('config').fn;
    cachedConfigPreFn = Class.getPreprocessor('cachedConfig');
    cachedConfigPreFn = cachedConfigPreFn && cachedConfigPreFn.fn;
    privatesPreFn = Class.getPreprocessor('privates');
    privatesPreFn = privatesPreFn && privatesPreFn.fn;
    platformConfigPreFn = Class.getPreprocessor('platformConfig');
    platformConfigPreFn = platformConfigPreFn && platformConfigPreFn.fn;
    platformConfigPostFn = ClassManager.postprocessors.platformConfig;
    platformConfigPostFn = platformConfigPostFn && platformConfigPostFn.fn;
    deprecatedPostFn = ClassManager.postprocessors.deprecated;
    deprecatedPostFn = deprecatedPostFn && deprecatedPostFn.fn;
    baseStaticMembers = Base.$staticMembers;
    if (!baseStaticMembers) {
      baseStaticMembers = [];
      for (baseStaticMember in Base) {
        if (Base.hasOwnProperty(baseStaticMember)) {
          baseStaticMembers.push(baseStaticMember);
        }
      }
    }
    ExtCmd.derive = derive;
    return derive.apply(this, arguments);
  }, onBeforeCreated = function(cls, data, hooks) {
    var enumerableMembers = hooks.enumerableMembers, proto = cls.prototype, member, fn, which, val, existing;
    if (!data) {
      return;
    }
    if (v5ClassSystem) {
      cls.addMembers(data);
    } else {
      for (member in data) {
        val = data[member];
        if (val && val.$isFunction && !val.$isClass && val !== Ext.emptyFn && val !== Ext.identityFn) {
          existing = proto.hasOwnProperty(member) && proto[member];
          if (existing) {
            val.$previous = existing;
          }
          proto[member] = fn = val;
          fn.$owner = cls;
          fn.$name = member;
        } else {
          proto[member] = val;
        }
      }
      for (which = 1; enumerableMembers; which <<= 1) {
        if (enumerableMembers & which) {
          enumerableMembers &= ~which;
          member = enumerablesMap[which];
          proto[member] = fn = data[member];
          fn.$owner = cls;
          fn.$name = member;
        }
      }
    }
    if (data.platformConfig && platformConfigPostFn) {
      platformConfigPostFn.call(ClassManager, cls.$className, cls, data);
    }
    if (data.deprecated && deprecatedPostFn) {
      deprecatedPostFn.call(ClassManager, cls.$className, cls, data);
    }
  }, derive = function(className, base, data, enumerableMembers, xtypes, xtypesChain, xtypeMap, aliases, mixins, names, createdFn) {
    var cls = function ctor() {
      return this.constructor.apply(this, arguments) || null;
    }, ret = cls, hooks = {enumerableMembers:enumerableMembers & enumerablesMask, onCreated:createdFn, onBeforeCreated:onBeforeCreated, aliases:aliases}, alternates = data.alternateClassName || [], global = Ext.global, alias, alternate, i, ln, n, ns, name, proto, statics, staticMember, targetName, fn, val, altToName = ClassManager.alternateToName || ClassManager.maps.alternateToName, nameToAlt = ClassManager.nameToAlternates || ClassManager.maps.nameToAlternates;
    for (i = baseStaticMembers.length; i-- > 0;) {
      name = baseStaticMembers[i];
      cls[name] = Base[name];
    }
    if (data.$isFunction) {
      data = data(cls);
    }
    hooks.data = data;
    statics = data.statics;
    delete data.statics;
    data.$className = className;
    if ('$className' in data) {
      cls.$className = data.$className;
    }
    cls.extend(base);
    proto = cls.prototype;
    if (xtypes) {
      cls.xtype = data.xtype = xtypes[0];
      proto.xtypes = xtypes;
    }
    proto.xtypesChain = xtypesChain;
    proto.xtypesMap = xtypeMap;
    data.alias = aliases;
    ret.triggerExtended(cls, data, hooks);
    if (data.onClassExtended) {
      cls.onExtended(data.onClassExtended, cls);
      delete data.onClassExtended;
    }
    if (data.privates && privatesPreFn) {
      privatesPreFn.call(Class, cls, data);
    }
    if (statics) {
      if (v5ClassSystem) {
        cls.addStatics(statics);
      } else {
        for (staticMember in statics) {
          if (statics.hasOwnProperty(staticMember)) {
            val = statics[staticMember];
            if (val && val.$isFunction && !val.$isClass && val !== Ext.emptyFn && val !== Ext.identityFn) {
              cls[staticMember] = fn = val;
              fn.$owner = cls;
              fn.$name = staticMember;
            }
            cls[staticMember] = val;
          }
        }
      }
    }
    if (data.inheritableStatics) {
      cls.addInheritableStatics(data.inheritableStatics);
      delete data.inheritableStatics;
    }
    if (proto.onClassExtended) {
      ret.onExtended(proto.onClassExtended, ret);
      delete proto.onClassExtended;
    }
    if (data.platformConfig && platformConfigPreFn) {
      platformConfigPreFn.call(Class, cls, data);
      delete data.platformConfig;
    }
    if (data.config) {
      configPreFn.call(Class, cls, data);
    }
    if (data.cachedConfig && cachedConfigPreFn) {
      cachedConfigPreFn.call(Class, cls, data);
      delete data.cachedConfig;
    }
    hooks.onBeforeCreated(cls, hooks.data, hooks);
    for (i = 0, n = mixins && mixins.length; i < n; ++i) {
      cls.mixin.apply(cls, mixins[i]);
    }
    for (i = 0, n = aliases.length; i < n; i++) {
      alias = aliases[i];
      ClassManager.setAlias ? ClassManager.setAlias(cls, alias) : ClassManager.addAlias(cls, alias);
    }
    if (data.singleton) {
      ret = new cls;
    }
    if (!(alternates instanceof Array)) {
      alternates = [alternates];
    }
    targetName = ClassManager.getName(ret);
    for (i = 0, ln = alternates.length; i < ln; i++) {
      alternate = alternates[i];
      ClassManager.classes[alternate] = ret;
      if (v5ClassSystem) {
        ClassManager.addAlternate(cls, alternate);
      } else {
        if (targetName) {
          altToName[alternate] = targetName;
          alternates = nameToAlt[targetName] || (nameToAlt[targetName] = []);
          alternates.push(alternate);
        }
      }
    }
    for (i = 0, n = names.length; i < n; i += 2) {
      ns = names[i];
      if (!ns) {
        ns = global;
      }
      ns[names[i + 1]] = ret;
    }
    ClassManager.classes[className] = ret;
    if (!v5ClassSystem) {
      if (targetName && targetName !== className) {
        altToName[className] = targetName;
        alternates = nameToAlt[targetName] || (nameToAlt[targetName] = []);
        alternates.push(className);
      }
    }
    delete proto.alternateClassName;
    if (hooks.onCreated) {
      hooks.onCreated.call(ret, ret);
    }
    if (className) {
      ClassManager.triggerCreated(className);
    }
    return ret;
  };
  ExtCmd.derive = thunk;
})(Ext.cmd = {});
(function() {
  var global = this, objectPrototype = Object.prototype, toString = objectPrototype.toString, enumerables = true, enumerablesTest = {toString:1}, emptyFn = function() {
  }, i;
  if (typeof Ext === 'undefined') {
    global.Ext = {};
  }
  Ext.global = global;
  for (i in enumerablesTest) {
    enumerables = null;
  }
  if (enumerables) {
    enumerables = ['hasOwnProperty', 'valueOf', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'constructor'];
  }
  Ext.enumerables = enumerables;
  Ext.apply = function(object, config, defaults) {
    if (defaults) {
      Ext.apply(object, defaults);
    }
    if (object && config && typeof config === 'object') {
      var i, j, k;
      for (i in config) {
        object[i] = config[i];
      }
      if (enumerables) {
        for (j = enumerables.length; j--;) {
          k = enumerables[j];
          if (config.hasOwnProperty(k)) {
            object[k] = config[k];
          }
        }
      }
    }
    return object;
  };
  Ext.buildSettings = Ext.apply({baseCSSPrefix:'x-', scopeResetCSS:false}, Ext.buildSettings || {});
  Ext.apply(Ext, {emptyFn:emptyFn, baseCSSPrefix:Ext.buildSettings.baseCSSPrefix, applyIf:function(object, config) {
    var property;
    if (object) {
      for (property in config) {
        if (object[property] === undefined) {
          object[property] = config[property];
        }
      }
    }
    return object;
  }, iterate:function(object, fn, scope) {
    if (Ext.isEmpty(object)) {
      return;
    }
    if (scope === undefined) {
      scope = object;
    }
    if (Ext.isIterable(object)) {
      Ext.Array.each.call(Ext.Array, object, fn, scope);
    } else {
      Ext.Object.each.call(Ext.Object, object, fn, scope);
    }
  }});
  Ext.apply(Ext, {extend:function() {
    var objectConstructor = objectPrototype.constructor, inlineOverrides = function(o) {
      for (var m in o) {
        if (!o.hasOwnProperty(m)) {
          continue;
        }
        this[m] = o[m];
      }
    };
    return function(subclass, superclass, overrides) {
      if (Ext.isObject(superclass)) {
        overrides = superclass;
        superclass = subclass;
        subclass = overrides.constructor !== objectConstructor ? overrides.constructor : function() {
          superclass.apply(this, arguments);
        };
      }
      var F = function() {
      }, subclassProto, superclassProto = superclass.prototype;
      F.prototype = superclassProto;
      subclassProto = subclass.prototype = new F;
      subclassProto.constructor = subclass;
      subclass.superclass = superclassProto;
      if (superclassProto.constructor === objectConstructor) {
        superclassProto.constructor = superclass;
      }
      subclass.override = function(overrides) {
        Ext.override(subclass, overrides);
      };
      subclassProto.override = inlineOverrides;
      subclassProto.proto = subclassProto;
      subclass.override(overrides);
      subclass.extend = function(o) {
        return Ext.extend(subclass, o);
      };
      return subclass;
    };
  }(), override:function(cls, overrides) {
    if (cls.$isClass) {
      return cls.override(overrides);
    } else {
      Ext.apply(cls.prototype, overrides);
    }
  }});
  Ext.apply(Ext, {valueFrom:function(value, defaultValue, allowBlank) {
    return Ext.isEmpty(value, allowBlank) ? defaultValue : value;
  }, typeOf:function(value) {
    if (value === null) {
      return 'null';
    }
    var type = typeof value;
    if (type === 'undefined' || type === 'string' || type === 'number' || type === 'boolean') {
      return type;
    }
    var typeToString = toString.call(value);
    switch(typeToString) {
      case '[object Array]':
        return 'array';
      case '[object Date]':
        return 'date';
      case '[object Boolean]':
        return 'boolean';
      case '[object Number]':
        return 'number';
      case '[object RegExp]':
        return 'regexp';
    }
    if (type === 'function') {
      return 'function';
    }
    if (type === 'object') {
      if (value.nodeType !== undefined) {
        if (value.nodeType === 3) {
          return /\S/.test(value.nodeValue) ? 'textnode' : 'whitespace';
        } else {
          return 'element';
        }
      }
      return 'object';
    }
  }, isEmpty:function(value, allowEmptyString) {
    return value === null || value === undefined || (!allowEmptyString ? value === '' : false) || Ext.isArray(value) && value.length === 0;
  }, isArray:'isArray' in Array ? Array.isArray : function(value) {
    return toString.call(value) === '[object Array]';
  }, isDate:function(value) {
    return toString.call(value) === '[object Date]';
  }, isMSDate:function(value) {
    if (!Ext.isString(value)) {
      return false;
    } else {
      return value.match('\\\\?/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\\\?/') !== null;
    }
  }, isObject:toString.call(null) === '[object Object]' ? function(value) {
    return value !== null && value !== undefined && toString.call(value) === '[object Object]' && value.ownerDocument === undefined;
  } : function(value) {
    return toString.call(value) === '[object Object]';
  }, isSimpleObject:function(value) {
    return value instanceof Object && value.constructor === Object;
  }, isPrimitive:function(value) {
    var type = typeof value;
    return type === 'string' || type === 'number' || type === 'boolean';
  }, isFunction:typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function' ? function(value) {
    return toString.call(value) === '[object Function]';
  } : function(value) {
    return typeof value === 'function';
  }, isNumber:function(value) {
    return typeof value === 'number' && isFinite(value);
  }, isNumeric:function(value) {
    return !isNaN(parseFloat(value)) && isFinite(value);
  }, isString:function(value) {
    return typeof value === 'string';
  }, isBoolean:function(value) {
    return typeof value === 'boolean';
  }, isElement:function(value) {
    return value ? value.nodeType === 1 : false;
  }, isTextNode:function(value) {
    return value ? value.nodeName === '#text' : false;
  }, isDefined:function(value) {
    return typeof value !== 'undefined';
  }, isIterable:function(value) {
    return value && typeof value !== 'string' ? value.length !== undefined : false;
  }});
  Ext.apply(Ext, {clone:function(item) {
    if (item === null || item === undefined) {
      return item;
    }
    if (item.nodeType && item.cloneNode) {
      return item.cloneNode(true);
    }
    var type = toString.call(item);
    if (type === '[object Date]') {
      return new Date(item.getTime());
    }
    var i, j, k, clone, key;
    if (type === '[object Array]') {
      i = item.length;
      clone = [];
      while (i--) {
        clone[i] = Ext.clone(item[i]);
      }
    } else {
      if (type === '[object Object]' && item.constructor === Object) {
        clone = {};
        for (key in item) {
          clone[key] = Ext.clone(item[key]);
        }
        if (enumerables) {
          for (j = enumerables.length; j--;) {
            k = enumerables[j];
            clone[k] = item[k];
          }
        }
      }
    }
    return clone || item;
  }, getUniqueGlobalNamespace:function() {
    var uniqueGlobalNamespace = this.uniqueGlobalNamespace;
    if (uniqueGlobalNamespace === undefined) {
      var i = 0;
      do {
        uniqueGlobalNamespace = 'ExtBox' + ++i;
      } while (Ext.global[uniqueGlobalNamespace] !== undefined);
      Ext.global[uniqueGlobalNamespace] = Ext;
      this.uniqueGlobalNamespace = uniqueGlobalNamespace;
    }
    return uniqueGlobalNamespace;
  }, functionFactory:function() {
    var args = Array.prototype.slice.call(arguments), ln = args.length;
    if (ln > 0) {
      args[ln - 1] = 'var Ext\x3dwindow.' + this.getUniqueGlobalNamespace() + ';' + args[ln - 1];
    }
    return Function.prototype.constructor.apply(Function.prototype, args);
  }, globalEval:'execScript' in global ? function(code) {
    global.execScript(code);
  } : function(code) {
    (function() {
      eval(code);
    })();
  }});
  Ext.type = Ext.typeOf;
})();
(function() {
  var version = '2.4.2.571', Version;
  Ext.Version = Version = Ext.extend(Object, {constructor:function(version) {
    var toNumber = this.toNumber, parts, releaseStartIndex;
    if (version instanceof Version) {
      return version;
    }
    this.version = this.shortVersion = String(version).toLowerCase().replace(/_/g, '.').replace(/[\-+]/g, '');
    releaseStartIndex = this.version.search(/([^\d\.])/);
    if (releaseStartIndex !== -1) {
      this.release = this.version.substr(releaseStartIndex, version.length);
      this.shortVersion = this.version.substr(0, releaseStartIndex);
    }
    this.shortVersion = this.shortVersion.replace(/[^\d]/g, '');
    parts = this.version.split('.');
    this.major = toNumber(parts.shift());
    this.minor = toNumber(parts.shift());
    this.patch = toNumber(parts.shift());
    this.build = toNumber(parts.shift());
    return this;
  }, toNumber:function(value) {
    value = parseInt(value || 0, 10);
    if (isNaN(value)) {
      value = 0;
    }
    return value;
  }, toString:function() {
    return this.version;
  }, valueOf:function() {
    return this.version;
  }, getMajor:function() {
    return this.major || 0;
  }, getMinor:function() {
    return this.minor || 0;
  }, getPatch:function() {
    return this.patch || 0;
  }, getBuild:function() {
    return this.build || 0;
  }, getRelease:function() {
    return this.release || '';
  }, isGreaterThan:function(target) {
    return Version.compare(this.version, target) === 1;
  }, isGreaterThanOrEqual:function(target) {
    return Version.compare(this.version, target) >= 0;
  }, isLessThan:function(target) {
    return Version.compare(this.version, target) === -1;
  }, isLessThanOrEqual:function(target) {
    return Version.compare(this.version, target) <= 0;
  }, equals:function(target) {
    return Version.compare(this.version, target) === 0;
  }, match:function(target) {
    target = String(target);
    return this.version.substr(0, target.length) === target;
  }, toArray:function() {
    return [this.getMajor(), this.getMinor(), this.getPatch(), this.getBuild(), this.getRelease()];
  }, getShortVersion:function() {
    return this.shortVersion;
  }, gt:function() {
    return this.isGreaterThan.apply(this, arguments);
  }, lt:function() {
    return this.isLessThan.apply(this, arguments);
  }, gtEq:function() {
    return this.isGreaterThanOrEqual.apply(this, arguments);
  }, ltEq:function() {
    return this.isLessThanOrEqual.apply(this, arguments);
  }});
  Ext.apply(Version, {releaseValueMap:{'dev':-6, 'alpha':-5, 'a':-5, 'beta':-4, 'b':-4, 'rc':-3, '#':-2, 'p':-1, 'pl':-1}, getComponentValue:function(value) {
    return !value ? 0 : isNaN(value) ? this.releaseValueMap[value] || value : parseInt(value, 10);
  }, compare:function(current, target) {
    var currentValue, targetValue, i;
    current = (new Version(current)).toArray();
    target = (new Version(target)).toArray();
    for (i = 0; i < Math.max(current.length, target.length); i++) {
      currentValue = this.getComponentValue(current[i]);
      targetValue = this.getComponentValue(target[i]);
      if (currentValue < targetValue) {
        return -1;
      } else {
        if (currentValue > targetValue) {
          return 1;
        }
      }
    }
    return 0;
  }});
  Ext.apply(Ext, {versions:{}, lastRegisteredVersion:null, setVersion:function(packageName, version) {
    Ext.versions[packageName] = new Version(version);
    Ext.lastRegisteredVersion = Ext.versions[packageName];
    return this;
  }, getVersion:function(packageName) {
    if (packageName === undefined) {
      return Ext.lastRegisteredVersion;
    }
    return Ext.versions[packageName];
  }, deprecate:function(packageName, since, closure, scope) {
    if (Version.compare(Ext.getVersion(packageName), since) < 1) {
      closure.call(scope);
    }
  }});
  Ext.setVersion('core', version);
})();
Ext.String = {trimRegex:/^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g, escapeRe:/('|\\)/g, formatRe:/\{(\d+)\}/g, escapeRegexRe:/([-.*+?^${}()|[\]\/\\])/g, htmlEncode:function() {
  var entities = {'\x26':'\x26amp;', '\x3e':'\x26gt;', '\x3c':'\x26lt;', '"':'\x26quot;'}, keys = [], p, regex;
  for (p in entities) {
    keys.push(p);
  }
  regex = new RegExp('(' + keys.join('|') + ')', 'g');
  return function(value) {
    return !value ? value : String(value).replace(regex, function(match, capture) {
      return entities[capture];
    });
  };
}(), htmlDecode:function() {
  var entities = {'\x26amp;':'\x26', '\x26gt;':'\x3e', '\x26lt;':'\x3c', '\x26quot;':'"'}, keys = [], p, regex;
  for (p in entities) {
    keys.push(p);
  }
  regex = new RegExp('(' + keys.join('|') + '|\x26#[0-9]{1,5};)', 'g');
  return function(value) {
    return !value ? value : String(value).replace(regex, function(match, capture) {
      if (capture in entities) {
        return entities[capture];
      } else {
        return String.fromCharCode(parseInt(capture.substr(2), 10));
      }
    });
  };
}(), urlAppend:function(url, string) {
  if (!Ext.isEmpty(string)) {
    return url + (url.indexOf('?') === -1 ? '?' : '\x26') + string;
  }
  return url;
}, trim:function(string) {
  return string.replace(Ext.String.trimRegex, '');
}, capitalize:function(string) {
  return string.charAt(0).toUpperCase() + string.substr(1);
}, ellipsis:function(value, len, word) {
  if (value && value.length > len) {
    if (word) {
      var vs = value.substr(0, len - 2), index = Math.max(vs.lastIndexOf(' '), vs.lastIndexOf('.'), vs.lastIndexOf('!'), vs.lastIndexOf('?'));
      if (index !== -1 && index >= len - 15) {
        return vs.substr(0, index) + '...';
      }
    }
    return value.substr(0, len - 3) + '...';
  }
  return value;
}, escapeRegex:function(string) {
  return string.replace(Ext.String.escapeRegexRe, '\\$1');
}, escape:function(string) {
  return string.replace(Ext.String.escapeRe, '\\$1');
}, toggle:function(string, value, other) {
  return string === value ? other : value;
}, leftPad:function(string, size, character) {
  var result = String(string);
  character = character || ' ';
  while (result.length < size) {
    result = character + result;
  }
  return result;
}, format:function(format) {
  var args = Ext.Array.toArray(arguments, 1);
  return format.replace(Ext.String.formatRe, function(m, i) {
    return args[i];
  });
}, repeat:function(pattern, count, sep) {
  for (var buf = [], i = count; i--;) {
    buf.push(pattern);
  }
  return buf.join(sep || '');
}};
Ext.htmlEncode = Ext.String.htmlEncode;
Ext.htmlDecode = Ext.String.htmlDecode;
Ext.urlAppend = Ext.String.urlAppend;
(function() {
  var arrayPrototype = Array.prototype, slice = arrayPrototype.slice, supportsSplice = function() {
    var array = [], lengthBefore, j = 20;
    if (!array.splice) {
      return false;
    }
    while (j--) {
      array.push('A');
    }
    array.splice(15, 0, 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F');
    lengthBefore = array.length;
    array.splice(13, 0, 'XXX');
    if (lengthBefore + 1 != array.length) {
      return false;
    }
    return true;
  }(), supportsForEach = 'forEach' in arrayPrototype, supportsMap = 'map' in arrayPrototype, supportsIndexOf = 'indexOf' in arrayPrototype, supportsEvery = 'every' in arrayPrototype, supportsSome = 'some' in arrayPrototype, supportsFilter = 'filter' in arrayPrototype, supportsSort = function() {
    var a = [1, 2, 3, 4, 5].sort(function() {
      return 0;
    });
    return a[0] === 1 && a[1] === 2 && a[2] === 3 && a[3] === 4 && a[4] === 5;
  }(), supportsSliceOnNodeList = true, ExtArray;
  try {
    if (typeof document !== 'undefined') {
      slice.call(document.getElementsByTagName('body'));
    }
  } catch (e$0) {
    supportsSliceOnNodeList = false;
  }
  function fixArrayIndex(array, index) {
    return index < 0 ? Math.max(0, array.length + index) : Math.min(array.length, index);
  }
  function replaceSim(array, index, removeCount, insert) {
    var add = insert ? insert.length : 0, length = array.length, pos = fixArrayIndex(array, index);
    if (pos === length) {
      if (add) {
        array.push.apply(array, insert);
      }
    } else {
      var remove = Math.min(removeCount, length - pos), tailOldPos = pos + remove, tailNewPos = tailOldPos + add - remove, tailCount = length - tailOldPos, lengthAfterRemove = length - remove, i;
      if (tailNewPos < tailOldPos) {
        for (i = 0; i < tailCount; ++i) {
          array[tailNewPos + i] = array[tailOldPos + i];
        }
      } else {
        if (tailNewPos > tailOldPos) {
          for (i = tailCount; i--;) {
            array[tailNewPos + i] = array[tailOldPos + i];
          }
        }
      }
      if (add && pos === lengthAfterRemove) {
        array.length = lengthAfterRemove;
        array.push.apply(array, insert);
      } else {
        array.length = lengthAfterRemove + add;
        for (i = 0; i < add; ++i) {
          array[pos + i] = insert[i];
        }
      }
    }
    return array;
  }
  function replaceNative(array, index, removeCount, insert) {
    if (insert && insert.length) {
      if (index < array.length) {
        array.splice.apply(array, [index, removeCount].concat(insert));
      } else {
        array.push.apply(array, insert);
      }
    } else {
      array.splice(index, removeCount);
    }
    return array;
  }
  function eraseSim(array, index, removeCount) {
    return replaceSim(array, index, removeCount);
  }
  function eraseNative(array, index, removeCount) {
    array.splice(index, removeCount);
    return array;
  }
  function spliceSim(array, index, removeCount) {
    var pos = fixArrayIndex(array, index), removed = array.slice(index, fixArrayIndex(array, pos + removeCount));
    if (arguments.length < 4) {
      replaceSim(array, pos, removeCount);
    } else {
      replaceSim(array, pos, removeCount, slice.call(arguments, 3));
    }
    return removed;
  }
  function spliceNative(array) {
    return array.splice.apply(array, slice.call(arguments, 1));
  }
  var erase = supportsSplice ? eraseNative : eraseSim, replace = supportsSplice ? replaceNative : replaceSim, splice = supportsSplice ? spliceNative : spliceSim;
  ExtArray = Ext.Array = {each:function(array, fn, scope, reverse) {
    array = ExtArray.from(array);
    var i, ln = array.length;
    if (reverse !== true) {
      for (i = 0; i < ln; i++) {
        if (fn.call(scope || array[i], array[i], i, array) === false) {
          return i;
        }
      }
    } else {
      for (i = ln - 1; i > -1; i--) {
        if (fn.call(scope || array[i], array[i], i, array) === false) {
          return i;
        }
      }
    }
    return true;
  }, forEach:supportsForEach ? function(array, fn, scope) {
    return array.forEach(fn, scope);
  } : function(array, fn, scope) {
    var i = 0, ln = array.length;
    for (; i < ln; i++) {
      fn.call(scope, array[i], i, array);
    }
  }, indexOf:supportsIndexOf ? function(array, item, from) {
    return array.indexOf(item, from);
  } : function(array, item, from) {
    var i, length = array.length;
    for (i = from < 0 ? Math.max(0, length + from) : from || 0; i < length; i++) {
      if (array[i] === item) {
        return i;
      }
    }
    return -1;
  }, contains:supportsIndexOf ? function(array, item) {
    return array.indexOf(item) !== -1;
  } : function(array, item) {
    var i, ln;
    for (i = 0, ln = array.length; i < ln; i++) {
      if (array[i] === item) {
        return true;
      }
    }
    return false;
  }, toArray:function(iterable, start, end) {
    if (!iterable || !iterable.length) {
      return [];
    }
    if (typeof iterable === 'string') {
      iterable = iterable.split('');
    }
    if (supportsSliceOnNodeList) {
      return slice.call(iterable, start || 0, end || iterable.length);
    }
    var array = [], i;
    start = start || 0;
    end = end ? end < 0 ? iterable.length + end : end : iterable.length;
    for (i = start; i < end; i++) {
      array.push(iterable[i]);
    }
    return array;
  }, pluck:function(array, propertyName) {
    var ret = [], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      ret.push(item[propertyName]);
    }
    return ret;
  }, map:supportsMap ? function(array, fn, scope) {
    return array.map(fn, scope);
  } : function(array, fn, scope) {
    var results = [], i = 0, len = array.length;
    for (; i < len; i++) {
      results[i] = fn.call(scope, array[i], i, array);
    }
    return results;
  }, every:function(array, fn, scope) {
    if (supportsEvery) {
      return array.every(fn, scope);
    }
    var i = 0, ln = array.length;
    for (; i < ln; ++i) {
      if (!fn.call(scope, array[i], i, array)) {
        return false;
      }
    }
    return true;
  }, some:function(array, fn, scope) {
    if (supportsSome) {
      return array.some(fn, scope);
    }
    var i = 0, ln = array.length;
    for (; i < ln; ++i) {
      if (fn.call(scope, array[i], i, array)) {
        return true;
      }
    }
    return false;
  }, clean:function(array) {
    var results = [], i = 0, ln = array.length, item;
    for (; i < ln; i++) {
      item = array[i];
      if (!Ext.isEmpty(item)) {
        results.push(item);
      }
    }
    return results;
  }, unique:function(array) {
    var clone = [], i = 0, ln = array.length, item;
    for (; i < ln; i++) {
      item = array[i];
      if (ExtArray.indexOf(clone, item) === -1) {
        clone.push(item);
      }
    }
    return clone;
  }, filter:function(array, fn, scope) {
    if (supportsFilter) {
      return array.filter(fn, scope);
    }
    var results = [], i = 0, ln = array.length;
    for (; i < ln; i++) {
      if (fn.call(scope, array[i], i, array)) {
        results.push(array[i]);
      }
    }
    return results;
  }, from:function(value, newReference) {
    if (value === undefined || value === null) {
      return [];
    }
    if (Ext.isArray(value)) {
      return newReference ? slice.call(value) : value;
    }
    if (value && value.length !== undefined && typeof value !== 'string') {
      return ExtArray.toArray(value);
    }
    return [value];
  }, remove:function(array, item) {
    var index = ExtArray.indexOf(array, item);
    if (index !== -1) {
      erase(array, index, 1);
    }
    return array;
  }, include:function(array, item) {
    if (!ExtArray.contains(array, item)) {
      array.push(item);
    }
  }, clone:function(array) {
    return slice.call(array);
  }, merge:function() {
    var args = slice.call(arguments), array = [], i, ln;
    for (i = 0, ln = args.length; i < ln; i++) {
      array = array.concat(args[i]);
    }
    return ExtArray.unique(array);
  }, intersect:function() {
    var intersect = [], arrays = slice.call(arguments), item, minArray, itemIndex, arrayIndex;
    if (!arrays.length) {
      return intersect;
    }
    arrays = arrays.sort(function(a, b) {
      if (a.length > b.length) {
        return 1;
      } else {
        if (a.length < b.length) {
          return -1;
        } else {
          return 0;
        }
      }
    });
    minArray = ExtArray.unique(arrays[0]);
    for (itemIndex = 0; itemIndex < minArray.length; itemIndex++) {
      item = minArray[itemIndex];
      for (arrayIndex = 1; arrayIndex < arrays.length; arrayIndex++) {
        if (arrays[arrayIndex].indexOf(item) === -1) {
          break;
        }
        if (arrayIndex == arrays.length - 1) {
          intersect.push(item);
        }
      }
    }
    return intersect;
  }, difference:function(arrayA, arrayB) {
    var clone = slice.call(arrayA), ln = clone.length, i, j, lnB;
    for (i = 0, lnB = arrayB.length; i < lnB; i++) {
      for (j = 0; j < ln; j++) {
        if (clone[j] === arrayB[i]) {
          erase(clone, j, 1);
          j--;
          ln--;
        }
      }
    }
    return clone;
  }, slice:function(array, begin, end) {
    return slice.call(array, begin, end);
  }, sort:function(array, sortFn) {
    if (supportsSort) {
      if (sortFn) {
        return array.sort(sortFn);
      } else {
        return array.sort();
      }
    }
    var length = array.length, i = 0, comparison, j, min, tmp;
    for (; i < length; i++) {
      min = i;
      for (j = i + 1; j < length; j++) {
        if (sortFn) {
          comparison = sortFn(array[j], array[min]);
          if (comparison < 0) {
            min = j;
          }
        } else {
          if (array[j] < array[min]) {
            min = j;
          }
        }
      }
      if (min !== i) {
        tmp = array[i];
        array[i] = array[min];
        array[min] = tmp;
      }
    }
    return array;
  }, flatten:function(array) {
    var worker = [];
    function rFlatten(a) {
      var i, ln, v;
      for (i = 0, ln = a.length; i < ln; i++) {
        v = a[i];
        if (Ext.isArray(v)) {
          rFlatten(v);
        } else {
          worker.push(v);
        }
      }
      return worker;
    }
    return rFlatten(array);
  }, min:function(array, comparisonFn) {
    var min = array[0], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      if (comparisonFn) {
        if (comparisonFn(min, item) === 1) {
          min = item;
        }
      } else {
        if (item < min) {
          min = item;
        }
      }
    }
    return min;
  }, max:function(array, comparisonFn) {
    var max = array[0], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      if (comparisonFn) {
        if (comparisonFn(max, item) === -1) {
          max = item;
        }
      } else {
        if (item > max) {
          max = item;
        }
      }
    }
    return max;
  }, mean:function(array) {
    return array.length > 0 ? ExtArray.sum(array) / array.length : undefined;
  }, sum:function(array) {
    var sum = 0, i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      sum += item;
    }
    return sum;
  }, erase:erase, insert:function(array, index, items) {
    return replace(array, index, 0, items);
  }, replace:replace, splice:splice};
  Ext.each = ExtArray.each;
  ExtArray.union = ExtArray.merge;
  Ext.min = ExtArray.min;
  Ext.max = ExtArray.max;
  Ext.sum = ExtArray.sum;
  Ext.mean = ExtArray.mean;
  Ext.flatten = ExtArray.flatten;
  Ext.clean = ExtArray.clean;
  Ext.unique = ExtArray.unique;
  Ext.pluck = ExtArray.pluck;
  Ext.toArray = function() {
    return ExtArray.toArray.apply(ExtArray, arguments);
  };
})();
(function() {
  var isToFixedBroken = (0.9).toFixed() !== '1';
  Ext.Number = {constrain:function(number, min, max) {
    number = parseFloat(number);
    if (!isNaN(min)) {
      number = Math.max(number, min);
    }
    if (!isNaN(max)) {
      number = Math.min(number, max);
    }
    return number;
  }, snap:function(value, increment, minValue, maxValue) {
    var newValue = value, m;
    if (!(increment && value)) {
      return value;
    }
    m = value % increment;
    if (m !== 0) {
      newValue -= m;
      if (m * 2 >= increment) {
        newValue += increment;
      } else {
        if (m * 2 < -increment) {
          newValue -= increment;
        }
      }
    }
    return Ext.Number.constrain(newValue, minValue, maxValue);
  }, toFixed:function(value, precision) {
    if (isToFixedBroken) {
      precision = precision || 0;
      var pow = Math.pow(10, precision);
      return (Math.round(value * pow) / pow).toFixed(precision);
    }
    return value.toFixed(precision);
  }, from:function(value, defaultValue) {
    if (isFinite(value)) {
      value = parseFloat(value);
    }
    return !isNaN(value) ? value : defaultValue;
  }};
})();
Ext.num = function() {
  return Ext.Number.from.apply(this, arguments);
};
(function() {
  var TemplateClass = function() {
  };
  var ExtObject = Ext.Object = {chain:'create' in Object ? function(object) {
    return Object.create(object);
  } : function(object) {
    TemplateClass.prototype = object;
    var result = new TemplateClass;
    TemplateClass.prototype = null;
    return result;
  }, toQueryObjects:function(name, value, recursive) {
    var self = ExtObject.toQueryObjects, objects = [], i, ln;
    if (Ext.isArray(value)) {
      for (i = 0, ln = value.length; i < ln; i++) {
        if (recursive) {
          objects = objects.concat(self(name + '[' + i + ']', value[i], true));
        } else {
          objects.push({name:name, value:value[i]});
        }
      }
    } else {
      if (Ext.isObject(value)) {
        for (i in value) {
          if (value.hasOwnProperty(i)) {
            if (recursive) {
              objects = objects.concat(self(name + '[' + i + ']', value[i], true));
            } else {
              objects.push({name:name, value:value[i]});
            }
          }
        }
      } else {
        objects.push({name:name, value:value});
      }
    }
    return objects;
  }, toQueryString:function(object, recursive) {
    var paramObjects = [], params = [], i, j, ln, paramObject, value;
    for (i in object) {
      if (object.hasOwnProperty(i)) {
        paramObjects = paramObjects.concat(ExtObject.toQueryObjects(i, object[i], recursive));
      }
    }
    for (j = 0, ln = paramObjects.length; j < ln; j++) {
      paramObject = paramObjects[j];
      value = paramObject.value;
      if (Ext.isEmpty(value)) {
        value = '';
      } else {
        if (Ext.isDate(value)) {
          value = Ext.Date.toString(value);
        }
      }
      params.push(encodeURIComponent(paramObject.name) + '\x3d' + encodeURIComponent(String(value)));
    }
    return params.join('\x26');
  }, fromQueryString:function(queryString, recursive) {
    var parts = queryString.replace(/^\?/, '').split('\x26'), object = {}, temp, components, name, value, i, ln, part, j, subLn, matchedKeys, matchedName, keys, key, nextKey;
    for (i = 0, ln = parts.length; i < ln; i++) {
      part = parts[i];
      if (part.length > 0) {
        components = part.split('\x3d');
        name = decodeURIComponent(components[0]);
        value = components[1] !== undefined ? decodeURIComponent(components[1]) : '';
        if (!recursive) {
          if (object.hasOwnProperty(name)) {
            if (!Ext.isArray(object[name])) {
              object[name] = [object[name]];
            }
            object[name].push(value);
          } else {
            object[name] = value;
          }
        } else {
          matchedKeys = name.match(/(\[):?([^\]]*)\]/g);
          matchedName = name.match(/^([^\[]+)/);
          name = matchedName[0];
          keys = [];
          if (matchedKeys === null) {
            object[name] = value;
            continue;
          }
          for (j = 0, subLn = matchedKeys.length; j < subLn; j++) {
            key = matchedKeys[j];
            key = key.length === 2 ? '' : key.substring(1, key.length - 1);
            keys.push(key);
          }
          keys.unshift(name);
          temp = object;
          for (j = 0, subLn = keys.length; j < subLn; j++) {
            key = keys[j];
            if (j === subLn - 1) {
              if (Ext.isArray(temp) && key === '') {
                temp.push(value);
              } else {
                temp[key] = value;
              }
            } else {
              if (temp[key] === undefined || typeof temp[key] === 'string') {
                nextKey = keys[j + 1];
                temp[key] = Ext.isNumeric(nextKey) || nextKey === '' ? [] : {};
              }
              temp = temp[key];
            }
          }
        }
      }
    }
    return object;
  }, each:function(object, fn, scope) {
    for (var property in object) {
      if (object.hasOwnProperty(property)) {
        if (fn.call(scope || object, property, object[property], object) === false) {
          return;
        }
      }
    }
  }, merge:function(source) {
    var i = 1, ln = arguments.length, mergeFn = ExtObject.merge, cloneFn = Ext.clone, object, key, value, sourceKey;
    for (; i < ln; i++) {
      object = arguments[i];
      for (key in object) {
        value = object[key];
        if (value && value.constructor === Object) {
          sourceKey = source[key];
          if (sourceKey && sourceKey.constructor === Object) {
            mergeFn(sourceKey, value);
          } else {
            source[key] = cloneFn(value);
          }
        } else {
          source[key] = value;
        }
      }
    }
    return source;
  }, mergeIf:function(source) {
    var i = 1, ln = arguments.length, cloneFn = Ext.clone, object, key, value;
    for (; i < ln; i++) {
      object = arguments[i];
      for (key in object) {
        if (!(key in source)) {
          value = object[key];
          if (value && value.constructor === Object) {
            source[key] = cloneFn(value);
          } else {
            source[key] = value;
          }
        }
      }
    }
    return source;
  }, getKey:function(object, value) {
    for (var property in object) {
      if (object.hasOwnProperty(property) && object[property] === value) {
        return property;
      }
    }
    return null;
  }, getValues:function(object) {
    var values = [], property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        values.push(object[property]);
      }
    }
    return values;
  }, getKeys:'keys' in Object ? Object.keys : function(object) {
    var keys = [], property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        keys.push(property);
      }
    }
    return keys;
  }, getSize:function(object) {
    var size = 0, property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        size++;
      }
    }
    return size;
  }, classify:function(object) {
    var objectProperties = [], arrayProperties = [], propertyClassesMap = {}, objectClass = function() {
      var i = 0, ln = objectProperties.length, property;
      for (; i < ln; i++) {
        property = objectProperties[i];
        this[property] = new propertyClassesMap[property];
      }
      ln = arrayProperties.length;
      for (i = 0; i < ln; i++) {
        property = arrayProperties[i];
        this[property] = object[property].slice();
      }
    }, key, value, constructor;
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        value = object[key];
        if (value) {
          constructor = value.constructor;
          if (constructor === Object) {
            objectProperties.push(key);
            propertyClassesMap[key] = ExtObject.classify(value);
          } else {
            if (constructor === Array) {
              arrayProperties.push(key);
            }
          }
        }
      }
    }
    objectClass.prototype = object;
    return objectClass;
  }, equals:function(origin, target) {
    var originType = typeof origin, targetType = typeof target, key;
    if (targetType === targetType) {
      if (originType === 'object') {
        for (key in origin) {
          if (!(key in target)) {
            return false;
          }
          if (!ExtObject.equals(origin[key], target[key])) {
            return false;
          }
        }
        for (key in target) {
          if (!(key in origin)) {
            return false;
          }
        }
        return true;
      } else {
        return origin === target;
      }
    }
    return false;
  }, defineProperty:'defineProperty' in Object ? Object.defineProperty : function(object, name, descriptor) {
    if (descriptor.get) {
      object.__defineGetter__(name, descriptor.get);
    }
    if (descriptor.set) {
      object.__defineSetter__(name, descriptor.set);
    }
  }};
  Ext.merge = Ext.Object.merge;
  Ext.mergeIf = Ext.Object.mergeIf;
  Ext.urlEncode = function() {
    var args = Ext.Array.from(arguments), prefix = '';
    if (typeof args[1] === 'string') {
      prefix = args[1] + '\x26';
      args[1] = false;
    }
    return prefix + ExtObject.toQueryString.apply(ExtObject, args);
  };
  Ext.urlDecode = function() {
    return ExtObject.fromQueryString.apply(ExtObject, arguments);
  };
})();
Ext.Function = {flexSetter:function(fn) {
  return function(a, b) {
    var k, i;
    if (a === null) {
      return this;
    }
    if (typeof a !== 'string') {
      for (k in a) {
        if (a.hasOwnProperty(k)) {
          fn.call(this, k, a[k]);
        }
      }
      if (Ext.enumerables) {
        for (i = Ext.enumerables.length; i--;) {
          k = Ext.enumerables[i];
          if (a.hasOwnProperty(k)) {
            fn.call(this, k, a[k]);
          }
        }
      }
    } else {
      fn.call(this, a, b);
    }
    return this;
  };
}, bind:function(fn, scope, args, appendArgs) {
  if (arguments.length === 2) {
    return function() {
      return fn.apply(scope, arguments);
    };
  }
  var method = fn, slice = Array.prototype.slice;
  return function() {
    var callArgs = args || arguments;
    if (appendArgs === true) {
      callArgs = slice.call(arguments, 0);
      callArgs = callArgs.concat(args);
    } else {
      if (typeof appendArgs == 'number') {
        callArgs = slice.call(arguments, 0);
        Ext.Array.insert(callArgs, appendArgs, args);
      }
    }
    return method.apply(scope || window, callArgs);
  };
}, pass:function(fn, args, scope) {
  if (!Ext.isArray(args)) {
    args = Ext.Array.clone(args);
  }
  return function() {
    args.push.apply(args, arguments);
    return fn.apply(scope || this, args);
  };
}, alias:function(object, methodName) {
  return function() {
    return object[methodName].apply(object, arguments);
  };
}, clone:function(method) {
  return function() {
    return method.apply(this, arguments);
  };
}, createInterceptor:function(origFn, newFn, scope, returnValue) {
  var method = origFn;
  if (!Ext.isFunction(newFn)) {
    return origFn;
  } else {
    return function() {
      var me = this, args = arguments;
      newFn.target = me;
      newFn.method = origFn;
      return newFn.apply(scope || me || window, args) !== false ? origFn.apply(me || window, args) : returnValue || null;
    };
  }
}, createDelayed:function(fn, delay, scope, args, appendArgs) {
  if (scope || args) {
    fn = Ext.Function.bind(fn, scope, args, appendArgs);
  }
  return function() {
    var me = this, args = Array.prototype.slice.call(arguments);
    setTimeout(function() {
      fn.apply(me, args);
    }, delay);
  };
}, defer:function(fn, millis, scope, args, appendArgs) {
  fn = Ext.Function.bind(fn, scope, args, appendArgs);
  if (millis > 0) {
    return setTimeout(fn, millis);
  }
  fn();
  return 0;
}, createSequence:function(originalFn, newFn, scope) {
  if (!newFn) {
    return originalFn;
  } else {
    return function() {
      var result = originalFn.apply(this, arguments);
      newFn.apply(scope || this, arguments);
      return result;
    };
  }
}, createBuffered:function(fn, buffer, scope, args) {
  var timerId;
  return function() {
    var callArgs = args || Array.prototype.slice.call(arguments, 0), me = scope || this;
    if (timerId) {
      clearTimeout(timerId);
    }
    timerId = setTimeout(function() {
      fn.apply(me, callArgs);
    }, buffer);
  };
}, createThrottled:function(fn, interval, scope) {
  var lastCallTime, elapsed, lastArgs, timer, execute = function() {
    fn.apply(scope || this, lastArgs);
    lastCallTime = (new Date).getTime();
  };
  return function() {
    elapsed = (new Date).getTime() - lastCallTime;
    lastArgs = arguments;
    clearTimeout(timer);
    if (!lastCallTime || elapsed >= interval) {
      execute();
    } else {
      timer = setTimeout(execute, interval - elapsed);
    }
  };
}, interceptBefore:function(object, methodName, fn, scope) {
  var method = object[methodName] || Ext.emptyFn;
  return object[methodName] = function() {
    var ret = fn.apply(scope || this, arguments);
    method.apply(this, arguments);
    return ret;
  };
}, interceptAfter:function(object, methodName, fn, scope) {
  var method = object[methodName] || Ext.emptyFn;
  return object[methodName] = function() {
    method.apply(this, arguments);
    return fn.apply(scope || this, arguments);
  };
}};
Ext.defer = Ext.Function.alias(Ext.Function, 'defer');
Ext.pass = Ext.Function.alias(Ext.Function, 'pass');
Ext.bind = Ext.Function.alias(Ext.Function, 'bind');
Ext.JSON = new function() {
  var useHasOwn = !!{}.hasOwnProperty, isNative = function() {
    var useNative = null;
    return function() {
      if (useNative === null) {
        useNative = Ext.USE_NATIVE_JSON && window.JSON && JSON.toString() == '[object JSON]';
      }
      return useNative;
    };
  }(), pad = function(n) {
    return n < 10 ? '0' + n : n;
  }, doDecode = function(json) {
    return eval('(' + json + ')');
  }, doEncode = function(o) {
    if (!Ext.isDefined(o) || o === null) {
      return 'null';
    } else {
      if (Ext.isArray(o)) {
        return encodeArray(o);
      } else {
        if (Ext.isDate(o)) {
          return Ext.JSON.encodeDate(o);
        } else {
          if (Ext.isString(o)) {
            if (Ext.isMSDate(o)) {
              return encodeMSDate(o);
            } else {
              return encodeString(o);
            }
          } else {
            if (typeof o == 'number') {
              return isFinite(o) ? String(o) : 'null';
            } else {
              if (Ext.isBoolean(o)) {
                return String(o);
              } else {
                if (Ext.isObject(o)) {
                  return encodeObject(o);
                } else {
                  if (typeof o === 'function') {
                    return 'null';
                  }
                }
              }
            }
          }
        }
      }
    }
    return 'undefined';
  }, m = {'\b':'\\b', '\t':'\\t', '\n':'\\n', '\f':'\\f', '\r':'\\r', '"':'\\"', '\\':'\\\\', '\x0B':'\\u000b'}, charToReplace = /[\\"\x00-\x1f\x7f-\uffff]/g, encodeString = function(s) {
    return '"' + s.replace(charToReplace, function(a) {
      var c = m[a];
      return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"';
  }, encodeArray = function(o) {
    var a = ['[', ''], len = o.length, i;
    for (i = 0; i < len; i += 1) {
      a.push(doEncode(o[i]), ',');
    }
    a[a.length - 1] = ']';
    return a.join('');
  }, encodeObject = function(o) {
    var a = ['{', ''], i;
    for (i in o) {
      if (!useHasOwn || o.hasOwnProperty(i)) {
        a.push(doEncode(i), ':', doEncode(o[i]), ',');
      }
    }
    a[a.length - 1] = '}';
    return a.join('');
  }, encodeMSDate = function(o) {
    return '"' + o + '"';
  };
  this.encodeDate = function(o) {
    return '"' + o.getFullYear() + '-' + pad(o.getMonth() + 1) + '-' + pad(o.getDate()) + 'T' + pad(o.getHours()) + ':' + pad(o.getMinutes()) + ':' + pad(o.getSeconds()) + '"';
  };
  this.encode = function() {
    var ec;
    return function(o) {
      if (!ec) {
        ec = isNative() ? JSON.stringify : doEncode;
      }
      return ec(o);
    };
  }();
  this.decode = function() {
    var dc;
    return function(json, safe) {
      if (!dc) {
        dc = isNative() ? JSON.parse : doDecode;
      }
      try {
        return dc(json);
      } catch (e$1) {
        if (safe === true) {
          return null;
        }
        Ext.Error.raise({sourceClass:'Ext.JSON', sourceMethod:'decode', msg:"You're trying to decode an invalid JSON String: " + json});
      }
    };
  }();
};
if (!Ext.util) {
  Ext.util = {};
}
Ext.util.JSON = Ext.JSON;
Ext.encode = Ext.JSON.encode;
Ext.decode = Ext.JSON.decode;
Ext.Error = {raise:function(object) {
  throw new Error(object.msg);
}};
Ext.Date = {now:Date.now, toString:function(date) {
  if (!date) {
    date = new Date;
  }
  var pad = Ext.String.leftPad;
  return date.getFullYear() + '-' + pad(date.getMonth() + 1, 2, '0') + '-' + pad(date.getDate(), 2, '0') + 'T' + pad(date.getHours(), 2, '0') + ':' + pad(date.getMinutes(), 2, '0') + ':' + pad(date.getSeconds(), 2, '0');
}};
(function(flexSetter) {
  var noArgs = [], Base = function() {
  };
  Ext.apply(Base, {$className:'Ext.Base', $isClass:true, create:function() {
    return Ext.create.apply(Ext, [this].concat(Array.prototype.slice.call(arguments, 0)));
  }, extend:function(parent) {
    var parentPrototype = parent.prototype, prototype, i, ln, name, statics;
    prototype = this.prototype = Ext.Object.chain(parentPrototype);
    prototype.self = this;
    this.superclass = prototype.superclass = parentPrototype;
    if (!parent.$isClass) {
      Ext.apply(prototype, Ext.Base.prototype);
      prototype.constructor = function() {
        parentPrototype.constructor.apply(this, arguments);
      };
    }
    statics = parentPrototype.$inheritableStatics;
    if (statics) {
      for (i = 0, ln = statics.length; i < ln; i++) {
        name = statics[i];
        if (!this.hasOwnProperty(name)) {
          this[name] = parent[name];
        }
      }
    }
    if (parent.$onExtended) {
      this.$onExtended = parent.$onExtended.slice();
    }
    prototype.config = prototype.defaultConfig = new prototype.configClass;
    prototype.initConfigList = prototype.initConfigList.slice();
    prototype.initConfigMap = Ext.Object.chain(prototype.initConfigMap);
  }, '$onExtended':[], triggerExtended:function() {
    var callbacks = this.$onExtended, ln = callbacks.length, i, callback;
    if (ln > 0) {
      for (i = 0; i < ln; i++) {
        callback = callbacks[i];
        callback.fn.apply(callback.scope || this, arguments);
      }
    }
  }, onExtended:function(fn, scope) {
    this.$onExtended.push({fn:fn, scope:scope});
    return this;
  }, addConfig:function(config, fullMerge) {
    var prototype = this.prototype, initConfigList = prototype.initConfigList, initConfigMap = prototype.initConfigMap, defaultConfig = prototype.defaultConfig, hasInitConfigItem, name, value;
    fullMerge = Boolean(fullMerge);
    for (name in config) {
      if (config.hasOwnProperty(name) && (fullMerge || !(name in defaultConfig))) {
        value = config[name];
        hasInitConfigItem = initConfigMap[name];
        if (value !== null) {
          if (!hasInitConfigItem) {
            initConfigMap[name] = true;
            initConfigList.push(name);
          }
        } else {
          if (hasInitConfigItem) {
            initConfigMap[name] = false;
            Ext.Array.remove(initConfigList, name);
          }
        }
      }
    }
    if (fullMerge) {
      Ext.merge(defaultConfig, config);
    } else {
      Ext.mergeIf(defaultConfig, config);
    }
    prototype.configClass = Ext.Object.classify(defaultConfig);
  }, addStatics:function(members) {
    var member, name;
    for (name in members) {
      if (members.hasOwnProperty(name)) {
        member = members[name];
        this[name] = member;
      }
    }
    return this;
  }, addInheritableStatics:function(members) {
    var inheritableStatics, hasInheritableStatics, prototype = this.prototype, name, member;
    inheritableStatics = prototype.$inheritableStatics;
    hasInheritableStatics = prototype.$hasInheritableStatics;
    if (!inheritableStatics) {
      inheritableStatics = prototype.$inheritableStatics = [];
      hasInheritableStatics = prototype.$hasInheritableStatics = {};
    }
    for (name in members) {
      if (members.hasOwnProperty(name)) {
        member = members[name];
        this[name] = member;
        if (!hasInheritableStatics[name]) {
          hasInheritableStatics[name] = true;
          inheritableStatics.push(name);
        }
      }
    }
    return this;
  }, addMembers:function(members) {
    var prototype = this.prototype, names = [], name, member;
    for (name in members) {
      if (members.hasOwnProperty(name)) {
        member = members[name];
        if (typeof member == 'function' && !member.$isClass && member !== Ext.emptyFn) {
          member.$owner = this;
          member.$name = name;
        }
        prototype[name] = member;
      }
    }
    return this;
  }, addMember:function(name, member) {
    if (typeof member == 'function' && !member.$isClass && member !== Ext.emptyFn) {
      member.$owner = this;
      member.$name = name;
    }
    this.prototype[name] = member;
    return this;
  }, implement:function() {
    this.addMembers.apply(this, arguments);
  }, borrow:function(fromClass, members) {
    var prototype = this.prototype, fromPrototype = fromClass.prototype, i, ln, name, fn, toBorrow;
    members = Ext.Array.from(members);
    for (i = 0, ln = members.length; i < ln; i++) {
      name = members[i];
      toBorrow = fromPrototype[name];
      if (typeof toBorrow == 'function') {
        fn = function() {
          return toBorrow.apply(this, arguments);
        };
        fn.$owner = this;
        fn.$name = name;
        prototype[name] = fn;
      } else {
        prototype[name] = toBorrow;
      }
    }
    return this;
  }, override:function(members) {
    var me = this, enumerables = Ext.enumerables, target = me.prototype, cloneFunction = Ext.Function.clone, currentConfig = target.config, name, index, member, statics, names, previous, newConfig, prop;
    if (arguments.length === 2) {
      name = members;
      members = {};
      members[name] = arguments[1];
      enumerables = null;
    }
    do {
      names = [];
      statics = null;
      for (name in members) {
        if (name == 'statics') {
          statics = members[name];
        } else {
          if (name == 'config') {
            newConfig = members[name];
            me.addConfig(newConfig, true);
          } else {
            names.push(name);
          }
        }
      }
      if (enumerables) {
        names.push.apply(names, enumerables);
      }
      for (index = names.length; index--;) {
        name = names[index];
        if (members.hasOwnProperty(name)) {
          member = members[name];
          if (typeof member == 'function' && !member.$className && member !== Ext.emptyFn) {
            if (typeof member.$owner != 'undefined') {
              member = cloneFunction(member);
            }
            member.$owner = me;
            member.$name = name;
            previous = target[name];
            if (previous) {
              member.$previous = previous;
            }
          }
          target[name] = member;
        }
      }
      target = me;
      members = statics;
    } while (members);
    return this;
  }, callParent:function(args) {
    var method;
    return (method = this.callParent.caller) && (method.$previous || (method = method.$owner ? method : method.caller) && method.$owner.superclass.$class[method.$name]).apply(this, args || noArgs);
  }, mixin:function(name, mixinClass) {
    var mixin = mixinClass.prototype, prototype = this.prototype, key;
    if (typeof mixin.onClassMixedIn != 'undefined') {
      mixin.onClassMixedIn.call(mixinClass, this);
    }
    if (!prototype.hasOwnProperty('mixins')) {
      if ('mixins' in prototype) {
        prototype.mixins = Ext.Object.chain(prototype.mixins);
      } else {
        prototype.mixins = {};
      }
    }
    for (key in mixin) {
      if (key === 'mixins') {
        Ext.merge(prototype.mixins, mixin[key]);
      } else {
        if (typeof prototype[key] == 'undefined' && key != 'mixinId' && key != 'config') {
          prototype[key] = mixin[key];
        }
      }
    }
    if ('config' in mixin) {
      this.addConfig(mixin.config, false);
    }
    prototype.mixins[name] = mixin;
  }, getName:function() {
    return Ext.getClassName(this);
  }, createAlias:flexSetter(function(alias, origin) {
    this.override(alias, function() {
      return this[origin].apply(this, arguments);
    });
  }), addXtype:function(xtype) {
    var prototype = this.prototype, xtypesMap = prototype.xtypesMap, xtypes = prototype.xtypes, xtypesChain = prototype.xtypesChain;
    if (!prototype.hasOwnProperty('xtypesMap')) {
      xtypesMap = prototype.xtypesMap = Ext.merge({}, prototype.xtypesMap || {});
      xtypes = prototype.xtypes = prototype.xtypes ? [].concat(prototype.xtypes) : [];
      xtypesChain = prototype.xtypesChain = prototype.xtypesChain ? [].concat(prototype.xtypesChain) : [];
      prototype.xtype = xtype;
    }
    if (!xtypesMap[xtype]) {
      xtypesMap[xtype] = true;
      xtypes.push(xtype);
      xtypesChain.push(xtype);
      Ext.ClassManager.setAlias(this, 'widget.' + xtype);
    }
    return this;
  }});
  Base.implement({isInstance:true, $className:'Ext.Base', configClass:Ext.emptyFn, initConfigList:[], initConfigMap:{}, statics:function() {
    var method = this.statics.caller, self = this.self;
    if (!method) {
      return self;
    }
    return method.$owner;
  }, callParent:function(args) {
    var method, superMethod = (method = this.callParent.caller) && (method.$previous || (method = method.$owner ? method : method.caller) && method.$owner.superclass[method.$name]);
    return superMethod.apply(this, args || noArgs);
  }, callSuper:function(args) {
    var method, superMethod = (method = this.callSuper.caller) && ((method = method.$owner ? method : method.caller) && method.$owner.superclass[method.$name]);
    return superMethod.apply(this, args || noArgs);
  }, callOverridden:function(args) {
    var method = this.callOverridden.caller;
    return method && method.$previous.apply(this, args || noArgs);
  }, self:Base, constructor:function() {
    return this;
  }, wasInstantiated:false, initConfig:function(instanceConfig) {
    var configNameCache = Ext.Class.configNameCache, prototype = this.self.prototype, initConfigList = this.initConfigList, initConfigMap = this.initConfigMap, config = new this.configClass, defaultConfig = this.defaultConfig, i, ln, name, value, nameMap, getName;
    this.initConfig = Ext.emptyFn;
    this.initialConfig = instanceConfig || {};
    if (instanceConfig) {
      Ext.merge(config, instanceConfig);
    }
    this.config = config;
    if (!prototype.hasOwnProperty('wasInstantiated')) {
      prototype.wasInstantiated = true;
      for (i = 0, ln = initConfigList.length; i < ln; i++) {
        name = initConfigList[i];
        nameMap = configNameCache[name];
        value = defaultConfig[name];
        if (!(nameMap.apply in prototype) && !(nameMap.update in prototype) && prototype[nameMap.set].$isDefault && typeof value != 'object') {
          prototype[nameMap.internal] = defaultConfig[name];
          initConfigMap[name] = false;
          Ext.Array.remove(initConfigList, name);
          i--;
          ln--;
        }
      }
    }
    if (instanceConfig) {
      initConfigList = initConfigList.slice();
      for (name in instanceConfig) {
        if (name in defaultConfig && !initConfigMap[name]) {
          initConfigList.push(name);
        }
      }
    }
    for (i = 0, ln = initConfigList.length; i < ln; i++) {
      name = initConfigList[i];
      nameMap = configNameCache[name];
      this[nameMap.get] = this[nameMap.initGet];
    }
    this.beforeInitConfig(config);
    for (i = 0, ln = initConfigList.length; i < ln; i++) {
      name = initConfigList[i];
      nameMap = configNameCache[name];
      getName = nameMap.get;
      if (this.hasOwnProperty(getName)) {
        this[nameMap.set].call(this, config[name]);
        delete this[getName];
      }
    }
    return this;
  }, beforeInitConfig:Ext.emptyFn, getCurrentConfig:function() {
    var defaultConfig = this.defaultConfig, configNameCache = Ext.Class.configNameCache, config = {}, name, nameMap;
    for (name in defaultConfig) {
      nameMap = configNameCache[name];
      config[name] = this[nameMap.get].call(this);
    }
    return config;
  }, setConfig:function(config, applyIfNotSet) {
    if (!config) {
      return this;
    }
    var configNameCache = Ext.Class.configNameCache, currentConfig = this.config, defaultConfig = this.defaultConfig, initialConfig = this.initialConfig, configList = [], name, i, ln, nameMap;
    applyIfNotSet = Boolean(applyIfNotSet);
    for (name in config) {
      if (applyIfNotSet && name in initialConfig) {
        continue;
      }
      currentConfig[name] = config[name];
      if (name in defaultConfig) {
        configList.push(name);
        nameMap = configNameCache[name];
        this[nameMap.get] = this[nameMap.initGet];
      }
    }
    for (i = 0, ln = configList.length; i < ln; i++) {
      name = configList[i];
      nameMap = configNameCache[name];
      this[nameMap.set].call(this, config[name]);
      delete this[nameMap.get];
    }
    return this;
  }, set:function(name, value) {
    return this[Ext.Class.configNameCache[name].set].call(this, value);
  }, get:function(name) {
    return this[Ext.Class.configNameCache[name].get].call(this);
  }, getConfig:function(name) {
    return this[Ext.Class.configNameCache[name].get].call(this);
  }, hasConfig:function(name) {
    return name in this.defaultConfig;
  }, getInitialConfig:function(name) {
    var config = this.config;
    if (!name) {
      return config;
    } else {
      return config[name];
    }
  }, onConfigUpdate:function(names, callback, scope) {
    var self = this.self, i, ln, name, updaterName, updater, newUpdater;
    names = Ext.Array.from(names);
    scope = scope || this;
    for (i = 0, ln = names.length; i < ln; i++) {
      name = names[i];
      updaterName = 'update' + Ext.String.capitalize(name);
      updater = this[updaterName] || Ext.emptyFn;
      newUpdater = function() {
        updater.apply(this, arguments);
        scope[callback].apply(scope, arguments);
      };
      newUpdater.$name = updaterName;
      newUpdater.$owner = self;
      this[updaterName] = newUpdater;
    }
  }, link:function(name, value) {
    this.$links = {};
    this.link = this.doLink;
    return this.link.apply(this, arguments);
  }, doLink:function(name, value) {
    this.$links[name] = true;
    this[name] = value;
    return value;
  }, unlink:function() {
    var i, ln, link, value;
    for (i = 0, ln = arguments.length; i < ln; i++) {
      link = arguments[i];
      if (this.hasOwnProperty(link)) {
        value = this[link];
        if (value) {
          if (value.isInstance && !value.isDestroyed) {
            value.destroy();
          } else {
            if (value.parentNode && 'nodeType' in value) {
              value.parentNode.removeChild(value);
            }
          }
        }
        delete this[link];
      }
    }
    return this;
  }, destroy:function() {
    this.destroy = Ext.emptyFn;
    this.isDestroyed = true;
    if (this.hasOwnProperty('$links')) {
      this.unlink.apply(this, Ext.Object.getKeys(this.$links));
      delete this.$links;
    }
  }});
  Ext.Base = Base;
})(Ext.Function.flexSetter);
(function() {
  var ExtClass, Base = Ext.Base, baseStaticMembers = [], baseStaticMember, baseStaticMemberLength;
  for (baseStaticMember in Base) {
    if (Base.hasOwnProperty(baseStaticMember)) {
      baseStaticMembers.push(baseStaticMember);
    }
  }
  baseStaticMemberLength = baseStaticMembers.length;
  Ext.Class = ExtClass = function(Class, data, onCreated) {
    if (typeof Class != 'function') {
      onCreated = data;
      data = Class;
      Class = null;
    }
    if (!data) {
      data = {};
    }
    Class = ExtClass.create(Class);
    ExtClass.process(Class, data, onCreated);
    return Class;
  };
  Ext.apply(ExtClass, {onBeforeCreated:function(Class, data, hooks) {
    Class.addMembers(data);
    hooks.onCreated.call(Class, Class);
  }, create:function(Class) {
    var name, i;
    if (!Class) {
      Class = function() {
        return this.constructor.apply(this, arguments);
      };
    }
    for (i = 0; i < baseStaticMemberLength; i++) {
      name = baseStaticMembers[i];
      Class[name] = Base[name];
    }
    return Class;
  }, process:function(Class, data, onCreated) {
    var preprocessorStack = data.preprocessors || ExtClass.defaultPreprocessors, preprocessors = this.preprocessors, hooks = {onBeforeCreated:this.onBeforeCreated, onCreated:onCreated || Ext.emptyFn}, index = 0, name, preprocessor, properties, i, ln, fn, property, process;
    delete data.preprocessors;
    process = function(Class, data, hooks) {
      fn = null;
      while (fn === null) {
        name = preprocessorStack[index++];
        if (name) {
          preprocessor = preprocessors[name];
          properties = preprocessor.properties;
          if (properties === true) {
            fn = preprocessor.fn;
          } else {
            for (i = 0, ln = properties.length; i < ln; i++) {
              property = properties[i];
              if (data.hasOwnProperty(property)) {
                fn = preprocessor.fn;
                break;
              }
            }
          }
        } else {
          hooks.onBeforeCreated.apply(this, arguments);
          return;
        }
      }
      if (fn.call(this, Class, data, hooks, process) !== false) {
        process.apply(this, arguments);
      }
    };
    process.call(this, Class, data, hooks);
  }, preprocessors:{}, registerPreprocessor:function(name, fn, properties, position, relativeTo) {
    if (!position) {
      position = 'last';
    }
    if (!properties) {
      properties = [name];
    }
    this.preprocessors[name] = {name:name, properties:properties || false, fn:fn};
    this.setDefaultPreprocessorPosition(name, position, relativeTo);
    return this;
  }, getPreprocessor:function(name) {
    return this.preprocessors[name];
  }, getPreprocessors:function() {
    return this.preprocessors;
  }, defaultPreprocessors:[], getDefaultPreprocessors:function() {
    return this.defaultPreprocessors;
  }, setDefaultPreprocessors:function(preprocessors) {
    this.defaultPreprocessors = Ext.Array.from(preprocessors);
    return this;
  }, setDefaultPreprocessorPosition:function(name, offset, relativeName) {
    var defaultPreprocessors = this.defaultPreprocessors, index;
    if (typeof offset == 'string') {
      if (offset === 'first') {
        defaultPreprocessors.unshift(name);
        return this;
      } else {
        if (offset === 'last') {
          defaultPreprocessors.push(name);
          return this;
        }
      }
      offset = offset === 'after' ? 1 : -1;
    }
    index = Ext.Array.indexOf(defaultPreprocessors, relativeName);
    if (index !== -1) {
      Ext.Array.splice(defaultPreprocessors, Math.max(0, index + offset), 0, name);
    }
    return this;
  }, configNameCache:{}, getConfigNameMap:function(name) {
    var cache = this.configNameCache, map = cache[name], capitalizedName;
    if (!map) {
      capitalizedName = name.charAt(0).toUpperCase() + name.substr(1);
      map = cache[name] = {name:name, internal:'_' + name, initializing:'is' + capitalizedName + 'Initializing', apply:'apply' + capitalizedName, update:'update' + capitalizedName, set:'set' + capitalizedName, get:'get' + capitalizedName, initGet:'initGet' + capitalizedName, doSet:'doSet' + capitalizedName, changeEvent:name.toLowerCase() + 'change'};
    }
    return map;
  }, generateSetter:function(nameMap) {
    var internalName = nameMap.internal, getName = nameMap.get, applyName = nameMap.apply, updateName = nameMap.update, setter;
    setter = function(value) {
      var oldValue = this[internalName], applier = this[applyName], updater = this[updateName];
      delete this[getName];
      if (applier) {
        value = applier.call(this, value, oldValue);
        if (typeof value == 'undefined') {
          return this;
        }
      }
      this[internalName] = value;
      if (updater && value !== oldValue) {
        updater.call(this, value, oldValue);
      }
      return this;
    };
    setter.$isDefault = true;
    return setter;
  }, generateInitGetter:function(nameMap) {
    var name = nameMap.name, setName = nameMap.set, getName = nameMap.get, initializingName = nameMap.initializing;
    return function() {
      this[initializingName] = true;
      delete this[getName];
      this[setName].call(this, this.config[name]);
      delete this[initializingName];
      return this[getName].apply(this, arguments);
    };
  }, generateGetter:function(nameMap) {
    var internalName = nameMap.internal;
    return function() {
      return this[internalName];
    };
  }});
  ExtClass.registerPreprocessor('extend', function(Class, data) {
    var Base = Ext.Base, extend = data.extend, Parent;
    delete data.extend;
    if (extend && extend !== Object) {
      Parent = extend;
    } else {
      Parent = Base;
    }
    Class.extend(Parent);
    Class.triggerExtended.apply(Class, arguments);
    if (data.onClassExtended) {
      Class.onExtended(data.onClassExtended, Class);
      delete data.onClassExtended;
    }
  }, true);
  ExtClass.registerPreprocessor('statics', function(Class, data) {
    Class.addStatics(data.statics);
    delete data.statics;
  });
  ExtClass.registerPreprocessor('inheritableStatics', function(Class, data) {
    Class.addInheritableStatics(data.inheritableStatics);
    delete data.inheritableStatics;
  });
  ExtClass.registerPreprocessor('platformConfig', function(Class, data, hooks) {
    var platformConfigs = data.platformConfig, config = data.config || {}, platform, theme, platformConfig, i, ln, j, ln2, exclude;
    delete data.platformConfig;
    if (!Ext.filterPlatform) {
      Ext.filterPlatform = function(platform) {
        var profileMatch = false, ua = navigator.userAgent, j, jln;
        platform = [].concat(platform);
        function isPhone(ua) {
          var isMobile = /Mobile(\/|\s)/.test(ua);
          return /(iPhone|iPod)/.test(ua) || !/(Silk)/.test(ua) && (/(Android)/.test(ua) && (/(Android 2)/.test(ua) || isMobile)) || /(BlackBerry|BB)/.test(ua) && isMobile || /(Windows Phone)/.test(ua);
        }
        function isTablet(ua) {
          return !isPhone(ua) && (/iPad/.test(ua) || /Android/.test(ua) || /(RIM Tablet OS)/.test(ua) || /MSIE 10/.test(ua) && /; Touch/.test(ua));
        }
        var paramsString = window.location.search.substr(1), paramsArray = paramsString.split('\x26'), params = {}, testPlatform, i;
        for (i = 0; i < paramsArray.length; i++) {
          var tmpArray = paramsArray[i].split('\x3d');
          params[tmpArray[0]] = tmpArray[1];
        }
        testPlatform = params.platform;
        if (testPlatform) {
          return platform.indexOf(testPlatform) != -1;
        }
        for (j = 0, jln = platform.length; j < jln; j++) {
          switch(platform[j]) {
            case 'phone':
              profileMatch = isPhone(ua);
              break;
            case 'tablet':
              profileMatch = isTablet(ua);
              break;
            case 'desktop':
              profileMatch = !isPhone(ua) && !isTablet(ua);
              break;
            case 'ios':
              profileMatch = /(iPad|iPhone|iPod)/.test(ua);
              break;
            case 'android':
              profileMatch = /(Android|Silk)/.test(ua);
              break;
            case 'blackberry':
              profileMatch = /(BlackBerry|BB)/.test(ua);
              break;
            case 'safari':
              profileMatch = /Safari/.test(ua) && !/(BlackBerry|BB)/.test(ua);
              break;
            case 'chrome':
              profileMatch = /Chrome/.test(ua);
              break;
            case 'ie10':
              profileMatch = /MSIE 10/.test(ua);
              break;
            case 'windows':
              profileMatch = /MSIE 10/.test(ua) || /Trident/.test(ua);
              break;
            case 'tizen':
              profileMatch = /Tizen/.test(ua);
              break;
            case 'firefox':
              profileMatch = /Firefox/.test(ua);
          }
          if (profileMatch) {
            return true;
          }
        }
        return false;
      };
    }
    for (i = 0, ln = platformConfigs.length; i < ln; i++) {
      platformConfig = platformConfigs[i];
      platform = platformConfig.platform;
      exclude = platformConfig.exclude || [];
      delete platformConfig.platform;
      theme = [].concat(platformConfig.theme);
      ln2 = theme.length;
      delete platformConfig.theme;
      if (platform && Ext.filterPlatform(platform) && !Ext.filterPlatform(exclude)) {
        Ext.merge(config, platformConfig);
      }
      if (ln2) {
        for (j = 0; j < ln2; j++) {
          if (Ext.theme.name == theme[j]) {
            Ext.merge(config, platformConfig);
          }
        }
      }
    }
  });
  ExtClass.registerPreprocessor('config', function(Class, data) {
    var config = data.config, prototype = Class.prototype, defaultConfig = prototype.config, nameMap, name, setName, getName, initGetName, internalName, value;
    delete data.config;
    for (name in config) {
      if (config.hasOwnProperty(name) && !(name in defaultConfig)) {
        value = config[name];
        nameMap = this.getConfigNameMap(name);
        setName = nameMap.set;
        getName = nameMap.get;
        initGetName = nameMap.initGet;
        internalName = nameMap.internal;
        data[initGetName] = this.generateInitGetter(nameMap);
        if (value === null && !data.hasOwnProperty(internalName)) {
          data[internalName] = null;
        }
        if (!data.hasOwnProperty(getName)) {
          data[getName] = this.generateGetter(nameMap);
        }
        if (!data.hasOwnProperty(setName)) {
          data[setName] = this.generateSetter(nameMap);
        }
      }
    }
    Class.addConfig(config, true);
  });
  ExtClass.registerPreprocessor('mixins', function(Class, data, hooks) {
    var mixins = data.mixins, name, mixin, i, ln;
    delete data.mixins;
    Ext.Function.interceptBefore(hooks, 'onCreated', function() {
      if (mixins instanceof Array) {
        for (i = 0, ln = mixins.length; i < ln; i++) {
          mixin = mixins[i];
          name = mixin.prototype.mixinId || mixin.$className;
          Class.mixin(name, mixin);
        }
      } else {
        for (name in mixins) {
          if (mixins.hasOwnProperty(name)) {
            Class.mixin(name, mixins[name]);
          }
        }
      }
    });
  });
  Ext.extend = function(Class, Parent, members) {
    if (arguments.length === 2 && Ext.isObject(Parent)) {
      members = Parent;
      Parent = Class;
      Class = null;
    }
    var cls;
    if (!Parent) {
      throw new Error('[Ext.extend] Attempting to extend from a class which has not been loaded on the page.');
    }
    members.extend = Parent;
    members.preprocessors = ['extend', 'statics', 'inheritableStatics', 'mixins', 'platformConfig', 'config'];
    if (Class) {
      cls = new ExtClass(Class, members);
    } else {
      cls = new ExtClass(members);
    }
    cls.prototype.override = function(o) {
      for (var m in o) {
        if (o.hasOwnProperty(m)) {
          this[m] = o[m];
        }
      }
    };
    return cls;
  };
})();
(function(Class, alias, arraySlice, arrayFrom, global) {
  var Manager = Ext.ClassManager = {classes:{}, existCache:{}, namespaceRewrites:[{from:'Ext.', to:Ext}], maps:{alternateToName:{}, aliasToName:{}, nameToAliases:{}, nameToAlternates:{}}, enableNamespaceParseCache:true, namespaceParseCache:{}, instantiators:[], isCreated:function(className) {
    var existCache = this.existCache, i, ln, part, root, parts;
    if (this.classes[className] || existCache[className]) {
      return true;
    }
    root = global;
    parts = this.parseNamespace(className);
    for (i = 0, ln = parts.length; i < ln; i++) {
      part = parts[i];
      if (typeof part != 'string') {
        root = part;
      } else {
        if (!root || !root[part]) {
          return false;
        }
        root = root[part];
      }
    }
    existCache[className] = true;
    this.triggerCreated(className);
    return true;
  }, createdListeners:[], nameCreatedListeners:{}, triggerCreated:function(className) {
    var listeners = this.createdListeners, nameListeners = this.nameCreatedListeners, alternateNames = this.maps.nameToAlternates[className], names = [className], i, ln, j, subLn, listener, name;
    for (i = 0, ln = listeners.length; i < ln; i++) {
      listener = listeners[i];
      listener.fn.call(listener.scope, className);
    }
    if (alternateNames) {
      names.push.apply(names, alternateNames);
    }
    for (i = 0, ln = names.length; i < ln; i++) {
      name = names[i];
      listeners = nameListeners[name];
      if (listeners) {
        for (j = 0, subLn = listeners.length; j < subLn; j++) {
          listener = listeners[j];
          listener.fn.call(listener.scope, name);
        }
        delete nameListeners[name];
      }
    }
  }, onCreated:function(fn, scope, className) {
    var listeners = this.createdListeners, nameListeners = this.nameCreatedListeners, listener = {fn:fn, scope:scope};
    if (className) {
      if (this.isCreated(className)) {
        fn.call(scope, className);
        return;
      }
      if (!nameListeners[className]) {
        nameListeners[className] = [];
      }
      nameListeners[className].push(listener);
    } else {
      listeners.push(listener);
    }
  }, parseNamespace:function(namespace) {
    var cache = this.namespaceParseCache;
    if (this.enableNamespaceParseCache) {
      if (cache.hasOwnProperty(namespace)) {
        return cache[namespace];
      }
    }
    var parts = [], rewrites = this.namespaceRewrites, root = global, name = namespace, rewrite, from, to, i, ln;
    for (i = 0, ln = rewrites.length; i < ln; i++) {
      rewrite = rewrites[i];
      from = rewrite.from;
      to = rewrite.to;
      if (name === from || name.substring(0, from.length) === from) {
        name = name.substring(from.length);
        if (typeof to != 'string') {
          root = to;
        } else {
          parts = parts.concat(to.split('.'));
        }
        break;
      }
    }
    parts.push(root);
    parts = parts.concat(name.split('.'));
    if (this.enableNamespaceParseCache) {
      cache[namespace] = parts;
    }
    return parts;
  }, setNamespace:function(name, value) {
    var root = global, parts = this.parseNamespace(name), ln = parts.length - 1, leaf = parts[ln], i, part;
    for (i = 0; i < ln; i++) {
      part = parts[i];
      if (typeof part != 'string') {
        root = part;
      } else {
        if (!root[part]) {
          root[part] = {};
        }
        root = root[part];
      }
    }
    root[leaf] = value;
    return root[leaf];
  }, createNamespaces:function() {
    var root = global, parts, part, i, j, ln, subLn;
    for (i = 0, ln = arguments.length; i < ln; i++) {
      parts = this.parseNamespace(arguments[i]);
      for (j = 0, subLn = parts.length; j < subLn; j++) {
        part = parts[j];
        if (typeof part != 'string') {
          root = part;
        } else {
          if (!root[part]) {
            root[part] = {};
          }
          root = root[part];
        }
      }
    }
    return root;
  }, set:function(name, value) {
    var me = this, maps = me.maps, nameToAlternates = maps.nameToAlternates, targetName = me.getName(value), alternates;
    me.classes[name] = me.setNamespace(name, value);
    if (targetName && targetName !== name) {
      maps.alternateToName[name] = targetName;
      alternates = nameToAlternates[targetName] || (nameToAlternates[targetName] = []);
      alternates.push(name);
    }
    return this;
  }, get:function(name) {
    var classes = this.classes;
    if (classes[name]) {
      return classes[name];
    }
    var root = global, parts = this.parseNamespace(name), part, i, ln;
    for (i = 0, ln = parts.length; i < ln; i++) {
      part = parts[i];
      if (typeof part != 'string') {
        root = part;
      } else {
        if (!root || !root[part]) {
          return null;
        }
        root = root[part];
      }
    }
    return root;
  }, setAlias:function(cls, alias) {
    var aliasToNameMap = this.maps.aliasToName, nameToAliasesMap = this.maps.nameToAliases, className;
    if (typeof cls == 'string') {
      className = cls;
    } else {
      className = this.getName(cls);
    }
    if (alias && aliasToNameMap[alias] !== className) {
      aliasToNameMap[alias] = className;
    }
    if (!nameToAliasesMap[className]) {
      nameToAliasesMap[className] = [];
    }
    if (alias) {
      Ext.Array.include(nameToAliasesMap[className], alias);
    }
    return this;
  }, addNameAliasMappings:function(aliases) {
    var aliasToNameMap = this.maps.aliasToName, nameToAliasesMap = this.maps.nameToAliases, className, aliasList, alias, i;
    for (className in aliases) {
      aliasList = nameToAliasesMap[className] || (nameToAliasesMap[className] = []);
      for (i = 0; i < aliases[className].length; i++) {
        alias = aliases[className][i];
        if (!aliasToNameMap[alias]) {
          aliasToNameMap[alias] = className;
          aliasList.push(alias);
        }
      }
    }
    return this;
  }, addNameAlternateMappings:function(alternates) {
    var alternateToName = this.maps.alternateToName, nameToAlternates = this.maps.nameToAlternates, className, aliasList, alternate, i;
    for (className in alternates) {
      aliasList = nameToAlternates[className] || (nameToAlternates[className] = []);
      for (i = 0; i < alternates[className].length; i++) {
        alternate = alternates[className];
        if (!alternateToName[alternate]) {
          alternateToName[alternate] = className;
          aliasList.push(alternate);
        }
      }
    }
    return this;
  }, getByAlias:function(alias) {
    return this.get(this.getNameByAlias(alias));
  }, getNameByAlias:function(alias) {
    return this.maps.aliasToName[alias] || '';
  }, getNameByAlternate:function(alternate) {
    return this.maps.alternateToName[alternate] || '';
  }, getAliasesByName:function(name) {
    return this.maps.nameToAliases[name] || [];
  }, getName:function(object) {
    return object && object.$className || '';
  }, getClass:function(object) {
    return object && object.self || null;
  }, create:function(className, data, createdFn) {
    data.$className = className;
    return new Class(data, function() {
      var postprocessorStack = data.postprocessors || Manager.defaultPostprocessors, registeredPostprocessors = Manager.postprocessors, index = 0, postprocessors = [], postprocessor, process, i, ln, j, subLn, postprocessorProperties, postprocessorProperty;
      delete data.postprocessors;
      for (i = 0, ln = postprocessorStack.length; i < ln; i++) {
        postprocessor = postprocessorStack[i];
        if (typeof postprocessor == 'string') {
          postprocessor = registeredPostprocessors[postprocessor];
          postprocessorProperties = postprocessor.properties;
          if (postprocessorProperties === true) {
            postprocessors.push(postprocessor.fn);
          } else {
            if (postprocessorProperties) {
              for (j = 0, subLn = postprocessorProperties.length; j < subLn; j++) {
                postprocessorProperty = postprocessorProperties[j];
                if (data.hasOwnProperty(postprocessorProperty)) {
                  postprocessors.push(postprocessor.fn);
                  break;
                }
              }
            }
          }
        } else {
          postprocessors.push(postprocessor);
        }
      }
      process = function(clsName, cls, clsData) {
        postprocessor = postprocessors[index++];
        if (!postprocessor) {
          Manager.set(className, cls);
          if (createdFn) {
            createdFn.call(cls, cls);
          }
          Manager.triggerCreated(className);
          return;
        }
        if (postprocessor.call(this, clsName, cls, clsData, process) !== false) {
          process.apply(this, arguments);
        }
      };
      process.call(Manager, className, this, data);
    });
  }, createOverride:function(className, data, createdFn) {
    var overriddenClassName = data.override, requires = Ext.Array.from(data.requires);
    delete data.override;
    delete data.requires;
    this.existCache[className] = true;
    Ext.require(requires, function() {
      this.onCreated(function() {
        var overridenClass = this.get(overriddenClassName);
        if (overridenClass.singleton) {
          overridenClass.self.override(data);
        } else {
          overridenClass.override(data);
        }
        if (createdFn) {
          createdFn.call(overridenClass, overridenClass);
        }
        this.triggerCreated(className);
      }, this, overriddenClassName);
    }, this);
    return this;
  }, instantiateByAlias:function() {
    var alias = arguments[0], args = arraySlice.call(arguments), className = this.getNameByAlias(alias);
    if (!className) {
      className = this.maps.aliasToName[alias];
      Ext.syncRequire(className);
    }
    args[0] = className;
    return this.instantiate.apply(this, args);
  }, instantiate:function() {
    var name = arguments[0], args = arraySlice.call(arguments, 1), alias = name, possibleName, cls;
    if (typeof name != 'function') {
      cls = this.get(name);
    } else {
      cls = name;
    }
    if (!cls) {
      possibleName = this.getNameByAlias(name);
      if (possibleName) {
        name = possibleName;
        cls = this.get(name);
      }
    }
    if (!cls) {
      possibleName = this.getNameByAlternate(name);
      if (possibleName) {
        name = possibleName;
        cls = this.get(name);
      }
    }
    if (!cls) {
      Ext.syncRequire(name);
      cls = this.get(name);
    }
    return this.getInstantiator(args.length)(cls, args);
  }, dynInstantiate:function(name, args) {
    args = arrayFrom(args, true);
    args.unshift(name);
    return this.instantiate.apply(this, args);
  }, getInstantiator:function(length) {
    var instantiators = this.instantiators, instantiator;
    instantiator = instantiators[length];
    if (!instantiator) {
      var i = length, args = [];
      for (i = 0; i < length; i++) {
        args.push('a[' + i + ']');
      }
      instantiator = instantiators[length] = new Function('c', 'a', 'return new c(' + args.join(',') + ')');
    }
    return instantiator;
  }, postprocessors:{}, defaultPostprocessors:[], registerPostprocessor:function(name, fn, properties, position, relativeTo) {
    if (!position) {
      position = 'last';
    }
    if (!properties) {
      properties = [name];
    }
    this.postprocessors[name] = {name:name, properties:properties || false, fn:fn};
    this.setDefaultPostprocessorPosition(name, position, relativeTo);
    return this;
  }, setDefaultPostprocessors:function(postprocessors) {
    this.defaultPostprocessors = arrayFrom(postprocessors);
    return this;
  }, setDefaultPostprocessorPosition:function(name, offset, relativeName) {
    var defaultPostprocessors = this.defaultPostprocessors, index;
    if (typeof offset == 'string') {
      if (offset === 'first') {
        defaultPostprocessors.unshift(name);
        return this;
      } else {
        if (offset === 'last') {
          defaultPostprocessors.push(name);
          return this;
        }
      }
      offset = offset === 'after' ? 1 : -1;
    }
    index = Ext.Array.indexOf(defaultPostprocessors, relativeName);
    if (index !== -1) {
      Ext.Array.splice(defaultPostprocessors, Math.max(0, index + offset), 0, name);
    }
    return this;
  }, getNamesByExpression:function(expression) {
    var nameToAliasesMap = this.maps.nameToAliases, names = [], name, alias, aliases, possibleName, regex, i, ln;
    if (expression.indexOf('*') !== -1) {
      expression = expression.replace(/\*/g, '(.*?)');
      regex = new RegExp('^' + expression + '$');
      for (name in nameToAliasesMap) {
        if (nameToAliasesMap.hasOwnProperty(name)) {
          aliases = nameToAliasesMap[name];
          if (name.search(regex) !== -1) {
            names.push(name);
          } else {
            for (i = 0, ln = aliases.length; i < ln; i++) {
              alias = aliases[i];
              if (alias.search(regex) !== -1) {
                names.push(name);
                break;
              }
            }
          }
        }
      }
    } else {
      possibleName = this.getNameByAlias(expression);
      if (possibleName) {
        names.push(possibleName);
      } else {
        possibleName = this.getNameByAlternate(expression);
        if (possibleName) {
          names.push(possibleName);
        } else {
          names.push(expression);
        }
      }
    }
    return names;
  }};
  Manager.registerPostprocessor('alias', function(name, cls, data) {
    var aliases = data.alias, i, ln;
    for (i = 0, ln = aliases.length; i < ln; i++) {
      alias = aliases[i];
      this.setAlias(cls, alias);
    }
  }, ['xtype', 'alias']);
  Manager.registerPostprocessor('singleton', function(name, cls, data, fn) {
    fn.call(this, name, new cls, data);
    return false;
  });
  Manager.registerPostprocessor('alternateClassName', function(name, cls, data) {
    var alternates = data.alternateClassName, i, ln, alternate;
    if (!(alternates instanceof Array)) {
      alternates = [alternates];
    }
    for (i = 0, ln = alternates.length; i < ln; i++) {
      alternate = alternates[i];
      this.set(alternate, cls);
    }
  });
  Ext.apply(Ext, {create:alias(Manager, 'instantiate'), widget:function(name) {
    var args = arraySlice.call(arguments);
    args[0] = 'widget.' + name;
    return Manager.instantiateByAlias.apply(Manager, args);
  }, createByAlias:alias(Manager, 'instantiateByAlias'), define:function(className, data, createdFn) {
    if ('override' in data) {
      return Manager.createOverride.apply(Manager, arguments);
    }
    return Manager.create.apply(Manager, arguments);
  }, getClassName:alias(Manager, 'getName'), getDisplayName:function(object) {
    if (object) {
      if (object.displayName) {
        return object.displayName;
      }
      if (object.$name && object.$class) {
        return Ext.getClassName(object.$class) + '#' + object.$name;
      }
      if (object.$className) {
        return object.$className;
      }
    }
    return 'Anonymous';
  }, getClass:alias(Manager, 'getClass'), namespace:alias(Manager, 'createNamespaces')});
  Ext.createWidget = Ext.widget;
  Ext.ns = Ext.namespace;
  Class.registerPreprocessor('className', function(cls, data) {
    if (data.$className) {
      cls.$className = data.$className;
    }
  }, true, 'first');
  Class.registerPreprocessor('alias', function(cls, data) {
    var prototype = cls.prototype, xtypes = arrayFrom(data.xtype), aliases = arrayFrom(data.alias), widgetPrefix = 'widget.', widgetPrefixLength = widgetPrefix.length, xtypesChain = Array.prototype.slice.call(prototype.xtypesChain || []), xtypesMap = Ext.merge({}, prototype.xtypesMap || {}), i, ln, alias, xtype;
    for (i = 0, ln = aliases.length; i < ln; i++) {
      alias = aliases[i];
      if (alias.substring(0, widgetPrefixLength) === widgetPrefix) {
        xtype = alias.substring(widgetPrefixLength);
        Ext.Array.include(xtypes, xtype);
      }
    }
    cls.xtype = data.xtype = xtypes[0];
    data.xtypes = xtypes;
    for (i = 0, ln = xtypes.length; i < ln; i++) {
      xtype = xtypes[i];
      if (!xtypesMap[xtype]) {
        xtypesMap[xtype] = true;
        xtypesChain.push(xtype);
      }
    }
    data.xtypesChain = xtypesChain;
    data.xtypesMap = xtypesMap;
    Ext.Function.interceptAfter(data, 'onClassCreated', function() {
      var mixins = prototype.mixins, key, mixin;
      for (key in mixins) {
        if (mixins.hasOwnProperty(key)) {
          mixin = mixins[key];
          xtypes = mixin.xtypes;
          if (xtypes) {
            for (i = 0, ln = xtypes.length; i < ln; i++) {
              xtype = xtypes[i];
              if (!xtypesMap[xtype]) {
                xtypesMap[xtype] = true;
                xtypesChain.push(xtype);
              }
            }
          }
        }
      }
    });
    for (i = 0, ln = xtypes.length; i < ln; i++) {
      xtype = xtypes[i];
      Ext.Array.include(aliases, widgetPrefix + xtype);
    }
    data.alias = aliases;
  }, ['xtype', 'alias']);
})(Ext.Class, Ext.Function.alias, Array.prototype.slice, Ext.Array.from, Ext.global);
(function(Manager, Class, flexSetter, alias, pass, arrayFrom, arrayErase, arrayInclude) {
  var dependencyProperties = ['extend', 'mixins', 'requires'], Loader, setPathCount = 0;
  Loader = Ext.Loader = {isInHistory:{}, history:[], config:{enabled:true, disableCaching:true, disableCachingParam:'_dc', paths:{'Ext':'.'}}, setConfig:function(name, value) {
    if (Ext.isObject(name) && arguments.length === 1) {
      Ext.merge(this.config, name);
    } else {
      this.config[name] = Ext.isObject(value) ? Ext.merge(this.config[name], value) : value;
    }
    setPathCount += 1;
    return this;
  }, getConfig:function(name) {
    if (name) {
      return this.config[name];
    }
    return this.config;
  }, setPath:flexSetter(function(name, path) {
    this.config.paths[name] = path;
    setPathCount += 1;
    return this;
  }), addClassPathMappings:function(paths) {
    var name;
    if (setPathCount == 0) {
      Loader.config.paths = paths;
    } else {
      for (name in paths) {
        Loader.config.paths[name] = paths[name];
      }
    }
    setPathCount++;
    return Loader;
  }, getPath:function(className) {
    var path = '', paths = this.config.paths, prefix = this.getPrefix(className);
    if (prefix.length > 0) {
      if (prefix === className) {
        return paths[prefix];
      }
      path = paths[prefix];
      className = className.substring(prefix.length + 1);
    }
    if (path.length > 0) {
      path += '/';
    }
    return path.replace(/\/\.\//g, '/') + className.replace(/\./g, '/') + '.js';
  }, getPrefix:function(className) {
    var paths = this.config.paths, prefix, deepestPrefix = '';
    if (paths.hasOwnProperty(className)) {
      return className;
    }
    for (prefix in paths) {
      if (paths.hasOwnProperty(prefix) && prefix + '.' === className.substring(0, prefix.length + 1)) {
        if (prefix.length > deepestPrefix.length) {
          deepestPrefix = prefix;
        }
      }
    }
    return deepestPrefix;
  }, require:function(expressions, fn, scope, excludes) {
    if (fn) {
      fn.call(scope);
    }
  }, syncRequire:function() {
  }, exclude:function(excludes) {
    var me = this;
    return {require:function(expressions, fn, scope) {
      return me.require(expressions, fn, scope, excludes);
    }, syncRequire:function(expressions, fn, scope) {
      return me.syncRequire(expressions, fn, scope, excludes);
    }};
  }, onReady:function(fn, scope, withDomReady, options) {
    var oldFn;
    if (withDomReady !== false && Ext.onDocumentReady) {
      oldFn = fn;
      fn = function() {
        Ext.onDocumentReady(oldFn, scope, options);
      };
    }
    fn.call(scope);
  }};
  Ext.apply(Loader, {documentHead:typeof document != 'undefined' && (document.head || document.getElementsByTagName('head')[0]), isLoading:false, queue:[], isClassFileLoaded:{}, isFileLoaded:{}, readyListeners:[], optionalRequires:[], requiresMap:{}, numPendingFiles:0, numLoadedFiles:0, hasFileLoadError:false, classNameToFilePathMap:{}, syncModeEnabled:false, scriptElements:{}, refreshQueue:function() {
    var queue = this.queue, ln = queue.length, i, item, j, requires, references;
    if (ln === 0) {
      this.triggerReady();
      return;
    }
    for (i = 0; i < ln; i++) {
      item = queue[i];
      if (item) {
        requires = item.requires;
        references = item.references;
        if (requires.length > this.numLoadedFiles) {
          continue;
        }
        j = 0;
        do {
          if (Manager.isCreated(requires[j])) {
            arrayErase(requires, j, 1);
          } else {
            j++;
          }
        } while (j < requires.length);
        if (item.requires.length === 0) {
          arrayErase(queue, i, 1);
          item.callback.call(item.scope);
          this.refreshQueue();
          break;
        }
      }
    }
    return this;
  }, injectScriptElement:function(url, onLoad, onError, scope, charset) {
    var script = document.createElement('script'), me = this, onLoadFn = function() {
      me.cleanupScriptElement(script);
      onLoad.call(scope);
    }, onErrorFn = function() {
      me.cleanupScriptElement(script);
      onError.call(scope);
    };
    script.type = 'text/javascript';
    script.src = url;
    script.onload = onLoadFn;
    script.onerror = onErrorFn;
    script.onreadystatechange = function() {
      if (this.readyState === 'loaded' || this.readyState === 'complete') {
        onLoadFn();
      }
    };
    if (charset) {
      script.charset = charset;
    }
    this.documentHead.appendChild(script);
    return script;
  }, removeScriptElement:function(url) {
    var scriptElements = this.scriptElements;
    if (scriptElements[url]) {
      this.cleanupScriptElement(scriptElements[url], true);
      delete scriptElements[url];
    }
    return this;
  }, cleanupScriptElement:function(script, remove) {
    script.onload = null;
    script.onreadystatechange = null;
    script.onerror = null;
    if (remove) {
      this.documentHead.removeChild(script);
    }
    return this;
  }, loadScriptFile:function(url, onLoad, onError, scope, synchronous) {
    var me = this, isFileLoaded = this.isFileLoaded, scriptElements = this.scriptElements, noCacheUrl = url + (this.getConfig('disableCaching') ? '?' + this.getConfig('disableCachingParam') + '\x3d' + Ext.Date.now() : ''), xhr, status, content, onScriptError;
    if (isFileLoaded[url]) {
      return this;
    }
    scope = scope || this;
    this.isLoading = true;
    if (!synchronous) {
      onScriptError = function() {
      };
      if (!Ext.isReady && Ext.onDocumentReady) {
        Ext.onDocumentReady(function() {
          if (!isFileLoaded[url]) {
            scriptElements[url] = me.injectScriptElement(noCacheUrl, onLoad, onScriptError, scope);
          }
        });
      } else {
        scriptElements[url] = this.injectScriptElement(noCacheUrl, onLoad, onScriptError, scope);
      }
    } else {
      if (typeof XMLHttpRequest != 'undefined') {
        xhr = new XMLHttpRequest;
      } else {
        xhr = new ActiveXObject('Microsoft.XMLHTTP');
      }
      try {
        xhr.open('GET', noCacheUrl, false);
        xhr.send(null);
      } catch (e$2) {
      }
      status = xhr.status == 1223 ? 204 : xhr.status;
      content = xhr.responseText;
      if (status >= 200 && status < 300 || status == 304 || status == 0 && content.length > 0) {
        Ext.globalEval(content + '\n//@ sourceURL\x3d' + url);
        onLoad.call(scope);
      } else {
      }
      xhr = null;
    }
  }, syncRequire:function() {
    var syncModeEnabled = this.syncModeEnabled;
    if (!syncModeEnabled) {
      this.syncModeEnabled = true;
    }
    this.require.apply(this, arguments);
    if (!syncModeEnabled) {
      this.syncModeEnabled = false;
    }
    this.refreshQueue();
  }, require:function(expressions, fn, scope, excludes) {
    var excluded = {}, included = {}, queue = this.queue, classNameToFilePathMap = this.classNameToFilePathMap, isClassFileLoaded = this.isClassFileLoaded, excludedClassNames = [], possibleClassNames = [], classNames = [], references = [], callback, syncModeEnabled, filePath, expression, exclude, className, possibleClassName, i, j, ln, subLn;
    if (excludes) {
      excludes = arrayFrom(excludes);
      for (i = 0, ln = excludes.length; i < ln; i++) {
        exclude = excludes[i];
        if (typeof exclude == 'string' && exclude.length > 0) {
          excludedClassNames = Manager.getNamesByExpression(exclude);
          for (j = 0, subLn = excludedClassNames.length; j < subLn; j++) {
            excluded[excludedClassNames[j]] = true;
          }
        }
      }
    }
    expressions = arrayFrom(expressions);
    if (fn) {
      if (fn.length > 0) {
        callback = function() {
          var classes = [], i, ln, name;
          for (i = 0, ln = references.length; i < ln; i++) {
            name = references[i];
            classes.push(Manager.get(name));
          }
          return fn.apply(this, classes);
        };
      } else {
        callback = fn;
      }
    } else {
      callback = Ext.emptyFn;
    }
    scope = scope || Ext.global;
    for (i = 0, ln = expressions.length; i < ln; i++) {
      expression = expressions[i];
      if (typeof expression == 'string' && expression.length > 0) {
        possibleClassNames = Manager.getNamesByExpression(expression);
        subLn = possibleClassNames.length;
        for (j = 0; j < subLn; j++) {
          possibleClassName = possibleClassNames[j];
          if (excluded[possibleClassName] !== true) {
            references.push(possibleClassName);
            if (!Manager.isCreated(possibleClassName) && !included[possibleClassName]) {
              included[possibleClassName] = true;
              classNames.push(possibleClassName);
            }
          }
        }
      }
    }
    if (classNames.length > 0) {
      if (!this.config.enabled) {
        throw new Error('Ext.Loader is not enabled, so dependencies cannot be resolved dynamically. Missing required class' + (classNames.length > 1 ? 'es' : '') + ': ' + classNames.join(', '));
      }
    } else {
      callback.call(scope);
      return this;
    }
    syncModeEnabled = this.syncModeEnabled;
    if (!syncModeEnabled) {
      queue.push({requires:classNames.slice(), callback:callback, scope:scope});
    }
    ln = classNames.length;
    for (i = 0; i < ln; i++) {
      className = classNames[i];
      filePath = this.getPath(className);
      if (syncModeEnabled && isClassFileLoaded.hasOwnProperty(className)) {
        this.numPendingFiles--;
        this.removeScriptElement(filePath);
        delete isClassFileLoaded[className];
      }
      if (!isClassFileLoaded.hasOwnProperty(className)) {
        isClassFileLoaded[className] = false;
        classNameToFilePathMap[className] = filePath;
        this.numPendingFiles++;
        this.loadScriptFile(filePath, pass(this.onFileLoaded, [className, filePath], this), pass(this.onFileLoadError, [className, filePath]), this, syncModeEnabled);
      }
    }
    if (syncModeEnabled) {
      callback.call(scope);
      if (ln === 1) {
        return Manager.get(className);
      }
    }
    return this;
  }, onFileLoaded:function(className, filePath) {
    this.numLoadedFiles++;
    this.isClassFileLoaded[className] = true;
    this.isFileLoaded[filePath] = true;
    this.numPendingFiles--;
    if (this.numPendingFiles === 0) {
      this.refreshQueue();
    }
  }, onFileLoadError:function(className, filePath, errorMessage, isSynchronous) {
    this.numPendingFiles--;
    this.hasFileLoadError = true;
  }, addOptionalRequires:function(requires) {
    var optionalRequires = this.optionalRequires, i, ln, require;
    requires = arrayFrom(requires);
    for (i = 0, ln = requires.length; i < ln; i++) {
      require = requires[i];
      arrayInclude(optionalRequires, require);
    }
    return this;
  }, triggerReady:function(force) {
    var readyListeners = this.readyListeners, optionalRequires = this.optionalRequires, listener;
    if (this.isLoading || force) {
      this.isLoading = false;
      if (optionalRequires.length !== 0) {
        optionalRequires = optionalRequires.slice();
        this.optionalRequires.length = 0;
        this.require(optionalRequires, pass(this.triggerReady, [true], this), this);
        return this;
      }
      while (readyListeners.length) {
        listener = readyListeners.shift();
        listener.fn.call(listener.scope);
        if (this.isLoading) {
          return this;
        }
      }
    }
    return this;
  }, onReady:function(fn, scope, withDomReady, options) {
    var oldFn;
    if (withDomReady !== false && Ext.onDocumentReady) {
      oldFn = fn;
      fn = function() {
        Ext.onDocumentReady(oldFn, scope, options);
      };
    }
    if (!this.isLoading) {
      fn.call(scope);
    } else {
      this.readyListeners.push({fn:fn, scope:scope});
    }
  }, historyPush:function(className) {
    var isInHistory = this.isInHistory;
    if (className && this.isClassFileLoaded.hasOwnProperty(className) && !isInHistory[className]) {
      isInHistory[className] = true;
      this.history.push(className);
    }
    return this;
  }});
  Ext.require = alias(Loader, 'require');
  Ext.syncRequire = alias(Loader, 'syncRequire');
  Ext.exclude = alias(Loader, 'exclude');
  Ext.onReady = function(fn, scope, options) {
    Loader.onReady(fn, scope, true, options);
  };
  Class.registerPreprocessor('loader', function(cls, data, hooks, continueFn) {
    var me = this, dependencies = [], className = Manager.getName(cls), i, j, ln, subLn, value, propertyName, propertyValue;
    for (i = 0, ln = dependencyProperties.length; i < ln; i++) {
      propertyName = dependencyProperties[i];
      if (data.hasOwnProperty(propertyName)) {
        propertyValue = data[propertyName];
        if (typeof propertyValue == 'string') {
          dependencies.push(propertyValue);
        } else {
          if (propertyValue instanceof Array) {
            for (j = 0, subLn = propertyValue.length; j < subLn; j++) {
              value = propertyValue[j];
              if (typeof value == 'string') {
                dependencies.push(value);
              }
            }
          } else {
            if (typeof propertyValue != 'function') {
              for (j in propertyValue) {
                if (propertyValue.hasOwnProperty(j)) {
                  value = propertyValue[j];
                  if (typeof value == 'string') {
                    dependencies.push(value);
                  }
                }
              }
            }
          }
        }
      }
    }
    if (dependencies.length === 0) {
      return;
    }
    Loader.require(dependencies, function() {
      for (i = 0, ln = dependencyProperties.length; i < ln; i++) {
        propertyName = dependencyProperties[i];
        if (data.hasOwnProperty(propertyName)) {
          propertyValue = data[propertyName];
          if (typeof propertyValue == 'string') {
            data[propertyName] = Manager.get(propertyValue);
          } else {
            if (propertyValue instanceof Array) {
              for (j = 0, subLn = propertyValue.length; j < subLn; j++) {
                value = propertyValue[j];
                if (typeof value == 'string') {
                  data[propertyName][j] = Manager.get(value);
                }
              }
            } else {
              if (typeof propertyValue != 'function') {
                for (var k in propertyValue) {
                  if (propertyValue.hasOwnProperty(k)) {
                    value = propertyValue[k];
                    if (typeof value == 'string') {
                      data[propertyName][k] = Manager.get(value);
                    }
                  }
                }
              }
            }
          }
        }
      }
      continueFn.call(me, cls, data, hooks);
    });
    return false;
  }, true, 'after', 'className');
  Manager.registerPostprocessor('uses', function(name, cls, data) {
    var uses = arrayFrom(data.uses), items = [], i, ln, item;
    for (i = 0, ln = uses.length; i < ln; i++) {
      item = uses[i];
      if (typeof item == 'string') {
        items.push(item);
      }
    }
    Loader.addOptionalRequires(items);
  });
  Manager.onCreated(function(className) {
    this.historyPush(className);
  }, Loader);
})(Ext.ClassManager, Ext.Class, Ext.Function.flexSetter, Ext.Function.alias, Ext.Function.pass, Ext.Array.from, Ext.Array.erase, Ext.Array.include);
(function() {
  var scripts = document.getElementsByTagName('script'), currentScript = scripts[scripts.length - 1], src = currentScript.src, path = src.substring(0, src.lastIndexOf('/') + 1), Loader = Ext.Loader;
  Loader.setConfig({enabled:true, disableCaching:!/[?&](cache|breakpoint)/i.test(location.search), paths:{'Ext':path + 'src'}});
})();
Ext.setVersion('touch', '2.4.2.571');
Ext.apply(Ext, {version:Ext.getVersion('touch'), idSeed:0, repaint:function() {
  var mask = Ext.getBody().createChild({cls:'x-mask x-mask-transparent'});
  setTimeout(function() {
    mask.destroy();
  }, 0);
}, id:function(el, prefix) {
  if (el && el.id) {
    return el.id;
  }
  el = Ext.getDom(el) || {};
  if (el === document || el === document.documentElement) {
    el.id = 'ext-app';
  } else {
    if (el === document.body) {
      el.id = 'ext-body';
    } else {
      if (el === window) {
        el.id = 'ext-window';
      }
    }
  }
  el.id = el.id || (prefix || 'ext-') + ++Ext.idSeed;
  return el.id;
}, getBody:function() {
  if (!Ext.documentBodyElement) {
    if (!document.body) {
      throw new Error('[Ext.getBody] document.body does not exist at this point');
    }
    Ext.documentBodyElement = Ext.get(document.body);
  }
  return Ext.documentBodyElement;
}, getHead:function() {
  if (!Ext.documentHeadElement) {
    Ext.documentHeadElement = Ext.get(document.head || document.getElementsByTagName('head')[0]);
  }
  return Ext.documentHeadElement;
}, getDoc:function() {
  if (!Ext.documentElement) {
    Ext.documentElement = Ext.get(document);
  }
  return Ext.documentElement;
}, getCmp:function(id) {
  return Ext.ComponentMgr.get(id);
}, copyTo:function(dest, source, names, usePrototypeKeys) {
  if (typeof names == 'string') {
    names = names.split(/[,;\s]/);
  }
  Ext.each(names, function(name) {
    if (usePrototypeKeys || source.hasOwnProperty(name)) {
      dest[name] = source[name];
    }
  }, this);
  return dest;
}, destroy:function() {
  var args = arguments, ln = args.length, i, item;
  for (i = 0; i < ln; i++) {
    item = args[i];
    if (item) {
      if (Ext.isArray(item)) {
        this.destroy.apply(this, item);
      } else {
        if (Ext.isFunction(item.destroy)) {
          item.destroy();
        }
      }
    }
  }
}, getDom:function(el) {
  if (!el || !document) {
    return null;
  }
  return el.dom ? el.dom : typeof el == 'string' ? document.getElementById(el) : el;
}, removeNode:function(node) {
  if (node && node.parentNode && node.tagName != 'BODY') {
    Ext.get(node).clearListeners();
    node.parentNode.removeChild(node);
    delete Ext.cache[node.id];
  }
}, defaultSetupConfig:{eventPublishers:{dom:{xclass:'Ext.event.publisher.Dom'}, touchGesture:{xclass:'Ext.event.publisher.TouchGesture', recognizers:{drag:{xclass:'Ext.event.recognizer.Drag'}, tap:{xclass:'Ext.event.recognizer.Tap'}, doubleTap:{xclass:'Ext.event.recognizer.DoubleTap'}, longPress:{xclass:'Ext.event.recognizer.LongPress'}, swipe:{xclass:'Ext.event.recognizer.Swipe'}, pinch:{xclass:'Ext.event.recognizer.Pinch'}, rotate:{xclass:'Ext.event.recognizer.Rotate'}, edgeSwipe:{xclass:'Ext.event.recognizer.EdgeSwipe'}}}, 
componentDelegation:{xclass:'Ext.event.publisher.ComponentDelegation'}, componentPaint:{xclass:'Ext.event.publisher.ComponentPaint'}, elementPaint:{xclass:'Ext.event.publisher.ElementPaint'}, elementSize:{xclass:'Ext.event.publisher.ElementSize'}}, animator:{xclass:'Ext.fx.Runner'}, viewport:{xclass:'Ext.viewport.Viewport'}}, isSetup:false, frameStartTime:+new Date, setupListeners:[], onSetup:function(fn, scope) {
  if (Ext.isSetup) {
    fn.call(scope);
  } else {
    Ext.setupListeners.push({fn:fn, scope:scope});
  }
}, setup:function(config) {
  var defaultSetupConfig = Ext.defaultSetupConfig, emptyFn = Ext.emptyFn, onReady = config.onReady || emptyFn, onUpdated = config.onUpdated || emptyFn, scope = config.scope, requires = Ext.Array.from(config.requires), extOnReady = Ext.onReady, head = Ext.getHead(), callback, viewport, precomposed;
  Ext.setup = function() {
    throw new Error('Ext.setup has already been called before');
  };
  delete config.requires;
  delete config.onReady;
  delete config.onUpdated;
  delete config.scope;
  callback = function() {
    var listeners = Ext.setupListeners, ln = listeners.length, i, listener;
    delete Ext.setupListeners;
    Ext.isSetup = true;
    for (i = 0; i < ln; i++) {
      listener = listeners[i];
      listener.fn.call(listener.scope);
    }
    Ext.onReady = extOnReady;
    Ext.onReady(onReady, scope);
  };
  Ext.onUpdated = onUpdated;
  Ext.onReady = function(fn, scope) {
    var origin = onReady;
    onReady = function() {
      origin();
      Ext.onReady(fn, scope);
    };
  };
  config = Ext.merge({}, defaultSetupConfig, config);
  Ext.onDocumentReady(function() {
    Ext.factoryConfig(config, function(data) {
      Ext.event.Dispatcher.getInstance().setPublishers(data.eventPublishers);
      if (data.logger) {
        Ext.Logger = data.logger;
      }
      if (data.animator) {
        Ext.Animator = data.animator;
      }
      if (data.viewport) {
        Ext.Viewport = viewport = data.viewport;
        if (!scope) {
          scope = viewport;
        }
        Ext.require(requires, function() {
          Ext.Viewport.on('ready', callback, null, {single:true});
        });
      } else {
        Ext.require(requires, callback);
      }
    });
    if (!Ext.microloaded && navigator.userAgent.match(/IEMobile\/10\.0/)) {
      var msViewportStyle = document.createElement('style');
      msViewportStyle.appendChild(document.createTextNode('@media screen and (orientation: portrait) {@-ms-viewport {width: 320px !important;}}@media screen and (orientation: landscape) {@-ms-viewport {width: 560px !important;}}'));
      head.appendChild(msViewportStyle);
    }
  });
  function addMeta(name, content) {
    var meta = document.createElement('meta');
    meta.setAttribute('name', name);
    meta.setAttribute('content', content);
    head.append(meta);
  }
  function addIcon(href, sizes, precomposed) {
    var link = document.createElement('link');
    link.setAttribute('rel', 'apple-touch-icon' + (precomposed ? '-precomposed' : ''));
    link.setAttribute('href', href);
    if (sizes) {
      link.setAttribute('sizes', sizes);
    }
    head.append(link);
  }
  function addStartupImage(href, media) {
    var link = document.createElement('link');
    link.setAttribute('rel', 'apple-touch-startup-image');
    link.setAttribute('href', href);
    if (media) {
      link.setAttribute('media', media);
    }
    head.append(link);
  }
  var icon = config.icon, isIconPrecomposed = Boolean(config.isIconPrecomposed), startupImage = config.startupImage || {}, statusBarStyle = config.statusBarStyle || 'black', devicePixelRatio = window.devicePixelRatio || 1;
  if (navigator.standalone) {
    addMeta('viewport', 'width\x3ddevice-width, initial-scale\x3d1.0, maximum-scale\x3d1.0, minimum-scale\x3d1.0');
  } else {
    addMeta('viewport', 'initial-scale\x3d1.0, maximum-scale\x3d1.0, minimum-scale\x3d1.0, minimum-ui');
  }
  addMeta('apple-mobile-web-app-capable', 'yes');
  addMeta('apple-touch-fullscreen', 'yes');
  if (Ext.browser.is.ie) {
    addMeta('msapplication-tap-highlight', 'no');
  }
  if (statusBarStyle) {
    addMeta('apple-mobile-web-app-status-bar-style', statusBarStyle);
  }
  if (Ext.isString(icon)) {
    icon = {57:icon, 72:icon, 114:icon, 144:icon};
  } else {
    if (!icon) {
      icon = {};
    }
  }
  if (Ext.os.is.iPad) {
    if (devicePixelRatio >= 2) {
      if ('1496x2048' in startupImage) {
        addStartupImage(startupImage['1496x2048'], '(orientation: landscape)');
      }
      if ('1536x2008' in startupImage) {
        addStartupImage(startupImage['1536x2008'], '(orientation: portrait)');
      }
      if ('144' in icon) {
        addIcon(icon['144'], '144x144', isIconPrecomposed);
      }
    } else {
      if ('748x1024' in startupImage) {
        addStartupImage(startupImage['748x1024'], '(orientation: landscape)');
      }
      if ('768x1004' in startupImage) {
        addStartupImage(startupImage['768x1004'], '(orientation: portrait)');
      }
      if ('72' in icon) {
        addIcon(icon['72'], '72x72', isIconPrecomposed);
      }
    }
  } else {
    if (devicePixelRatio >= 2 && Ext.os.version.gtEq('4.3')) {
      if (Ext.os.is.iPhone5) {
        addStartupImage(startupImage['640x1096']);
      } else {
        addStartupImage(startupImage['640x920']);
      }
      if ('114' in icon) {
        addIcon(icon['114'], '114x114', isIconPrecomposed);
      }
    } else {
      addStartupImage(startupImage['320x460']);
      if ('57' in icon) {
        addIcon(icon['57'], null, isIconPrecomposed);
      }
    }
  }
}, application:function(config) {
  var appName = config.name, onReady, scope, requires;
  if (!config) {
    config = {};
  }
  if (!Ext.Loader.config.paths[appName]) {
    Ext.Loader.setPath(appName, config.appFolder || 'app');
  }
  requires = Ext.Array.from(config.requires);
  config.requires = ['Ext.app.Application'];
  onReady = config.onReady;
  scope = config.scope;
  config.onReady = function() {
    config.requires = requires;
    new Ext.app.Application(config);
    if (onReady) {
      onReady.call(scope);
    }
  };
  Ext.setup(config);
}, factoryConfig:function(config, callback) {
  var isSimpleObject = Ext.isSimpleObject(config);
  if (isSimpleObject && config.xclass) {
    var className = config.xclass;
    delete config.xclass;
    Ext.require(className, function() {
      Ext.factoryConfig(config, function(cfg) {
        callback(Ext.create(className, cfg));
      });
    });
    return;
  }
  var isArray = Ext.isArray(config), keys = [], key, value, i, ln;
  if (isSimpleObject || isArray) {
    var factory = function() {
      if (i >= ln) {
        callback(config);
        return;
      }
      key = keys[i];
      value = config[key];
      Ext.factoryConfig(value, fn);
    };
    var fn = function(value) {
      config[key] = value;
      i++;
      factory();
    };
    if (isSimpleObject) {
      for (key in config) {
        if (config.hasOwnProperty(key)) {
          value = config[key];
          if (Ext.isSimpleObject(value) || Ext.isArray(value)) {
            keys.push(key);
          }
        }
      }
    } else {
      for (i = 0, ln = config.length; i < ln; i++) {
        value = config[i];
        if (Ext.isSimpleObject(value) || Ext.isArray(value)) {
          keys.push(i);
        }
      }
    }
    i = 0;
    ln = keys.length;
    if (ln === 0) {
      callback(config);
      return;
    }
    factory();
    return;
  }
  callback(config);
}, factory:function(config, classReference, instance, aliasNamespace) {
  var manager = Ext.ClassManager, newInstance;
  if (!config || config.isInstance) {
    if (instance && instance !== config) {
      instance.destroy();
    }
    return config;
  }
  if (aliasNamespace) {
    if (typeof config == 'string') {
      return manager.instantiateByAlias(aliasNamespace + '.' + config);
    } else {
      if (Ext.isObject(config) && 'type' in config) {
        return manager.instantiateByAlias(aliasNamespace + '.' + config.type, config);
      }
    }
  }
  if (config === true) {
    return instance || manager.instantiate(classReference);
  }
  if ('xtype' in config) {
    newInstance = manager.instantiateByAlias('widget.' + config.xtype, config);
  } else {
    if ('xclass' in config) {
      newInstance = manager.instantiate(config.xclass, config);
    }
  }
  if (newInstance) {
    if (instance) {
      instance.destroy();
    }
    return newInstance;
  }
  if (instance) {
    return instance.setConfig(config);
  }
  return manager.instantiate(classReference, config);
}, deprecateClassMember:function(cls, oldName, newName, message) {
  return this.deprecateProperty(cls.prototype, oldName, newName, message);
}, deprecateClassMembers:function(cls, members) {
  var prototype = cls.prototype, oldName, newName;
  for (oldName in members) {
    if (members.hasOwnProperty(oldName)) {
      newName = members[oldName];
      this.deprecateProperty(prototype, oldName, newName);
    }
  }
}, deprecateProperty:function(object, oldName, newName, message) {
  if (!message) {
    message = "'" + oldName + "' is deprecated";
  }
  if (newName) {
    message += ", please use '" + newName + "' instead";
  }
  if (newName) {
    Ext.Object.defineProperty(object, oldName, {get:function() {
      return this[newName];
    }, set:function(value) {
      this[newName] = value;
    }, configurable:true});
  }
}, deprecatePropertyValue:function(object, name, value, message) {
  Ext.Object.defineProperty(object, name, {get:function() {
    return value;
  }, configurable:true});
}, deprecateMethod:function(object, name, method, message) {
  object[name] = function() {
    if (method) {
      return method.apply(this, arguments);
    }
  };
}, deprecateClassMethod:function(cls, name, method, message) {
  if (typeof name != 'string') {
    var from, to;
    for (from in name) {
      if (name.hasOwnProperty(from)) {
        to = name[from];
        Ext.deprecateClassMethod(cls, from, to);
      }
    }
    return;
  }
  var isLateBinding = typeof method == 'string', member;
  if (!message) {
    message = "'" + name + "()' is deprecated, please use '" + (isLateBinding ? method : method.name) + "()' instead";
  }
  if (isLateBinding) {
    member = function() {
      return this[method].apply(this, arguments);
    };
  } else {
    member = function() {
      return method.apply(this, arguments);
    };
  }
  if (name in cls.prototype) {
    Ext.Object.defineProperty(cls.prototype, name, {value:null, writable:true, configurable:true});
  }
  cls.addMember(name, member);
}, isReady:false, readyListeners:[], triggerReady:function() {
  var listeners = Ext.readyListeners, i, ln, listener;
  if (!Ext.isReady) {
    Ext.isReady = true;
    for (i = 0, ln = listeners.length; i < ln; i++) {
      listener = listeners[i];
      listener.fn.call(listener.scope);
    }
    delete Ext.readyListeners;
  }
}, onDocumentReady:function(fn, scope) {
  if (Ext.isReady) {
    fn.call(scope);
  } else {
    var triggerFn = Ext.triggerReady;
    Ext.readyListeners.push({fn:fn, scope:scope});
    if ((Ext.browser.is.WebWorks || Ext.browser.is.PhoneGap) && !Ext.os.is.Desktop) {
      if (!Ext.readyListenerAttached) {
        Ext.readyListenerAttached = true;
        document.addEventListener(Ext.browser.is.PhoneGap ? 'deviceready' : 'webworksready', triggerFn, false);
      }
    } else {
      var readyStateRe = /MSIE 10/.test(navigator.userAgent) ? /complete|loaded/ : /interactive|complete|loaded/;
      if (document.readyState.match(readyStateRe) !== null) {
        triggerFn();
      } else {
        if (!Ext.readyListenerAttached) {
          Ext.readyListenerAttached = true;
          window.addEventListener('DOMContentLoaded', function() {
            if (navigator.standalone) {
              setTimeout(function() {
                setTimeout(function() {
                  triggerFn();
                }, 1);
              }, 1);
            } else {
              setTimeout(function() {
                triggerFn();
              }, 1);
            }
          }, false);
        }
      }
    }
  }
}, callback:function(callback, scope, args, delay) {
  if (Ext.isFunction(callback)) {
    args = args || [];
    scope = scope || window;
    if (delay) {
      Ext.defer(callback, delay, scope, args);
    } else {
      callback.apply(scope, args);
    }
  }
}});
Ext.cmd.derive('Ext.env.Browser', Ext.Base, {statics:{browserNames:{ie:'IE', firefox:'Firefox', safari:'Safari', chrome:'Chrome', opera:'Opera', dolfin:'Dolfin', webosbrowser:'webOSBrowser', chromeMobile:'ChromeMobile', chromeiOS:'ChromeiOS', silk:'Silk', other:'Other'}, engineNames:{webkit:'WebKit', gecko:'Gecko', presto:'Presto', trident:'Trident', other:'Other'}, enginePrefixes:{webkit:'AppleWebKit/', gecko:'Gecko/', presto:'Presto/', trident:'Trident/'}, browserPrefixes:{ie:'MSIE ', firefox:'Firefox/', 
chrome:'Chrome/', safari:'Version/', opera:'OPR/', dolfin:'Dolfin/', webosbrowser:'wOSBrowser/', chromeMobile:'CrMo/', chromeiOS:'CriOS/', silk:'Silk/'}}, styleDashPrefixes:{WebKit:'-webkit-', Gecko:'-moz-', Trident:'-ms-', Presto:'-o-', Other:''}, stylePrefixes:{WebKit:'Webkit', Gecko:'Moz', Trident:'ms', Presto:'O', Other:''}, propertyPrefixes:{WebKit:'webkit', Gecko:'moz', Trident:'ms', Presto:'o', Other:''}, is:Ext.emptyFn, name:null, version:null, engineName:null, engineVersion:null, setFlag:function(name, 
value) {
  if (typeof value == 'undefined') {
    value = true;
  }
  this.is[name] = value;
  this.is[name.toLowerCase()] = value;
  return this;
}, constructor:function(userAgent) {
  this.userAgent = userAgent;
  var statics = this.statics(), browserMatch = userAgent.match(new RegExp('((?:' + Ext.Object.getValues(statics.browserPrefixes).join(')|(?:') + '))([\\w\\._]+)')), engineMatch = userAgent.match(new RegExp('((?:' + Ext.Object.getValues(statics.enginePrefixes).join(')|(?:') + '))([\\w\\._]+)')), browserNames = statics.browserNames, browserName = browserNames.other, engineNames = statics.engineNames, engineName = engineNames.other, browserVersion = '', engineVersion = '', isWebView = false, is, i, 
  name;
  is = this.is = function(name) {
    return is[name] === true;
  };
  if (browserMatch) {
    browserName = browserNames[Ext.Object.getKey(statics.browserPrefixes, browserMatch[1])];
    browserVersion = new Ext.Version(browserMatch[2]);
  }
  if (engineMatch) {
    engineName = engineNames[Ext.Object.getKey(statics.enginePrefixes, engineMatch[1])];
    engineVersion = new Ext.Version(engineMatch[2]);
  }
  if (engineName == 'Trident' && browserName != 'IE') {
    browserName = 'IE';
    var version = userAgent.match(/.*rv:(\d+.\d+)/);
    if (version && version.length) {
      version = version[1];
      browserVersion = new Ext.Version(version);
    }
  }
  if (userAgent.match(/FB/) && browserName == 'Other') {
    browserName = browserNames.safari;
    engineName = engineNames.webkit;
  }
  if (userAgent.match(/Android.*Chrome/g)) {
    browserName = 'ChromeMobile';
  }
  if (userAgent.match(/OPR/)) {
    browserName = 'Opera';
    browserMatch = userAgent.match(/OPR\/(\d+.\d+)/);
    browserVersion = new Ext.Version(browserMatch[1]);
  }
  if (browserName === 'Safari' && userAgent.match(/BB10/)) {
    browserName = 'BlackBerry';
  }
  Ext.apply(this, {engineName:engineName, engineVersion:engineVersion, name:browserName, version:browserVersion});
  this.setFlag(browserName);
  if (browserVersion) {
    this.setFlag(browserName + (browserVersion.getMajor() || ''));
    this.setFlag(browserName + browserVersion.getShortVersion());
  }
  for (i in browserNames) {
    if (browserNames.hasOwnProperty(i)) {
      name = browserNames[i];
      this.setFlag(name, browserName === name);
    }
  }
  this.setFlag(name);
  if (engineVersion) {
    this.setFlag(engineName + (engineVersion.getMajor() || ''));
    this.setFlag(engineName + engineVersion.getShortVersion());
  }
  for (i in engineNames) {
    if (engineNames.hasOwnProperty(i)) {
      name = engineNames[i];
      this.setFlag(name, engineName === name);
    }
  }
  this.setFlag('Standalone', !!navigator.standalone);
  this.setFlag('Ripple', !!document.getElementById('tinyhippos-injected') && !Ext.isEmpty(window.top.ripple));
  this.setFlag('WebWorks', !!window.blackberry);
  if (typeof window.PhoneGap != 'undefined' || typeof window.Cordova != 'undefined' || typeof window.cordova != 'undefined') {
    isWebView = true;
    this.setFlag('PhoneGap');
    this.setFlag('Cordova');
  } else {
    if (!!window.isNK) {
      isWebView = true;
      this.setFlag('Sencha');
    }
  }
  if (/(Glass)/i.test(userAgent)) {
    this.setFlag('GoogleGlass');
  }
  if (/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)(?!.*FBAN)/i.test(userAgent)) {
    isWebView = true;
  }
  this.setFlag('WebView', isWebView);
  this.isStrict = document.compatMode == 'CSS1Compat';
  this.isSecure = /^https/i.test(window.location.protocol);
  return this;
}, getStyleDashPrefix:function() {
  return this.styleDashPrefixes[this.engineName];
}, getStylePrefix:function() {
  return this.stylePrefixes[this.engineName];
}, getVendorProperyName:function(name) {
  var prefix = this.propertyPrefixes[this.engineName];
  if (prefix.length > 0) {
    return prefix + Ext.String.capitalize(name);
  }
  return name;
}, getPreferredTranslationMethod:function(config) {
  if (typeof config == 'object' && 'translationMethod' in config && config.translationMethod !== 'auto') {
    return config.translationMethod;
  } else {
    if (this.is.AndroidStock2 || this.is.IE) {
      return 'scrollposition';
    } else {
      return 'csstransform';
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.env, 'Browser'], function() {
  var browserEnv = Ext.browser = new this(Ext.global.navigator.userAgent);
});
Ext.cmd.derive('Ext.env.OS', Ext.Base, {statics:{names:{ios:'iOS', android:'Android', windowsPhone:'WindowsPhone', webos:'webOS', blackberry:'BlackBerry', rimTablet:'RIMTablet', mac:'MacOS', win:'Windows', tizen:'Tizen', linux:'Linux', bada:'Bada', chrome:'ChromeOS', other:'Other'}, prefixes:{tizen:'(Tizen )', ios:'i(?:Pad|Phone|Pod)(?:.*)CPU(?: iPhone)? OS ', android:'(Android |HTC_|Silk/)', windowsPhone:'Windows Phone ', blackberry:'(?:BlackBerry|BB)(?:.*)Version/', rimTablet:'RIM Tablet OS ', 
webos:'(?:webOS|hpwOS)/', bada:'Bada/', chrome:'CrOS '}}, is:Ext.emptyFn, name:null, version:null, setFlag:function(name, value) {
  if (typeof value == 'undefined') {
    value = true;
  }
  this.is[name] = value;
  this.is[name.toLowerCase()] = value;
  return this;
}, constructor:function(userAgent, platform, browserScope) {
  var statics = this.statics(), names = statics.names, prefixes = statics.prefixes, name, version = '', i, prefix, match, item, is, match1;
  browserScope = browserScope || Ext.browser;
  is = this.is = function(name) {
    return this.is[name] === true;
  };
  for (i in prefixes) {
    if (prefixes.hasOwnProperty(i)) {
      prefix = prefixes[i];
      match = userAgent.match(new RegExp('(?:' + prefix + ')([^\\s;]+)'));
      if (match) {
        name = names[i];
        match1 = match[1];
        if (match1 && match1 == 'HTC_') {
          version = new Ext.Version('2.3');
        } else {
          if (match1 && match1 == 'Silk/') {
            version = new Ext.Version('2.3');
          } else {
            version = new Ext.Version(match[match.length - 1]);
          }
        }
        break;
      }
    }
  }
  if (!name) {
    name = names[(userAgent.toLowerCase().match(/mac|win|linux/) || ['other'])[0]];
    version = new Ext.Version('');
  }
  this.name = name;
  this.version = version;
  if (platform) {
    this.setFlag(platform.replace(/ simulator$/i, ''));
  }
  this.setFlag(name);
  if (version) {
    this.setFlag(name + (version.getMajor() || ''));
    this.setFlag(name + version.getShortVersion());
  }
  for (i in names) {
    if (names.hasOwnProperty(i)) {
      item = names[i];
      if (!is.hasOwnProperty(name)) {
        this.setFlag(item, name === item);
      }
    }
  }
  if (this.name == 'iOS' && window.screen.height == 568) {
    this.setFlag('iPhone5');
  }
  if (browserScope.is.Safari || browserScope.is.Silk) {
    if (this.is.Android2 || this.is.Android3 || browserScope.version.shortVersion == 501) {
      browserScope.setFlag('AndroidStock');
      browserScope.setFlag('AndroidStock2');
    }
    if (this.is.Android4) {
      browserScope.setFlag('AndroidStock');
      browserScope.setFlag('AndroidStock4');
    }
  }
  return this;
}}, 1, 0, 0, 0, 0, 0, [Ext.env, 'OS'], function() {
  var navigation = Ext.global.navigator, userAgent = navigation.userAgent, osEnv, osName, deviceType;
  Ext.os = osEnv = new this(userAgent, navigation.platform);
  osName = osEnv.name;
  var search = window.location.search.match(/deviceType=(Tablet|Phone)/), nativeDeviceType = window.deviceType;
  if (search && search[1]) {
    deviceType = search[1];
  } else {
    if (nativeDeviceType === 'iPhone') {
      deviceType = 'Phone';
    } else {
      if (nativeDeviceType === 'iPad') {
        deviceType = 'Tablet';
      } else {
        if (!osEnv.is.Android && !osEnv.is.iOS && !osEnv.is.WindowsPhone && /Windows|Linux|MacOS/.test(osName)) {
          deviceType = 'Desktop';
          Ext.browser.is.WebView = Ext.browser.is.Ripple ? true : false;
        } else {
          if (osEnv.is.iPad || osEnv.is.RIMTablet || osEnv.is.Android3 || Ext.browser.is.Silk || osEnv.is.Android && userAgent.search(/mobile/i) == -1) {
            deviceType = 'Tablet';
          } else {
            deviceType = 'Phone';
          }
        }
      }
    }
  }
  osEnv.setFlag(deviceType, true);
  osEnv.deviceType = deviceType;
});
Ext.cmd.derive('Ext.env.Feature', Ext.Base, {constructor:function() {
  this.testElements = {};
  this.has = function(name) {
    return !!this.has[name];
  };
  if (!Ext.theme) {
    Ext.theme = {name:'Default'};
  }
  Ext.theme.is = {};
  Ext.theme.is[Ext.theme.name] = true;
  Ext.onDocumentReady(function() {
    this.registerTest({ProperHBoxStretching:function() {
      var bodyElement = document.createElement('div'), innerElement = bodyElement.appendChild(document.createElement('div')), contentElement = innerElement.appendChild(document.createElement('div')), innerWidth;
      bodyElement.setAttribute('style', 'width: 100px; height: 100px; position: relative;');
      innerElement.setAttribute('style', 'position: absolute; display: -ms-flexbox; display: -webkit-flex; display: -moz-flexbox; display: flex; -ms-flex-direction: row; -webkit-flex-direction: row; -moz-flex-direction: row; flex-direction: row; min-width: 100%;');
      contentElement.setAttribute('style', 'width: 200px; height: 50px;');
      document.body.appendChild(bodyElement);
      innerWidth = innerElement.offsetWidth;
      document.body.removeChild(bodyElement);
      return innerWidth > 100;
    }});
  }, this);
}, getTestElement:function(tag, createNew) {
  if (tag === undefined) {
    tag = 'div';
  } else {
    if (typeof tag !== 'string') {
      return tag;
    }
  }
  if (createNew) {
    return document.createElement(tag);
  }
  if (!this.testElements[tag]) {
    this.testElements[tag] = document.createElement(tag);
  }
  return this.testElements[tag];
}, isStyleSupported:function(name, tag) {
  var elementStyle = this.getTestElement(tag).style, cName = Ext.String.capitalize(name);
  if (typeof elementStyle[name] !== 'undefined' || typeof elementStyle[Ext.browser.getStylePrefix(name) + cName] !== 'undefined') {
    return true;
  }
  return false;
}, isStyleSupportedWithoutPrefix:function(name, tag) {
  var elementStyle = this.getTestElement(tag).style;
  if (typeof elementStyle[name] !== 'undefined') {
    return true;
  }
  return false;
}, isEventSupported:function(name, tag) {
  if (tag === undefined) {
    tag = window;
  }
  var element = this.getTestElement(tag), eventName = 'on' + name.toLowerCase(), isSupported = eventName in element;
  if (!isSupported) {
    if (element.setAttribute && element.removeAttribute) {
      element.setAttribute(eventName, '');
      isSupported = typeof element[eventName] === 'function';
      if (typeof element[eventName] !== 'undefined') {
        element[eventName] = undefined;
      }
      element.removeAttribute(eventName);
    }
  }
  return isSupported;
}, getSupportedPropertyName:function(object, name) {
  var vendorName = Ext.browser.getVendorProperyName(name);
  if (vendorName in object) {
    return vendorName;
  } else {
    if (name in object) {
      return name;
    }
  }
  return null;
}, registerTest:Ext.Function.flexSetter(function(name, fn) {
  this.has[name] = fn.call(this);
  return this;
})}, 1, 0, 0, 0, 0, 0, [Ext.env, 'Feature'], function() {
  Ext.feature = new this;
  var has = Ext.feature.has;
  Ext.feature.registerTest({Canvas:function() {
    var element = this.getTestElement('canvas');
    return !!(element && element.getContext && element.getContext('2d'));
  }, Svg:function() {
    var doc = document;
    return !!(doc.createElementNS && !!doc.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect);
  }, Vml:function() {
    var element = this.getTestElement(), ret = false;
    element.innerHTML = '\x3c!--[if vml]\x3e\x3cbr\x3e\x3c![endif]--\x3e';
    ret = element.childNodes.length === 1;
    element.innerHTML = '';
    return ret;
  }, Touch:function() {
    return Ext.browser.is.Ripple || this.isEventSupported('touchstart') && !(Ext.os && Ext.os.name.match(/Windows|MacOS|Linux/) && !Ext.os.is.BlackBerry6);
  }, Pointer:function() {
    return !!window.navigator.msPointerEnabled;
  }, Orientation:function() {
    return 'orientation' in window;
  }, OrientationChange:function() {
    return this.isEventSupported('orientationchange');
  }, DeviceMotion:function() {
    return this.isEventSupported('devicemotion');
  }, Geolocation:function() {
    return 'geolocation' in window.navigator;
  }, SqlDatabase:function() {
    return 'openDatabase' in window;
  }, WebSockets:function() {
    return 'WebSocket' in window;
  }, Range:function() {
    return !!document.createRange;
  }, CreateContextualFragment:function() {
    var range = !!document.createRange ? document.createRange() : false;
    return range && !!range.createContextualFragment;
  }, History:function() {
    return 'history' in window && 'pushState' in window.history;
  }, CssTransforms:function() {
    return this.isStyleSupported('transform');
  }, CssTransformNoPrefix:function() {
    if (!Ext.browser.is.AndroidStock) {
      return this.isStyleSupportedWithoutPrefix('transform');
    } else {
      return this.isStyleSupportedWithoutPrefix('transform') && !this.isStyleSupportedWithoutPrefix('-webkit-transform');
    }
  }, Css3dTransforms:function() {
    return this.has('CssTransforms') && this.isStyleSupported('perspective') && !Ext.browser.is.AndroidStock2;
  }, CssAnimations:function() {
    return this.isStyleSupported('animationName');
  }, CssTransitions:function() {
    return this.isStyleSupported('transitionProperty');
  }, Audio:function() {
    return !!this.getTestElement('audio').canPlayType;
  }, Video:function() {
    return !!this.getTestElement('video').canPlayType;
  }, ClassList:function() {
    return 'classList' in this.getTestElement();
  }, LocalStorage:function() {
    var supported = false;
    try {
      if ('localStorage' in window && window['localStorage'] !== null) {
        localStorage.setItem('sencha-localstorage-test', 'test success');
        localStorage.removeItem('sencha-localstorage-test');
        supported = true;
      }
    } catch (e$3) {
    }
    return supported;
  }, MatchMedia:function() {
    return 'matchMedia' in window;
  }, XHR2:function() {
    return window.ProgressEvent && window.FormData && window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest;
  }, XHRUploadProgress:function() {
    if (window.XMLHttpRequest && !Ext.browser.is.AndroidStock) {
      var xhr = new XMLHttpRequest;
      return xhr && 'upload' in xhr && 'onprogress' in xhr.upload;
    }
    return false;
  }, NumericInputPlaceHolder:function() {
    return !(Ext.browser.is.AndroidStock4 && Ext.os.version.getMinor() < 2);
  }});
});
Ext.cmd.derive('Ext.dom.Query', Ext.Base, {select:function(q, root) {
  var results = [], nodes, i, j, qlen, nlen;
  root = root || document;
  if (typeof root == 'string') {
    root = document.getElementById(root);
  }
  q = q.split(',');
  for (i = 0, qlen = q.length; i < qlen; i++) {
    if (typeof q[i] == 'string') {
      if (q[i][0] == '@') {
        nodes = root.getAttributeNode(q[i].substring(1));
        results.push(nodes);
      } else {
        nodes = root.querySelectorAll(q[i]);
        for (j = 0, nlen = nodes.length; j < nlen; j++) {
          results.push(nodes[j]);
        }
      }
    }
  }
  return results;
}, selectNode:function(q, root) {
  return this.select(q, root)[0];
}, is:function(el, q) {
  var root, is, i, ln;
  if (typeof el == 'string') {
    el = document.getElementById(el);
  }
  if (Ext.isArray(el)) {
    is = true;
    ln = el.length;
    for (i = 0; i < ln; i++) {
      if (!this.is(el[i], q)) {
        is = false;
        break;
      }
    }
  } else {
    root = el.parentNode;
    if (!root) {
      root = document.createDocumentFragment();
      root.appendChild(el);
      is = this.select(q, root).indexOf(el) !== -1;
      root.removeChild(el);
      root = null;
    } else {
      is = this.select(q, root).indexOf(el) !== -1;
    }
  }
  return is;
}, isXml:function(el) {
  var docEl = (el ? el.ownerDocument || el : 0).documentElement;
  return docEl ? docEl.nodeName !== 'HTML' : false;
}}, 0, 0, 0, 0, 0, 0, [Ext.dom, 'Query'], function() {
  Ext.ns('Ext.core');
  Ext.core.DomQuery = Ext.DomQuery = new this;
  Ext.query = Ext.Function.alias(Ext.DomQuery, 'select');
});
Ext.cmd.derive('Ext.dom.Helper', Ext.Base, {emptyTags:/^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i, confRe:/tag|children|cn|html|tpl|tplData$/i, endRe:/end/i, attribXlat:{cls:'class', htmlFor:'for'}, closeTags:{}, decamelizeName:function() {
  var camelCaseRe = /([a-z])([A-Z])/g, cache = {};
  function decamel(match, p1, p2) {
    return p1 + '-' + p2.toLowerCase();
  }
  return function(s) {
    return cache[s] || (cache[s] = s.replace(camelCaseRe, decamel));
  };
}(), generateMarkup:function(spec, buffer) {
  var me = this, attr, val, tag, i, closeTags;
  if (typeof spec == 'string') {
    buffer.push(spec);
  } else {
    if (Ext.isArray(spec)) {
      for (i = 0; i < spec.length; i++) {
        if (spec[i]) {
          me.generateMarkup(spec[i], buffer);
        }
      }
    } else {
      tag = spec.tag || 'div';
      buffer.push('\x3c', tag);
      for (attr in spec) {
        if (spec.hasOwnProperty(attr)) {
          val = spec[attr];
          if (!me.confRe.test(attr)) {
            if (typeof val == 'object') {
              buffer.push(' ', attr, '\x3d"');
              me.generateStyles(val, buffer).push('"');
            } else {
              buffer.push(' ', me.attribXlat[attr] || attr, '\x3d"', val, '"');
            }
          }
        }
      }
      if (me.emptyTags.test(tag)) {
        buffer.push('/\x3e');
      } else {
        buffer.push('\x3e');
        if (val = spec.tpl) {
          val.applyOut(spec.tplData, buffer);
        }
        if (val = spec.html) {
          buffer.push(val);
        }
        if (val = spec.cn || spec.children) {
          me.generateMarkup(val, buffer);
        }
        closeTags = me.closeTags;
        buffer.push(closeTags[tag] || (closeTags[tag] = '\x3c/' + tag + '\x3e'));
      }
    }
  }
  return buffer;
}, generateStyles:function(styles, buffer) {
  var a = buffer || [], name;
  for (name in styles) {
    if (styles.hasOwnProperty(name)) {
      a.push(this.decamelizeName(name), ':', styles[name], ';');
    }
  }
  return buffer || a.join('');
}, markup:function(spec) {
  if (typeof spec == 'string') {
    return spec;
  }
  var buf = this.generateMarkup(spec, []);
  return buf.join('');
}, applyStyles:function(el, styles) {
  Ext.fly(el).applyStyles(styles);
}, createContextualFragment:function(html) {
  var div = document.createElement('div'), fragment = document.createDocumentFragment(), i = 0, length, childNodes;
  div.innerHTML = html;
  childNodes = div.childNodes;
  length = childNodes.length;
  for (; i < length; i++) {
    fragment.appendChild(childNodes[i].cloneNode(true));
  }
  return fragment;
}, insertHtml:function(where, el, html) {
  var setStart, range, frag, rangeEl, isBeforeBegin, isAfterBegin;
  where = where.toLowerCase();
  if (Ext.isTextNode(el)) {
    if (where == 'afterbegin') {
      where = 'beforebegin';
    } else {
      if (where == 'beforeend') {
        where = 'afterend';
      }
    }
  }
  isBeforeBegin = where == 'beforebegin';
  isAfterBegin = where == 'afterbegin';
  range = Ext.feature.has.CreateContextualFragment ? el.ownerDocument.createRange() : undefined;
  setStart = 'setStart' + (this.endRe.test(where) ? 'After' : 'Before');
  if (isBeforeBegin || where == 'afterend') {
    if (range) {
      range[setStart](el);
      frag = range.createContextualFragment(html);
    } else {
      frag = this.createContextualFragment(html);
    }
    el.parentNode.insertBefore(frag, isBeforeBegin ? el : el.nextSibling);
    return el[(isBeforeBegin ? 'previous' : 'next') + 'Sibling'];
  } else {
    rangeEl = (isAfterBegin ? 'first' : 'last') + 'Child';
    if (el.firstChild) {
      if (range) {
        try {
          range[setStart](el[rangeEl]);
          frag = range.createContextualFragment(html);
        } catch (e$4) {
          frag = this.createContextualFragment(html);
        }
      } else {
        frag = this.createContextualFragment(html);
      }
      if (isAfterBegin) {
        el.insertBefore(frag, el.firstChild);
      } else {
        el.appendChild(frag);
      }
    } else {
      el.innerHTML = html;
    }
    return el[rangeEl];
  }
}, insertBefore:function(el, o, returnElement) {
  return this.doInsert(el, o, returnElement, 'beforebegin');
}, insertAfter:function(el, o, returnElement) {
  return this.doInsert(el, o, returnElement, 'afterend');
}, insertFirst:function(el, o, returnElement) {
  return this.doInsert(el, o, returnElement, 'afterbegin');
}, append:function(el, o, returnElement) {
  return this.doInsert(el, o, returnElement, 'beforeend');
}, overwrite:function(el, o, returnElement) {
  el = Ext.getDom(el);
  el.innerHTML = this.markup(o);
  return returnElement ? Ext.get(el.firstChild) : el.firstChild;
}, doInsert:function(el, o, returnElement, pos) {
  var newNode = this.insertHtml(pos, Ext.getDom(el), this.markup(o));
  return returnElement ? Ext.get(newNode, true) : newNode;
}, createTemplate:function(o) {
  var html = this.markup(o);
  return new Ext.Template(html);
}}, 0, 0, 0, 0, 0, 0, [Ext.dom, 'Helper'], function() {
  Ext.ns('Ext.core');
  Ext.core.DomHelper = Ext.DomHelper = new this;
});
Ext.cmd.derive('Ext.mixin.Identifiable', Ext.Base, {statics:{uniqueIds:{}}, isIdentifiable:true, mixinId:'identifiable', idCleanRegex:/\.|[^\w\-]/g, defaultIdPrefix:'ext-', defaultIdSeparator:'-', getOptimizedId:function() {
  return this.id;
}, getUniqueId:function() {
  var id = this.id, prototype, separator, xtype, uniqueIds, prefix;
  if (!id) {
    prototype = this.self.prototype;
    separator = this.defaultIdSeparator;
    uniqueIds = Ext.mixin.Identifiable.uniqueIds;
    if (!prototype.hasOwnProperty('identifiablePrefix')) {
      xtype = this.xtype;
      if (xtype) {
        prefix = this.defaultIdPrefix + xtype + separator;
      } else {
        prefix = prototype.$className.replace(this.idCleanRegex, separator).toLowerCase() + separator;
      }
      prototype.identifiablePrefix = prefix;
    }
    prefix = this.identifiablePrefix;
    if (!uniqueIds.hasOwnProperty(prefix)) {
      uniqueIds[prefix] = 0;
    }
    id = this.id = prefix + ++uniqueIds[prefix];
  }
  this.getUniqueId = this.getOptimizedId;
  return id;
}, setId:function(id) {
  this.id = id;
}, getId:function() {
  var id = this.id;
  if (!id) {
    id = this.getUniqueId();
  }
  this.getId = this.getOptimizedId;
  return id;
}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Identifiable'], 0);
Ext.cmd.derive('Ext.dom.Element', Ext.Base, {alternateClassName:'Ext.Element', observableType:'element', statics:{CREATE_ATTRIBUTES:{style:'style', className:'className', cls:'cls', classList:'classList', text:'text', hidden:'hidden', html:'html', children:'children'}, create:function(attributes, domNode) {
  var ATTRIBUTES = this.CREATE_ATTRIBUTES, element, elementStyle, tag, value, name, i, ln;
  if (!attributes) {
    attributes = {};
  }
  if (attributes.isElement) {
    return attributes.dom;
  } else {
    if ('nodeType' in attributes) {
      return attributes;
    }
  }
  if (typeof attributes == 'string') {
    return document.createTextNode(attributes);
  }
  tag = attributes.tag;
  if (!tag) {
    tag = 'div';
  }
  if (attributes.namespace) {
    element = document.createElementNS(attributes.namespace, tag);
  } else {
    element = document.createElement(tag);
  }
  elementStyle = element.style;
  for (name in attributes) {
    if (name != 'tag') {
      value = attributes[name];
      switch(name) {
        case ATTRIBUTES.style:
          if (typeof value == 'string') {
            element.setAttribute(name, value);
          } else {
            for (i in value) {
              if (value.hasOwnProperty(i)) {
                elementStyle[i] = value[i];
              }
            }
          }
          break;
        case ATTRIBUTES.className:
        case ATTRIBUTES.cls:
          element.className = value;
          break;
        case ATTRIBUTES.classList:
          element.className = value.join(' ');
          break;
        case ATTRIBUTES.text:
          element.textContent = value;
          break;
        case ATTRIBUTES.hidden:
          if (value) {
            element.style.display = 'none';
          }
          break;
        case ATTRIBUTES.html:
          element.innerHTML = value;
          break;
        case ATTRIBUTES.children:
          for (i = 0, ln = value.length; i < ln; i++) {
            element.appendChild(this.create(value[i], true));
          }
          break;
        default:
          element.setAttribute(name, value);
      }
    }
  }
  if (domNode) {
    return element;
  } else {
    return this.get(element);
  }
}, documentElement:null, cache:{}, get:function(element) {
  var cache = this.cache, instance, dom, id;
  if (!element) {
    return null;
  }
  if (typeof element == 'string') {
    dom = document.getElementById(element);
    if (cache.hasOwnProperty(element)) {
      instance = cache[element];
    }
    if (dom) {
      if (instance) {
        instance.dom = dom;
      } else {
        instance = cache[element] = new this(dom);
      }
    } else {
      if (!instance) {
        instance = null;
      }
    }
    return instance;
  }
  if ('tagName' in element) {
    id = element.id;
    if (cache.hasOwnProperty(id)) {
      instance = cache[id];
      instance.dom = element;
      return instance;
    } else {
      instance = new this(element);
      cache[instance.getId()] = instance;
    }
    return instance;
  }
  if (element.isElement) {
    return element;
  }
  if (element.isComposite) {
    return element;
  }
  if (Ext.isArray(element)) {
    return this.select(element);
  }
  if (element === document) {
    if (!this.documentElement) {
      this.documentElement = new this(document.documentElement);
      this.documentElement.setId('ext-application');
    }
    return this.documentElement;
  }
  return null;
}, data:function(element, key, value) {
  var cache = Ext.cache, id, data;
  element = this.get(element);
  if (!element) {
    return null;
  }
  id = element.id;
  data = cache[id].data;
  if (!data) {
    cache[id].data = data = {};
  }
  if (arguments.length == 2) {
    return data[key];
  } else {
    return data[key] = value;
  }
}, serializeForm:function(form) {
  var fElements = form.elements || (document.forms[form] || Ext.getDom(form)).elements, hasSubmit = false, encoder = encodeURIComponent, data = '', eLen = fElements.length, element, name, type, options, hasValue, e, o, oLen, opt;
  for (e = 0; e < eLen; e++) {
    element = fElements[e];
    name = element.name;
    type = element.type;
    options = element.options;
    if (!element.disabled && name) {
      if (/select-(one|multiple)/i.test(type)) {
        oLen = options.length;
        for (o = 0; o < oLen; o++) {
          opt = options[o];
          if (opt.selected) {
            hasValue = opt.hasAttribute ? opt.hasAttribute('value') : opt.getAttributeNode('value').specified;
            data += Ext.String.format('{0}\x3d{1}\x26', encoder(name), encoder(hasValue ? opt.value : opt.text));
          }
        }
      } else {
        if (!/file|undefined|reset|button/i.test(type)) {
          if (!(/radio|checkbox/i.test(type) && !element.checked) && !(type == 'submit' && hasSubmit)) {
            data += encoder(name) + '\x3d' + encoder(element.value) + '\x26';
            hasSubmit = /submit/i.test(type);
          }
        }
      }
    }
  }
  return data.substr(0, data.length - 1);
}, serializeNode:function(node) {
  var result = '', i, n, attr, child;
  if (node.nodeType === document.TEXT_NODE) {
    return node.nodeValue;
  }
  result += '\x3c' + node.nodeName;
  if (node.attributes.length) {
    for (i = 0, n = node.attributes.length; i < n; i++) {
      attr = node.attributes[i];
      result += ' ' + attr.name + '\x3d"' + attr.value + '"';
    }
  }
  result += '\x3e';
  if (node.childNodes && node.childNodes.length) {
    for (i = 0, n = node.childNodes.length; i < n; i++) {
      child = node.childNodes[i];
      result += this.serializeNode(child);
    }
  }
  result += '\x3c/' + node.nodeName + '\x3e';
  return result;
}}, isElement:true, constructor:function(dom) {
  if (typeof dom == 'string') {
    dom = document.getElementById(dom);
  }
  if (!dom) {
    throw new Error('Invalid domNode reference or an id of an existing domNode: ' + dom);
  }
  this.dom = dom;
  this.getUniqueId();
}, attach:function(dom) {
  this.dom = dom;
  this.id = dom.id;
  return this;
}, getUniqueId:function() {
  var id = this.id, dom;
  if (!id) {
    dom = this.dom;
    if (dom.id.length > 0) {
      this.id = id = dom.id;
    } else {
      dom.id = id = this.mixins.identifiable.getUniqueId.call(this);
    }
    Ext.Element.cache[id] = this;
  }
  return id;
}, setId:function(id) {
  var currentId = this.id, cache = Ext.Element.cache;
  if (currentId) {
    delete cache[currentId];
  }
  this.dom.id = id;
  this.id = id;
  cache[id] = this;
  return this;
}, setHtml:function(html) {
  this.dom.innerHTML = html;
}, getHtml:function() {
  return this.dom.innerHTML;
}, setText:function(text) {
  this.dom.textContent = text;
}, redraw:function() {
  var dom = this.dom, domStyle = dom.style;
  domStyle.display = 'none';
  dom.offsetHeight;
  domStyle.display = '';
}, isPainted:function() {
  return !Ext.browser.is.IE ? function() {
    var dom = this.dom;
    return Boolean(dom && dom.offsetParent);
  } : function() {
    var dom = this.dom;
    return Boolean(dom && (dom.offsetHeight !== 0 && dom.offsetWidth !== 0));
  };
}(), set:function(attributes, useSet) {
  var dom = this.dom, attribute, value;
  for (attribute in attributes) {
    if (attributes.hasOwnProperty(attribute)) {
      value = attributes[attribute];
      if (attribute == 'style') {
        this.applyStyles(value);
      } else {
        if (attribute == 'cls') {
          dom.className = value;
        } else {
          if (useSet !== false) {
            if (value === undefined) {
              dom.removeAttribute(attribute);
            } else {
              dom.setAttribute(attribute, value);
            }
          } else {
            dom[attribute] = value;
          }
        }
      }
    }
  }
  return this;
}, is:function(selector) {
  return Ext.DomQuery.is(this.dom, selector);
}, getValue:function(asNumber) {
  var value = this.dom.value;
  return asNumber ? parseInt(value, 10) : value;
}, getAttribute:function(name, namespace) {
  var dom = this.dom;
  return dom.getAttributeNS(namespace, name) || dom.getAttribute(namespace + ':' + name) || dom.getAttribute(name) || dom[name];
}, setSizeState:function(state) {
  var classes = ['x-sized', 'x-unsized', 'x-stretched'], states = [true, false, null], index = states.indexOf(state), addedClass;
  if (index !== -1) {
    addedClass = classes[index];
    classes.splice(index, 1);
    this.addCls(addedClass);
  }
  this.removeCls(classes);
  return this;
}, destroy:function() {
  this.isDestroyed = true;
  var cache = Ext.Element.cache, dom = this.dom;
  if (dom && dom.parentNode && dom.tagName != 'BODY') {
    dom.parentNode.removeChild(dom);
  }
  delete cache[this.id];
  delete this.dom;
}}, 1, ['element'], ['element'], {'element':true}, ['widget.element'], [[Ext.mixin.Identifiable.prototype.mixinId || Ext.mixin.Identifiable.$className, Ext.mixin.Identifiable]], [Ext.dom, 'Element', Ext, 'Element'], function(Element) {
  Ext.elements = Ext.cache = Element.cache;
  this.addStatics({Fly:new Ext.Class({extend:Element, constructor:function(dom) {
    this.dom = dom;
  }}), _flyweights:{}, fly:function(element, named) {
    var fly = null, flyweights = Element._flyweights, cachedElement;
    named = named || '_global';
    element = Ext.getDom(element);
    if (element) {
      fly = flyweights[named] || (flyweights[named] = new Element.Fly);
      fly.dom = element;
      fly.isSynchronized = false;
      cachedElement = Ext.cache[element.id];
      if (cachedElement && cachedElement.isElement) {
        cachedElement.isSynchronized = false;
      }
    }
    return fly;
  }});
  Ext.get = function(element) {
    return Element.get(element);
  };
  Ext.fly = function() {
    return Element.fly.apply(Element, arguments);
  };
  Ext.ClassManager.onCreated(function() {
    Element.mixin('observable', Ext.mixin.Observable);
  }, null, 'Ext.mixin.Observable');
});
Ext.dom.Element.addStatics({numberRe:/\d+$/, unitRe:/\d+(px|em|%|en|ex|pt|in|cm|mm|pc)$/i, camelRe:/(-[a-z])/gi, cssRe:/([a-z0-9-]+)\s*:\s*([^;\s]+(?:\s*[^;\s]+)*);?/gi, opacityRe:/alpha\(opacity=(.*)\)/i, propertyCache:{}, defaultUnit:'px', borders:{l:'border-left-width', r:'border-right-width', t:'border-top-width', b:'border-bottom-width'}, paddings:{l:'padding-left', r:'padding-right', t:'padding-top', b:'padding-bottom'}, margins:{l:'margin-left', r:'margin-right', t:'margin-top', b:'margin-bottom'}, 
addUnits:function(size, units) {
  if (size === '' || size == 'auto' || size === undefined || size === null) {
    return size || '';
  }
  if (Ext.isNumber(size) || this.numberRe.test(size)) {
    return size + (units || this.defaultUnit || 'px');
  } else {
    if (!this.unitRe.test(size)) {
      return size || '';
    }
  }
  return size;
}, isAncestor:function(p, c) {
  var ret = false;
  p = Ext.getDom(p);
  c = Ext.getDom(c);
  if (p && c) {
    if (p.contains) {
      return p.contains(c);
    } else {
      if (p.compareDocumentPosition) {
        return !!(p.compareDocumentPosition(c) & 16);
      } else {
        while (c = c.parentNode) {
          ret = c == p || ret;
        }
      }
    }
  }
  return ret;
}, parseBox:function(box) {
  if (typeof box != 'string') {
    box = box.toString();
  }
  var parts = box.split(' '), ln = parts.length;
  if (ln == 1) {
    parts[1] = parts[2] = parts[3] = parts[0];
  } else {
    if (ln == 2) {
      parts[2] = parts[0];
      parts[3] = parts[1];
    } else {
      if (ln == 3) {
        parts[3] = parts[1];
      }
    }
  }
  return {top:parts[0] || 0, right:parts[1] || 0, bottom:parts[2] || 0, left:parts[3] || 0};
}, unitizeBox:function(box, units) {
  var me = this;
  box = me.parseBox(box);
  return me.addUnits(box.top, units) + ' ' + me.addUnits(box.right, units) + ' ' + me.addUnits(box.bottom, units) + ' ' + me.addUnits(box.left, units);
}, camelReplaceFn:function(m, a) {
  return a.charAt(1).toUpperCase();
}, normalize:function(prop) {
  return this.propertyCache[prop] || (this.propertyCache[prop] = prop.replace(this.camelRe, this.camelReplaceFn));
}, fromPoint:function(x, y) {
  return Ext.get(document.elementFromPoint(x, y));
}, parseStyles:function(styles) {
  var out = {}, cssRe = this.cssRe, matches;
  if (styles) {
    cssRe.lastIndex = 0;
    while (matches = cssRe.exec(styles)) {
      out[matches[1]] = matches[2];
    }
  }
  return out;
}});
Ext.dom.Element.addMembers({appendChild:function(element) {
  this.dom.appendChild(Ext.getDom(element));
  return this;
}, removeChild:function(element) {
  this.dom.removeChild(Ext.getDom(element));
  return this;
}, append:function() {
  this.appendChild.apply(this, arguments);
}, appendTo:function(el) {
  Ext.getDom(el).appendChild(this.dom);
  return this;
}, insertBefore:function(el) {
  el = Ext.getDom(el);
  el.parentNode.insertBefore(this.dom, el);
  return this;
}, insertAfter:function(el) {
  el = Ext.getDom(el);
  el.parentNode.insertBefore(this.dom, el.nextSibling);
  return this;
}, insertFirst:function(element) {
  var elementDom = Ext.getDom(element), dom = this.dom, firstChild = dom.firstChild;
  if (!firstChild) {
    dom.appendChild(elementDom);
  } else {
    dom.insertBefore(elementDom, firstChild);
  }
  return this;
}, insertSibling:function(el, where, returnDom) {
  var me = this, rt, isAfter = (where || 'before').toLowerCase() == 'after', insertEl;
  if (Ext.isArray(el)) {
    insertEl = me;
    Ext.each(el, function(e) {
      rt = Ext.fly(insertEl, '_internal').insertSibling(e, where, returnDom);
      if (isAfter) {
        insertEl = rt;
      }
    });
    return rt;
  }
  el = el || {};
  if (el.nodeType || el.dom) {
    rt = me.dom.parentNode.insertBefore(Ext.getDom(el), isAfter ? me.dom.nextSibling : me.dom);
    if (!returnDom) {
      rt = Ext.get(rt);
    }
  } else {
    if (isAfter && !me.dom.nextSibling) {
      rt = Ext.core.DomHelper.append(me.dom.parentNode, el, !returnDom);
    } else {
      rt = Ext.core.DomHelper[isAfter ? 'insertAfter' : 'insertBefore'](me.dom, el, !returnDom);
    }
  }
  return rt;
}, replace:function(element) {
  element = Ext.getDom(element);
  element.parentNode.replaceChild(this.dom, element);
  return this;
}, replaceWith:function(el) {
  var me = this;
  if (el.nodeType || el.dom || typeof el == 'string') {
    el = Ext.get(el);
    me.dom.parentNode.insertBefore(el.dom, me.dom);
  } else {
    el = Ext.core.DomHelper.insertBefore(me.dom, el);
  }
  delete Ext.cache[me.id];
  Ext.removeNode(me.dom);
  me.id = Ext.id(me.dom = el);
  return me;
}, doReplaceWith:function(element) {
  var dom = this.dom;
  dom.parentNode.replaceChild(Ext.getDom(element), dom);
}, createChild:function(config, insertBefore, returnDom) {
  config = config || {tag:'div'};
  if (insertBefore) {
    return Ext.core.DomHelper.insertBefore(insertBefore, config, returnDom !== true);
  } else {
    return Ext.core.DomHelper[!this.dom.firstChild ? 'insertFirst' : 'append'](this.dom, config, returnDom !== true);
  }
}, wrap:function(config, domNode) {
  var dom = this.dom, wrapper = this.self.create(config, domNode), wrapperDom = domNode ? wrapper : wrapper.dom, parentNode = dom.parentNode;
  if (parentNode) {
    parentNode.insertBefore(wrapperDom, dom);
  }
  wrapperDom.appendChild(dom);
  return wrapper;
}, wrapAllChildren:function(config) {
  var dom = this.dom, children = dom.childNodes, wrapper = this.self.create(config), wrapperDom = wrapper.dom;
  while (children.length > 0) {
    wrapperDom.appendChild(dom.firstChild);
  }
  dom.appendChild(wrapperDom);
  return wrapper;
}, unwrapAllChildren:function() {
  var dom = this.dom, children = dom.childNodes, parentNode = dom.parentNode;
  if (parentNode) {
    while (children.length > 0) {
      parentNode.insertBefore(dom, dom.firstChild);
    }
    this.destroy();
  }
}, unwrap:function() {
  var dom = this.dom, parentNode = dom.parentNode, grandparentNode;
  if (parentNode) {
    grandparentNode = parentNode.parentNode;
    grandparentNode.insertBefore(dom, parentNode);
    grandparentNode.removeChild(parentNode);
  } else {
    grandparentNode = document.createDocumentFragment();
    grandparentNode.appendChild(dom);
  }
  return this;
}, detach:function() {
  var dom = this.dom;
  if (dom && dom.parentNode && dom.tagName !== 'BODY') {
    dom.parentNode.removeChild(dom);
  }
  return this;
}, insertHtml:function(where, html, returnEl) {
  var el = Ext.core.DomHelper.insertHtml(where, this.dom, html);
  return returnEl ? Ext.get(el) : el;
}});
Ext.dom.Element.override({getX:function() {
  return this.getXY()[0];
}, getY:function() {
  return this.getXY()[1];
}, getXY:function() {
  var rect = this.dom.getBoundingClientRect(), round = Math.round;
  return [round(rect.left + window.pageXOffset), round(rect.top + window.pageYOffset)];
}, getOffsetsTo:function(el) {
  var o = this.getXY(), e = Ext.fly(el, '_internal').getXY();
  return [o[0] - e[0], o[1] - e[1]];
}, setX:function(x) {
  return this.setXY([x, this.getY()]);
}, setY:function(y) {
  return this.setXY([this.getX(), y]);
}, setXY:function(pos) {
  var me = this;
  if (arguments.length > 1) {
    pos = [pos, arguments[1]];
  }
  var pts = me.translatePoints(pos), style = me.dom.style;
  for (pos in pts) {
    if (!pts.hasOwnProperty(pos)) {
      continue;
    }
    if (!isNaN(pts[pos])) {
      style[pos] = pts[pos] + 'px';
    }
  }
  return me;
}, getLeft:function() {
  return parseInt(this.getStyle('left'), 10) || 0;
}, getRight:function() {
  return parseInt(this.getStyle('right'), 10) || 0;
}, getTop:function() {
  return parseInt(this.getStyle('top'), 10) || 0;
}, getBottom:function() {
  return parseInt(this.getStyle('bottom'), 10) || 0;
}, translatePoints:function(x, y) {
  y = isNaN(x[1]) ? y : x[1];
  x = isNaN(x[0]) ? x : x[0];
  var me = this, relative = me.isStyle('position', 'relative'), o = me.getXY(), l = parseInt(me.getStyle('left'), 10), t = parseInt(me.getStyle('top'), 10);
  l = !isNaN(l) ? l : relative ? 0 : me.dom.offsetLeft;
  t = !isNaN(t) ? t : relative ? 0 : me.dom.offsetTop;
  return {left:x - o[0] + l, top:y - o[1] + t};
}, setBox:function(box) {
  var me = this, width = box.width, height = box.height, top = box.top, left = box.left;
  if (left !== undefined) {
    me.setLeft(left);
  }
  if (top !== undefined) {
    me.setTop(top);
  }
  if (width !== undefined) {
    me.setWidth(width);
  }
  if (height !== undefined) {
    me.setHeight(height);
  }
  return this;
}, getBox:function(contentBox, local) {
  var me = this, dom = me.dom, width = dom.offsetWidth, height = dom.offsetHeight, xy, box, l, r, t, b;
  if (!local) {
    xy = me.getXY();
  } else {
    if (contentBox) {
      xy = [0, 0];
    } else {
      xy = [parseInt(me.getStyle('left'), 10) || 0, parseInt(me.getStyle('top'), 10) || 0];
    }
  }
  if (!contentBox) {
    box = {x:xy[0], y:xy[1], 0:xy[0], 1:xy[1], width:width, height:height};
  } else {
    l = me.getBorderWidth.call(me, 'l') + me.getPadding.call(me, 'l');
    r = me.getBorderWidth.call(me, 'r') + me.getPadding.call(me, 'r');
    t = me.getBorderWidth.call(me, 't') + me.getPadding.call(me, 't');
    b = me.getBorderWidth.call(me, 'b') + me.getPadding.call(me, 'b');
    box = {x:xy[0] + l, y:xy[1] + t, 0:xy[0] + l, 1:xy[1] + t, width:width - (l + r), height:height - (t + b)};
  }
  box.left = box.x;
  box.top = box.y;
  box.right = box.x + box.width;
  box.bottom = box.y + box.height;
  return box;
}, getPageBox:function(getRegion) {
  var me = this, el = me.dom;
  if (!el) {
    return new Ext.util.Region;
  }
  var w = el.offsetWidth, h = el.offsetHeight, xy = me.getXY(), t = xy[1], r = xy[0] + w, b = xy[1] + h, l = xy[0];
  if (getRegion) {
    return new Ext.util.Region(t, r, b, l);
  } else {
    return {left:l, top:t, width:w, height:h, right:r, bottom:b};
  }
}});
Ext.dom.Element.addMembers({WIDTH:'width', HEIGHT:'height', MIN_WIDTH:'min-width', MIN_HEIGHT:'min-height', MAX_WIDTH:'max-width', MAX_HEIGHT:'max-height', TOP:'top', RIGHT:'right', BOTTOM:'bottom', LEFT:'left', VISIBILITY:1, DISPLAY:2, OFFSETS:3, SEPARATOR:'-', trimRe:/^\s+|\s+$/g, wordsRe:/\w/g, spacesRe:/\s+/, styleSplitRe:/\s*(?::|;)\s*/, transparentRe:/^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i, classNameSplitRegex:/[\s]+/, borders:{t:'border-top-width', r:'border-right-width', 
b:'border-bottom-width', l:'border-left-width'}, paddings:{t:'padding-top', r:'padding-right', b:'padding-bottom', l:'padding-left'}, margins:{t:'margin-top', r:'margin-right', b:'margin-bottom', l:'margin-left'}, defaultUnit:'px', isSynchronized:false, synchronize:function() {
  var dom = this.dom, hasClassMap = {}, className = dom.className, classList, i, ln, name;
  if (className.length > 0) {
    classList = dom.className.split(this.classNameSplitRegex);
    for (i = 0, ln = classList.length; i < ln; i++) {
      name = classList[i];
      hasClassMap[name] = true;
    }
  } else {
    classList = [];
  }
  this.classList = classList;
  this.hasClassMap = hasClassMap;
  this.isSynchronized = true;
  return this;
}, addCls:function(names, prefix, suffix) {
  if (!names) {
    return this;
  }
  if (!this.isSynchronized) {
    this.synchronize();
  }
  var dom = this.dom, map = this.hasClassMap, classList = this.classList, SEPARATOR = this.SEPARATOR, i, ln, name;
  prefix = prefix ? prefix + SEPARATOR : '';
  suffix = suffix ? SEPARATOR + suffix : '';
  if (typeof names == 'string') {
    names = names.split(this.spacesRe);
  }
  for (i = 0, ln = names.length; i < ln; i++) {
    name = prefix + names[i] + suffix;
    if (!map[name]) {
      map[name] = true;
      classList.push(name);
    }
  }
  dom.className = classList.join(' ');
  return this;
}, removeCls:function(names, prefix, suffix) {
  if (!names) {
    return this;
  }
  if (!this.isSynchronized) {
    this.synchronize();
  }
  if (!suffix) {
    suffix = '';
  }
  var dom = this.dom, map = this.hasClassMap, classList = this.classList, SEPARATOR = this.SEPARATOR, i, ln, name;
  prefix = prefix ? prefix + SEPARATOR : '';
  suffix = suffix ? SEPARATOR + suffix : '';
  if (typeof names == 'string') {
    names = names.split(this.spacesRe);
  }
  for (i = 0, ln = names.length; i < ln; i++) {
    name = prefix + names[i] + suffix;
    if (map[name]) {
      delete map[name];
      Ext.Array.remove(classList, name);
    }
  }
  dom.className = classList.join(' ');
  return this;
}, replaceCls:function(oldName, newName, prefix, suffix) {
  if (!oldName && !newName) {
    return this;
  }
  oldName = oldName || [];
  newName = newName || [];
  if (!this.isSynchronized) {
    this.synchronize();
  }
  if (!suffix) {
    suffix = '';
  }
  var dom = this.dom, map = this.hasClassMap, classList = this.classList, SEPARATOR = this.SEPARATOR, i, ln, name;
  prefix = prefix ? prefix + SEPARATOR : '';
  suffix = suffix ? SEPARATOR + suffix : '';
  if (typeof oldName == 'string') {
    oldName = oldName.split(this.spacesRe);
  }
  if (typeof newName == 'string') {
    newName = newName.split(this.spacesRe);
  }
  for (i = 0, ln = oldName.length; i < ln; i++) {
    name = prefix + oldName[i] + suffix;
    if (map[name]) {
      delete map[name];
      Ext.Array.remove(classList, name);
    }
  }
  for (i = 0, ln = newName.length; i < ln; i++) {
    name = prefix + newName[i] + suffix;
    if (!map[name]) {
      map[name] = true;
      classList.push(name);
    }
  }
  dom.className = classList.join(' ');
  return this;
}, hasCls:function(name) {
  if (!this.isSynchronized) {
    this.synchronize();
  }
  return this.hasClassMap.hasOwnProperty(name);
}, setCls:function(className) {
  var map = this.hasClassMap, i, ln, name;
  if (typeof className == 'string') {
    className = className.split(this.spacesRe);
  }
  for (i = 0, ln = className.length; i < ln; i++) {
    name = className[i];
    if (!map[name]) {
      map[name] = true;
    }
  }
  this.classList = className.slice();
  this.dom.className = className.join(' ');
}, toggleCls:function(className, force) {
  if (typeof force !== 'boolean') {
    force = !this.hasCls(className);
  }
  return force ? this.addCls(className) : this.removeCls(className);
}, swapCls:function(firstClass, secondClass, flag, prefix) {
  if (flag === undefined) {
    flag = true;
  }
  var addedClass = flag ? firstClass : secondClass, removedClass = flag ? secondClass : firstClass;
  if (removedClass) {
    this.removeCls(prefix ? prefix + '-' + removedClass : removedClass);
  }
  if (addedClass) {
    this.addCls(prefix ? prefix + '-' + addedClass : addedClass);
  }
  return this;
}, setWidth:function(width) {
  return this.setLengthValue(this.WIDTH, width);
}, setHeight:function(height) {
  return this.setLengthValue(this.HEIGHT, height);
}, setSize:function(width, height) {
  if (Ext.isObject(width)) {
    height = width.height;
    width = width.width;
  }
  this.setWidth(width);
  this.setHeight(height);
  return this;
}, setMinWidth:function(width) {
  return this.setLengthValue(this.MIN_WIDTH, width);
}, setMinHeight:function(height) {
  return this.setLengthValue(this.MIN_HEIGHT, height);
}, setMaxWidth:function(width) {
  return this.setLengthValue(this.MAX_WIDTH, width);
}, setMaxHeight:function(height) {
  return this.setLengthValue(this.MAX_HEIGHT, height);
}, setTop:function(top) {
  return this.setLengthValue(this.TOP, top);
}, setRight:function(right) {
  return this.setLengthValue(this.RIGHT, right);
}, setBottom:function(bottom) {
  return this.setLengthValue(this.BOTTOM, bottom);
}, setLeft:function(left) {
  return this.setLengthValue(this.LEFT, left);
}, setMargin:function(margin) {
  var domStyle = this.dom.style;
  if (margin || margin === 0) {
    margin = this.self.unitizeBox(margin === true ? 5 : margin);
    domStyle.setProperty('margin', margin, 'important');
  } else {
    domStyle.removeProperty('margin-top');
    domStyle.removeProperty('margin-right');
    domStyle.removeProperty('margin-bottom');
    domStyle.removeProperty('margin-left');
  }
}, setPadding:function(padding) {
  var domStyle = this.dom.style;
  if (padding || padding === 0) {
    padding = this.self.unitizeBox(padding === true ? 5 : padding);
    domStyle.setProperty('padding', padding, 'important');
  } else {
    domStyle.removeProperty('padding-top');
    domStyle.removeProperty('padding-right');
    domStyle.removeProperty('padding-bottom');
    domStyle.removeProperty('padding-left');
  }
}, setBorder:function(border) {
  var domStyle = this.dom.style;
  if (border || border === 0) {
    border = this.self.unitizeBox(border === true ? 1 : border);
    domStyle.setProperty('border-width', border, 'important');
  } else {
    domStyle.removeProperty('border-top-width');
    domStyle.removeProperty('border-right-width');
    domStyle.removeProperty('border-bottom-width');
    domStyle.removeProperty('border-left-width');
  }
}, setLengthValue:function(name, value) {
  var domStyle = this.dom.style;
  if (value === null) {
    domStyle.removeProperty(name);
    return this;
  }
  if (typeof value == 'number') {
    value = value + 'px';
  }
  domStyle.setProperty(name, value, 'important');
  return this;
}, setVisible:function(visible) {
  var mode = this.getVisibilityMode(), method = visible ? 'removeCls' : 'addCls';
  switch(mode) {
    case this.VISIBILITY:
      this.removeCls(['x-hidden-display', 'x-hidden-offsets']);
      this[method]('x-hidden-visibility');
      break;
    case this.DISPLAY:
      this.removeCls(['x-hidden-visibility', 'x-hidden-offsets']);
      this[method]('x-hidden-display');
      break;
    case this.OFFSETS:
      this.removeCls(['x-hidden-visibility', 'x-hidden-display']);
      this[method]('x-hidden-offsets');
      break;
  }
  return this;
}, getVisibilityMode:function() {
  var dom = this.dom, mode = Ext.dom.Element.data(dom, 'visibilityMode');
  if (mode === undefined) {
    Ext.dom.Element.data(dom, 'visibilityMode', mode = this.DISPLAY);
  }
  return mode;
}, setVisibilityMode:function(mode) {
  this.self.data(this.dom, 'visibilityMode', mode);
  return this;
}, show:function() {
  var dom = this.dom;
  if (dom) {
    dom.style.removeProperty('display');
  }
}, hide:function() {
  this.dom.style.setProperty('display', 'none', 'important');
}, setVisibility:function(isVisible) {
  var domStyle = this.dom.style;
  if (isVisible) {
    domStyle.removeProperty('visibility');
  } else {
    domStyle.setProperty('visibility', 'hidden', 'important');
  }
}, styleHooks:{}, addStyles:function(sides, styles) {
  var totalSize = 0, sidesArr = sides.match(this.wordsRe), i = 0, len = sidesArr.length, side, size;
  for (; i < len; i++) {
    side = sidesArr[i];
    size = side && parseInt(this.getStyle(styles[side]), 10);
    if (size) {
      totalSize += Math.abs(size);
    }
  }
  return totalSize;
}, isStyle:function(style, val) {
  return this.getStyle(style) == val;
}, getStyleValue:function(name) {
  return this.dom.style.getPropertyValue(name);
}, getStyle:function(prop) {
  var me = this, dom = me.dom, hook = me.styleHooks[prop], cs, result;
  if (dom == document) {
    return null;
  }
  if (!hook) {
    me.styleHooks[prop] = hook = {name:Ext.dom.Element.normalize(prop)};
  }
  if (hook.get) {
    return hook.get(dom, me);
  }
  cs = window.getComputedStyle(dom, '');
  result = cs && cs[hook.name];
  return result;
}, setStyle:function(prop, value) {
  var me = this, dom = me.dom, hooks = me.styleHooks, style = dom.style, valueFrom = Ext.valueFrom, name, hook;
  if (typeof prop == 'string') {
    hook = hooks[prop];
    if (!hook) {
      hooks[prop] = hook = {name:Ext.dom.Element.normalize(prop)};
    }
    value = valueFrom(value, '');
    if (hook.set) {
      hook.set(dom, value, me);
    } else {
      style[hook.name] = value;
    }
  } else {
    for (name in prop) {
      if (prop.hasOwnProperty(name)) {
        hook = hooks[name];
        if (!hook) {
          hooks[name] = hook = {name:Ext.dom.Element.normalize(name)};
        }
        value = valueFrom(prop[name], '');
        if (hook.set) {
          hook.set(dom, value, me);
        } else {
          style[hook.name] = value;
        }
      }
    }
  }
  return me;
}, getHeight:function(contentHeight) {
  var dom = this.dom, height = contentHeight ? dom.clientHeight - this.getPadding('tb') : dom.offsetHeight;
  return height > 0 ? height : 0;
}, getWidth:function(contentWidth) {
  var dom = this.dom, width = contentWidth ? dom.clientWidth - this.getPadding('lr') : dom.offsetWidth;
  return width > 0 ? width : 0;
}, getBorderWidth:function(side) {
  return this.addStyles(side, this.borders);
}, getPadding:function(side) {
  return this.addStyles(side, this.paddings);
}, applyStyles:function(styles) {
  if (styles) {
    var dom = this.dom, styleType, i, len;
    if (typeof styles == 'function') {
      styles = styles.call();
    }
    styleType = typeof styles;
    if (styleType == 'string') {
      styles = Ext.util.Format.trim(styles).split(this.styleSplitRe);
      for (i = 0, len = styles.length; i < len;) {
        dom.style[Ext.dom.Element.normalize(styles[i++])] = styles[i++];
      }
    } else {
      if (styleType == 'object') {
        this.setStyle(styles);
      }
    }
  }
  return this;
}, getSize:function(contentSize) {
  var dom = this.dom;
  return {width:Math.max(0, contentSize ? dom.clientWidth - this.getPadding('lr') : dom.offsetWidth), height:Math.max(0, contentSize ? dom.clientHeight - this.getPadding('tb') : dom.offsetHeight)};
}, repaint:function() {
  var dom = this.dom;
  this.addCls('x-repaint');
  setTimeout(function() {
    Ext.fly(dom).removeCls('x-repaint');
  }, 1);
  return this;
}, getMargin:function(side) {
  var me = this, hash = {t:'top', l:'left', r:'right', b:'bottom'}, o = {}, key;
  if (!side) {
    for (key in me.margins) {
      o[hash[key]] = parseFloat(me.getStyle(me.margins[key])) || 0;
    }
    return o;
  } else {
    return me.addStyles.call(me, side, me.margins);
  }
}, translate:function() {
  var transformStyleName = 'webkitTransform' in document.createElement('div').style ? 'webkitTransform' : 'transform';
  return function(x, y, z) {
    this.dom.style[transformStyleName] = 'translate3d(' + (x || 0) + 'px, ' + (y || 0) + 'px, ' + (z || 0) + 'px)';
  };
}()});
Ext.dom.Element.addMembers({getParent:function() {
  return Ext.get(this.dom.parentNode);
}, getFirstChild:function() {
  return Ext.get(this.dom.firstElementChild);
}, contains:function(element) {
  if (!element) {
    return false;
  }
  var dom = Ext.getDom(element);
  return dom === this.dom || this.self.isAncestor(this.dom, dom);
}, findParent:function(simpleSelector, maxDepth, returnEl) {
  var p = this.dom, b = document.body, depth = 0, stopEl;
  maxDepth = maxDepth || 50;
  if (isNaN(maxDepth)) {
    stopEl = Ext.getDom(maxDepth);
    maxDepth = Number.MAX_VALUE;
  }
  while (p && p.nodeType == 1 && depth < maxDepth && p != b && p != stopEl) {
    if (Ext.DomQuery.is(p, simpleSelector)) {
      return returnEl ? Ext.get(p) : p;
    }
    depth++;
    p = p.parentNode;
  }
  return null;
}, findParentNode:function(simpleSelector, maxDepth, returnEl) {
  var p = Ext.fly(this.dom.parentNode, '_internal');
  return p ? p.findParent(simpleSelector, maxDepth, returnEl) : null;
}, up:function(simpleSelector, maxDepth) {
  return this.findParentNode(simpleSelector, maxDepth, true);
}, select:function(selector, composite) {
  return Ext.dom.Element.select(selector, composite, this.dom);
}, query:function(selector) {
  return Ext.DomQuery.select(selector, this.dom);
}, down:function(selector, returnDom) {
  var n = Ext.DomQuery.selectNode(selector, this.dom);
  return returnDom ? n : Ext.get(n);
}, child:function(selector, returnDom) {
  var node, me = this, id;
  id = Ext.get(me).id;
  id = id.replace(/[\.:]/g, '\\$0');
  node = Ext.DomQuery.selectNode('#' + id + ' \x3e ' + selector, me.dom);
  return returnDom ? node : Ext.get(node);
}, parent:function(selector, returnDom) {
  return this.matchNode('parentNode', 'parentNode', selector, returnDom);
}, next:function(selector, returnDom) {
  return this.matchNode('nextSibling', 'nextSibling', selector, returnDom);
}, prev:function(selector, returnDom) {
  return this.matchNode('previousSibling', 'previousSibling', selector, returnDom);
}, first:function(selector, returnDom) {
  return this.matchNode('nextSibling', 'firstChild', selector, returnDom);
}, last:function(selector, returnDom) {
  return this.matchNode('previousSibling', 'lastChild', selector, returnDom);
}, matchNode:function(dir, start, selector, returnDom) {
  if (!this.dom) {
    return null;
  }
  var n = this.dom[start];
  while (n) {
    if (n.nodeType == 1 && (!selector || Ext.DomQuery.is(n, selector))) {
      return !returnDom ? Ext.get(n) : n;
    }
    n = n[dir];
  }
  return null;
}, isAncestor:function(element) {
  return this.self.isAncestor.call(this.self, this.dom, element);
}});
Ext.cmd.derive('Ext.dom.CompositeElementLite', Ext.Base, {alternateClassName:['Ext.CompositeElementLite', 'Ext.CompositeElement'], statics:{importElementMethods:function() {
}}, constructor:function(elements, root) {
  this.elements = [];
  this.add(elements, root);
  this.el = new Ext.dom.Element.Fly;
}, isComposite:true, getElement:function(el) {
  return this.el.attach(el).synchronize();
}, transformElement:function(el) {
  return Ext.getDom(el);
}, getCount:function() {
  return this.elements.length;
}, add:function(els, root) {
  var elements = this.elements, i, ln;
  if (!els) {
    return this;
  }
  if (typeof els == 'string') {
    els = Ext.dom.Element.selectorFunction(els, root);
  } else {
    if (els.isComposite) {
      els = els.elements;
    } else {
      if (!Ext.isIterable(els)) {
        els = [els];
      }
    }
  }
  for (i = 0, ln = els.length; i < ln; ++i) {
    elements.push(this.transformElement(els[i]));
  }
  return this;
}, invoke:function(fn, args) {
  var elements = this.elements, ln = elements.length, element, i;
  for (i = 0; i < ln; i++) {
    element = elements[i];
    if (element) {
      Ext.dom.Element.prototype[fn].apply(this.getElement(element), args);
    }
  }
  return this;
}, item:function(index) {
  var el = this.elements[index], out = null;
  if (el) {
    out = this.getElement(el);
  }
  return out;
}, addListener:function(eventName, handler, scope, opt) {
  var els = this.elements, len = els.length, i, e;
  for (i = 0; i < len; i++) {
    e = els[i];
    if (e) {
      e.on(eventName, handler, scope || e, opt);
    }
  }
  return this;
}, each:function(fn, scope) {
  var me = this, els = me.elements, len = els.length, i, e;
  for (i = 0; i < len; i++) {
    e = els[i];
    if (e) {
      e = this.getElement(e);
      if (fn.call(scope || e, e, me, i) === false) {
        break;
      }
    }
  }
  return me;
}, fill:function(els) {
  var me = this;
  me.elements = [];
  me.add(els);
  return me;
}, filter:function(selector) {
  var els = [], me = this, fn = Ext.isFunction(selector) ? selector : function(el) {
    return el.is(selector);
  };
  me.each(function(el, self, i) {
    if (fn(el, i) !== false) {
      els[els.length] = me.transformElement(el);
    }
  });
  me.elements = els;
  return me;
}, indexOf:function(el) {
  return Ext.Array.indexOf(this.elements, this.transformElement(el));
}, replaceElement:function(el, replacement, domReplace) {
  var index = !isNaN(el) ? el : this.indexOf(el), d;
  if (index > -1) {
    replacement = Ext.getDom(replacement);
    if (domReplace) {
      d = this.elements[index];
      d.parentNode.insertBefore(replacement, d);
      Ext.removeNode(d);
    }
    Ext.Array.splice(this.elements, index, 1, replacement);
  }
  return this;
}, clear:function() {
  this.elements = [];
}, addElements:function(els, root) {
  if (!els) {
    return this;
  }
  if (typeof els == 'string') {
    els = Ext.dom.Element.selectorFunction(els, root);
  }
  var yels = this.elements;
  Ext.each(els, function(e) {
    yels.push(Ext.get(e));
  });
  return this;
}, first:function() {
  return this.item(0);
}, last:function() {
  return this.item(this.getCount() - 1);
}, contains:function(el) {
  return this.indexOf(el) != -1;
}, removeElement:function(keys, removeDom) {
  var me = this, elements = this.elements, el;
  Ext.each(keys, function(val) {
    if (el = elements[val] || elements[val = me.indexOf(val)]) {
      if (removeDom) {
        if (el.dom) {
          el.remove();
        } else {
          Ext.removeNode(el);
        }
      }
      Ext.Array.erase(elements, val, 1);
    }
  });
  return this;
}}, 1, 0, 0, 0, 0, 0, [Ext.dom, 'CompositeElementLite', Ext, 'CompositeElementLite', Ext, 'CompositeElement'], function() {
  var Element = Ext.dom.Element, elementPrototype = Element.prototype, prototype = this.prototype, name;
  for (name in elementPrototype) {
    if (typeof elementPrototype[name] == 'function') {
      (function(key) {
        if (key === 'destroy') {
          prototype[key] = function() {
            return this.invoke(key, arguments);
          };
        } else {
          prototype[key] = prototype[key] || function() {
            return this.invoke(key, arguments);
          };
        }
      }).call(prototype, name);
    }
  }
  prototype.on = prototype.addListener;
  Element.selectorFunction = Ext.DomQuery.select;
  Ext.dom.Element.select = function(selector, composite, root) {
    var elements;
    if (typeof selector == 'string') {
      elements = Ext.dom.Element.selectorFunction(selector, root);
    } else {
      if (selector.length !== undefined) {
        elements = selector;
      } else {
      }
    }
    return composite === true ? new Ext.dom.CompositeElement(elements) : new Ext.dom.CompositeElementLite(elements);
  };
  Ext.select = function() {
    return Element.select.apply(Element, arguments);
  };
});
Ext.cmd.derive('Ext.util.TaskRunner', Ext.Base, {interval:10, timerId:null, constructor:function(interval) {
  var me = this;
  if (typeof interval == 'number') {
    me.interval = interval;
  } else {
    if (interval) {
      Ext.apply(me, interval);
    }
  }
  me.tasks = [];
  me.timerFn = Ext.Function.bind(me.onTick, me);
}, newTask:function(config) {
  var task = new Ext.util.TaskRunner.Task(config);
  task.manager = this;
  return task;
}, start:function(task) {
  var me = this, now = Ext.Date.now();
  if (!task.pending) {
    me.tasks.push(task);
    task.pending = true;
  }
  task.stopped = false;
  task.taskStartTime = now;
  task.taskRunTime = task.fireOnStart !== false ? 0 : task.taskStartTime;
  task.taskRunCount = 0;
  if (!me.firing) {
    if (task.fireOnStart !== false) {
      me.startTimer(0, now);
    } else {
      me.startTimer(task.interval, now);
    }
  }
  return task;
}, stop:function(task) {
  if (!task.stopped) {
    task.stopped = true;
    if (task.onStop) {
      task.onStop.call(task.scope || task, task);
    }
  }
  return task;
}, stopAll:function() {
  Ext.each(this.tasks, this.stop, this);
}, firing:false, nextExpires:1.0E99, onTick:function() {
  var me = this, tasks = me.tasks, now = Ext.Date.now(), nextExpires = 1.0E99, len = tasks.length, globalEvents = Ext.GlobalEvents, expires, newTasks, i, task, rt, remove, fireIdleEvent;
  me.timerId = null;
  me.firing = true;
  for (i = 0; i < len || i < (len = tasks.length); ++i) {
    task = tasks[i];
    if (!(remove = task.stopped)) {
      expires = task.taskRunTime + task.interval;
      if (expires <= now) {
        rt = 1;
        if (task.hasOwnProperty('fireIdleEvent')) {
          fireIdleEvent = task.fireIdleEvent;
        } else {
          fireIdleEvent = me.fireIdleEvent;
        }
        try {
          rt = task.run.apply(task.scope || task, task.args || [++task.taskRunCount]);
        } catch (taskError) {
          try {
            if (task.onError) {
              rt = task.onError.call(task.scope || task, task, taskError);
            }
          } catch (ignore) {
          }
        }
        task.taskRunTime = now;
        if (rt === false || task.taskRunCount === task.repeat) {
          me.stop(task);
          remove = true;
        } else {
          remove = task.stopped;
          expires = now + task.interval;
        }
      }
      if (!remove && task.duration && task.duration <= now - task.taskStartTime) {
        me.stop(task);
        remove = true;
      }
    }
    if (remove) {
      task.pending = false;
      if (!newTasks) {
        newTasks = tasks.slice(0, i);
      }
    } else {
      if (newTasks) {
        newTasks.push(task);
      }
      if (nextExpires > expires) {
        nextExpires = expires;
      }
    }
  }
  if (newTasks) {
    me.tasks = newTasks;
  }
  me.firing = false;
  if (me.tasks.length) {
    me.startTimer(nextExpires - now, Ext.Date.now());
  }
  if (fireIdleEvent !== false && globalEvents.hasListeners.idle) {
    globalEvents.fireEvent('idle');
  }
}, startTimer:function(timeout, now) {
  var me = this, expires = now + timeout, timerId = me.timerId;
  if (timerId && me.nextExpires - expires > me.interval) {
    clearTimeout(timerId);
    timerId = null;
  }
  if (!timerId) {
    if (timeout < me.interval) {
      timeout = me.interval;
    }
    me.timerId = Ext.defer(me.timerFn, timeout);
    me.nextExpires = expires;
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'TaskRunner'], function() {
  var me = this, proto = me.prototype;
  proto.destroy = proto.stopAll;
  me.Task = new Ext.Class({isTask:true, stopped:true, fireOnStart:false, constructor:function(config) {
    Ext.apply(this, config);
  }, restart:function(interval) {
    if (interval !== undefined) {
      this.interval = interval;
    }
    this.manager.start(this);
  }, start:function(interval) {
    if (this.stopped) {
      this.restart(interval);
    }
  }, stop:function() {
    this.manager.stop(this);
  }});
  proto = me.Task.prototype;
  proto.destroy = proto.stop;
});
Ext.cmd.derive('Ext.util.TaskManager', Ext.util.TaskRunner, {alternateClassName:['Ext.TaskManager'], singleton:true}, 0, 0, 0, 0, 0, 0, [Ext.util, 'TaskManager', Ext, 'TaskManager'], 0);
Ext.cmd.derive('Ext.event.ListenerStack', Ext.Base, {currentOrder:'current', length:0, constructor:function() {
  this.listeners = {before:[], current:[], after:[]};
  this.lateBindingMap = {};
  return this;
}, add:function(fn, scope, options, order) {
  var lateBindingMap = this.lateBindingMap, listeners = this.getAll(order), i = listeners.length, bindingMap, listener, id;
  if (typeof fn == 'string' && scope.isIdentifiable) {
    id = scope.getId();
    bindingMap = lateBindingMap[id];
    if (bindingMap) {
      if (bindingMap[fn]) {
        return false;
      } else {
        bindingMap[fn] = true;
      }
    } else {
      lateBindingMap[id] = bindingMap = {};
      bindingMap[fn] = true;
    }
  } else {
    if (i > 0) {
      while (i--) {
        listener = listeners[i];
        if (listener.fn === fn && listener.scope === scope) {
          listener.options = options;
          return false;
        }
      }
    }
  }
  listener = this.create(fn, scope, options, order);
  if (options && options.prepend) {
    delete options.prepend;
    listeners.unshift(listener);
  } else {
    listeners.push(listener);
  }
  this.length++;
  return true;
}, getAt:function(index, order) {
  return this.getAll(order)[index];
}, getAll:function(order) {
  if (!order) {
    order = this.currentOrder;
  }
  return this.listeners[order];
}, count:function(order) {
  return this.getAll(order).length;
}, create:function(fn, scope, options, order) {
  return {stack:this, fn:fn, firingFn:false, boundFn:false, isLateBinding:typeof fn == 'string', scope:scope, options:options || {}, order:order};
}, remove:function(fn, scope, order) {
  var listeners = this.getAll(order), i = listeners.length, isRemoved = false, lateBindingMap = this.lateBindingMap, listener, id;
  if (i > 0) {
    while (i--) {
      listener = listeners[i];
      if (listener.fn === fn && listener.scope === scope) {
        listeners.splice(i, 1);
        isRemoved = true;
        this.length--;
        if (typeof fn == 'string' && scope.isIdentifiable) {
          id = scope.getId();
          if (lateBindingMap[id] && lateBindingMap[id][fn]) {
            delete lateBindingMap[id][fn];
          }
        }
        break;
      }
    }
  }
  return isRemoved;
}}, 1, 0, 0, 0, 0, 0, [Ext.event, 'ListenerStack'], 0);
Ext.cmd.derive('Ext.event.Controller', Ext.Base, {isFiring:false, listenerStack:null, constructor:function(info) {
  this.firingListeners = [];
  this.firingArguments = [];
  this.setInfo(info);
  return this;
}, setInfo:function(info) {
  this.info = info;
}, getInfo:function() {
  return this.info;
}, setListenerStacks:function(listenerStacks) {
  this.listenerStacks = listenerStacks;
}, fire:function(args, action) {
  var listenerStacks = this.listenerStacks, firingListeners = this.firingListeners, firingArguments = this.firingArguments, push = firingListeners.push, ln = listenerStacks.length, listeners, beforeListeners, currentListeners, afterListeners, isActionBefore = false, isActionAfter = false, i;
  firingListeners.length = 0;
  if (action) {
    if (action.order !== 'after') {
      isActionBefore = true;
    } else {
      isActionAfter = true;
    }
  }
  if (ln === 1) {
    listeners = listenerStacks[0].listeners;
    beforeListeners = listeners.before;
    currentListeners = listeners.current;
    afterListeners = listeners.after;
    if (beforeListeners.length > 0) {
      push.apply(firingListeners, beforeListeners);
    }
    if (isActionBefore) {
      push.call(firingListeners, action);
    }
    if (currentListeners.length > 0) {
      push.apply(firingListeners, currentListeners);
    }
    if (isActionAfter) {
      push.call(firingListeners, action);
    }
    if (afterListeners.length > 0) {
      push.apply(firingListeners, afterListeners);
    }
  } else {
    for (i = 0; i < ln; i++) {
      beforeListeners = listenerStacks[i].listeners.before;
      if (beforeListeners.length > 0) {
        push.apply(firingListeners, beforeListeners);
      }
    }
    if (isActionBefore) {
      push.call(firingListeners, action);
    }
    for (i = 0; i < ln; i++) {
      currentListeners = listenerStacks[i].listeners.current;
      if (currentListeners.length > 0) {
        push.apply(firingListeners, currentListeners);
      }
    }
    if (isActionAfter) {
      push.call(firingListeners, action);
    }
    for (i = 0; i < ln; i++) {
      afterListeners = listenerStacks[i].listeners.after;
      if (afterListeners.length > 0) {
        push.apply(firingListeners, afterListeners);
      }
    }
  }
  if (firingListeners.length === 0) {
    return this;
  }
  if (!args) {
    args = [];
  }
  firingArguments.length = 0;
  firingArguments.push.apply(firingArguments, args);
  firingArguments.push(null, this);
  this.doFire();
  return this;
}, doFire:function() {
  var firingListeners = this.firingListeners, firingArguments = this.firingArguments, optionsArgumentIndex = firingArguments.length - 2, i, ln, listener, options, fn, firingFn, boundFn, isLateBinding, scope, args, result;
  this.isPausing = false;
  this.isPaused = false;
  this.isStopped = false;
  this.isFiring = true;
  for (i = 0, ln = firingListeners.length; i < ln; i++) {
    listener = firingListeners[i];
    options = listener.options;
    fn = listener.fn;
    firingFn = listener.firingFn;
    boundFn = listener.boundFn;
    isLateBinding = listener.isLateBinding;
    scope = listener.scope;
    if (isLateBinding && boundFn && boundFn !== scope[fn]) {
      boundFn = false;
      firingFn = false;
    }
    if (!boundFn) {
      if (isLateBinding) {
        boundFn = scope[fn];
        if (!boundFn) {
          continue;
        }
      } else {
        boundFn = fn;
      }
      listener.boundFn = boundFn;
    }
    if (!firingFn) {
      firingFn = boundFn;
      if (options.buffer) {
        firingFn = Ext.Function.createBuffered(firingFn, options.buffer, scope);
      }
      if (options.delay) {
        firingFn = Ext.Function.createDelayed(firingFn, options.delay, scope);
      }
      listener.firingFn = firingFn;
    }
    firingArguments[optionsArgumentIndex] = options;
    args = firingArguments;
    if (options.args) {
      args = options.args.concat(args);
    }
    if (options.single === true) {
      listener.stack.remove(fn, scope, listener.order);
    }
    result = firingFn.apply(scope, args);
    if (result === false) {
      this.stop();
    }
    if (this.isStopped) {
      break;
    }
    if (this.isPausing) {
      this.isPaused = true;
      firingListeners.splice(0, i + 1);
      return;
    }
  }
  this.isFiring = false;
  this.listenerStacks = null;
  firingListeners.length = 0;
  firingArguments.length = 0;
  this.connectingController = null;
}, connect:function(controller) {
  this.connectingController = controller;
}, resume:function() {
  var connectingController = this.connectingController;
  this.isPausing = false;
  if (this.isPaused && this.firingListeners.length > 0) {
    this.isPaused = false;
    this.doFire();
  }
  if (connectingController) {
    connectingController.resume();
  }
  return this;
}, isInterrupted:function() {
  return this.isStopped || this.isPaused;
}, stop:function() {
  var connectingController = this.connectingController;
  this.isStopped = true;
  if (connectingController) {
    this.connectingController = null;
    connectingController.stop();
  }
  this.isFiring = false;
  this.listenerStacks = null;
  return this;
}, pause:function() {
  var connectingController = this.connectingController;
  this.isPausing = true;
  if (connectingController) {
    connectingController.pause();
  }
  return this;
}}, 1, 0, 0, 0, 0, 0, [Ext.event, 'Controller'], 0);
Ext.cmd.derive('Ext.event.Dispatcher', Ext.Base, {statics:{getInstance:function() {
  if (!this.instance) {
    this.instance = new this;
  }
  return this.instance;
}, setInstance:function(instance) {
  this.instance = instance;
  return this;
}}, config:{publishers:{}}, wildcard:'*', constructor:function(config) {
  this.listenerStacks = {};
  this.activePublishers = {};
  this.publishersCache = {};
  this.noActivePublishers = [];
  this.controller = null;
  this.initConfig(config);
  return this;
}, getListenerStack:function(targetType, target, eventName, createIfNotExist) {
  var listenerStacks = this.listenerStacks, map = listenerStacks[targetType], listenerStack;
  createIfNotExist = Boolean(createIfNotExist);
  if (!map) {
    if (createIfNotExist) {
      listenerStacks[targetType] = map = {};
    } else {
      return null;
    }
  }
  map = map[target];
  if (!map) {
    if (createIfNotExist) {
      listenerStacks[targetType][target] = map = {};
    } else {
      return null;
    }
  }
  listenerStack = map[eventName];
  if (!listenerStack) {
    if (createIfNotExist) {
      map[eventName] = listenerStack = new Ext.event.ListenerStack;
    } else {
      return null;
    }
  }
  return listenerStack;
}, getController:function(targetType, target, eventName, connectedController) {
  var controller = this.controller, info = {targetType:targetType, target:target, eventName:eventName};
  if (!controller) {
    this.controller = controller = new Ext.event.Controller;
  }
  if (controller.isFiring) {
    controller = new Ext.event.Controller;
  }
  controller.setInfo(info);
  if (connectedController && controller !== connectedController) {
    controller.connect(connectedController);
  }
  return controller;
}, applyPublishers:function(publishers) {
  var i, publisher;
  this.publishersCache = {};
  for (i in publishers) {
    if (publishers.hasOwnProperty(i)) {
      publisher = publishers[i];
      this.registerPublisher(publisher);
    }
  }
  return publishers;
}, registerPublisher:function(publisher) {
  var activePublishers = this.activePublishers, targetType = publisher.getTargetType(), publishers = activePublishers[targetType];
  if (!publishers) {
    activePublishers[targetType] = publishers = [];
  }
  publishers.push(publisher);
  publisher.setDispatcher(this);
  return this;
}, getCachedActivePublishers:function(targetType, eventName) {
  var cache = this.publishersCache, publishers;
  if ((publishers = cache[targetType]) && (publishers = publishers[eventName])) {
    return publishers;
  }
  return null;
}, cacheActivePublishers:function(targetType, eventName, publishers) {
  var cache = this.publishersCache;
  if (!cache[targetType]) {
    cache[targetType] = {};
  }
  cache[targetType][eventName] = publishers;
  return publishers;
}, getActivePublishers:function(targetType, eventName) {
  var publishers, activePublishers, i, ln, publisher;
  if (publishers = this.getCachedActivePublishers(targetType, eventName)) {
    return publishers;
  }
  activePublishers = this.activePublishers[targetType];
  if (activePublishers) {
    publishers = [];
    for (i = 0, ln = activePublishers.length; i < ln; i++) {
      publisher = activePublishers[i];
      if (publisher.handles(eventName)) {
        publishers.push(publisher);
      }
    }
  } else {
    publishers = this.noActivePublishers;
  }
  return this.cacheActivePublishers(targetType, eventName, publishers);
}, hasListener:function(targetType, target, eventName) {
  var listenerStack = this.getListenerStack(targetType, target, eventName);
  if (listenerStack) {
    return listenerStack.count() > 0;
  }
  return false;
}, addListener:function(targetType, target, eventName) {
  var publishers = this.getActivePublishers(targetType, eventName), ln = publishers.length, i, result;
  result = this.doAddListener.apply(this, arguments);
  if (result && ln > 0) {
    for (i = 0; i < ln; i++) {
      publishers[i].subscribe(target, eventName);
    }
  }
  return result;
}, doAddListener:function(targetType, target, eventName, fn, scope, options, order) {
  var listenerStack = this.getListenerStack(targetType, target, eventName, true);
  return listenerStack.add(fn, scope, options, order);
}, removeListener:function(targetType, target, eventName) {
  var publishers = this.getActivePublishers(targetType, eventName), ln = publishers.length, i, result;
  result = this.doRemoveListener.apply(this, arguments);
  if (result && ln > 0) {
    for (i = 0; i < ln; i++) {
      publishers[i].unsubscribe(target, eventName);
    }
  }
  return result;
}, doRemoveListener:function(targetType, target, eventName, fn, scope, order) {
  var listenerStack = this.getListenerStack(targetType, target, eventName);
  if (listenerStack === null) {
    return false;
  }
  return listenerStack.remove(fn, scope, order);
}, clearListeners:function(targetType, target, eventName) {
  var listenerStacks = this.listenerStacks, ln = arguments.length, stacks, publishers, i, publisherGroup;
  if (ln === 3) {
    if (listenerStacks[targetType] && listenerStacks[targetType][target]) {
      this.removeListener(targetType, target, eventName);
      delete listenerStacks[targetType][target][eventName];
    }
  } else {
    if (ln === 2) {
      if (listenerStacks[targetType]) {
        stacks = listenerStacks[targetType][target];
        if (stacks) {
          for (eventName in stacks) {
            if (stacks.hasOwnProperty(eventName)) {
              publishers = this.getActivePublishers(targetType, eventName);
              for (i = 0, ln = publishers.length; i < ln; i++) {
                publishers[i].unsubscribe(target, eventName, true);
              }
            }
          }
          delete listenerStacks[targetType][target];
        }
      }
    } else {
      if (ln === 1) {
        publishers = this.activePublishers[targetType];
        for (i = 0, ln = publishers.length; i < ln; i++) {
          publishers[i].unsubscribeAll();
        }
        delete listenerStacks[targetType];
      } else {
        publishers = this.activePublishers;
        for (targetType in publishers) {
          if (publishers.hasOwnProperty(targetType)) {
            publisherGroup = publishers[targetType];
            for (i = 0, ln = publisherGroup.length; i < ln; i++) {
              publisherGroup[i].unsubscribeAll();
            }
          }
        }
        delete this.listenerStacks;
        this.listenerStacks = {};
      }
    }
  }
  return this;
}, dispatchEvent:function(targetType, target, eventName) {
  var publishers = this.getActivePublishers(targetType, eventName), ln = publishers.length, i;
  if (ln > 0) {
    for (i = 0; i < ln; i++) {
      publishers[i].notify(target, eventName);
    }
  }
  return this.doDispatchEvent.apply(this, arguments);
}, doDispatchEvent:function(targetType, target, eventName, args, action, connectedController) {
  var listenerStack = this.getListenerStack(targetType, target, eventName), wildcardStacks = this.getWildcardListenerStacks(targetType, target, eventName), controller;
  if (listenerStack === null || listenerStack.length == 0) {
    if (wildcardStacks.length == 0 && !action) {
      return;
    }
  } else {
    wildcardStacks.push(listenerStack);
  }
  controller = this.getController(targetType, target, eventName, connectedController);
  controller.setListenerStacks(wildcardStacks);
  controller.fire(args, action);
  return !controller.isInterrupted();
}, getWildcardListenerStacks:function(targetType, target, eventName) {
  var stacks = [], wildcard = this.wildcard, isEventNameNotWildcard = eventName !== wildcard, isTargetNotWildcard = target !== wildcard, stack;
  if (isEventNameNotWildcard && (stack = this.getListenerStack(targetType, target, wildcard))) {
    stacks.push(stack);
  }
  if (isTargetNotWildcard && (stack = this.getListenerStack(targetType, wildcard, eventName))) {
    stacks.push(stack);
  }
  return stacks;
}, getPublisher:function(name) {
  return this.getPublishers()[name];
}}, 1, 0, 0, 0, 0, 0, [Ext.event, 'Dispatcher'], 0);
Ext.cmd.derive('Ext.mixin.Mixin', Ext.Base, {onClassExtended:function(cls, data) {
  var mixinConfig = data.mixinConfig, parentClassMixinConfig, beforeHooks, afterHooks;
  if (mixinConfig) {
    parentClassMixinConfig = cls.superclass.mixinConfig;
    if (parentClassMixinConfig) {
      mixinConfig = data.mixinConfig = Ext.merge({}, parentClassMixinConfig, mixinConfig);
    }
    data.mixinId = mixinConfig.id;
    beforeHooks = mixinConfig.beforeHooks;
    afterHooks = mixinConfig.hooks || mixinConfig.afterHooks;
    if (beforeHooks || afterHooks) {
      Ext.Function.interceptBefore(data, 'onClassMixedIn', function(targetClass) {
        var mixin = this.prototype;
        if (beforeHooks) {
          Ext.Object.each(beforeHooks, function(from, to) {
            targetClass.override(to, function() {
              if (mixin[from].apply(this, arguments) !== false) {
                return this.callOverridden(arguments);
              }
            });
          });
        }
        if (afterHooks) {
          Ext.Object.each(afterHooks, function(from, to) {
            targetClass.override(to, function() {
              var ret = this.callOverridden(arguments);
              mixin[from].apply(this, arguments);
              return ret;
            });
          });
        }
      });
    }
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Mixin'], 0);
Ext.cmd.derive('Ext.mixin.Observable', Ext.mixin.Mixin, {mixinConfig:{id:'observable', hooks:{destroy:'destroy'}}, alternateClassName:'Ext.util.Observable', isObservable:true, observableType:'observable', validIdRegex:/^([\w\-]+)$/, observableIdPrefix:'#', listenerOptionsRegex:/^(?:delegate|single|delay|buffer|args|prepend)$/, eventFiringSuspended:false, config:{listeners:null, bubbleEvents:null}, constructor:function(config) {
  this.initConfig(config);
}, applyListeners:function(listeners) {
  if (listeners) {
    this.addListener(listeners);
  }
}, applyBubbleEvents:function(bubbleEvents) {
  if (bubbleEvents) {
    this.enableBubble(bubbleEvents);
  }
}, getOptimizedObservableId:function() {
  return this.observableId;
}, getObservableId:function() {
  if (!this.observableId) {
    var id = this.getUniqueId();
    this.observableId = this.observableIdPrefix + id;
    this.getObservableId = this.getOptimizedObservableId;
  }
  return this.observableId;
}, getOptimizedEventDispatcher:function() {
  return this.eventDispatcher;
}, getEventDispatcher:function() {
  if (!this.eventDispatcher) {
    this.eventDispatcher = Ext.event.Dispatcher.getInstance();
    this.getEventDispatcher = this.getOptimizedEventDispatcher;
    this.getListeners();
    this.getBubbleEvents();
  }
  return this.eventDispatcher;
}, getManagedListeners:function(object, eventName) {
  var id = object.getUniqueId(), managedListeners = this.managedListeners;
  if (!managedListeners) {
    this.managedListeners = managedListeners = {};
  }
  if (!managedListeners[id]) {
    managedListeners[id] = {};
    object.doAddListener('destroy', 'clearManagedListeners', this, {single:true, args:[object]});
  }
  if (!managedListeners[id][eventName]) {
    managedListeners[id][eventName] = [];
  }
  return managedListeners[id][eventName];
}, getUsedSelectors:function() {
  var selectors = this.usedSelectors;
  if (!selectors) {
    selectors = this.usedSelectors = [];
    selectors.$map = {};
  }
  return selectors;
}, fireEvent:function(eventName) {
  var args = Array.prototype.slice.call(arguments, 1);
  return this.doFireEvent(eventName, args);
}, fireAction:function(eventName, args, fn, scope, options, order) {
  var fnType = typeof fn, action;
  if (args === undefined) {
    args = [];
  }
  if (fnType != 'undefined') {
    action = {fn:fn, isLateBinding:fnType == 'string', scope:scope || this, options:options || {}, order:order};
  }
  return this.doFireEvent(eventName, args, action);
}, doFireEvent:function(eventName, args, action, connectedController) {
  var me = this, ret = true, eventQueue;
  if (me.eventFiringSuspended) {
    eventQueue = me.eventQueue;
    if (!eventQueue) {
      me.eventQueue = eventQueue = [];
    }
    eventQueue.push([eventName, args, action, connectedController]);
  } else {
    ret = me.getEventDispatcher().dispatchEvent(me.observableType, me.getObservableId(), eventName, args, action, connectedController);
  }
  return ret;
}, doAddListener:function(name, fn, scope, options, order) {
  var isManaged = scope && scope !== this && scope.isIdentifiable, usedSelectors = this.getUsedSelectors(), usedSelectorsMap = usedSelectors.$map, selector = this.getObservableId(), isAdded, managedListeners, delegate;
  if (!options) {
    options = {};
  }
  if (!scope) {
    scope = this;
  }
  if (options.delegate) {
    delegate = options.delegate;
    selector += ' ' + delegate;
  }
  if (!(selector in usedSelectorsMap)) {
    usedSelectorsMap[selector] = true;
    usedSelectors.push(selector);
  }
  isAdded = this.addDispatcherListener(selector, name, fn, scope, options, order);
  if (isAdded && isManaged) {
    managedListeners = this.getManagedListeners(scope, name);
    managedListeners.push({delegate:delegate, scope:scope, fn:fn, order:order});
  }
  return isAdded;
}, addDispatcherListener:function(selector, name, fn, scope, options, order) {
  return this.getEventDispatcher().addListener(this.observableType, selector, name, fn, scope, options, order);
}, doRemoveListener:function(name, fn, scope, options, order) {
  var isManaged = scope && scope !== this && scope.isIdentifiable, selector = this.getObservableId(), isRemoved, managedListeners, i, ln, listener, delegate;
  if (options && options.delegate) {
    delegate = options.delegate;
    selector += ' ' + delegate;
  }
  if (!scope) {
    scope = this;
  }
  isRemoved = this.removeDispatcherListener(selector, name, fn, scope, order);
  if (isRemoved && isManaged) {
    managedListeners = this.getManagedListeners(scope, name);
    for (i = 0, ln = managedListeners.length; i < ln; i++) {
      listener = managedListeners[i];
      if (listener.fn === fn && listener.scope === scope && listener.delegate === delegate && listener.order === order) {
        managedListeners.splice(i, 1);
        break;
      }
    }
  }
  return isRemoved;
}, removeDispatcherListener:function(selector, name, fn, scope, order) {
  return this.getEventDispatcher().removeListener(this.observableType, selector, name, fn, scope, order);
}, clearManagedListeners:function(object) {
  var managedListeners = this.managedListeners, id, namedListeners, listeners, eventName, i, ln, listener, options;
  if (!managedListeners) {
    return this;
  }
  if (object) {
    if (typeof object != 'string') {
      id = object.getUniqueId();
    } else {
      id = object;
    }
    namedListeners = managedListeners[id];
    for (eventName in namedListeners) {
      if (namedListeners.hasOwnProperty(eventName)) {
        listeners = namedListeners[eventName];
        for (i = 0, ln = listeners.length; i < ln; i++) {
          listener = listeners[i];
          options = {};
          if (listener.delegate) {
            options.delegate = listener.delegate;
          }
          if (this.doRemoveListener(eventName, listener.fn, listener.scope, options, listener.order)) {
            i--;
            ln--;
          }
        }
      }
    }
    delete managedListeners[id];
    return this;
  }
  for (id in managedListeners) {
    if (managedListeners.hasOwnProperty(id)) {
      this.clearManagedListeners(id);
    }
  }
}, changeListener:function(actionFn, eventName, fn, scope, options, order) {
  var eventNames, listeners, listenerOptionsRegex, actualOptions, name, value, i, ln, listener, valueType;
  if (typeof fn != 'undefined') {
    if (typeof eventName != 'string') {
      for (i = 0, ln = eventName.length; i < ln; i++) {
        name = eventName[i];
        actionFn.call(this, name, fn, scope, options, order);
      }
      return this;
    }
    actionFn.call(this, eventName, fn, scope, options, order);
  } else {
    if (Ext.isArray(eventName)) {
      listeners = eventName;
      for (i = 0, ln = listeners.length; i < ln; i++) {
        listener = listeners[i];
        actionFn.call(this, listener.event, listener.fn, listener.scope, listener, listener.order);
      }
    } else {
      listenerOptionsRegex = this.listenerOptionsRegex;
      options = eventName;
      eventNames = [];
      listeners = [];
      actualOptions = {};
      for (name in options) {
        value = options[name];
        if (name === 'scope') {
          scope = value;
          continue;
        } else {
          if (name === 'order') {
            order = value;
            continue;
          }
        }
        if (!listenerOptionsRegex.test(name)) {
          valueType = typeof value;
          if (valueType != 'string' && valueType != 'function') {
            actionFn.call(this, name, value.fn, value.scope || scope, value, value.order || order);
            continue;
          }
          eventNames.push(name);
          listeners.push(value);
        } else {
          actualOptions[name] = value;
        }
      }
      for (i = 0, ln = eventNames.length; i < ln; i++) {
        actionFn.call(this, eventNames[i], listeners[i], scope, actualOptions, order);
      }
    }
  }
  return this;
}, addListener:function(eventName, fn, scope, options, order) {
  return this.changeListener(this.doAddListener, eventName, fn, scope, options, order);
}, toggleListener:function(toggle, eventName, fn, scope, options, order) {
  return this.changeListener(toggle ? this.doAddListener : this.doRemoveListener, eventName, fn, scope, options, order);
}, addBeforeListener:function(eventName, fn, scope, options) {
  return this.addListener(eventName, fn, scope, options, 'before');
}, addAfterListener:function(eventName, fn, scope, options) {
  return this.addListener(eventName, fn, scope, options, 'after');
}, removeListener:function(eventName, fn, scope, options, order) {
  return this.changeListener(this.doRemoveListener, eventName, fn, scope, options, order);
}, removeBeforeListener:function(eventName, fn, scope, options) {
  return this.removeListener(eventName, fn, scope, options, 'before');
}, removeAfterListener:function(eventName, fn, scope, options) {
  return this.removeListener(eventName, fn, scope, options, 'after');
}, clearListeners:function() {
  var usedSelectors = this.getUsedSelectors(), dispatcher = this.getEventDispatcher(), i, ln, selector;
  for (i = 0, ln = usedSelectors.length; i < ln; i++) {
    selector = usedSelectors[i];
    dispatcher.clearListeners(this.observableType, selector);
  }
}, hasListener:function(eventName) {
  return this.getEventDispatcher().hasListener(this.observableType, this.getObservableId(), eventName);
}, suspendEvents:function() {
  this.eventFiringSuspended = true;
}, resumeEvents:function(discardQueuedEvents) {
  var me = this, eventQueue = me.eventQueue || [], i, ln;
  me.eventFiringSuspended = false;
  if (!discardQueuedEvents) {
    for (i = 0, ln = eventQueue.length; i < ln; i++) {
      me.doFireEvent.apply(me, eventQueue[i]);
    }
  }
  me.eventQueue = [];
}, relayEvents:function(object, events, prefix) {
  var i, ln, oldName, newName;
  if (typeof prefix == 'undefined') {
    prefix = '';
  }
  if (typeof events == 'string') {
    events = [events];
  }
  if (Ext.isArray(events)) {
    for (i = 0, ln = events.length; i < ln; i++) {
      oldName = events[i];
      newName = prefix + oldName;
      object.addListener(oldName, this.createEventRelayer(newName), this);
    }
  } else {
    for (oldName in events) {
      if (events.hasOwnProperty(oldName)) {
        newName = prefix + events[oldName];
        object.addListener(oldName, this.createEventRelayer(newName), this);
      }
    }
  }
  return this;
}, relayEvent:function(args, fn, scope, options, order) {
  var fnType = typeof fn, controller = args[args.length - 1], eventName = controller.getInfo().eventName, action;
  args = Array.prototype.slice.call(args, 0, -2);
  args[0] = this;
  if (fnType != 'undefined') {
    action = {fn:fn, scope:scope || this, options:options || {}, order:order, isLateBinding:fnType == 'string'};
  }
  return this.doFireEvent(eventName, args, action, controller);
}, createEventRelayer:function(newName) {
  return function() {
    return this.doFireEvent(newName, Array.prototype.slice.call(arguments, 0, -2));
  };
}, enableBubble:function(events) {
  var isBubblingEnabled = this.isBubblingEnabled, i, ln, name;
  if (!isBubblingEnabled) {
    isBubblingEnabled = this.isBubblingEnabled = {};
  }
  if (typeof events == 'string') {
    events = Ext.Array.clone(arguments);
  }
  for (i = 0, ln = events.length; i < ln; i++) {
    name = events[i];
    if (!isBubblingEnabled[name]) {
      isBubblingEnabled[name] = true;
      this.addListener(name, this.createEventBubbler(name), this);
    }
  }
}, createEventBubbler:function(name) {
  return function doBubbleEvent() {
    var bubbleTarget = 'getBubbleTarget' in this ? this.getBubbleTarget() : null;
    if (bubbleTarget && bubbleTarget !== this && bubbleTarget.isObservable) {
      bubbleTarget.fireAction(name, Array.prototype.slice.call(arguments, 0, -2), doBubbleEvent, bubbleTarget, null, 'after');
    }
  };
}, getBubbleTarget:function() {
  return false;
}, destroy:function() {
  if (this.observableId) {
    this.fireEvent('destroy', this);
    this.clearListeners();
    this.clearManagedListeners();
  }
}, addEvents:Ext.emptyFn}, 1, 0, 0, 0, 0, [[Ext.mixin.Identifiable.prototype.mixinId || Ext.mixin.Identifiable.$className, Ext.mixin.Identifiable]], [Ext.mixin, 'Observable', Ext.util, 'Observable'], function() {
  this.createAlias({on:'addListener', un:'removeListener', onBefore:'addBeforeListener', onAfter:'addAfterListener', unBefore:'removeBeforeListener', unAfter:'removeAfterListener'});
});
Ext.cmd.derive('Ext.Evented', Ext.Base, {alternateClassName:'Ext.EventedBase', statics:{generateSetter:function(nameMap) {
  var internalName = nameMap.internal, applyName = nameMap.apply, changeEventName = nameMap.changeEvent, doSetName = nameMap.doSet;
  return function(value) {
    var initialized = this.initialized, oldValue = this[internalName], applier = this[applyName];
    if (applier) {
      value = applier.call(this, value, oldValue);
      if (typeof value == 'undefined') {
        return this;
      }
    }
    oldValue = this[internalName];
    if (value !== oldValue) {
      if (initialized) {
        this.fireAction(changeEventName, [this, value, oldValue], this.doSet, this, {nameMap:nameMap});
      } else {
        this[internalName] = value;
        if (this[doSetName]) {
          this[doSetName].call(this, value, oldValue);
        }
      }
    }
    return this;
  };
}}, initialized:false, constructor:function(config) {
  this.initialConfig = config;
  this.initialize();
}, initialize:function() {
  this.initConfig(this.initialConfig);
  this.initialized = true;
}, doSet:function(me, value, oldValue, options) {
  var nameMap = options.nameMap;
  me[nameMap.internal] = value;
  if (me[nameMap.doSet]) {
    me[nameMap.doSet].call(this, value, oldValue);
  }
}, onClassExtended:function(Class, data) {
  if (!data.hasOwnProperty('eventedConfig')) {
    return;
  }
  var ExtClass = Ext.Class, config = data.config, eventedConfig = data.eventedConfig, name, nameMap;
  data.config = config ? Ext.applyIf(config, eventedConfig) : eventedConfig;
  for (name in eventedConfig) {
    if (eventedConfig.hasOwnProperty(name)) {
      nameMap = ExtClass.getConfigNameMap(name);
      data[nameMap.set] = this.generateSetter(nameMap);
    }
  }
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext, 'Evented', Ext, 'EventedBase'], 0);
Ext.cmd.derive('Ext.AbstractComponent', Ext.Evented, {onClassExtended:function(Class, members) {
  if (!members.hasOwnProperty('cachedConfig')) {
    return;
  }
  var prototype = Class.prototype, config = members.config, cachedConfig = members.cachedConfig, cachedConfigList = prototype.cachedConfigList, hasCachedConfig = prototype.hasCachedConfig, name, value;
  delete members.cachedConfig;
  prototype.cachedConfigList = cachedConfigList = cachedConfigList ? cachedConfigList.slice() : [];
  prototype.hasCachedConfig = hasCachedConfig = hasCachedConfig ? Ext.Object.chain(hasCachedConfig) : {};
  if (!config) {
    members.config = config = {};
  }
  for (name in cachedConfig) {
    if (cachedConfig.hasOwnProperty(name)) {
      value = cachedConfig[name];
      if (!hasCachedConfig[name]) {
        hasCachedConfig[name] = true;
        cachedConfigList.push(name);
      }
      config[name] = value;
    }
  }
}, getElementConfig:Ext.emptyFn, referenceAttributeName:'reference', referenceSelector:'[reference]', addReferenceNode:function(name, domNode) {
  Ext.Object.defineProperty(this, name, {get:function() {
    var reference;
    delete this[name];
    this[name] = reference = new Ext.Element(domNode);
    return reference;
  }, configurable:true});
}, initElement:function() {
  var prototype = this.self.prototype, id = this.getId(), referenceList = [], cleanAttributes = true, referenceAttributeName = this.referenceAttributeName, needsOptimization = false, renderTemplate, renderElement, element, referenceNodes, i, ln, referenceNode, reference, configNameCache, defaultConfig, cachedConfigList, initConfigList, initConfigMap, configList, elements, name, nameMap, internalName;
  if (prototype.hasOwnProperty('renderTemplate')) {
    renderTemplate = this.renderTemplate.cloneNode(true);
    renderElement = renderTemplate.firstChild;
  } else {
    cleanAttributes = false;
    needsOptimization = true;
    renderTemplate = document.createDocumentFragment();
    renderElement = Ext.Element.create(this.getElementConfig(), true);
    renderTemplate.appendChild(renderElement);
  }
  referenceNodes = renderTemplate.querySelectorAll(this.referenceSelector);
  for (i = 0, ln = referenceNodes.length; i < ln; i++) {
    referenceNode = referenceNodes[i];
    reference = referenceNode.getAttribute(referenceAttributeName);
    if (cleanAttributes) {
      referenceNode.removeAttribute(referenceAttributeName);
    }
    if (reference == 'element') {
      referenceNode.id = id;
      this.element = element = new Ext.Element(referenceNode);
    } else {
      this.addReferenceNode(reference, referenceNode);
    }
    referenceList.push(reference);
  }
  this.referenceList = referenceList;
  if (!this.innerElement) {
    this.innerElement = element;
  }
  if (!this.bodyElement) {
    this.bodyElement = this.innerElement;
  }
  if (renderElement === element.dom) {
    this.renderElement = element;
  } else {
    this.addReferenceNode('renderElement', renderElement);
  }
  if (needsOptimization) {
    configNameCache = Ext.Class.configNameCache;
    defaultConfig = this.config;
    cachedConfigList = this.cachedConfigList;
    initConfigList = this.initConfigList;
    initConfigMap = this.initConfigMap;
    configList = [];
    for (i = 0, ln = cachedConfigList.length; i < ln; i++) {
      name = cachedConfigList[i];
      nameMap = configNameCache[name];
      if (initConfigMap[name]) {
        initConfigMap[name] = false;
        Ext.Array.remove(initConfigList, name);
      }
      if (defaultConfig[name] !== null) {
        configList.push(name);
        this[nameMap.get] = this[nameMap.initGet];
      }
    }
    for (i = 0, ln = configList.length; i < ln; i++) {
      name = configList[i];
      nameMap = configNameCache[name];
      internalName = nameMap.internal;
      this[internalName] = null;
      this[nameMap.set].call(this, defaultConfig[name]);
      delete this[nameMap.get];
      prototype[internalName] = this[internalName];
    }
    renderElement = this.renderElement.dom;
    prototype.renderTemplate = renderTemplate = document.createDocumentFragment();
    renderTemplate.appendChild(renderElement.cloneNode(true));
    elements = renderTemplate.querySelectorAll('[id]');
    for (i = 0, ln = elements.length; i < ln; i++) {
      element = elements[i];
      element.removeAttribute('id');
    }
    for (i = 0, ln = referenceList.length; i < ln; i++) {
      reference = referenceList[i];
      this[reference].dom.removeAttribute('reference');
    }
  }
  return this;
}}, 0, 0, 0, 0, 0, 0, [Ext, 'AbstractComponent'], 0);
Ext.cmd.derive('Ext.util.HashMap', Ext.Base, {constructor:function(config) {
  this.callParent();
  this.mixins.observable.constructor.call(this);
  this.clear(true);
}, getCount:function() {
  return this.length;
}, getData:function(key, value) {
  if (value === undefined) {
    value = key;
    key = this.getKey(value);
  }
  return [key, value];
}, getKey:function(o) {
  return o.id;
}, add:function(key, value) {
  var me = this, data;
  if (me.containsKey(key)) {
    throw new Error('This key already exists in the HashMap');
  }
  data = this.getData(key, value);
  key = data[0];
  value = data[1];
  me.map[key] = value;
  ++me.length;
  me.fireEvent('add', me, key, value);
  return value;
}, replace:function(key, value) {
  var me = this, map = me.map, old;
  if (!me.containsKey(key)) {
    me.add(key, value);
  }
  old = map[key];
  map[key] = value;
  me.fireEvent('replace', me, key, value, old);
  return value;
}, remove:function(o) {
  var key = this.findKey(o);
  if (key !== undefined) {
    return this.removeByKey(key);
  }
  return false;
}, removeByKey:function(key) {
  var me = this, value;
  if (me.containsKey(key)) {
    value = me.map[key];
    delete me.map[key];
    --me.length;
    me.fireEvent('remove', me, key, value);
    return true;
  }
  return false;
}, get:function(key) {
  return this.map[key];
}, clear:function(initial) {
  var me = this;
  me.map = {};
  me.length = 0;
  if (initial !== true) {
    me.fireEvent('clear', me);
  }
  return me;
}, containsKey:function(key) {
  return this.map[key] !== undefined;
}, contains:function(value) {
  return this.containsKey(this.findKey(value));
}, getKeys:function() {
  return this.getArray(true);
}, getValues:function() {
  return this.getArray(false);
}, getArray:function(isKey) {
  var arr = [], key, map = this.map;
  for (key in map) {
    if (map.hasOwnProperty(key)) {
      arr.push(isKey ? key : map[key]);
    }
  }
  return arr;
}, each:function(fn, scope) {
  var items = Ext.apply({}, this.map), key, length = this.length;
  scope = scope || this;
  for (key in items) {
    if (items.hasOwnProperty(key)) {
      if (fn.call(scope, key, items[key], length) === false) {
        break;
      }
    }
  }
  return this;
}, clone:function() {
  var hash = new Ext.util.HashMap, map = this.map, key;
  hash.suspendEvents();
  for (key in map) {
    if (map.hasOwnProperty(key)) {
      hash.add(key, map[key]);
    }
  }
  hash.resumeEvents();
  return hash;
}, findKey:function(value) {
  var key, map = this.map;
  for (key in map) {
    if (map.hasOwnProperty(key) && map[key] === value) {
      return key;
    }
  }
  return undefined;
}}, 1, 0, 0, 0, 0, [['observable', Ext.mixin.Observable]], [Ext.util, 'HashMap'], 0);
Ext.cmd.derive('Ext.AbstractManager', Ext.Base, {typeName:'type', constructor:function(config) {
  Ext.apply(this, config || {});
  this.all = Ext.create('Ext.util.HashMap');
  this.types = {};
}, get:function(id) {
  return this.all.get(id);
}, register:function(item) {
  this.all.add(item);
}, unregister:function(item) {
  this.all.remove(item);
}, registerType:function(type, cls) {
  this.types[type] = cls;
  cls[this.typeName] = type;
}, isRegistered:function(type) {
  return this.types[type] !== undefined;
}, create:function(config, defaultType) {
  var type = config[this.typeName] || config.type || defaultType, Constructor = this.types[type];
  return new Constructor(config);
}, onAvailable:function(id, fn, scope) {
  var all = this.all, item;
  if (all.containsKey(id)) {
    item = all.get(id);
    fn.call(scope || item, item);
  } else {
    all.on('add', function(map, key, item) {
      if (key == id) {
        fn.call(scope || item, item);
        all.un('add', fn, scope);
      }
    });
  }
}, each:function(fn, scope) {
  this.all.each(fn, scope || this);
}, getCount:function() {
  return this.all.getCount();
}}, 1, 0, 0, 0, 0, 0, [Ext, 'AbstractManager'], 0);
Ext.cmd.derive('Ext.mixin.Traversable', Ext.mixin.Mixin, {mixinConfig:{id:'traversable'}, setParent:function(parent) {
  this.parent = parent;
  return this;
}, hasParent:function() {
  return Boolean(this.parent);
}, getParent:function() {
  return this.parent;
}, getAncestors:function() {
  var ancestors = [], parent = this.getParent();
  while (parent) {
    ancestors.push(parent);
    parent = parent.getParent();
  }
  return ancestors;
}, getAncestorIds:function() {
  var ancestorIds = [], parent = this.getParent();
  while (parent) {
    ancestorIds.push(parent.getId());
    parent = parent.getParent();
  }
  return ancestorIds;
}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Traversable'], 0);
Ext.cmd.derive('Ext.ComponentManager', Ext.Base, {alternateClassName:'Ext.ComponentMgr', singleton:true, constructor:function() {
  var map = {};
  this.all = {map:map, getArray:function() {
    var list = [], id;
    for (id in map) {
      if (map.hasOwnProperty(id)) {
        list.push(map[id]);
      }
    }
    return list;
  }};
  this.map = map;
}, register:function(component) {
  var id = component.getId();
  this.map[component.getId()] = component;
}, unregister:function(component) {
  delete this.map[component.getId()];
}, isRegistered:function(component) {
  return this.map[component] !== undefined;
}, get:function(id) {
  return this.map[id];
}, create:function(component, defaultType) {
  if (component.isComponent) {
    return component;
  } else {
    if (Ext.isString(component)) {
      return Ext.createByAlias('widget.' + component);
    } else {
      var type = component.xtype || defaultType;
      return Ext.createByAlias('widget.' + type, component);
    }
  }
}, registerType:Ext.emptyFn}, 1, 0, 0, 0, 0, 0, [Ext, 'ComponentManager', Ext, 'ComponentMgr'], 0);
(function() {
  function xf(format) {
    var args = Array.prototype.slice.call(arguments, 1);
    return format.replace(/\{(\d+)\}/g, function(m, i) {
      return args[i];
    });
  }
  Ext.DateExtras = {now:Date.now || function() {
    return +new Date;
  }, getElapsed:function(dateA, dateB) {
    return Math.abs(dateA - (dateB || new Date));
  }, useStrict:false, formatCodeToRegex:function(character, currentGroup) {
    var p = utilDate.parseCodes[character];
    if (p) {
      p = typeof p == 'function' ? p() : p;
      utilDate.parseCodes[character] = p;
    }
    return p ? Ext.applyIf({c:p.c ? xf(p.c, currentGroup || '{0}') : p.c}, p) : {g:0, c:null, s:Ext.String.escapeRegex(character)};
  }, parseFunctions:{'MS':function(input, strict) {
    var re = new RegExp('\\\\?/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\\\?/');
    var r = (input || '').match(re);
    return r ? new Date(((r[1] || '') + r[2]) * 1) : null;
  }}, parseRegexes:[], formatFunctions:{'MS':function() {
    return '\\/Date(' + this.getTime() + ')\\/';
  }}, y2kYear:50, MILLI:'ms', SECOND:'s', MINUTE:'mi', HOUR:'h', DAY:'d', MONTH:'mo', YEAR:'y', defaults:{}, dayNames:['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], monthNames:['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], monthNumbers:{Jan:0, Feb:1, Mar:2, Apr:3, May:4, Jun:5, Jul:6, Aug:7, Sep:8, Oct:9, Nov:10, Dec:11}, defaultFormat:'m/d/Y', getShortMonthName:function(month) {
    return utilDate.monthNames[month].substring(0, 3);
  }, getShortDayName:function(day) {
    return utilDate.dayNames[day].substring(0, 3);
  }, getMonthNumber:function(name) {
    return utilDate.monthNumbers[name.substring(0, 1).toUpperCase() + name.substring(1, 3).toLowerCase()];
  }, formatCodes:{d:"Ext.String.leftPad(this.getDate(), 2, '0')", D:'Ext.Date.getShortDayName(this.getDay())', j:'this.getDate()', l:'Ext.Date.dayNames[this.getDay()]', N:'(this.getDay() ? this.getDay() : 7)', S:'Ext.Date.getSuffix(this)', w:'this.getDay()', z:'Ext.Date.getDayOfYear(this)', W:"Ext.String.leftPad(Ext.Date.getWeekOfYear(this), 2, '0')", F:'Ext.Date.monthNames[this.getMonth()]', m:"Ext.String.leftPad(this.getMonth() + 1, 2, '0')", M:'Ext.Date.getShortMonthName(this.getMonth())', n:'(this.getMonth() + 1)', 
  t:'Ext.Date.getDaysInMonth(this)', L:'(Ext.Date.isLeapYear(this) ? 1 : 0)', o:'(this.getFullYear() + (Ext.Date.getWeekOfYear(this) \x3d\x3d 1 \x26\x26 this.getMonth() \x3e 0 ? +1 : (Ext.Date.getWeekOfYear(this) \x3e\x3d 52 \x26\x26 this.getMonth() \x3c 11 ? -1 : 0)))', Y:"Ext.String.leftPad(this.getFullYear(), 4, '0')", y:"('' + this.getFullYear()).substring(2, 4)", a:"(this.getHours() \x3c 12 ? 'am' : 'pm')", A:"(this.getHours() \x3c 12 ? 'AM' : 'PM')", g:'((this.getHours() % 12) ? this.getHours() % 12 : 12)', 
  G:'this.getHours()', h:"Ext.String.leftPad((this.getHours() % 12) ? this.getHours() % 12 : 12, 2, '0')", H:"Ext.String.leftPad(this.getHours(), 2, '0')", i:"Ext.String.leftPad(this.getMinutes(), 2, '0')", s:"Ext.String.leftPad(this.getSeconds(), 2, '0')", u:"Ext.String.leftPad(this.getMilliseconds(), 3, '0')", O:'Ext.Date.getGMTOffset(this)', P:'Ext.Date.getGMTOffset(this, true)', T:'Ext.Date.getTimezone(this)', Z:'(this.getTimezoneOffset() * -60)', c:function() {
    for (var c = 'Y-m-dTH:i:sP', code = [], i = 0, l = c.length; i < l; ++i) {
      var e = c.charAt(i);
      code.push(e == 'T' ? "'T'" : utilDate.getFormatCode(e));
    }
    return code.join(' + ');
  }, U:'Math.round(this.getTime() / 1000)'}, isValid:function(y, m, d, h, i, s, ms) {
    h = h || 0;
    i = i || 0;
    s = s || 0;
    ms = ms || 0;
    var dt = utilDate.add(new Date(y < 100 ? 100 : y, m - 1, d, h, i, s, ms), utilDate.YEAR, y < 100 ? y - 100 : 0);
    return y == dt.getFullYear() && m == dt.getMonth() + 1 && d == dt.getDate() && h == dt.getHours() && i == dt.getMinutes() && s == dt.getSeconds() && ms == dt.getMilliseconds();
  }, parse:function(input, format, strict) {
    var p = utilDate.parseFunctions;
    if (p[format] == null) {
      utilDate.createParser(format);
    }
    return p[format](input, Ext.isDefined(strict) ? strict : utilDate.useStrict);
  }, parseDate:function(input, format, strict) {
    return utilDate.parse(input, format, strict);
  }, getFormatCode:function(character) {
    var f = utilDate.formatCodes[character];
    if (f) {
      f = typeof f == 'function' ? f() : f;
      utilDate.formatCodes[character] = f;
    }
    return f || "'" + Ext.String.escape(character) + "'";
  }, createFormat:function(format) {
    var code = [], special = false, ch = '';
    for (var i = 0; i < format.length; ++i) {
      ch = format.charAt(i);
      if (!special && ch == '\\') {
        special = true;
      } else {
        if (special) {
          special = false;
          code.push("'" + Ext.String.escape(ch) + "'");
        } else {
          if (ch == '\n') {
            code.push(Ext.JSON.encode(ch));
          } else {
            code.push(utilDate.getFormatCode(ch));
          }
        }
      }
    }
    utilDate.formatFunctions[format] = Ext.functionFactory('return ' + code.join('+'));
  }, createParser:function() {
    var code = ['var dt, y, m, d, h, i, s, ms, o, z, zz, u, v,', 'def \x3d Ext.Date.defaults,', 'results \x3d String(input).match(Ext.Date.parseRegexes[{0}]);', 'if(results){', '{1}', 'if(u !\x3d null){', 'v \x3d new Date(u * 1000);', '}else{', 'dt \x3d Ext.Date.clearTime(new Date);', 'y \x3d Ext.Number.from(y, Ext.Number.from(def.y, dt.getFullYear()));', 'm \x3d Ext.Number.from(m, Ext.Number.from(def.m - 1, dt.getMonth()));', 'd \x3d Ext.Number.from(d, Ext.Number.from(def.d, dt.getDate()));', 'h  \x3d Ext.Number.from(h, Ext.Number.from(def.h, dt.getHours()));', 
    'i  \x3d Ext.Number.from(i, Ext.Number.from(def.i, dt.getMinutes()));', 's  \x3d Ext.Number.from(s, Ext.Number.from(def.s, dt.getSeconds()));', 'ms \x3d Ext.Number.from(ms, Ext.Number.from(def.ms, dt.getMilliseconds()));', 'if(z \x3e\x3d 0 \x26\x26 y \x3e\x3d 0){', 'v \x3d Ext.Date.add(new Date(y \x3c 100 ? 100 : y, 0, 1, h, i, s, ms), Ext.Date.YEAR, y \x3c 100 ? y - 100 : 0);', 'v \x3d !strict? v : (strict \x3d\x3d\x3d true \x26\x26 (z \x3c\x3d 364 || (Ext.Date.isLeapYear(v) \x26\x26 z \x3c\x3d 365))? Ext.Date.add(v, Ext.Date.DAY, z) : null);', 
    '}else if(strict \x3d\x3d\x3d true \x26\x26 !Ext.Date.isValid(y, m + 1, d, h, i, s, ms)){', 'v \x3d null;', '}else{', 'v \x3d Ext.Date.add(new Date(y \x3c 100 ? 100 : y, m, d, h, i, s, ms), Ext.Date.YEAR, y \x3c 100 ? y - 100 : 0);', '}', '}', '}', 'if(v){', 'if(zz !\x3d null){', 'v \x3d Ext.Date.add(v, Ext.Date.SECOND, -v.getTimezoneOffset() * 60 - zz);', '}else if(o){', "v \x3d Ext.Date.add(v, Ext.Date.MINUTE, -v.getTimezoneOffset() + (sn \x3d\x3d '+'? -1 : 1) * (hr * 60 + mn));", '}', '}', 
    'return v;'].join('\n');
    return function(format) {
      var regexNum = utilDate.parseRegexes.length, currentGroup = 1, calc = [], regex = [], special = false, ch = '';
      for (var i = 0; i < format.length; ++i) {
        ch = format.charAt(i);
        if (!special && ch == '\\') {
          special = true;
        } else {
          if (special) {
            special = false;
            regex.push(Ext.String.escape(ch));
          } else {
            var obj = utilDate.formatCodeToRegex(ch, currentGroup);
            currentGroup += obj.g;
            regex.push(obj.s);
            if (obj.g && obj.c) {
              calc.push(obj.c);
            }
          }
        }
      }
      utilDate.parseRegexes[regexNum] = new RegExp('^' + regex.join('') + '$', 'i');
      utilDate.parseFunctions[format] = Ext.functionFactory('input', 'strict', xf(code, regexNum, calc.join('')));
    };
  }(), parseCodes:{d:{g:1, c:'d \x3d parseInt(results[{0}], 10);\n', s:'(\\d{2})'}, j:{g:1, c:'d \x3d parseInt(results[{0}], 10);\n', s:'(\\d{1,2})'}, D:function() {
    for (var a = [], i = 0; i < 7; a.push(utilDate.getShortDayName(i)), ++i) {
    }
    return {g:0, c:null, s:'(?:' + a.join('|') + ')'};
  }, l:function() {
    return {g:0, c:null, s:'(?:' + utilDate.dayNames.join('|') + ')'};
  }, N:{g:0, c:null, s:'[1-7]'}, S:{g:0, c:null, s:'(?:st|nd|rd|th)'}, w:{g:0, c:null, s:'[0-6]'}, z:{g:1, c:'z \x3d parseInt(results[{0}], 10);\n', s:'(\\d{1,3})'}, W:{g:0, c:null, s:'(?:\\d{2})'}, F:function() {
    return {g:1, c:'m \x3d parseInt(Ext.Date.getMonthNumber(results[{0}]), 10);\n', s:'(' + utilDate.monthNames.join('|') + ')'};
  }, M:function() {
    for (var a = [], i = 0; i < 12; a.push(utilDate.getShortMonthName(i)), ++i) {
    }
    return Ext.applyIf({s:'(' + a.join('|') + ')'}, utilDate.formatCodeToRegex('F'));
  }, m:{g:1, c:'m \x3d parseInt(results[{0}], 10) - 1;\n', s:'(\\d{2})'}, n:{g:1, c:'m \x3d parseInt(results[{0}], 10) - 1;\n', s:'(\\d{1,2})'}, t:{g:0, c:null, s:'(?:\\d{2})'}, L:{g:0, c:null, s:'(?:1|0)'}, o:function() {
    return utilDate.formatCodeToRegex('Y');
  }, Y:{g:1, c:'y \x3d parseInt(results[{0}], 10);\n', s:'(\\d{4})'}, y:{g:1, c:'var ty \x3d parseInt(results[{0}], 10);\ny \x3d ty \x3e Ext.Date.y2kYear ? 1900 + ty : 2000 + ty;\n', s:'(\\d{1,2})'}, a:{g:1, c:'if (/(am)/i.test(results[{0}])) {\nif (!h || h \x3d\x3d 12) { h \x3d 0; }\n} else { if (!h || h \x3c 12) { h \x3d (h || 0) + 12; }}', s:'(am|pm|AM|PM)'}, A:{g:1, c:'if (/(am)/i.test(results[{0}])) {\nif (!h || h \x3d\x3d 12) { h \x3d 0; }\n} else { if (!h || h \x3c 12) { h \x3d (h || 0) + 12; }}', 
  s:'(AM|PM|am|pm)'}, g:function() {
    return utilDate.formatCodeToRegex('G');
  }, G:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(\\d{1,2})'}, h:function() {
    return utilDate.formatCodeToRegex('H');
  }, H:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(\\d{2})'}, i:{g:1, c:'i \x3d parseInt(results[{0}], 10);\n', s:'(\\d{2})'}, s:{g:1, c:'s \x3d parseInt(results[{0}], 10);\n', s:'(\\d{2})'}, u:{g:1, c:'ms \x3d results[{0}]; ms \x3d parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n', s:'(\\d+)'}, O:{g:1, c:['o \x3d results[{0}];', 'var sn \x3d o.substring(0,1),', 'hr \x3d o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),', 'mn \x3d o.substring(3,5) % 60;', "o \x3d ((-12 \x3c\x3d (hr*60 + mn)/60) \x26\x26 ((hr*60 + mn)/60 \x3c\x3d 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join('\n'), 
  s:'([+-]\\d{4})'}, P:{g:1, c:['o \x3d results[{0}];', 'var sn \x3d o.substring(0,1),', 'hr \x3d o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),', 'mn \x3d o.substring(4,6) % 60;', "o \x3d ((-12 \x3c\x3d (hr*60 + mn)/60) \x26\x26 ((hr*60 + mn)/60 \x3c\x3d 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join('\n'), s:'([+-]\\d{2}:\\d{2})'}, T:{g:0, c:null, s:'[A-Z]{1,4}'}, Z:{g:1, c:'zz \x3d results[{0}] * 1;\nzz \x3d (-43200 \x3c\x3d zz \x26\x26 zz \x3c\x3d 50400)? zz : null;\n', 
  s:'([+-]?\\d{1,5})'}, c:function() {
    var calc = [], arr = [utilDate.formatCodeToRegex('Y', 1), utilDate.formatCodeToRegex('m', 2), utilDate.formatCodeToRegex('d', 3), utilDate.formatCodeToRegex('h', 4), utilDate.formatCodeToRegex('i', 5), utilDate.formatCodeToRegex('s', 6), {c:"ms \x3d results[7] || '0'; ms \x3d parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n"}, {c:['if(results[8]) {', "if(results[8] \x3d\x3d 'Z'){", 'zz \x3d 0;', "}else if (results[8].indexOf(':') \x3e -1){", utilDate.formatCodeToRegex('P', 8).c, '}else{', utilDate.formatCodeToRegex('O', 
    8).c, '}', '}'].join('\n')}];
    for (var i = 0, l = arr.length; i < l; ++i) {
      calc.push(arr[i].c);
    }
    return {g:1, c:calc.join(''), s:[arr[0].s, '(?:', '-', arr[1].s, '(?:', '-', arr[2].s, '(?:', '(?:T| )?', arr[3].s, ':', arr[4].s, '(?::', arr[5].s, ')?', '(?:(?:\\.|,)(\\d+))?', '(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?', ')?', ')?', ')?'].join('')};
  }, U:{g:1, c:'u \x3d parseInt(results[{0}], 10);\n', s:'(-?\\d+)'}}, dateFormat:function(date, format) {
    return utilDate.format(date, format);
  }, format:function(date, format) {
    if (utilDate.formatFunctions[format] == null) {
      utilDate.createFormat(format);
    }
    var result = utilDate.formatFunctions[format].call(date);
    return result + '';
  }, getTimezone:function(date) {
    return date.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,4})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, '$1$2').replace(/[^A-Z]/g, '');
  }, getGMTOffset:function(date, colon) {
    var offset = date.getTimezoneOffset();
    return (offset > 0 ? '-' : '+') + Ext.String.leftPad(Math.floor(Math.abs(offset) / 60), 2, '0') + (colon ? ':' : '') + Ext.String.leftPad(Math.abs(offset % 60), 2, '0');
  }, getDayOfYear:function(date) {
    var num = 0, d = Ext.Date.clone(date), m = date.getMonth(), i;
    for (i = 0, d.setDate(1), d.setMonth(0); i < m; d.setMonth(++i)) {
      num += utilDate.getDaysInMonth(d);
    }
    return num + date.getDate() - 1;
  }, getWeekOfYear:function() {
    var ms1d = 86400000, ms7d = 7 * ms1d;
    return function(date) {
      var DC3 = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate() + 3) / ms1d, AWN = Math.floor(DC3 / 7), Wyr = (new Date(AWN * ms7d)).getUTCFullYear();
      return AWN - Math.floor(Date.UTC(Wyr, 0, 7) / ms7d) + 1;
    };
  }(), isLeapYear:function(date) {
    var year = date.getFullYear();
    return !!((year & 3) == 0 && (year % 100 || year % 400 == 0 && year));
  }, getFirstDayOfMonth:function(date) {
    var day = (date.getDay() - (date.getDate() - 1)) % 7;
    return day < 0 ? day + 7 : day;
  }, getLastDayOfMonth:function(date) {
    return utilDate.getLastDateOfMonth(date).getDay();
  }, getFirstDateOfMonth:function(date) {
    return new Date(date.getFullYear(), date.getMonth(), 1);
  }, getLastDateOfMonth:function(date) {
    return new Date(date.getFullYear(), date.getMonth(), utilDate.getDaysInMonth(date));
  }, getDaysInMonth:function() {
    var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    return function(date) {
      var m = date.getMonth();
      return m == 1 && utilDate.isLeapYear(date) ? 29 : daysInMonth[m];
    };
  }(), getSuffix:function(date) {
    switch(date.getDate()) {
      case 1:
      case 21:
      case 31:
        return 'st';
      case 2:
      case 22:
        return 'nd';
      case 3:
      case 23:
        return 'rd';
      default:
        return 'th';
    }
  }, clone:function(date) {
    return new Date(date.getTime());
  }, isDST:function(date) {
    return (new Date(date.getFullYear(), 0, 1)).getTimezoneOffset() != date.getTimezoneOffset();
  }, clearTime:function(date, clone) {
    if (clone) {
      return Ext.Date.clearTime(Ext.Date.clone(date));
    }
    var d = date.getDate();
    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    if (date.getDate() != d) {
      for (var hr = 1, c = utilDate.add(date, Ext.Date.HOUR, hr); c.getDate() != d; hr++, c = utilDate.add(date, Ext.Date.HOUR, hr)) {
      }
      date.setDate(d);
      date.setHours(c.getHours());
    }
    return date;
  }, add:function(date, interval, value) {
    var d = Ext.Date.clone(date);
    if (!interval || value === 0) {
      return d;
    }
    switch(interval.toLowerCase()) {
      case Ext.Date.MILLI:
        d = new Date(d.valueOf() + value);
        break;
      case Ext.Date.SECOND:
        d = new Date(d.valueOf() + value * 1000);
        break;
      case Ext.Date.MINUTE:
        d = new Date(d.valueOf() + value * 60000);
        break;
      case Ext.Date.HOUR:
        d = new Date(d.valueOf() + value * 3600000);
        break;
      case Ext.Date.DAY:
        d = new Date(d.valueOf() + value * 86400000);
        break;
      case Ext.Date.MONTH:
        var day = date.getDate();
        if (day > 28) {
          day = Math.min(day, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(date), 'mo', value)).getDate());
        }
        d.setDate(day);
        d.setMonth(date.getMonth() + value);
        break;
      case Ext.Date.YEAR:
        d.setFullYear(date.getFullYear() + value);
        break;
    }
    return d;
  }, between:function(date, start, end) {
    var t = date.getTime();
    return start.getTime() <= t && t <= end.getTime();
  }, diff:function(min, max, unit) {
    var ExtDate = Ext.Date, est, diff = +max - min;
    switch(unit) {
      case ExtDate.MILLI:
        return diff;
      case ExtDate.SECOND:
        return Math.floor(diff / 1000);
      case ExtDate.MINUTE:
        return Math.floor(diff / 60000);
      case ExtDate.HOUR:
        return Math.floor(diff / 3600000);
      case ExtDate.DAY:
        return Math.floor(diff / 86400000);
      case 'w':
        return Math.floor(diff / 604800000);
      case ExtDate.MONTH:
        est = max.getFullYear() * 12 + max.getMonth() - (min.getFullYear() * 12 + min.getMonth());
        if (Ext.Date.add(min, unit, est) > max) {
          return est - 1;
        } else {
          return est;
        }
      case ExtDate.YEAR:
        est = max.getFullYear() - min.getFullYear();
        if (Ext.Date.add(min, unit, est) > max) {
          return est - 1;
        } else {
          return est;
        }
    }
  }, align:function(date, unit, step) {
    var num = new Date(+date);
    switch(unit.toLowerCase()) {
      case Ext.Date.MILLI:
        return num;
        break;
      case Ext.Date.SECOND:
        num.setUTCSeconds(num.getUTCSeconds() - num.getUTCSeconds() % step);
        num.setUTCMilliseconds(0);
        return num;
        break;
      case Ext.Date.MINUTE:
        num.setUTCMinutes(num.getUTCMinutes() - num.getUTCMinutes() % step);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
        break;
      case Ext.Date.HOUR:
        num.setUTCHours(num.getUTCHours() - num.getUTCHours() % step);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
        break;
      case Ext.Date.DAY:
        if (step == 7 || step == 14) {
          num.setUTCDate(num.getUTCDate() - num.getUTCDay() + 1);
        }
        num.setUTCHours(0);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
        break;
      case Ext.Date.MONTH:
        num.setUTCMonth(num.getUTCMonth() - (num.getUTCMonth() - 1) % step, 1);
        num.setUTCHours(0);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
        break;
      case Ext.Date.YEAR:
        num.setUTCFullYear(num.getUTCFullYear() - num.getUTCFullYear() % step, 1, 1);
        num.setUTCHours(0);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return date;
        break;
    }
  }};
  var utilDate = Ext.DateExtras;
  Ext.apply(Ext.Date, utilDate);
})();
Ext.cmd.derive('Ext.util.Format', Ext.Base, {singleton:true, defaultDateFormat:'m/d/Y', escapeRe:/('|\\)/g, trimRe:/^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g, formatRe:/\{(\d+)\}/g, escapeRegexRe:/([-.*+?^${}()|[\]\/\\])/g, dashesRe:/-/g, iso8601TestRe:/\d\dT\d\d/, 
iso8601SplitRe:/[- :T\.Z\+]/, ellipsis:function(value, len, word) {
  if (value && value.length > len) {
    if (word) {
      var vs = value.substr(0, len - 2), index = Math.max(vs.lastIndexOf(' '), vs.lastIndexOf('.'), vs.lastIndexOf('!'), vs.lastIndexOf('?'));
      if (index != -1 && index >= len - 15) {
        return vs.substr(0, index) + '...';
      }
    }
    return value.substr(0, len - 3) + '...';
  }
  return value;
}, escapeRegex:function(s) {
  return s.replace(Ext.util.Format.escapeRegexRe, '\\$1');
}, escape:function(string) {
  return string.replace(Ext.util.Format.escapeRe, '\\$1');
}, toggle:function(string, value, other) {
  return string == value ? other : value;
}, trim:function(string) {
  return string.replace(Ext.util.Format.trimRe, '');
}, leftPad:function(val, size, ch) {
  var result = String(val);
  ch = ch || ' ';
  while (result.length < size) {
    result = ch + result;
  }
  return result;
}, format:function(format) {
  var args = Ext.toArray(arguments, 1);
  return format.replace(Ext.util.Format.formatRe, function(m, i) {
    return args[i];
  });
}, htmlEncode:function(value) {
  return !value ? value : String(value).replace(/&/g, '\x26amp;').replace(/>/g, '\x26gt;').replace(/</g, '\x26lt;').replace(/"/g, '\x26quot;');
}, htmlDecode:function(value) {
  return !value ? value : String(value).replace(/&gt;/g, '\x3e').replace(/&lt;/g, '\x3c').replace(/&quot;/g, '"').replace(/&amp;/g, '\x26');
}, date:function(value, format) {
  var date = value;
  if (!value) {
    return '';
  }
  if (!Ext.isDate(value)) {
    date = new Date(Date.parse(value));
    if (isNaN(date)) {
      if (this.iso8601TestRe.test(value)) {
        if (Ext.os.is.Android && Ext.os.version.isLessThan('3.0')) {
          var potentialUndefinedKeys = [1, 4, 5, 6, 7, 10, 11];
          var dateParsed, minutesOffset = 0;
          if (dateParsed = /^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/.exec(value)) {
            for (var i = 0, k; k = potentialUndefinedKeys[i]; ++i) {
              dateParsed[k] = +dateParsed[k] || 0;
            }
            dateParsed[2] = (+dateParsed[2] || 1) - 1;
            dateParsed[3] = +dateParsed[3] || 1;
            if (dateParsed[8] !== 'Z' && dateParsed[9] !== undefined) {
              minutesOffset = dateParsed[10] * 60 + dateParsed[11];
              if (dateParsed[9] === '+') {
                minutesOffset = 0 - minutesOffset;
              }
            }
            date = new Date(Date.UTC(dateParsed[1], dateParsed[2], dateParsed[3], dateParsed[4], dateParsed[5] + minutesOffset, dateParsed[6], dateParsed[7]));
          }
        } else {
          date = value.split(this.iso8601SplitRe);
          date = new Date(date[0], date[1] - 1, date[2], date[3], date[4], date[5]);
        }
      }
    }
    if (isNaN(date)) {
      date = new Date(Date.parse(value.replace(this.dashesRe, '/')));
    }
    value = date;
  }
  return Ext.Date.format(value, format || Ext.util.Format.defaultDateFormat);
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Format'], 0);
Ext.cmd.derive('Ext.Template', Ext.Base, {inheritableStatics:{from:function(el, config) {
  el = Ext.getDom(el);
  return new this(el.value || el.innerHTML, config || '');
}}, constructor:function(html) {
  var me = this, args = arguments, buffer = [], i = 0, length = args.length, value;
  me.initialConfig = {};
  if (length === 1 && Ext.isArray(html)) {
    args = html;
    length = args.length;
  }
  if (length > 1) {
    for (; i < length; i++) {
      value = args[i];
      if (typeof value == 'object') {
        Ext.apply(me.initialConfig, value);
        Ext.apply(me, value);
      } else {
        buffer.push(value);
      }
    }
  } else {
    buffer.push(html);
  }
  me.html = buffer.join('');
  if (me.compiled) {
    me.compile();
  }
}, isTemplate:true, disableFormats:false, re:/\{([\w\-]+)(?::([\w\.]*)(?:\((.*?)?\))?)?\}/g, apply:function(values) {
  var me = this, useFormat = me.disableFormats !== true, fm = Ext.util.Format, tpl = me, ret;
  if (me.compiled) {
    return me.compiled(values).join('');
  }
  function fn(m, name, format, args) {
    if (format && useFormat) {
      if (args) {
        args = [values[name]].concat(Ext.functionFactory('return [' + args + '];')());
      } else {
        args = [values[name]];
      }
      if (format.substr(0, 5) == 'this.') {
        return tpl[format.substr(5)].apply(tpl, args);
      } else {
        return fm[format].apply(fm, args);
      }
    } else {
      return values[name] !== undefined ? values[name] : '';
    }
  }
  ret = me.html.replace(me.re, fn);
  return ret;
}, applyOut:function(values, out) {
  var me = this;
  if (me.compiled) {
    out.push.apply(out, me.compiled(values));
  } else {
    out.push(me.apply(values));
  }
  return out;
}, applyTemplate:function() {
  return this.apply.apply(this, arguments);
}, set:function(html, compile) {
  var me = this;
  me.html = html;
  me.compiled = null;
  return compile ? me.compile() : me;
}, compileARe:/\\/g, compileBRe:/(\r\n|\n)/g, compileCRe:/'/g, compile:function() {
  var me = this, fm = Ext.util.Format, useFormat = me.disableFormats !== true, body, bodyReturn;
  function fn(m, name, format, args) {
    if (format && useFormat) {
      args = args ? ',' + args : '';
      if (format.substr(0, 5) != 'this.') {
        format = 'fm.' + format + '(';
      } else {
        format = 'this.' + format.substr(5) + '(';
      }
    } else {
      args = '';
      format = "(values['" + name + "'] \x3d\x3d undefined ? '' : ";
    }
    return "'," + format + "values['" + name + "']" + args + ") ,'";
  }
  bodyReturn = me.html.replace(me.compileARe, '\\\\').replace(me.compileBRe, '\\n').replace(me.compileCRe, "\\'").replace(me.re, fn);
  body = "this.compiled \x3d function(values){ return ['" + bodyReturn + "'];};";
  eval(body);
  return me;
}, insertFirst:function(el, values, returnElement) {
  return this.doInsert('afterBegin', el, values, returnElement);
}, insertBefore:function(el, values, returnElement) {
  return this.doInsert('beforeBegin', el, values, returnElement);
}, insertAfter:function(el, values, returnElement) {
  return this.doInsert('afterEnd', el, values, returnElement);
}, append:function(el, values, returnElement) {
  return this.doInsert('beforeEnd', el, values, returnElement);
}, doInsert:function(where, el, values, returnElement) {
  var newNode = Ext.DomHelper.insertHtml(where, Ext.getDom(el), this.apply(values));
  return returnElement ? Ext.get(newNode) : newNode;
}, overwrite:function(el, values, returnElement) {
  var newNode = Ext.DomHelper.overwrite(Ext.getDom(el), this.apply(values));
  return returnElement ? Ext.get(newNode) : newNode;
}}, 1, 0, 0, 0, 0, 0, [Ext, 'Template'], 0);
Ext.cmd.derive('Ext.XTemplateParser', Ext.Base, {constructor:function(config) {
  Ext.apply(this, config);
}, doTpl:Ext.emptyFn, parse:function(str) {
  var me = this, len = str.length, aliases = {elseif:'elif'}, topRe = me.topRe, actionsRe = me.actionsRe, index, stack, s, m, t, prev, frame, subMatch, begin, end, actions, prop;
  me.level = 0;
  me.stack = stack = [];
  for (index = 0; index < len; index = end) {
    topRe.lastIndex = index;
    m = topRe.exec(str);
    if (!m) {
      me.doText(str.substring(index, len));
      break;
    }
    begin = m.index;
    end = topRe.lastIndex;
    if (index < begin) {
      me.doText(str.substring(index, begin));
    }
    if (m[1]) {
      end = str.indexOf('%}', begin + 2);
      me.doEval(str.substring(begin + 2, end));
      end += 2;
    } else {
      if (m[2]) {
        end = str.indexOf(']}', begin + 2);
        me.doExpr(str.substring(begin + 2, end));
        end += 2;
      } else {
        if (m[3]) {
          me.doTag(m[3]);
        } else {
          if (m[4]) {
            actions = null;
            while ((subMatch = actionsRe.exec(m[4])) !== null) {
              s = subMatch[2] || subMatch[3];
              if (s) {
                s = Ext.String.htmlDecode(s);
                t = subMatch[1];
                t = aliases[t] || t;
                actions = actions || {};
                prev = actions[t];
                if (typeof prev == 'string') {
                  actions[t] = [prev, s];
                } else {
                  if (prev) {
                    actions[t].push(s);
                  } else {
                    actions[t] = s;
                  }
                }
              }
            }
            if (!actions) {
              if (me.elseRe.test(m[4])) {
                me.doElse();
              } else {
                if (me.defaultRe.test(m[4])) {
                  me.doDefault();
                } else {
                  me.doTpl();
                  stack.push({type:'tpl'});
                }
              }
            } else {
              if (actions['if']) {
                me.doIf(actions['if'], actions);
                stack.push({type:'if'});
              } else {
                if (actions['switch']) {
                  me.doSwitch(actions['switch'], actions);
                  stack.push({type:'switch'});
                } else {
                  if (actions['case']) {
                    me.doCase(actions['case'], actions);
                  } else {
                    if (actions['elif']) {
                      me.doElseIf(actions['elif'], actions);
                    } else {
                      if (actions['for']) {
                        ++me.level;
                        if (prop = me.propRe.exec(m[4])) {
                          actions.propName = prop[1] || prop[2];
                        }
                        me.doFor(actions['for'], actions);
                        stack.push({type:'for', actions:actions});
                      } else {
                        if (actions.exec) {
                          me.doExec(actions.exec, actions);
                          stack.push({type:'exec', actions:actions});
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (m[0].length === 5) {
              stack.push({type:'tpl'});
            } else {
              frame = stack.pop();
              me.doEnd(frame.type, frame.actions);
              if (frame.type == 'for') {
                --me.level;
              }
            }
          }
        }
      }
    }
  }
}, topRe:/(?:(\{%)|(\{\[)|\{([^{}]*)\})|(?:<tpl([^>]*)>)|(?:<\/tpl>)/g, actionsRe:/\s*(elif|elseif|if|for|exec|switch|case|eval)\s*=\s*(?:(?:"([^"]*)")|(?:'([^']*)'))\s*/g, propRe:/prop=(?:(?:"([^"]*)")|(?:'([^']*)'))/, defaultRe:/^\s*default\s*$/, elseRe:/^\s*else\s*$/}, 1, 0, 0, 0, 0, 0, [Ext, 'XTemplateParser'], 0);
Ext.cmd.derive('Ext.XTemplateCompiler', Ext.XTemplateParser, {useEval:Ext.isGecko, useIndex:Ext.isIE6 || Ext.isIE7, useFormat:true, propNameRe:/^[\w\d\$]*$/, compile:function(tpl) {
  var me = this, code = me.generate(tpl);
  return me.useEval ? me.evalTpl(code) : (new Function('Ext', code))(Ext);
}, generate:function(tpl) {
  var me = this, definitions = 'var fm\x3dExt.util.Format,ts\x3dObject.prototype.toString;', code;
  me.maxLevel = 0;
  me.body = ['var c0\x3dvalues, a0\x3d' + me.createArrayTest(0) + ', p0\x3dparent, n0\x3dxcount, i0\x3dxindex, v;\n'];
  if (me.definitions) {
    if (typeof me.definitions === 'string') {
      me.definitions = [me.definitions, definitions];
    } else {
      me.definitions.push(definitions);
    }
  } else {
    me.definitions = [definitions];
  }
  me.switches = [];
  me.parse(tpl);
  me.definitions.push((me.useEval ? '$\x3d' : 'return') + ' function (' + me.fnArgs + ') {', me.body.join(''), '}');
  code = me.definitions.join('\n');
  me.definitions.length = me.body.length = me.switches.length = 0;
  delete me.definitions;
  delete me.body;
  delete me.switches;
  return code;
}, doText:function(text) {
  var me = this, out = me.body;
  text = text.replace(me.aposRe, "\\'").replace(me.newLineRe, '\\n');
  if (me.useIndex) {
    out.push("out[out.length]\x3d'", text, "'\n");
  } else {
    out.push("out.push('", text, "')\n");
  }
}, doExpr:function(expr) {
  var out = this.body;
  out.push('v\x3d' + expr + '; if (v !\x3d\x3d undefined \x26\x26 v !\x3d\x3d null) out');
  if (this.useIndex) {
    out.push("[out.length]\x3dv+''\n");
  } else {
    out.push(".push(v+'')\n");
  }
}, doTag:function(tag) {
  this.doExpr(this.parseTag(tag));
}, doElse:function() {
  this.body.push('} else {\n');
}, doEval:function(text) {
  this.body.push(text, '\n');
}, doIf:function(action, actions) {
  var me = this;
  if (action === '.') {
    me.body.push('if (values) {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('if (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('if (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  if (actions.exec) {
    me.doExec(actions.exec);
  }
}, doElseIf:function(action, actions) {
  var me = this;
  if (action === '.') {
    me.body.push('else if (values) {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('} else if (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('} else if (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  if (actions.exec) {
    me.doExec(actions.exec);
  }
}, doSwitch:function(action) {
  var me = this;
  if (action === '.') {
    me.body.push('switch (values) {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('switch (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('switch (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  me.switches.push(0);
}, doCase:function(action) {
  var me = this, cases = Ext.isArray(action) ? action : [action], n = me.switches.length - 1, match, i;
  if (me.switches[n]) {
    me.body.push('break;\n');
  } else {
    me.switches[n]++;
  }
  for (i = 0, n = cases.length; i < n; ++i) {
    match = me.intRe.exec(cases[i]);
    cases[i] = match ? match[1] : "'" + cases[i].replace(me.aposRe, "\\'") + "'";
  }
  me.body.push('case ', cases.join(': case '), ':\n');
}, doDefault:function() {
  var me = this, n = me.switches.length - 1;
  if (me.switches[n]) {
    me.body.push('break;\n');
  } else {
    me.switches[n]++;
  }
  me.body.push('default:\n');
}, doEnd:function(type, actions) {
  var me = this, L = me.level - 1;
  if (type == 'for') {
    if (actions.exec) {
      me.doExec(actions.exec);
    }
    me.body.push('}\n');
    me.body.push('parent\x3dp', L, ';values\x3dr', L + 1, ';xcount\x3dn', L, ';xindex\x3di', L, '\n');
  } else {
    if (type == 'if' || type == 'switch') {
      me.body.push('}\n');
    }
  }
}, doFor:function(action, actions) {
  var me = this, s, L = me.level, up = L - 1, pL = 'p' + L, parentAssignment;
  if (action === '.') {
    s = 'values';
  } else {
    if (me.propNameRe.test(action)) {
      s = me.parseTag(action);
    } else {
      s = me.addFn(action) + me.callFn;
    }
  }
  if (me.maxLevel < L) {
    me.maxLevel = L;
    me.body.push('var ');
  }
  if (action == '.') {
    parentAssignment = 'c' + L;
  } else {
    parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:p' + L;
  }
  me.body.push('i', L, '\x3d0,n', L, '\x3d0,c', L, '\x3d', s, ',a', L, '\x3d', me.createArrayTest(L), ',p', L, '\x3dc', up, ',r', L, '\x3dvalues;\n', 'parent\x3d', parentAssignment, '\n', 'if (c', L, '){if(a', L, '){n', L, '\x3dc', L, '.length;}else if (c', L, '.isMixedCollection){c', L, '\x3dc', L, '.items;n', L, '\x3dc', L, '.length;}else if(c', L, '.isStore){c', L, '\x3dc', L, '.data.items;n', L, '\x3dc', L, '.length;}else{c', L, '\x3d[c', L, '];n', L, '\x3d1;}}\n', 'for (xcount\x3dn', L, ';i', 
  L, '\x3cn' + L + ';++i', L, '){\n', 'values\x3dc', L, '[i', L, ']');
  if (actions.propName) {
    me.body.push('.', actions.propName);
  }
  me.body.push('\n', 'xindex\x3di', L, '+1\n');
}, createArrayTest:'isArray' in Array ? function(L) {
  return 'Array.isArray(c' + L + ')';
} : function(L) {
  return 'ts.call(c' + L + ')\x3d\x3d\x3d"[object Array]"';
}, doExec:function(action, actions) {
  var me = this, name = 'f' + me.definitions.length;
  me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' try { with(values) {', '  ' + action, ' }} catch(e) {', '}', '}');
  me.body.push(name + me.callFn + '\n');
}, addFn:function(body) {
  var me = this, name = 'f' + me.definitions.length;
  if (body === '.') {
    me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' return values', '}');
  } else {
    if (body === '..') {
      me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' return parent', '}');
    } else {
      me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' try { with(values) {', '  return(' + body + ')', ' }} catch(e) {', '}', '}');
    }
  }
  return name;
}, parseTag:function(tag) {
  var me = this, m = me.tagRe.exec(tag), name = m[1], format = m[2], args = m[3], math = m[4], v;
  if (name == '.') {
    if (!me.validTypes) {
      me.definitions.push('var validTypes\x3d{string:1,number:1,boolean:1};');
      me.validTypes = true;
    }
    v = 'validTypes[typeof values] || ts.call(values) \x3d\x3d\x3d "[object Date]" ? values : ""';
  } else {
    if (name == '#') {
      v = 'xindex';
    } else {
      if (name.substr(0, 7) == 'parent.') {
        v = name;
      } else {
        if (isNaN(name) && name.indexOf('-') == -1 && name.indexOf('.') != -1) {
          v = 'values.' + name;
        } else {
          v = "values['" + name + "']";
        }
      }
    }
  }
  if (math) {
    v = '(' + v + math + ')';
  }
  if (format && me.useFormat) {
    args = args ? ',' + args : '';
    if (format.substr(0, 5) != 'this.') {
      format = 'fm.' + format + '(';
    } else {
      format += '(';
    }
  } else {
    return v;
  }
  return format + v + args + ')';
}, evalTpl:function($) {
  eval($);
  return $;
}, newLineRe:/\r\n|\r|\n/g, aposRe:/[']/g, intRe:/^\s*(\d+)\s*$/, tagRe:/([\w-\.#\$]+)(?::([\w\.]*)(?:\((.*?)?\))?)?(\s?[\+\-\*\/]\s?[\d\.\+\-\*\/\(\)]+)?/}, 0, 0, 0, 0, 0, 0, [Ext, 'XTemplateCompiler'], function() {
  var proto = this.prototype;
  proto.fnArgs = 'out,values,parent,xindex,xcount';
  proto.callFn = '.call(this,' + proto.fnArgs + ')';
});
Ext.cmd.derive('Ext.XTemplate', Ext.Template, {emptyObj:{}, apply:function(values) {
  return this.applyOut(values, []).join('');
}, applyOut:function(values, out, parent) {
  var me = this, xindex = values.xindex, xcount = values.xcount, compiler;
  if (!me.fn) {
    compiler = new Ext.XTemplateCompiler({useFormat:me.disableFormats !== true, definitions:me.definitions});
    me.fn = compiler.compile(me.html);
  }
  try {
    xindex = typeof xindex === 'number' ? xindex : 1;
    xcount = typeof xcount === 'number' ? xcount : 1;
    me.fn.call(me, out, values, parent || me.emptyObj, xindex, xcount);
  } catch (e$5) {
  }
  return out;
}, compile:function() {
  return this;
}, statics:{getTpl:function(instance, name) {
  var tpl = instance[name], proto;
  if (tpl && !tpl.isTemplate) {
    tpl = Ext.ClassManager.dynInstantiate('Ext.XTemplate', tpl);
    if (instance.hasOwnProperty(name)) {
      instance[name] = tpl;
    } else {
      for (proto = instance.self.prototype; proto; proto = proto.superclass) {
        if (proto.hasOwnProperty(name)) {
          proto[name] = tpl;
          break;
        }
      }
    }
  }
  return tpl || null;
}}}, 0, 0, 0, 0, 0, 0, [Ext, 'XTemplate'], 0);
Ext.cmd.derive('Ext.behavior.Behavior', Ext.Base, {constructor:function(component) {
  this.component = component;
  component.on('destroy', 'onComponentDestroy', this);
}, onComponentDestroy:Ext.emptyFn}, 1, 0, 0, 0, 0, 0, [Ext.behavior, 'Behavior'], 0);
Ext.cmd.derive('Ext.fx.easing.Abstract', Ext.Base, {config:{startTime:0, startValue:0}, isEasing:true, isEnded:false, constructor:function(config) {
  this.initConfig(config);
  return this;
}, applyStartTime:function(startTime) {
  if (!startTime) {
    startTime = Ext.Date.now();
  }
  return startTime;
}, updateStartTime:function(startTime) {
  this.reset();
}, reset:function() {
  this.isEnded = false;
}, getValue:Ext.emptyFn}, 1, 0, 0, 0, 0, 0, [Ext.fx.easing, 'Abstract'], 0);
Ext.cmd.derive('Ext.fx.easing.Linear', Ext.fx.easing.Abstract, {config:{duration:0, endValue:0}, updateStartValue:function(startValue) {
  this.distance = this.getEndValue() - startValue;
}, updateEndValue:function(endValue) {
  this.distance = endValue - this.getStartValue();
}, getValue:function() {
  var deltaTime = Ext.Date.now() - this.getStartTime(), duration = this.getDuration();
  if (deltaTime > duration) {
    this.isEnded = true;
    return this.getEndValue();
  } else {
    return this.getStartValue() + deltaTime / duration * this.distance;
  }
}}, 0, 0, 0, 0, ['easing.linear'], 0, [Ext.fx.easing, 'Linear'], 0);
Ext.cmd.derive('Ext.util.translatable.Abstract', Ext.Evented, {config:{useWrapper:null, easing:null, easingX:null, easingY:null}, x:0, y:0, activeEasingX:null, activeEasingY:null, isAnimating:false, isTranslatable:true, constructor:function(config) {
  this.initConfig(config);
}, factoryEasing:function(easing) {
  return Ext.factory(easing, Ext.fx.easing.Linear, null, 'easing');
}, applyEasing:function(easing) {
  if (!this.getEasingX()) {
    this.setEasingX(this.factoryEasing(easing));
  }
  if (!this.getEasingY()) {
    this.setEasingY(this.factoryEasing(easing));
  }
}, applyEasingX:function(easing) {
  return this.factoryEasing(easing);
}, applyEasingY:function(easing) {
  return this.factoryEasing(easing);
}, doTranslate:Ext.emptyFn, translate:function(x, y, animation) {
  if (animation) {
    return this.translateAnimated(x, y, animation);
  }
  if (this.isAnimating) {
    this.stopAnimation();
  }
  if (!isNaN(x) && typeof x == 'number') {
    this.x = x;
  }
  if (!isNaN(y) && typeof y == 'number') {
    this.y = y;
  }
  this.doTranslate(x, y);
}, translateAxis:function(axis, value, animation) {
  var x, y;
  if (axis == 'x') {
    x = value;
  } else {
    y = value;
  }
  return this.translate(x, y, animation);
}, animate:function(easingX, easingY) {
  this.activeEasingX = easingX;
  this.activeEasingY = easingY;
  this.isAnimating = true;
  this.lastX = null;
  this.lastY = null;
  Ext.AnimationQueue.start(this.doAnimationFrame, this);
  this.fireEvent('animationstart', this, this.x, this.y);
  return this;
}, translateAnimated:function(x, y, animation) {
  if (!Ext.isObject(animation)) {
    animation = {};
  }
  if (this.isAnimating) {
    this.stopAnimation();
  }
  var now = Ext.Date.now(), easing = animation.easing, easingX = typeof x == 'number' ? animation.easingX || easing || this.getEasingX() || true : null, easingY = typeof y == 'number' ? animation.easingY || easing || this.getEasingY() || true : null;
  if (easingX) {
    easingX = this.factoryEasing(easingX);
    easingX.setStartTime(now);
    easingX.setStartValue(this.x);
    easingX.setEndValue(x);
    if ('duration' in animation) {
      easingX.setDuration(animation.duration);
    }
  }
  if (easingY) {
    easingY = this.factoryEasing(easingY);
    easingY.setStartTime(now);
    easingY.setStartValue(this.y);
    easingY.setEndValue(y);
    if ('duration' in animation) {
      easingY.setDuration(animation.duration);
    }
  }
  return this.animate(easingX, easingY);
}, doAnimationFrame:function() {
  var me = this, easingX = me.activeEasingX, easingY = me.activeEasingY, now = Date.now(), x, y;
  if (!me.isAnimating) {
    return;
  }
  me.lastRun = now;
  if (easingX === null && easingY === null) {
    me.stopAnimation();
    return;
  }
  if (easingX !== null) {
    me.x = x = Math.round(easingX.getValue());
    if (easingX.isEnded) {
      me.activeEasingX = null;
      me.fireEvent('axisanimationend', me, 'x', x);
    }
  } else {
    x = me.x;
  }
  if (easingY !== null) {
    me.y = y = Math.round(easingY.getValue());
    if (easingY.isEnded) {
      me.activeEasingY = null;
      me.fireEvent('axisanimationend', me, 'y', y);
    }
  } else {
    y = me.y;
  }
  if (me.lastX !== x || me.lastY !== y) {
    me.doTranslate(x, y);
    me.lastX = x;
    me.lastY = y;
  }
  me.fireEvent('animationframe', me, x, y);
}, stopAnimation:function() {
  if (!this.isAnimating) {
    return;
  }
  this.activeEasingX = null;
  this.activeEasingY = null;
  this.isAnimating = false;
  Ext.AnimationQueue.stop(this.doAnimationFrame, this);
  this.fireEvent('animationend', this, this.x, this.y);
}, refresh:function() {
  this.translate(this.x, this.y);
}, destroy:function() {
  if (this.isAnimating) {
    this.stopAnimation();
  }
  Ext.Evented.prototype.destroy.apply(this, arguments);
}}, 1, 0, 0, 0, 0, 0, [Ext.util.translatable, 'Abstract'], 0);
Ext.cmd.derive('Ext.util.translatable.Dom', Ext.util.translatable.Abstract, {config:{element:null}, applyElement:function(element) {
  if (!element) {
    return;
  }
  return Ext.get(element);
}, updateElement:function() {
  this.refresh();
}}, 0, 0, 0, 0, 0, 0, [Ext.util.translatable, 'Dom'], 0);
Ext.cmd.derive('Ext.util.translatable.CssTransform', Ext.util.translatable.Dom, {doTranslate:function(x, y) {
  var element = this.getElement();
  if (!this.isDestroyed && !element.isDestroyed) {
    element.translate(x, y);
  }
}, destroy:function() {
  var element = this.getElement();
  if (element && !element.isDestroyed) {
    element.dom.style.webkitTransform = null;
  }
  Ext.util.translatable.Dom.prototype.destroy.call(this);
}}, 0, 0, 0, 0, 0, 0, [Ext.util.translatable, 'CssTransform'], 0);
Ext.cmd.derive('Ext.util.translatable.ScrollPosition', Ext.util.translatable.Dom, {type:'scrollposition', config:{useWrapper:true}, getWrapper:function() {
  var wrapper = this.wrapper, element = this.getElement(), container;
  if (!wrapper) {
    container = element.getParent();
    if (!container) {
      return null;
    }
    if (container.hasCls('x-translatable-hboxfix')) {
      container = container.getParent();
    }
    if (this.getUseWrapper()) {
      wrapper = element.wrap();
    } else {
      wrapper = container;
    }
    element.addCls('x-translatable');
    wrapper.addCls('x-translatable-container');
    this.wrapper = wrapper;
    wrapper.on('painted', function() {
      if (!this.isAnimating) {
        this.refresh();
      }
    }, this);
    this.refresh();
  }
  return wrapper;
}, doTranslate:function(x, y) {
  var wrapper = this.getWrapper(), dom;
  if (wrapper) {
    dom = wrapper.dom;
    if (typeof x == 'number') {
      dom.scrollLeft = 500000 - x;
    }
    if (typeof y == 'number') {
      dom.scrollTop = 500000 - y;
    }
  }
}, destroy:function() {
  var element = this.getElement(), wrapper = this.wrapper;
  if (wrapper) {
    if (!element.isDestroyed) {
      if (this.getUseWrapper()) {
        wrapper.doReplaceWith(element);
      }
      element.removeCls('x-translatable');
    }
    if (!wrapper.isDestroyed) {
      wrapper.removeCls('x-translatable-container');
      wrapper.un('painted', 'refresh', this);
    }
    delete this.wrapper;
    delete this._element;
  }
  Ext.util.translatable.Dom.prototype.destroy.call(this);
}}, 0, 0, 0, 0, 0, 0, [Ext.util.translatable, 'ScrollPosition'], 0);
Ext.cmd.derive('Ext.util.translatable.CssPosition', Ext.util.translatable.Dom, {doTranslate:function(x, y) {
  var domStyle = this.getElement().dom.style;
  if (typeof x == 'number') {
    domStyle.left = x + 'px';
  }
  if (typeof y == 'number') {
    domStyle.top = y + 'px';
  }
}, destroy:function() {
  var domStyle = this.getElement().dom.style;
  domStyle.left = null;
  domStyle.top = null;
  Ext.util.translatable.Dom.prototype.destroy.apply(this, arguments);
}}, 0, 0, 0, 0, 0, 0, [Ext.util.translatable, 'CssPosition'], 0);
Ext.cmd.derive('Ext.util.Translatable', Ext.Base, {constructor:function(config) {
  var namespace = Ext.util.translatable;
  switch(Ext.browser.getPreferredTranslationMethod(config)) {
    case 'scrollposition':
      return new namespace.ScrollPosition(config);
    case 'csstransform':
      return new namespace.CssTransform(config);
    case 'cssposition':
      return new namespace.CssPosition(config);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Translatable'], 0);
Ext.cmd.derive('Ext.behavior.Translatable', Ext.behavior.Behavior, {setConfig:function(config) {
  var translatable = this.translatable, component = this.component;
  if (config) {
    if (!translatable) {
      this.translatable = translatable = new Ext.util.Translatable(config);
      translatable.setElement(component.renderElement);
      translatable.on('destroy', 'onTranslatableDestroy', this);
    } else {
      if (Ext.isObject(config)) {
        translatable.setConfig(config);
      }
    }
  } else {
    if (translatable) {
      translatable.destroy();
    }
  }
  return this;
}, getTranslatable:function() {
  return this.translatable;
}, onTranslatableDestroy:function() {
  delete this.translatable;
}, onComponentDestroy:function() {
  var translatable = this.translatable;
  if (translatable) {
    translatable.destroy();
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.behavior, 'Translatable'], 0);
Ext.cmd.derive('Ext.util.Draggable', Ext.Base, {isDraggable:true, config:{cls:'x-draggable', draggingCls:'x-dragging', element:null, constraint:'container', disabled:null, direction:'both', initialOffset:{x:0, y:0}, translatable:{}}, DIRECTION_BOTH:'both', DIRECTION_VERTICAL:'vertical', DIRECTION_HORIZONTAL:'horizontal', defaultConstraint:{min:{x:-Infinity, y:-Infinity}, max:{x:Infinity, y:Infinity}}, containerWidth:0, containerHeight:0, width:0, height:0, constructor:function(config) {
  var element;
  this.extraConstraint = {};
  this.initialConfig = config;
  this.offset = {x:0, y:0};
  this.listeners = {dragstart:'onDragStart', drag:'onDrag', dragend:'onDragEnd', resize:'onElementResize', touchstart:'onPress', touchend:'onRelease', scope:this};
  if (config && config.element) {
    element = config.element;
    delete config.element;
    this.setElement(element);
  }
  return this;
}, applyElement:function(element) {
  if (!element) {
    return;
  }
  return Ext.get(element);
}, updateElement:function(element) {
  element.on(this.listeners);
  this.initConfig(this.initialConfig);
}, updateInitialOffset:function(initialOffset) {
  if (typeof initialOffset == 'number') {
    initialOffset = {x:initialOffset, y:initialOffset};
  }
  var offset = this.offset, x, y;
  offset.x = x = initialOffset.x;
  offset.y = y = initialOffset.y;
  this.getTranslatable().translate(x, y);
}, updateCls:function(cls) {
  this.getElement().addCls(cls);
}, applyTranslatable:function(translatable, currentInstance) {
  translatable = Ext.factory(translatable, Ext.util.Translatable, currentInstance);
  if (translatable) {
    translatable.setElement(this.getElement());
  }
  return translatable;
}, setExtraConstraint:function(constraint) {
  this.extraConstraint = constraint || {};
  this.refreshConstraint();
  return this;
}, addExtraConstraint:function(constraint) {
  Ext.merge(this.extraConstraint, constraint);
  this.refreshConstraint();
  return this;
}, applyConstraint:function(newConstraint) {
  this.currentConstraint = newConstraint;
  if (!newConstraint) {
    newConstraint = this.defaultConstraint;
  }
  if (newConstraint === 'container') {
    return Ext.merge(this.getContainerConstraint(), this.extraConstraint);
  }
  return Ext.merge({}, this.extraConstraint, newConstraint);
}, updateConstraint:function() {
  this.refreshOffset();
}, getContainerConstraint:function() {
  var container = this.getContainer(), element = this.getElement();
  if (!container || !element.dom) {
    return this.defaultConstraint;
  }
  return {min:{x:0, y:0}, max:{x:this.containerWidth - this.width, y:this.containerHeight - this.height}};
}, getContainer:function() {
  var container = this.container;
  if (!container) {
    container = this.getElement().getParent();
    if (container) {
      this.container = container;
      container.on({resize:'onContainerResize', destroy:'onContainerDestroy', scope:this});
    }
  }
  return container;
}, onElementResize:function(element, info) {
  this.width = info.width;
  this.height = info.height;
  this.refresh();
}, onContainerResize:function(container, info) {
  this.containerWidth = info.width;
  this.containerHeight = info.height;
  this.refresh();
}, onContainerDestroy:function() {
  delete this.container;
  delete this.containerSizeMonitor;
}, detachListeners:function() {
  this.getElement().un(this.listeners);
}, isAxisEnabled:function(axis) {
  var direction = this.getDirection();
  if (axis === 'x') {
    return direction === this.DIRECTION_BOTH || direction === this.DIRECTION_HORIZONTAL;
  }
  return direction === this.DIRECTION_BOTH || direction === this.DIRECTION_VERTICAL;
}, onPress:function(e) {
  this.fireAction('touchstart', [this, e]);
}, onRelease:function(e) {
  this.fireAction('touchend', [this, e]);
}, onDragStart:function(e) {
  if (this.getDisabled()) {
    return false;
  }
  var offset = this.offset;
  this.fireAction('dragstart', [this, e, offset.x, offset.y], this.initDragStart);
}, initDragStart:function(me, e, offsetX, offsetY) {
  this.dragStartOffset = {x:offsetX, y:offsetY};
  this.isDragging = true;
  this.getElement().addCls(this.getDraggingCls());
}, onDrag:function(e) {
  if (!this.isDragging) {
    return;
  }
  var startOffset = this.dragStartOffset;
  this.fireAction('drag', [this, e, startOffset.x + e.deltaX, startOffset.y + e.deltaY], this.doDrag);
}, doDrag:function(me, e, offsetX, offsetY) {
  me.setOffset(offsetX, offsetY);
}, onDragEnd:function(e) {
  if (!this.isDragging) {
    return;
  }
  this.onDrag(e);
  this.isDragging = false;
  this.getElement().removeCls(this.getDraggingCls());
  this.fireEvent('dragend', this, e, this.offset.x, this.offset.y);
}, setOffset:function(x, y, animation) {
  var currentOffset = this.offset, constraint = this.getConstraint(), minOffset = constraint.min, maxOffset = constraint.max, min = Math.min, max = Math.max;
  if (this.isAxisEnabled('x') && typeof x == 'number') {
    x = min(max(x, minOffset.x), maxOffset.x);
  } else {
    x = currentOffset.x;
  }
  if (this.isAxisEnabled('y') && typeof y == 'number') {
    y = min(max(y, minOffset.y), maxOffset.y);
  } else {
    y = currentOffset.y;
  }
  currentOffset.x = x;
  currentOffset.y = y;
  this.getTranslatable().translate(x, y, animation);
}, getOffset:function() {
  return this.offset;
}, refreshConstraint:function() {
  this.setConstraint(this.currentConstraint);
}, refreshOffset:function() {
  var offset = this.offset;
  this.setOffset(offset.x, offset.y);
}, refresh:function() {
  this.refreshConstraint();
  this.getTranslatable().refresh();
  this.refreshOffset();
}, enable:function() {
  return this.setDisabled(false);
}, disable:function() {
  return this.setDisabled(true);
}, destroy:function() {
  var translatable = this.getTranslatable();
  var element = this.getElement();
  if (element && !element.isDestroyed) {
    element.removeCls(this.getCls());
  }
  this.detachListeners();
  if (translatable) {
    translatable.destroy();
  }
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.util, 'Draggable'], function() {
});
Ext.cmd.derive('Ext.behavior.Draggable', Ext.behavior.Behavior, {setConfig:function(config) {
  var draggable = this.draggable, component = this.component;
  if (config) {
    if (!draggable) {
      component.setTranslatable(config.translatable);
      this.draggable = draggable = new Ext.util.Draggable(config);
      draggable.setTranslatable(component.getTranslatable());
      draggable.setElement(component.renderElement);
      draggable.on('destroy', 'onDraggableDestroy', this);
      component.on(this.listeners);
    } else {
      if (Ext.isObject(config)) {
        draggable.setConfig(config);
      }
    }
  } else {
    if (draggable) {
      draggable.destroy();
    }
  }
  return this;
}, getDraggable:function() {
  return this.draggable;
}, onDraggableDestroy:function() {
  delete this.draggable;
}, onComponentDestroy:function() {
  var draggable = this.draggable;
  if (draggable) {
    draggable.destroy();
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.behavior, 'Draggable'], 0);
(function(clsPrefix) {
  Ext.cmd.derive('Ext.Component', Ext.AbstractComponent, {alternateClassName:'Ext.lib.Component', observableType:'component', cachedConfig:{baseCls:null, cls:null, floatingCls:clsPrefix + 'floating', hiddenCls:clsPrefix + 'item-hidden', ui:null, margin:null, padding:null, border:null, styleHtmlCls:clsPrefix + 'html', styleHtmlContent:null}, eventedConfig:{flex:null, left:null, top:null, right:null, bottom:null, width:null, height:null, minWidth:null, minHeight:null, maxWidth:null, maxHeight:null, 
  docked:null, centered:null, hidden:null, disabled:null}, config:{style:null, html:null, draggable:null, translatable:null, renderTo:null, zIndex:null, tpl:null, enterAnimation:null, exitAnimation:null, showAnimation:null, hideAnimation:null, tplWriteMode:'overwrite', data:null, disabledCls:clsPrefix + 'item-disabled', contentEl:null, itemId:undefined, record:null, plugins:null}, listenerOptionsRegex:/^(?:delegate|single|delay|buffer|args|prepend|element)$/, alignmentRegex:/^([a-z]+)-([a-z]+)(\?)?$/, 
  isComponent:true, floating:false, rendered:false, isInner:true, activeAnimation:null, dockPositions:{top:true, right:true, bottom:true, left:true}, innerElement:null, element:null, template:[], widthLayoutSized:false, heightLayoutSized:false, layoutStretched:false, sizeState:false, sizeFlags:0, LAYOUT_WIDTH:1, LAYOUT_HEIGHT:2, LAYOUT_BOTH:3, LAYOUT_STRETCHED:4, constructor:function(config) {
    var me = this, currentConfig = me.config, id;
    me.onInitializedListeners = [];
    me.initialConfig = config;
    if (config !== undefined && 'id' in config) {
      id = config.id;
    } else {
      if ('id' in currentConfig) {
        id = currentConfig.id;
      } else {
        id = me.getId();
      }
    }
    me.id = id;
    me.setId(id);
    Ext.ComponentManager.register(me);
    me.initElement();
    me.initConfig(me.initialConfig);
    me.refreshSizeState = me.doRefreshSizeState;
    me.refreshFloating = me.doRefreshFloating;
    if (me.refreshSizeStateOnInitialized) {
      me.refreshSizeState();
    }
    if (me.refreshFloatingOnInitialized) {
      me.refreshFloating();
    }
    me.initialize();
    me.triggerInitialized();
    if (me.config.fullscreen) {
      me.fireEvent('fullscreen', me);
    }
    me.fireEvent('initialize', me);
  }, beforeInitConfig:function(config) {
    this.beforeInitialize.apply(this, arguments);
  }, beforeInitialize:Ext.emptyFn, initialize:Ext.emptyFn, getTemplate:function() {
    return this.template;
  }, getElementConfig:function() {
    return {reference:'element', classList:['x-unsized'], children:this.getTemplate()};
  }, triggerInitialized:function() {
    var listeners = this.onInitializedListeners, ln = listeners.length, listener, fn, scope, args, i;
    if (!this.initialized) {
      this.initialized = true;
      if (ln > 0) {
        for (i = 0; i < ln; i++) {
          listener = listeners[i];
          fn = listener.fn;
          scope = listener.scope;
          args = listener.args;
          if (typeof fn == 'string') {
            scope[fn].apply(scope, args);
          } else {
            fn.apply(scope, args);
          }
        }
        listeners.length = 0;
      }
    }
  }, onInitialized:function(fn, scope, args) {
    var listeners = this.onInitializedListeners;
    if (!scope) {
      scope = this;
    }
    if (this.initialized) {
      if (typeof fn == 'string') {
        scope[fn].apply(scope, args);
      } else {
        fn.apply(scope, args);
      }
    } else {
      listeners.push({fn:fn, scope:scope, args:args});
    }
  }, renderTo:function(container, insertBeforeElement) {
    var dom = this.renderElement.dom, containerDom = Ext.getDom(container), insertBeforeChildDom = Ext.getDom(insertBeforeElement);
    if (containerDom) {
      if (insertBeforeChildDom) {
        containerDom.insertBefore(dom, insertBeforeChildDom);
      } else {
        containerDom.appendChild(dom);
      }
      this.setRendered(Boolean(dom.offsetParent));
    }
  }, setParent:function(parent) {
    var currentParent = this.parent;
    if (parent && currentParent && currentParent !== parent) {
      currentParent.remove(this, false);
    }
    this.parent = parent;
    return this;
  }, applyPlugins:function(config) {
    var ln, i, configObj;
    if (!config) {
      return config;
    }
    config = [].concat(config);
    for (i = 0, ln = config.length; i < ln; i++) {
      configObj = config[i];
      config[i] = Ext.factory(configObj, 'Ext.plugin.Plugin', null, 'plugin');
    }
    return config;
  }, updatePlugins:function(newPlugins, oldPlugins) {
    var ln, i;
    if (newPlugins) {
      for (i = 0, ln = newPlugins.length; i < ln; i++) {
        newPlugins[i].init(this);
      }
    }
    if (oldPlugins) {
      for (i = 0, ln = oldPlugins.length; i < ln; i++) {
        Ext.destroy(oldPlugins[i]);
      }
    }
  }, updateRenderTo:function(newContainer) {
    this.renderTo(newContainer);
  }, updateStyle:function(style) {
    this.element.applyStyles(style);
  }, updateBorder:function(border) {
    this.element.setBorder(border);
  }, updatePadding:function(padding) {
    this.innerElement.setPadding(padding);
  }, updateMargin:function(margin) {
    this.element.setMargin(margin);
  }, updateUi:function(newUi, oldUi) {
    var baseCls = this.getBaseCls(), element = this.element, currentUi = this.currentUi;
    if (baseCls) {
      if (oldUi) {
        if (currentUi) {
          element.removeCls(currentUi);
        } else {
          element.removeCls(baseCls + '-' + oldUi);
        }
      }
      if (newUi) {
        element.addCls(newUi, baseCls);
        this.currentUi = baseCls + '-' + newUi;
        if (!this.self.prototype.currentUi) {
          this.self.prototype.currentUi = this.currentUi;
        }
      }
    }
  }, applyBaseCls:function(baseCls) {
    return baseCls || clsPrefix + this.xtype;
  }, updateBaseCls:function(newBaseCls, oldBaseCls) {
    var me = this, ui = me.getUi();
    if (oldBaseCls) {
      this.element.removeCls(oldBaseCls);
      if (ui) {
        this.element.removeCls(this.currentUi);
      }
    }
    if (newBaseCls) {
      this.element.addCls(newBaseCls);
      if (ui) {
        this.element.addCls(newBaseCls, null, ui);
        this.currentUi = newBaseCls + '-' + ui;
      }
    }
  }, addCls:function(cls, prefix, suffix) {
    var oldCls = this.getCls(), newCls = oldCls ? oldCls.slice() : [], ln, i, cachedCls;
    prefix = prefix || '';
    suffix = suffix || '';
    if (typeof cls == 'string') {
      cls = [cls];
    }
    ln = cls.length;
    if (!newCls.length && prefix === '' && suffix === '') {
      newCls = cls;
    } else {
      for (i = 0; i < ln; i++) {
        cachedCls = prefix + cls[i] + suffix;
        if (newCls.indexOf(cachedCls) == -1) {
          newCls.push(cachedCls);
        }
      }
    }
    this.setCls(newCls);
  }, removeCls:function(cls, prefix, suffix) {
    var oldCls = this.getCls(), newCls = oldCls ? oldCls.slice() : [], ln, i;
    prefix = prefix || '';
    suffix = suffix || '';
    if (typeof cls == 'string') {
      newCls = Ext.Array.remove(newCls, prefix + cls + suffix);
    } else {
      ln = cls.length;
      for (i = 0; i < ln; i++) {
        newCls = Ext.Array.remove(newCls, prefix + cls[i] + suffix);
      }
    }
    this.setCls(newCls);
  }, replaceCls:function(oldCls, newCls, prefix, suffix) {
    var cls = this.getCls(), array = cls ? cls.slice() : [], ln, i, cachedCls;
    prefix = prefix || '';
    suffix = suffix || '';
    if (typeof oldCls == 'string') {
      array = Ext.Array.remove(array, prefix + oldCls + suffix);
    } else {
      if (oldCls) {
        ln = oldCls.length;
        for (i = 0; i < ln; i++) {
          array = Ext.Array.remove(array, prefix + oldCls[i] + suffix);
        }
      }
    }
    if (typeof newCls == 'string') {
      array.push(prefix + newCls + suffix);
    } else {
      if (newCls) {
        ln = newCls.length;
        if (!array.length && prefix === '' && suffix === '') {
          array = newCls;
        } else {
          for (i = 0; i < ln; i++) {
            cachedCls = prefix + newCls[i] + suffix;
            if (array.indexOf(cachedCls) == -1) {
              array.push(cachedCls);
            }
          }
        }
      }
    }
    this.setCls(array);
  }, toggleCls:function(className, force) {
    var oldCls = this.getCls(), newCls = oldCls ? oldCls.slice() : [];
    if (force || newCls.indexOf(className) == -1) {
      newCls.push(className);
    } else {
      Ext.Array.remove(newCls, className);
    }
    this.setCls(newCls);
    return this;
  }, applyCls:function(cls) {
    if (typeof cls == 'string') {
      cls = [cls];
    }
    if (!cls || !cls.length) {
      cls = null;
    }
    return cls;
  }, updateCls:function(newCls, oldCls) {
    if (this.element && (newCls && !oldCls || !newCls && oldCls || newCls.length != oldCls.length || Ext.Array.difference(newCls, oldCls).length > 0)) {
      this.element.replaceCls(oldCls, newCls);
    }
  }, updateStyleHtmlCls:function(newHtmlCls, oldHtmlCls) {
    var innerHtmlElement = this.innerHtmlElement, innerElement = this.innerElement;
    if (this.getStyleHtmlContent() && oldHtmlCls) {
      if (innerHtmlElement) {
        innerHtmlElement.replaceCls(oldHtmlCls, newHtmlCls);
      } else {
        innerElement.replaceCls(oldHtmlCls, newHtmlCls);
      }
    }
  }, applyStyleHtmlContent:function(config) {
    return Boolean(config);
  }, updateStyleHtmlContent:function(styleHtmlContent) {
    var htmlCls = this.getStyleHtmlCls(), innerElement = this.innerElement, innerHtmlElement = this.innerHtmlElement;
    if (styleHtmlContent) {
      if (innerHtmlElement) {
        innerHtmlElement.addCls(htmlCls);
      } else {
        innerElement.addCls(htmlCls);
      }
    } else {
      if (innerHtmlElement) {
        innerHtmlElement.removeCls(htmlCls);
      } else {
        innerElement.addCls(htmlCls);
      }
    }
  }, applyContentEl:function(contentEl) {
    if (contentEl) {
      return Ext.get(contentEl);
    }
  }, updateContentEl:function(newContentEl, oldContentEl) {
    if (oldContentEl) {
      oldContentEl.hide();
      Ext.getBody().append(oldContentEl);
    }
    if (newContentEl) {
      this.setHtml(newContentEl.dom);
      newContentEl.show();
    }
  }, getSize:function() {
    return {width:this.getWidth(), height:this.getHeight()};
  }, isCentered:function() {
    return Boolean(this.getCentered());
  }, isFloating:function() {
    return this.floating;
  }, isDocked:function() {
    return Boolean(this.getDocked());
  }, isInnerItem:function() {
    return this.isInner;
  }, setIsInner:function(isInner) {
    if (isInner !== this.isInner) {
      this.isInner = isInner;
      if (this.initialized) {
        this.fireEvent('innerstatechange', this, isInner);
      }
    }
  }, filterLengthValue:function(value) {
    if (value === 'auto' || !value && value !== 0) {
      return null;
    }
    return value;
  }, applyTop:function(top) {
    return this.filterLengthValue(top);
  }, applyRight:function(right) {
    return this.filterLengthValue(right);
  }, applyBottom:function(bottom) {
    return this.filterLengthValue(bottom);
  }, applyLeft:function(left) {
    return this.filterLengthValue(left);
  }, applyWidth:function(width) {
    return this.filterLengthValue(width);
  }, applyHeight:function(height) {
    return this.filterLengthValue(height);
  }, applyMinWidth:function(width) {
    return this.filterLengthValue(width);
  }, applyMinHeight:function(height) {
    return this.filterLengthValue(height);
  }, applyMaxWidth:function(width) {
    return this.filterLengthValue(width);
  }, applyMaxHeight:function(height) {
    return this.filterLengthValue(height);
  }, doSetTop:function(top) {
    this.element.setTop(top);
    this.refreshFloating();
  }, doSetRight:function(right) {
    this.element.setRight(right);
    this.refreshFloating();
  }, doSetBottom:function(bottom) {
    this.element.setBottom(bottom);
    this.refreshFloating();
  }, doSetLeft:function(left) {
    this.element.setLeft(left);
    this.refreshFloating();
  }, doSetWidth:function(width) {
    this.element.setWidth(width);
    this.refreshSizeState();
  }, doSetHeight:function(height) {
    this.element.setHeight(height);
    this.refreshSizeState();
  }, applyFlex:function(flex) {
    if (flex) {
      flex = Number(flex);
      if (isNaN(flex)) {
        flex = null;
      }
    } else {
      flex = null;
    }
    return flex;
  }, doSetFlex:Ext.emptyFn, refreshSizeState:function() {
    this.refreshSizeStateOnInitialized = true;
  }, doRefreshSizeState:function() {
    var hasWidth = this.getWidth() !== null || this.widthLayoutSized || this.getLeft() !== null && this.getRight() !== null, hasHeight = this.getHeight() !== null || this.heightLayoutSized || this.getTop() !== null && this.getBottom() !== null, stretched = this.layoutStretched || this.hasCSSMinHeight || !hasHeight && this.getMinHeight() !== null, state = hasWidth && hasHeight, flags = (hasWidth && this.LAYOUT_WIDTH) | (hasHeight && this.LAYOUT_HEIGHT) | (stretched && this.LAYOUT_STRETCHED);
    if (!state && stretched) {
      state = null;
    }
    this.setSizeState(state);
    this.setSizeFlags(flags);
  }, setLayoutSizeFlags:function(flags) {
    this.layoutStretched = !!(flags & this.LAYOUT_STRETCHED);
    this.widthLayoutSized = !!(flags & this.LAYOUT_WIDTH);
    this.heightLayoutSized = !!(flags & this.LAYOUT_HEIGHT);
    this.refreshSizeState();
  }, setSizeFlags:function(flags) {
    if (flags !== this.sizeFlags) {
      this.sizeFlags = flags;
      var hasWidth = !!(flags & this.LAYOUT_WIDTH), hasHeight = !!(flags & this.LAYOUT_HEIGHT), stretched = !!(flags & this.LAYOUT_STRETCHED);
      if (hasWidth && !stretched && !hasHeight) {
        this.element.addCls('x-has-width');
      } else {
        this.element.removeCls('x-has-width');
      }
      if (hasHeight && !stretched && !hasWidth) {
        this.element.addCls('x-has-height');
      } else {
        this.element.removeCls('x-has-height');
      }
      if (this.initialized) {
        this.fireEvent('sizeflagschange', this, flags);
      }
    }
  }, getSizeFlags:function() {
    if (!this.initialized) {
      this.doRefreshSizeState();
    }
    return this.sizeFlags;
  }, setSizeState:function(state) {
    if (state !== this.sizeState) {
      this.sizeState = state;
      this.element.setSizeState(state);
      if (this.initialized) {
        this.fireEvent('sizestatechange', this, state);
      }
    }
  }, getSizeState:function() {
    if (!this.initialized) {
      this.doRefreshSizeState();
    }
    return this.sizeState;
  }, doSetMinWidth:function(width) {
    this.element.setMinWidth(width);
  }, doSetMinHeight:function(height) {
    this.element.setMinHeight(height);
    this.refreshSizeState();
  }, doSetMaxWidth:function(width) {
    this.element.setMaxWidth(width);
  }, doSetMaxHeight:function(height) {
    this.element.setMaxHeight(height);
  }, applyCentered:function(centered) {
    centered = Boolean(centered);
    if (centered) {
      this.refreshInnerState = Ext.emptyFn;
      if (this.isFloating()) {
        this.resetFloating();
      }
      if (this.isDocked()) {
        this.setDocked(false);
      }
      this.setIsInner(false);
      delete this.refreshInnerState;
    }
    return centered;
  }, doSetCentered:function(centered) {
    this.toggleCls(this.getFloatingCls(), centered);
    if (!centered) {
      this.refreshInnerState();
    }
  }, applyDocked:function(docked) {
    if (!docked) {
      return null;
    }
    this.refreshInnerState = Ext.emptyFn;
    if (this.isFloating()) {
      this.resetFloating();
    }
    if (this.isCentered()) {
      this.setCentered(false);
    }
    this.setIsInner(false);
    delete this.refreshInnerState;
    return docked;
  }, doSetDocked:function(docked, oldDocked) {
    this.fireEvent('afterdockedchange', this, docked, oldDocked);
    if (!docked) {
      this.refreshInnerState();
    }
  }, resetFloating:function() {
    this.setTop(null);
    this.setRight(null);
    this.setBottom(null);
    this.setLeft(null);
  }, refreshInnerState:function() {
    this.setIsInner(!this.isCentered() && !this.isFloating() && !this.isDocked());
  }, refreshFloating:function() {
    this.refreshFloatingOnInitialized = true;
  }, doRefreshFloating:function() {
    var floating = true, floatingCls = this.getFloatingCls();
    if (this.getTop() === null && this.getBottom() === null && this.getRight() === null && this.getLeft() === null) {
      floating = false;
    } else {
      this.refreshSizeState();
    }
    if (floating !== this.floating) {
      this.floating = floating;
      if (floating) {
        this.refreshInnerState = Ext.emptyFn;
        if (this.isCentered()) {
          this.setCentered(false);
        }
        if (this.isDocked()) {
          this.setDocked(false);
        }
        this.setIsInner(false);
        delete this.refreshInnerState;
      }
      this.element.toggleCls(floatingCls, floating);
      if (this.initialized) {
        this.fireEvent('floatingchange', this, floating);
      }
      if (!floating) {
        this.refreshInnerState();
      }
    }
  }, updateFloatingCls:function(newFloatingCls, oldFloatingCls) {
    if (this.isFloating()) {
      this.replaceCls(oldFloatingCls, newFloatingCls);
    }
  }, applyDisabled:function(disabled) {
    return Boolean(disabled);
  }, doSetDisabled:function(disabled) {
    this.element[disabled ? 'addCls' : 'removeCls'](this.getDisabledCls());
  }, updateDisabledCls:function(newDisabledCls, oldDisabledCls) {
    if (this.isDisabled()) {
      this.element.replaceCls(oldDisabledCls, newDisabledCls);
    }
  }, disable:function() {
    this.setDisabled(true);
  }, enable:function() {
    this.setDisabled(false);
  }, isDisabled:function() {
    return this.getDisabled();
  }, applyZIndex:function(zIndex) {
    if (!zIndex && zIndex !== 0) {
      zIndex = null;
    }
    if (zIndex !== null) {
      zIndex = Number(zIndex);
      if (isNaN(zIndex)) {
        zIndex = null;
      }
    }
    return zIndex;
  }, updateZIndex:function(zIndex) {
    var element = this.element, domStyle;
    if (element && !element.isDestroyed) {
      domStyle = element.dom.style;
      if (zIndex !== null) {
        domStyle.setProperty('z-index', zIndex, 'important');
      } else {
        domStyle.removeProperty('z-index');
      }
    }
  }, getInnerHtmlElement:function() {
    var innerHtmlElement = this.innerHtmlElement, styleHtmlCls;
    if (!innerHtmlElement || !innerHtmlElement.dom || !innerHtmlElement.dom.parentNode) {
      this.innerHtmlElement = innerHtmlElement = Ext.Element.create({cls:'x-innerhtml'});
      if (this.getStyleHtmlContent()) {
        styleHtmlCls = this.getStyleHtmlCls();
        this.innerHtmlElement.addCls(styleHtmlCls);
        this.innerElement.removeCls(styleHtmlCls);
      }
      this.innerElement.appendChild(innerHtmlElement);
    }
    return innerHtmlElement;
  }, updateHtml:function(html) {
    if (!this.isDestroyed) {
      var innerHtmlElement = this.getInnerHtmlElement();
      if (Ext.isElement(html)) {
        innerHtmlElement.setHtml('');
        innerHtmlElement.append(html);
      } else {
        innerHtmlElement.setHtml(html);
      }
    }
  }, applyHidden:function(hidden) {
    return Boolean(hidden);
  }, doSetHidden:function(hidden) {
    var element = this.renderElement;
    if (element.isDestroyed) {
      return;
    }
    if (hidden) {
      element.hide();
    } else {
      element.show();
    }
    if (this.element) {
      this.element[hidden ? 'addCls' : 'removeCls'](this.getHiddenCls());
    }
    this.fireEvent(hidden ? 'hide' : 'show', this);
  }, updateHiddenCls:function(newHiddenCls, oldHiddenCls) {
    if (this.isHidden()) {
      this.element.replaceCls(oldHiddenCls, newHiddenCls);
    }
  }, isHidden:function() {
    return this.getHidden();
  }, hide:function(animation) {
    this.setCurrentAlignmentInfo(null);
    if (this.activeAnimation) {
      this.activeAnimation.on({animationend:function() {
        this.hide(animation);
      }, scope:this, single:true});
      return this;
    }
    if (!this.getHidden()) {
      if (animation === undefined || animation && animation.isComponent) {
        animation = this.getHideAnimation();
      }
      if (animation) {
        if (animation === true) {
          animation = 'fadeOut';
        }
        this.onBefore({hiddenchange:'animateFn', scope:this, single:true, args:[animation]});
      }
      this.setHidden(true);
    }
    return this;
  }, show:function(animation) {
    if (this.activeAnimation) {
      this.activeAnimation.on({animationend:function() {
        this.show(animation);
      }, scope:this, single:true});
      return this;
    }
    var hidden = this.getHidden();
    if (hidden || hidden === null) {
      if (animation === true) {
        animation = 'fadeIn';
      } else {
        if (animation === undefined || animation && animation.isComponent) {
          animation = this.getShowAnimation();
        }
      }
      if (animation) {
        this.beforeShowAnimation();
        this.onBefore({hiddenchange:'animateFn', scope:this, single:true, args:[animation]});
      }
      this.setHidden(false);
    }
    return this;
  }, beforeShowAnimation:function() {
    if (this.element) {
      this.renderElement.show();
      this.element.removeCls(this.getHiddenCls());
    }
  }, animateFn:function(animation, component, newState, oldState, options, controller) {
    var me = this;
    if (animation && (!newState || newState && this.isPainted())) {
      this.activeAnimation = new Ext.fx.Animation(animation);
      this.activeAnimation.setElement(component.element);
      if (!Ext.isEmpty(newState)) {
        this.activeAnimation.setOnEnd(function() {
          me.activeAnimation = null;
          controller.resume();
        });
        controller.pause();
      }
      Ext.Animator.run(me.activeAnimation);
    }
  }, setVisibility:function(isVisible) {
    this.renderElement.setVisibility(isVisible);
  }, isRendered:function() {
    return this.rendered;
  }, isPainted:function() {
    return this.renderElement.isPainted();
  }, applyTpl:function(config) {
    return Ext.isObject(config) && config.isTemplate ? config : new Ext.XTemplate(config);
  }, applyData:function(data) {
    if (Ext.isObject(data)) {
      return Ext.apply({}, data);
    } else {
      if (!data) {
        data = {};
      }
    }
    return data;
  }, updateData:function(newData) {
    var me = this;
    if (newData) {
      var tpl = me.getTpl(), tplWriteMode = me.getTplWriteMode();
      if (tpl) {
        tpl[tplWriteMode](me.getInnerHtmlElement(), newData);
      }
      this.fireEvent('updatedata', me, newData);
    }
  }, applyRecord:function(config) {
    if (config && Ext.isObject(config) && config.isModel) {
      return config;
    }
    return null;
  }, updateRecord:function(newRecord, oldRecord) {
    var me = this;
    if (oldRecord) {
      oldRecord.unjoin(me);
    }
    if (!newRecord) {
      me.updateData('');
    } else {
      newRecord.join(me);
      me.updateData(newRecord.getData(true));
    }
  }, afterEdit:function() {
    this.updateRecord(this.getRecord());
  }, afterErase:function() {
    this.setRecord(null);
  }, applyItemId:function(itemId) {
    return itemId || this.getId();
  }, isXType:function(xtype, shallow) {
    if (shallow) {
      return this.xtypes.indexOf(xtype) != -1;
    }
    return Boolean(this.xtypesMap[xtype]);
  }, getXTypes:function() {
    return this.xtypesChain.join('/');
  }, getDraggableBehavior:function() {
    var behavior = this.draggableBehavior;
    if (!behavior) {
      behavior = this.draggableBehavior = new Ext.behavior.Draggable(this);
    }
    return behavior;
  }, applyDraggable:function(config) {
    this.getDraggableBehavior().setConfig(config);
  }, getDraggable:function() {
    return this.getDraggableBehavior().getDraggable();
  }, getTranslatableBehavior:function() {
    var behavior = this.translatableBehavior;
    if (!behavior) {
      behavior = this.translatableBehavior = new Ext.behavior.Translatable(this);
    }
    return behavior;
  }, applyTranslatable:function(config) {
    this.getTranslatableBehavior().setConfig(config);
  }, getTranslatable:function() {
    return this.getTranslatableBehavior().getTranslatable();
  }, translateAxis:function(axis, value, animation) {
    var x, y;
    if (axis === 'x') {
      x = value;
    } else {
      y = value;
    }
    return this.translate(x, y, animation);
  }, translate:function() {
    var translatable = this.getTranslatable();
    if (!translatable) {
      this.setTranslatable(true);
      translatable = this.getTranslatable();
    }
    translatable.translate.apply(translatable, arguments);
  }, setRendered:function(rendered) {
    var wasRendered = this.rendered;
    if (rendered !== wasRendered) {
      this.rendered = rendered;
      return true;
    }
    return false;
  }, setSize:function(width, height) {
    if (width != undefined) {
      this.setWidth(width);
    }
    if (height != undefined) {
      this.setHeight(height);
    }
  }, doAddListener:function(name, fn, scope, options, order) {
    if (options && 'element' in options) {
      return this[options.element].doAddListener(name, fn, scope || this, options, order);
    }
    if (name == 'painted' || name == 'resize') {
      return this.element.doAddListener(name, fn, scope || this, options, order);
    }
    return Ext.AbstractComponent.prototype.doAddListener.apply(this, arguments);
  }, doRemoveListener:function(name, fn, scope, options, order) {
    if (options && 'element' in options) {
      this[options.element].doRemoveListener(name, fn, scope || this, options, order);
    }
    return Ext.AbstractComponent.prototype.doRemoveListener.apply(this, arguments);
  }, showBy:function(component, alignment) {
    var me = this, viewport = Ext.Viewport, parent = me.getParent();
    me.setVisibility(false);
    if (parent !== viewport) {
      viewport.add(me);
    }
    me.show();
    me.on({hide:'onShowByErased', destroy:'onShowByErased', single:true, scope:me});
    viewport.on('resize', 'alignTo', me, {args:[component, alignment]});
    me.alignTo(component, alignment);
    me.setVisibility(true);
  }, onShowByErased:function() {
    Ext.Viewport.un('resize', 'alignTo', this);
  }, getAlignmentInfo:function(component, alignment) {
    var alignToElement = component.isComponent ? component.renderElement : component, alignToBox = alignToElement.getPageBox(), element = this.renderElement, box = element.getPageBox(), stats = {alignToBox:alignToBox, alignment:alignment, top:alignToBox.top, left:alignToBox.left, alignToWidth:alignToBox.width, alignToHeight:alignToBox.height, width:box.width, height:box.height}, currentAlignmentInfo = this.getCurrentAlignmentInfo(), isAligned = true;
    if (!Ext.isEmpty(currentAlignmentInfo)) {
      Ext.Object.each(stats, function(key, value) {
        if (!Ext.isObject(value) && currentAlignmentInfo[key] != value) {
          isAligned = false;
          return false;
        }
        return true;
      });
    } else {
      isAligned = false;
    }
    return {isAligned:isAligned, stats:stats};
  }, getCurrentAlignmentInfo:function() {
    return this.$currentAlignmentInfo;
  }, setCurrentAlignmentInfo:function(alignmentInfo) {
    this.$currentAlignmentInfo = Ext.isEmpty(alignmentInfo) ? null : Ext.merge({}, alignmentInfo.stats ? alignmentInfo.stats : alignmentInfo);
  }, alignTo:function(component, alignment) {
    var alignmentInfo = this.getAlignmentInfo(component, alignment);
    if (alignmentInfo.isAligned) {
      return;
    }
    var alignToBox = alignmentInfo.stats.alignToBox, constrainBox = this.getParent().element.getPageBox(), alignToHeight = alignmentInfo.stats.alignToHeight, alignToWidth = alignmentInfo.stats.alignToWidth, height = alignmentInfo.stats.height, width = alignmentInfo.stats.width;
    constrainBox.bottom -= 5;
    constrainBox.height -= 10;
    constrainBox.left += 5;
    constrainBox.right -= 5;
    constrainBox.top += 5;
    constrainBox.width -= 10;
    if (!alignment || alignment === 'auto') {
      if (constrainBox.bottom - alignToBox.bottom < height) {
        if (alignToBox.top - constrainBox.top < height) {
          if (alignToBox.left - constrainBox.left < width) {
            alignment = 'cl-cr?';
          } else {
            alignment = 'cr-cl?';
          }
        } else {
          alignment = 'bc-tc?';
        }
      } else {
        alignment = 'tc-bc?';
      }
    }
    var matches = alignment.match(this.alignmentRegex);
    var from = matches[1].split(''), to = matches[2].split(''), constrained = matches[3] === '?', fromVertical = from[0], fromHorizontal = from[1] || fromVertical, toVertical = to[0], toHorizontal = to[1] || toVertical, top = alignToBox.top, left = alignToBox.left, halfAlignHeight = alignToHeight / 2, halfAlignWidth = alignToWidth / 2, halfWidth = width / 2, halfHeight = height / 2, maxLeft, maxTop;
    switch(fromVertical) {
      case 't':
        switch(toVertical) {
          case 'c':
            top += halfAlignHeight;
            break;
          case 'b':
            top += alignToHeight;
        }break;
      case 'b':
        switch(toVertical) {
          case 'c':
            top -= height - halfAlignHeight;
            break;
          case 't':
            top -= height;
            break;
          case 'b':
            top -= height - alignToHeight;
        }break;
      case 'c':
        switch(toVertical) {
          case 't':
            top -= halfHeight;
            break;
          case 'c':
            top -= halfHeight - halfAlignHeight;
            break;
          case 'b':
            top -= halfHeight - alignToHeight;
        }break;
    }
    switch(fromHorizontal) {
      case 'l':
        switch(toHorizontal) {
          case 'c':
            left += halfAlignHeight;
            break;
          case 'r':
            left += alignToWidth;
        }break;
      case 'r':
        switch(toHorizontal) {
          case 'r':
            left -= width - alignToWidth;
            break;
          case 'c':
            left -= width - halfWidth;
            break;
          case 'l':
            left -= width;
        }break;
      case 'c':
        switch(toHorizontal) {
          case 'l':
            left -= halfWidth;
            break;
          case 'c':
            left -= halfWidth - halfAlignWidth;
            break;
          case 'r':
            left -= halfWidth - alignToWidth;
        }break;
    }
    if (constrained) {
      maxLeft = constrainBox.left + constrainBox.width - width;
      maxTop = constrainBox.top + constrainBox.height - height;
      left = Math.max(constrainBox.left, Math.min(maxLeft, left));
      top = Math.max(constrainBox.top, Math.min(maxTop, top));
    }
    this.setLeft(left);
    this.setTop(top);
    this.setCurrentAlignmentInfo(alignmentInfo);
  }, up:function(selector) {
    var result = this.parent;
    if (selector) {
      for (; result; result = result.parent) {
        if (Ext.ComponentQuery.is(result, selector)) {
          return result;
        }
      }
    }
    return result;
  }, getBubbleTarget:function() {
    return this.getParent();
  }, destroy:function() {
    this.destroy = Ext.emptyFn;
    var parent = this.getParent(), referenceList = this.referenceList, i, ln, reference;
    this.isDestroying = true;
    Ext.destroy(this.getTranslatable(), this.getPlugins());
    if (parent) {
      parent.remove(this, false);
    }
    for (i = 0, ln = referenceList.length; i < ln; i++) {
      reference = referenceList[i];
      this[reference].destroy();
      delete this[reference];
    }
    Ext.destroy(this.innerHtmlElement);
    this.setRecord(null);
    Ext.AbstractComponent.prototype.destroy.call(this);
    Ext.ComponentManager.unregister(this);
  }}, 1, ['component'], ['component'], {'component':true}, ['widget.component'], [[Ext.mixin.Traversable.prototype.mixinId || Ext.mixin.Traversable.$className, Ext.mixin.Traversable]], [Ext, 'Component', Ext.lib, 'Component'], function() {
  });
})('x-');
Ext.cmd.derive('Ext.layout.Abstract', Ext.Base, {isLayout:true, constructor:function(config) {
  this.initialConfig = config;
}, setContainer:function(container) {
  this.container = container;
  this.initConfig(this.initialConfig);
  return this;
}, onItemAdd:function() {
}, onItemRemove:function() {
}, onItemMove:function() {
}, onItemCenteredChange:function() {
}, onItemFloatingChange:function() {
}, onItemDockedChange:function() {
}, onItemInnerStateChange:function() {
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.layout, 'Abstract'], 0);
Ext.cmd.derive('Ext.mixin.Bindable', Ext.mixin.Mixin, {mixinConfig:{id:'bindable'}, bind:function(instance, boundMethod, bindingMethod, preventDefault, extraArgs) {
  if (!bindingMethod) {
    bindingMethod = boundMethod;
  }
  var boundFn = instance[boundMethod], fn, binding;
  if (boundFn && boundFn.hasOwnProperty('$binding')) {
    binding = boundFn.$binding;
    if (binding.bindingMethod === bindingMethod && binding.bindingScope === this) {
      return this;
    }
  }
  instance[boundMethod] = fn = function() {
    var binding = fn.$binding, scope = binding.bindingScope, args = Array.prototype.slice.call(arguments);
    args.push(arguments);
    if (extraArgs) {
      args.push.apply(args, extraArgs);
    }
    if (!binding.preventDefault && scope[binding.bindingMethod].apply(scope, args) !== false) {
      return binding.boundFn.apply(this, arguments);
    }
  };
  fn.$binding = {preventDefault:!!preventDefault, boundFn:boundFn, bindingMethod:bindingMethod, bindingScope:this};
  return this;
}, unbind:function(instance, boundMethod, bindingMethod) {
  if (!bindingMethod) {
    bindingMethod = boundMethod;
  }
  var fn = instance[boundMethod], binding = fn.$binding, boundFn, currentBinding;
  while (binding) {
    boundFn = binding.boundFn;
    if (binding.bindingMethod === bindingMethod && binding.bindingScope === this) {
      if (currentBinding) {
        currentBinding.boundFn = boundFn;
      } else {
        instance[boundMethod] = boundFn;
      }
      return this;
    }
    currentBinding = binding;
    binding = boundFn.$binding;
  }
  return this;
}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Bindable'], 0);
Ext.cmd.derive('Ext.util.Wrapper', Ext.Base, {constructor:function(elementConfig, wrappedElement) {
  var element = this.link('element', Ext.Element.create(elementConfig));
  if (wrappedElement) {
    element.insertBefore(wrappedElement);
    this.wrap(wrappedElement);
  }
}, bindSize:function(sizeName) {
  var wrappedElement = this.wrappedElement, boundMethodName;
  this.boundSizeName = sizeName;
  this.boundMethodName = boundMethodName = sizeName === 'width' ? 'setWidth' : 'setHeight';
  this.bind(wrappedElement, boundMethodName, 'onBoundSizeChange');
  wrappedElement[boundMethodName].call(wrappedElement, wrappedElement.getStyleValue(sizeName));
}, onBoundSizeChange:function(size, args) {
  var element = this.element;
  if (typeof size === 'string' && size.substr(-1) === '%') {
    args[0] = '100%';
  } else {
    size = '';
  }
  element[this.boundMethodName].call(element, size);
}, wrap:function(wrappedElement) {
  var element = this.element, innerDom;
  this.wrappedElement = wrappedElement;
  innerDom = element.dom;
  while (innerDom.firstElementChild !== null) {
    innerDom = innerDom.firstElementChild;
  }
  innerDom.appendChild(wrappedElement.dom);
}, destroy:function() {
  var element = this.element, dom = element.dom, wrappedElement = this.wrappedElement, boundMethodName = this.boundMethodName, parentNode = dom.parentNode, size;
  if (boundMethodName) {
    this.unbind(wrappedElement, boundMethodName, 'onBoundSizeChange');
    size = element.getStyle(this.boundSizeName);
    if (size) {
      wrappedElement[boundMethodName].call(wrappedElement, size);
    }
  }
  if (parentNode) {
    if (!wrappedElement.isDestroyed) {
      parentNode.replaceChild(dom.firstElementChild, dom);
    }
    delete this.wrappedElement;
  }
  this.callSuper();
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Bindable.prototype.mixinId || Ext.mixin.Bindable.$className, Ext.mixin.Bindable]], [Ext.util, 'Wrapper'], 0);
Ext.cmd.derive('Ext.layout.wrapper.BoxDock', Ext.Base, {config:{direction:'horizontal', element:{className:'x-dock'}, bodyElement:{className:'x-dock-body'}, innerWrapper:null, sizeState:false, container:null}, positionMap:{top:'start', left:'start', bottom:'end', right:'end'}, constructor:function(config) {
  this.items = {start:[], end:[]};
  this.itemsCount = 0;
  this.initConfig(config);
}, addItems:function(items) {
  var i, ln, item;
  for (i = 0, ln = items.length; i < ln; i++) {
    item = items[i];
    this.addItem(item);
  }
}, addItem:function(item) {
  var docked = item.getDocked(), position = this.positionMap[docked], wrapper = item.$dockWrapper, container = this.getContainer(), index = container.indexOf(item), element = item.element, items = this.items, sideItems = items[position], i, ln, sibling, referenceElement, siblingIndex;
  if (wrapper) {
    wrapper.removeItem(item);
  }
  item.$dockWrapper = this;
  item.addCls('x-dock-item');
  item.addCls('x-docked-' + docked);
  for (i = 0, ln = sideItems.length; i < ln; i++) {
    sibling = sideItems[i];
    siblingIndex = container.indexOf(sibling);
    if (siblingIndex > index) {
      referenceElement = sibling.element;
      sideItems.splice(i, 0, item);
      break;
    }
  }
  if (!referenceElement) {
    sideItems.push(item);
    referenceElement = this.getBodyElement();
  }
  this.itemsCount++;
  if (position === 'start') {
    element.insertBefore(referenceElement);
  } else {
    element.insertAfter(referenceElement);
  }
}, removeItem:function(item) {
  var position = item.getDocked(), items = this.items[this.positionMap[position]];
  Ext.Array.remove(items, item);
  item.element.detach();
  delete item.$dockWrapper;
  item.removeCls('x-dock-item');
  item.removeCls('x-docked-' + position);
  if (--this.itemsCount === 0) {
    this.destroy();
  }
}, getItemsSlice:function(index) {
  var container = this.getContainer(), items = this.items, slice = [], sideItems, i, ln, item;
  for (sideItems = items.start, i = 0, ln = sideItems.length; i < ln; i++) {
    item = sideItems[i];
    if (container.indexOf(item) > index) {
      slice.push(item);
    }
  }
  for (sideItems = items.end, i = 0, ln = sideItems.length; i < ln; i++) {
    item = sideItems[i];
    if (container.indexOf(item) > index) {
      slice.push(item);
    }
  }
  return slice;
}, applyElement:function(element) {
  return Ext.Element.create(element);
}, updateElement:function(element) {
  element.addCls('x-dock-' + this.getDirection());
}, applyBodyElement:function(bodyElement) {
  return Ext.Element.create(bodyElement);
}, updateBodyElement:function(bodyElement) {
  this.getElement().append(bodyElement);
}, updateInnerWrapper:function(innerWrapper, oldInnerWrapper) {
  var bodyElement = this.getBodyElement();
  if (oldInnerWrapper && oldInnerWrapper.$outerWrapper === this) {
    oldInnerWrapper.getElement().detach();
    delete oldInnerWrapper.$outerWrapper;
  }
  if (innerWrapper) {
    innerWrapper.setSizeState(this.getSizeState());
    innerWrapper.$outerWrapper = this;
    bodyElement.append(innerWrapper.getElement());
  }
}, updateSizeState:function(state) {
  var innerWrapper = this.getInnerWrapper();
  this.getElement().setSizeState(state);
  if (innerWrapper) {
    innerWrapper.setSizeState(state);
  }
}, destroy:function() {
  var innerWrapper = this.getInnerWrapper(), outerWrapper = this.$outerWrapper, innerWrapperElement;
  if (innerWrapper) {
    if (outerWrapper) {
      outerWrapper.setInnerWrapper(innerWrapper);
    } else {
      innerWrapperElement = innerWrapper.getElement();
      if (!innerWrapperElement.isDestroyed) {
        innerWrapperElement.replace(this.getElement());
      }
      delete innerWrapper.$outerWrapper;
    }
  }
  delete this.$outerWrapper;
  this.setInnerWrapper(null);
  this.unlink('_bodyElement', '_element');
  this.callSuper();
}}, 1, 0, 0, 0, 0, 0, [Ext.layout.wrapper, 'BoxDock'], 0);
Ext.cmd.derive('Ext.layout.wrapper.Inner', Ext.Base, {config:{sizeState:null, container:null}, constructor:function(config) {
  this.initConfig(config);
}, getElement:function() {
  return this.getContainer().bodyElement;
}, setInnerWrapper:Ext.emptyFn, getInnerWrapper:Ext.emptyFn}, 1, 0, 0, 0, 0, 0, [Ext.layout.wrapper, 'Inner'], 0);
Ext.cmd.derive('Ext.layout.Default', Ext.layout.Abstract, {isAuto:true, config:{animation:null}, centerWrapperClass:'x-center', dockWrapperClass:'x-dock', positionMap:{top:'start', left:'start', middle:'center', bottom:'end', right:'end'}, positionDirectionMap:{top:'vertical', bottom:'vertical', left:'horizontal', right:'horizontal'}, setContainer:function(container) {
  var options = {delegate:'\x3e component'};
  this.dockedItems = [];
  Ext.layout.Abstract.prototype.setContainer.apply(this, arguments);
  container.on('centeredchange', 'onItemCenteredChange', this, options, 'before').on('floatingchange', 'onItemFloatingChange', this, options, 'before').on('dockedchange', 'onBeforeItemDockedChange', this, options, 'before').on('afterdockedchange', 'onAfterItemDockedChange', this, options);
}, monitorSizeStateChange:function() {
  this.monitorSizeStateChange = Ext.emptyFn;
  this.container.on('sizestatechange', 'onContainerSizeStateChange', this);
}, monitorSizeFlagsChange:function() {
  this.monitorSizeFlagsChange = Ext.emptyFn;
  this.container.on('sizeflagschange', 'onContainerSizeFlagsChange', this);
}, onItemAdd:function(item) {
  var docked = item.getDocked();
  if (docked !== null) {
    this.dockItem(item);
  } else {
    if (item.isCentered()) {
      this.onItemCenteredChange(item, true);
    } else {
      if (item.isFloating()) {
        this.onItemFloatingChange(item, true);
      } else {
        this.onItemInnerStateChange(item, true);
      }
    }
  }
}, onItemInnerStateChange:function(item, isInner, destroying) {
  if (isInner) {
    this.insertInnerItem(item, this.container.innerIndexOf(item));
  } else {
    this.removeInnerItem(item);
  }
}, insertInnerItem:function(item, index) {
  var container = this.container, containerDom = container.innerElement.dom, itemDom = item.element.dom, nextSibling = index !== -1 ? container.getInnerAt(index + 1) : null, nextSiblingDom = null, translatable;
  if (nextSibling) {
    translatable = nextSibling.getTranslatable();
    if (translatable && translatable.getUseWrapper()) {
      nextSiblingDom = translatable.getWrapper().dom;
    } else {
      nextSiblingDom = nextSibling ? nextSibling.element.dom : null;
    }
  }
  containerDom.insertBefore(itemDom, nextSiblingDom);
  return this;
}, insertBodyItem:function(item) {
  var container = this.container.setUseBodyElement(true), bodyDom = container.bodyElement.dom;
  if (item.getZIndex() === null) {
    item.setZIndex((container.indexOf(item) + 1) * 2);
  }
  bodyDom.insertBefore(item.element.dom, bodyDom.firstChild);
  return this;
}, removeInnerItem:function(item) {
  item.element.detach();
}, removeBodyItem:function(item) {
  item.setZIndex(null);
  item.element.detach();
}, onItemRemove:function(item, index, destroying) {
  var docked = item.getDocked();
  if (docked) {
    this.undockItem(item);
  } else {
    if (item.isCentered()) {
      this.onItemCenteredChange(item, false);
    } else {
      if (item.isFloating()) {
        this.onItemFloatingChange(item, false);
      } else {
        this.onItemInnerStateChange(item, false, destroying);
      }
    }
  }
}, onItemMove:function(item, toIndex, fromIndex) {
  if (item.isCentered() || item.isFloating()) {
    item.setZIndex((toIndex + 1) * 2);
  } else {
    if (item.isInnerItem()) {
      this.insertInnerItem(item, this.container.innerIndexOf(item));
    } else {
      this.undockItem(item);
      this.dockItem(item);
    }
  }
}, onItemCenteredChange:function(item, centered) {
  var wrapperName = '$centerWrapper';
  if (centered) {
    this.insertBodyItem(item);
    item.link(wrapperName, new Ext.util.Wrapper({className:this.centerWrapperClass}, item.element));
  } else {
    item.unlink(wrapperName);
    this.removeBodyItem(item);
  }
}, onItemFloatingChange:function(item, floating) {
  if (floating) {
    this.insertBodyItem(item);
  } else {
    this.removeBodyItem(item);
  }
}, onBeforeItemDockedChange:function(item, docked, oldDocked) {
  if (oldDocked) {
    this.undockItem(item);
  }
}, onAfterItemDockedChange:function(item, docked, oldDocked) {
  if (docked) {
    this.dockItem(item);
  }
}, onContainerSizeStateChange:function() {
  var dockWrapper = this.getDockWrapper();
  if (dockWrapper) {
    dockWrapper.setSizeState(this.container.getSizeState());
  }
}, onContainerSizeFlagsChange:function() {
  var items = this.dockedItems, i, ln, item;
  for (i = 0, ln = items.length; i < ln; i++) {
    item = items[i];
    this.refreshDockedItemLayoutSizeFlags(item);
  }
}, refreshDockedItemLayoutSizeFlags:function(item) {
  var container = this.container, dockedDirection = this.positionDirectionMap[item.getDocked()], binaryMask = dockedDirection === 'horizontal' ? container.LAYOUT_HEIGHT : container.LAYOUT_WIDTH, flags = container.getSizeFlags() & binaryMask;
  item.setLayoutSizeFlags(flags);
}, dockItem:function(item) {
  var DockClass = Ext.layout.wrapper.BoxDock, dockedItems = this.dockedItems, ln = dockedItems.length, container = this.container, itemIndex = container.indexOf(item), positionDirectionMap = this.positionDirectionMap, direction = positionDirectionMap[item.getDocked()], dockInnerWrapper = this.dockInnerWrapper, referenceDirection, i, dockedItem, index, previousItem, slice, referenceItem, referenceDocked, referenceWrapper, newWrapper, nestedWrapper, oldInnerWrapper;
  this.monitorSizeStateChange();
  this.monitorSizeFlagsChange();
  if (!dockInnerWrapper) {
    dockInnerWrapper = this.link('dockInnerWrapper', new Ext.layout.wrapper.Inner({container:this.container}));
  }
  if (ln === 0) {
    dockedItems.push(item);
    newWrapper = new DockClass({container:this.container, direction:direction});
    newWrapper.addItem(item);
    newWrapper.getElement().replace(dockInnerWrapper.getElement());
    newWrapper.setInnerWrapper(dockInnerWrapper);
    container.onInitialized('onContainerSizeStateChange', this);
  } else {
    for (i = 0; i < ln; i++) {
      dockedItem = dockedItems[i];
      index = container.indexOf(dockedItem);
      if (index > itemIndex) {
        referenceItem = previousItem || dockedItems[0];
        dockedItems.splice(i, 0, item);
        break;
      }
      previousItem = dockedItem;
    }
    if (!referenceItem) {
      referenceItem = dockedItems[ln - 1];
      dockedItems.push(item);
    }
    referenceDocked = referenceItem.getDocked();
    referenceWrapper = referenceItem.$dockWrapper;
    referenceDirection = positionDirectionMap[referenceDocked];
    if (direction === referenceDirection) {
      referenceWrapper.addItem(item);
    } else {
      slice = referenceWrapper.getItemsSlice(itemIndex);
      newWrapper = new DockClass({container:this.container, direction:direction});
      if (slice.length > 0) {
        if (slice.length === referenceWrapper.itemsCount) {
          nestedWrapper = referenceWrapper;
          newWrapper.setSizeState(nestedWrapper.getSizeState());
          newWrapper.getElement().replace(nestedWrapper.getElement());
        } else {
          nestedWrapper = new DockClass({container:this.container, direction:referenceDirection});
          nestedWrapper.setInnerWrapper(referenceWrapper.getInnerWrapper());
          nestedWrapper.addItems(slice);
          referenceWrapper.setInnerWrapper(newWrapper);
        }
        newWrapper.setInnerWrapper(nestedWrapper);
      } else {
        oldInnerWrapper = referenceWrapper.getInnerWrapper();
        referenceWrapper.setInnerWrapper(null);
        newWrapper.setInnerWrapper(oldInnerWrapper);
        referenceWrapper.setInnerWrapper(newWrapper);
      }
      newWrapper.addItem(item);
    }
  }
  container.onInitialized('refreshDockedItemLayoutSizeFlags', this, [item]);
}, getDockWrapper:function() {
  var dockedItems = this.dockedItems;
  if (dockedItems.length > 0) {
    return dockedItems[0].$dockWrapper;
  }
  return null;
}, undockItem:function(item) {
  var dockedItems = this.dockedItems;
  if (item.$dockWrapper) {
    item.$dockWrapper.removeItem(item);
  }
  Ext.Array.remove(dockedItems, item);
  item.setLayoutSizeFlags(0);
}, destroy:function() {
  this.dockedItems.length = 0;
  delete this.dockedItems;
  Ext.layout.Abstract.prototype.destroy.call(this);
}}, 0, 0, 0, 0, ['layout.auto', 'layout.default'], 0, [Ext.layout, 'Default'], 0);
Ext.cmd.derive('Ext.layout.Box', Ext.layout.Default, {config:{orient:'horizontal', align:'start', pack:'start'}, layoutBaseClass:'x-layout-tablebox', itemClass:'x-layout-tablebox-item', setContainer:function(container) {
  Ext.layout.Default.prototype.setContainer.apply(this, arguments);
  container.innerElement.addCls(this.layoutBaseClass);
  container.on('flexchange', 'onItemFlexChange', this, {delegate:'\x3e component'});
}, onItemInnerStateChange:function(item, isInner) {
  Ext.layout.Default.prototype.onItemInnerStateChange.apply(this, arguments);
  item.toggleCls(this.itemClass, isInner);
}, onItemFlexChange:function() {
}}, 0, 0, 0, 0, ['layout.tablebox'], 0, [Ext.layout, 'Box'], 0);
Ext.cmd.derive('Ext.fx.layout.card.Abstract', Ext.Evented, {isAnimation:true, config:{direction:'left', duration:null, reverse:null, layout:null}, updateLayout:function() {
  this.enable();
}, enable:function() {
  var layout = this.getLayout();
  if (layout) {
    layout.onBefore('activeitemchange', 'onActiveItemChange', this);
  }
}, disable:function() {
  var layout = this.getLayout();
  if (this.isAnimating) {
    this.stopAnimation();
  }
  if (layout) {
    layout.unBefore('activeitemchange', 'onActiveItemChange', this);
  }
}, onActiveItemChange:Ext.emptyFn, destroy:function() {
  var layout = this.getLayout();
  if (this.isAnimating) {
    this.stopAnimation();
  }
  if (layout) {
    layout.unBefore('activeitemchange', 'onActiveItemChange', this);
  }
  this.setLayout(null);
  if (this.observableId) {
    this.fireEvent('destroy', this);
    this.clearListeners();
    this.clearManagedListeners();
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.layout.card, 'Abstract'], 0);
Ext.cmd.derive('Ext.fx.State', Ext.Base, {isAnimatable:{'background-color':true, 'background-image':true, 'background-position':true, 'border-bottom-color':true, 'border-bottom-width':true, 'border-color':true, 'border-left-color':true, 'border-left-width':true, 'border-right-color':true, 'border-right-width':true, 'border-spacing':true, 'border-top-color':true, 'border-top-width':true, 'border-width':true, 'bottom':true, 'color':true, 'crop':true, 'font-size':true, 'font-weight':true, 'height':true, 
'left':true, 'letter-spacing':true, 'line-height':true, 'margin-bottom':true, 'margin-left':true, 'margin-right':true, 'margin-top':true, 'max-height':true, 'max-width':true, 'min-height':true, 'min-width':true, 'opacity':true, 'outline-color':true, 'outline-offset':true, 'outline-width':true, 'padding-bottom':true, 'padding-left':true, 'padding-right':true, 'padding-top':true, 'right':true, 'text-indent':true, 'text-shadow':true, 'top':true, 'vertical-align':true, 'visibility':true, 'width':true, 
'word-spacing':true, 'z-index':true, 'zoom':true, 'transform':true}, constructor:function(data) {
  this.data = {};
  this.set(data);
}, setConfig:function(data) {
  this.set(data);
  return this;
}, setRaw:function(data) {
  this.data = data;
  return this;
}, clear:function() {
  return this.setRaw({});
}, setTransform:function(name, value) {
  var data = this.data, isArray = Ext.isArray(value), transform = data.transform, ln, key;
  if (!transform) {
    transform = data.transform = {translateX:0, translateY:0, translateZ:0, scaleX:1, scaleY:1, scaleZ:1, rotate:0, rotateX:0, rotateY:0, rotateZ:0, skewX:0, skewY:0};
  }
  if (typeof name == 'string') {
    switch(name) {
      case 'translate':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.translateX = value[0];
          if (ln == 1) {
            break;
          }
          transform.translateY = value[1];
          if (ln == 2) {
            break;
          }
          transform.translateZ = value[2];
        } else {
          transform.translateX = value;
        }
        break;
      case 'rotate':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.rotateX = value[0];
          if (ln == 1) {
            break;
          }
          transform.rotateY = value[1];
          if (ln == 2) {
            break;
          }
          transform.rotateZ = value[2];
        } else {
          transform.rotate = value;
        }
        break;
      case 'scale':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.scaleX = value[0];
          if (ln == 1) {
            break;
          }
          transform.scaleY = value[1];
          if (ln == 2) {
            break;
          }
          transform.scaleZ = value[2];
        } else {
          transform.scaleX = value;
          transform.scaleY = value;
        }
        break;
      case 'skew':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.skewX = value[0];
          if (ln == 1) {
            break;
          }
          transform.skewY = value[1];
        } else {
          transform.skewX = value;
        }
        break;
      default:
        transform[name] = value;
    }
  } else {
    for (key in name) {
      if (name.hasOwnProperty(key)) {
        value = name[key];
        this.setTransform(key, value);
      }
    }
  }
}, set:function(name, value) {
  var data = this.data, key;
  if (typeof name != 'string') {
    for (key in name) {
      value = name[key];
      if (key === 'transform') {
        this.setTransform(value);
      } else {
        data[key] = value;
      }
    }
  } else {
    if (name === 'transform') {
      this.setTransform(value);
    } else {
      data[name] = value;
    }
  }
  return this;
}, unset:function(name) {
  var data = this.data;
  if (data.hasOwnProperty(name)) {
    delete data[name];
  }
  return this;
}, getData:function() {
  return this.data;
}}, 1, 0, 0, 0, 0, 0, [Ext.fx, 'State'], 0);
Ext.cmd.derive('Ext.fx.animation.Abstract', Ext.Evented, {isAnimation:true, config:{name:'', element:null, before:null, from:{}, to:{}, after:null, states:{}, duration:300, easing:'linear', iteration:1, direction:'normal', delay:0, onBeforeStart:null, onEnd:null, onBeforeEnd:null, scope:null, reverse:null, preserveEndState:false, replacePrevious:true}, STATE_FROM:'0%', STATE_TO:'100%', DIRECTION_UP:'up', DIRECTION_DOWN:'down', DIRECTION_LEFT:'left', DIRECTION_RIGHT:'right', stateNameRegex:/^(?:[\d\.]+)%$/, 
constructor:function() {
  this.states = {};
  Ext.Evented.prototype.constructor.apply(this, arguments);
  return this;
}, applyElement:function(element) {
  return Ext.get(element);
}, applyBefore:function(before, current) {
  if (before) {
    return Ext.factory(before, Ext.fx.State, current);
  }
}, applyAfter:function(after, current) {
  if (after) {
    return Ext.factory(after, Ext.fx.State, current);
  }
}, setFrom:function(from) {
  return this.setState(this.STATE_FROM, from);
}, setTo:function(to) {
  return this.setState(this.STATE_TO, to);
}, getFrom:function() {
  return this.getState(this.STATE_FROM);
}, getTo:function() {
  return this.getState(this.STATE_TO);
}, setStates:function(states) {
  var validNameRegex = this.stateNameRegex, name;
  for (name in states) {
    if (validNameRegex.test(name)) {
      this.setState(name, states[name]);
    }
  }
  return this;
}, getStates:function() {
  return this.states;
}, stop:function() {
  this.fireEvent('stop', this);
}, destroy:function() {
  this.stop();
  Ext.Evented.prototype.destroy.call(this);
}, setState:function(name, state) {
  var states = this.getStates(), stateInstance;
  stateInstance = Ext.factory(state, Ext.fx.State, states[name]);
  if (stateInstance) {
    states[name] = stateInstance;
  }
  return this;
}, getState:function(name) {
  return this.getStates()[name];
}, getData:function() {
  var states = this.getStates(), statesData = {}, before = this.getBefore(), after = this.getAfter(), from = states[this.STATE_FROM], to = states[this.STATE_TO], fromData = from.getData(), toData = to.getData(), data, name, state;
  for (name in states) {
    if (states.hasOwnProperty(name)) {
      state = states[name];
      data = state.getData();
      statesData[name] = data;
    }
  }
  if (Ext.browser.is.AndroidStock2) {
    statesData['0.0001%'] = fromData;
  }
  return {before:before ? before.getData() : {}, after:after ? after.getData() : {}, states:statesData, from:fromData, to:toData, duration:this.getDuration(), iteration:this.getIteration(), direction:this.getDirection(), easing:this.getEasing(), delay:this.getDelay(), onEnd:this.getOnEnd(), onBeforeEnd:this.getOnBeforeEnd(), onBeforeStart:this.getOnBeforeStart(), scope:this.getScope(), preserveEndState:this.getPreserveEndState(), replacePrevious:this.getReplacePrevious()};
}}, 1, 0, 0, 0, 0, 0, [Ext.fx.animation, 'Abstract'], 0);
Ext.cmd.derive('Ext.fx.animation.Slide', Ext.fx.animation.Abstract, {alternateClassName:'Ext.fx.animation.SlideIn', config:{direction:'left', out:false, offset:0, easing:'auto', containerBox:'auto', elementBox:'auto', isElementBoxFit:true, useCssTransform:true}, reverseDirectionMap:{up:'down', down:'up', left:'right', right:'left'}, applyEasing:function(easing) {
  if (easing === 'auto') {
    return 'ease-' + (this.getOut() ? 'in' : 'out');
  }
  return easing;
}, getContainerBox:function() {
  var box = this._containerBox;
  if (box === 'auto') {
    box = this.getElement().getParent().getPageBox();
  }
  return box;
}, getElementBox:function() {
  var box = this._elementBox;
  if (this.getIsElementBoxFit()) {
    return this.getContainerBox();
  }
  if (box === 'auto') {
    box = this.getElement().getPageBox();
  }
  return box;
}, getData:function() {
  var elementBox = this.getElementBox(), containerBox = this.getContainerBox(), box = elementBox ? elementBox : containerBox, from = this.getFrom(), to = this.getTo(), out = this.getOut(), offset = this.getOffset(), direction = this.getDirection(), useCssTransform = this.getUseCssTransform(), reverse = this.getReverse(), translateX = 0, translateY = 0, fromX, fromY, toX, toY;
  if (reverse) {
    direction = this.reverseDirectionMap[direction];
  }
  switch(direction) {
    case this.DIRECTION_UP:
      if (out) {
        translateY = containerBox.top - box.top - box.height - offset;
      } else {
        translateY = containerBox.bottom - box.bottom + box.height + offset;
      }
      break;
    case this.DIRECTION_DOWN:
      if (out) {
        translateY = containerBox.bottom - box.bottom + box.height + offset;
      } else {
        translateY = containerBox.top - box.height - box.top - offset;
      }
      break;
    case this.DIRECTION_RIGHT:
      if (out) {
        translateX = containerBox.right - box.right + box.width + offset;
      } else {
        translateX = containerBox.left - box.left - box.width - offset;
      }
      break;
    case this.DIRECTION_LEFT:
      if (out) {
        translateX = containerBox.left - box.left - box.width - offset;
      } else {
        translateX = containerBox.right - box.right + box.width + offset;
      }
      break;
  }
  fromX = out ? 0 : translateX;
  fromY = out ? 0 : translateY;
  if (useCssTransform) {
    from.setTransform({translateX:fromX, translateY:fromY});
  } else {
    from.set('left', fromX);
    from.set('top', fromY);
  }
  toX = out ? translateX : 0;
  toY = out ? translateY : 0;
  if (useCssTransform) {
    to.setTransform({translateX:toX, translateY:toY});
  } else {
    to.set('left', toX);
    to.set('top', toY);
  }
  return Ext.fx.animation.Abstract.prototype.getData.apply(this, arguments);
}}, 0, 0, 0, 0, ['animation.slide', 'animation.slideIn'], 0, [Ext.fx.animation, 'Slide', Ext.fx.animation, 'SlideIn'], 0);
Ext.cmd.derive('Ext.fx.animation.SlideOut', Ext.fx.animation.Slide, {config:{out:true}}, 0, 0, 0, 0, ['animation.slideOut'], 0, [Ext.fx.animation, 'SlideOut'], 0);
Ext.cmd.derive('Ext.fx.animation.Fade', Ext.fx.animation.Abstract, {alternateClassName:'Ext.fx.animation.FadeIn', config:{out:false, before:{display:null, opacity:0}, after:{opacity:null}, reverse:null}, updateOut:function(newOut) {
  var to = this.getTo(), from = this.getFrom();
  if (newOut) {
    from.set('opacity', 1);
    to.set('opacity', 0);
  } else {
    from.set('opacity', 0);
    to.set('opacity', 1);
  }
}}, 0, 0, 0, 0, ['animation.fade', 'animation.fadeIn'], 0, [Ext.fx.animation, 'Fade', Ext.fx.animation, 'FadeIn'], 0);
Ext.cmd.derive('Ext.fx.animation.FadeOut', Ext.fx.animation.Fade, {config:{out:true, before:{}}}, 0, 0, 0, 0, ['animation.fadeOut'], 0, [Ext.fx.animation, 'FadeOut'], 0);
Ext.cmd.derive('Ext.fx.animation.Flip', Ext.fx.animation.Abstract, {config:{easing:'ease-in', direction:'right', half:false, out:null}, getData:function() {
  var from = this.getFrom(), to = this.getTo(), direction = this.getDirection(), out = this.getOut(), half = this.getHalf(), rotate = half ? 90 : 180, fromScale = 1, toScale = 1, fromRotateX = 0, fromRotateY = 0, toRotateX = 0, toRotateY = 0;
  if (out) {
    toScale = 0.8;
  } else {
    fromScale = 0.8;
  }
  switch(direction) {
    case this.DIRECTION_UP:
      if (out) {
        toRotateX = rotate;
      } else {
        fromRotateX = -rotate;
      }
      break;
    case this.DIRECTION_DOWN:
      if (out) {
        toRotateX = -rotate;
      } else {
        fromRotateX = rotate;
      }
      break;
    case this.DIRECTION_RIGHT:
      if (out) {
        toRotateY = rotate;
      } else {
        fromRotateY = -rotate;
      }
      break;
    case this.DIRECTION_LEFT:
      if (out) {
        toRotateY = -rotate;
      } else {
        fromRotateY = rotate;
      }
      break;
  }
  from.setTransform({rotateX:fromRotateX, rotateY:fromRotateY, scale:fromScale});
  to.setTransform({rotateX:toRotateX, rotateY:toRotateY, scale:toScale});
  return Ext.fx.animation.Abstract.prototype.getData.apply(this, arguments);
}}, 0, 0, 0, 0, ['animation.flip'], 0, [Ext.fx.animation, 'Flip'], 0);
Ext.cmd.derive('Ext.fx.animation.Pop', Ext.fx.animation.Abstract, {alternateClassName:'Ext.fx.animation.PopIn', config:{out:false, before:{display:null, opacity:0}, after:{opacity:null}}, getData:function() {
  var to = this.getTo(), from = this.getFrom(), out = this.getOut();
  if (out) {
    from.set('opacity', 1);
    from.setTransform({scale:1});
    to.set('opacity', 0);
    to.setTransform({scale:0});
  } else {
    from.set('opacity', 0);
    from.setTransform({scale:0});
    to.set('opacity', 1);
    to.setTransform({scale:1});
  }
  return Ext.fx.animation.Abstract.prototype.getData.apply(this, arguments);
}}, 0, 0, 0, 0, ['animation.pop', 'animation.popIn'], 0, [Ext.fx.animation, 'Pop', Ext.fx.animation, 'PopIn'], 0);
Ext.cmd.derive('Ext.fx.animation.PopOut', Ext.fx.animation.Pop, {config:{out:true, before:{}}}, 0, 0, 0, 0, ['animation.popOut'], 0, [Ext.fx.animation, 'PopOut'], 0);
Ext.cmd.derive('Ext.fx.Animation', Ext.Base, {constructor:function(config) {
  var defaultClass = Ext.fx.animation.Abstract, type;
  if (typeof config == 'string') {
    type = config;
    config = {};
  } else {
    if (config && config.type) {
      type = config.type;
    }
  }
  if (type) {
    if (Ext.browser.is.AndroidStock2) {
      if (type == 'pop') {
        type = 'fade';
      }
      if (type == 'popIn') {
        type = 'fadeIn';
      }
      if (type == 'popOut') {
        type = 'fadeOut';
      }
    }
    defaultClass = Ext.ClassManager.getByAlias('animation.' + type);
  }
  return Ext.factory(config, defaultClass);
}}, 1, 0, 0, 0, 0, 0, [Ext.fx, 'Animation'], 0);
Ext.cmd.derive('Ext.fx.layout.card.Style', Ext.fx.layout.card.Abstract, {config:{inAnimation:{before:{visibility:null}, preserveEndState:false, replacePrevious:true}, outAnimation:{preserveEndState:false, replacePrevious:true}}, constructor:function(config) {
  var inAnimation, outAnimation;
  this.initConfig(config);
  this.endAnimationCounter = 0;
  inAnimation = this.getInAnimation();
  outAnimation = this.getOutAnimation();
  inAnimation.on('animationend', 'incrementEnd', this);
  outAnimation.on('animationend', 'incrementEnd', this);
}, updateDirection:function(direction) {
  this.getInAnimation().setDirection(direction);
  this.getOutAnimation().setDirection(direction);
}, updateDuration:function(duration) {
  this.getInAnimation().setDuration(duration);
  this.getOutAnimation().setDuration(duration);
}, updateReverse:function(reverse) {
  this.getInAnimation().setReverse(reverse);
  this.getOutAnimation().setReverse(reverse);
}, incrementEnd:function() {
  this.endAnimationCounter++;
  if (this.endAnimationCounter > 1) {
    this.endAnimationCounter = 0;
    this.fireEvent('animationend', this);
  }
}, applyInAnimation:function(animation, inAnimation) {
  return Ext.factory(animation, Ext.fx.Animation, inAnimation);
}, applyOutAnimation:function(animation, outAnimation) {
  return Ext.factory(animation, Ext.fx.Animation, outAnimation);
}, updateInAnimation:function(animation) {
  animation.setScope(this);
}, updateOutAnimation:function(animation) {
  animation.setScope(this);
}, onActiveItemChange:function(cardLayout, newItem, oldItem, options, controller) {
  var inAnimation = this.getInAnimation(), outAnimation = this.getOutAnimation(), inElement, outElement;
  if (newItem && oldItem && oldItem.isPainted()) {
    inElement = newItem.renderElement;
    outElement = oldItem.renderElement;
    inAnimation.setElement(inElement);
    outAnimation.setElement(outElement);
    outAnimation.setOnBeforeEnd(function(element, interrupted) {
      if (interrupted || Ext.Animator.hasRunningAnimations(element)) {
        controller.firingArguments[1] = null;
        controller.firingArguments[2] = null;
      }
    });
    outAnimation.setOnEnd(function() {
      controller.resume();
    });
    inElement.dom.style.setProperty('visibility', 'hidden', 'important');
    newItem.show();
    Ext.Animator.run([outAnimation, inAnimation]);
    controller.pause();
  }
}, destroy:function() {
  Ext.destroy(this.getInAnimation(), this.getOutAnimation());
  Ext.fx.layout.card.Abstract.prototype.destroy.apply(this, arguments);
}}, 1, 0, 0, 0, 0, 0, [Ext.fx.layout.card, 'Style'], 0);
Ext.cmd.derive('Ext.fx.layout.card.Slide', Ext.fx.layout.card.Style, {config:{inAnimation:{type:'slide', easing:'ease-out'}, outAnimation:{type:'slide', easing:'ease-out', out:true}}, updateReverse:function(reverse) {
  this.getInAnimation().setReverse(reverse);
  this.getOutAnimation().setReverse(reverse);
}}, 0, 0, 0, 0, ['fx.layout.card.slide'], 0, [Ext.fx.layout.card, 'Slide'], 0);
Ext.cmd.derive('Ext.fx.layout.card.Cover', Ext.fx.layout.card.Style, {config:{reverse:null, inAnimation:{before:{'z-index':100}, after:{'z-index':0}, type:'slide', easing:'ease-out'}, outAnimation:{easing:'ease-out', from:{opacity:0.99}, to:{opacity:1}, out:true}}, updateReverse:function(reverse) {
  this.getInAnimation().setReverse(reverse);
  this.getOutAnimation().setReverse(reverse);
}}, 0, 0, 0, 0, ['fx.layout.card.cover'], 0, [Ext.fx.layout.card, 'Cover'], 0);
Ext.cmd.derive('Ext.fx.layout.card.Reveal', Ext.fx.layout.card.Style, {config:{inAnimation:{easing:'ease-out', from:{opacity:0.99}, to:{opacity:1}}, outAnimation:{before:{'z-index':100}, after:{'z-index':0}, type:'slide', easing:'ease-out', out:true}}, updateReverse:function(reverse) {
  this.getInAnimation().setReverse(reverse);
  this.getOutAnimation().setReverse(reverse);
}}, 0, 0, 0, 0, ['fx.layout.card.reveal'], 0, [Ext.fx.layout.card, 'Reveal'], 0);
Ext.cmd.derive('Ext.fx.layout.card.Fade', Ext.fx.layout.card.Style, {config:{reverse:null, inAnimation:{type:'fade', easing:'ease-out'}, outAnimation:{type:'fade', easing:'ease-out', out:true}}}, 0, 0, 0, 0, ['fx.layout.card.fade'], 0, [Ext.fx.layout.card, 'Fade'], 0);
Ext.cmd.derive('Ext.fx.layout.card.Flip', Ext.fx.layout.card.Style, {config:{duration:500, inAnimation:{type:'flip', half:true, easing:'ease-out', before:{'backface-visibility':'hidden'}, after:{'backface-visibility':null}}, outAnimation:{type:'flip', half:true, easing:'ease-in', before:{'backface-visibility':'hidden'}, after:{'backface-visibility':null}, out:true}}, onActiveItemChange:function(cardLayout, newItem, oldItem, options, controller) {
  var parent = newItem.element.getParent();
  parent.addCls('x-layout-card-perspective');
  this.on('animationend', function() {
    parent.removeCls('x-layout-card-perspective');
  }, this, {single:true});
  Ext.fx.layout.card.Style.prototype.onActiveItemChange.apply(this, arguments);
}, updateDuration:function(duration) {
  var halfDuration = duration / 2, inAnimation = this.getInAnimation(), outAnimation = this.getOutAnimation();
  inAnimation.setDelay(halfDuration);
  inAnimation.setDuration(halfDuration);
  outAnimation.setDuration(halfDuration);
}}, 0, 0, 0, 0, ['fx.layout.card.flip'], 0, [Ext.fx.layout.card, 'Flip'], 0);
Ext.cmd.derive('Ext.fx.layout.card.Pop', Ext.fx.layout.card.Style, {config:{duration:500, inAnimation:{type:'pop', easing:'ease-out'}, outAnimation:{type:'pop', easing:'ease-in', out:true}}, updateDuration:function(duration) {
  var halfDuration = duration / 2, inAnimation = this.getInAnimation(), outAnimation = this.getOutAnimation();
  inAnimation.setDelay(halfDuration);
  inAnimation.setDuration(halfDuration);
  outAnimation.setDuration(halfDuration);
}}, 0, 0, 0, 0, ['fx.layout.card.pop'], 0, [Ext.fx.layout.card, 'Pop'], 0);
Ext.cmd.derive('Ext.fx.layout.card.Scroll', Ext.fx.layout.card.Abstract, {config:{duration:150}, constructor:function(config) {
  this.initConfig(config);
}, getEasing:function() {
  var easing = this.easing;
  if (!easing) {
    this.easing = easing = new Ext.fx.easing.Linear;
  }
  return easing;
}, updateDuration:function(duration) {
  this.getEasing().setDuration(duration);
}, onActiveItemChange:function(cardLayout, newItem, oldItem, options, controller) {
  var direction = this.getDirection(), easing = this.getEasing(), containerElement, inElement, outElement, containerWidth, containerHeight, reverse;
  if (newItem && oldItem) {
    if (this.isAnimating) {
      this.stopAnimation();
    }
    newItem.setWidth('100%');
    newItem.setHeight('100%');
    containerElement = this.getLayout().container.innerElement;
    containerWidth = containerElement.getWidth();
    containerHeight = containerElement.getHeight();
    inElement = newItem.renderElement;
    outElement = oldItem.renderElement;
    this.oldItem = oldItem;
    this.newItem = newItem;
    this.currentEventController = controller;
    this.containerElement = containerElement;
    this.isReverse = reverse = this.getReverse();
    newItem.show();
    if (direction == 'right') {
      direction = 'left';
      this.isReverse = reverse = !reverse;
    } else {
      if (direction == 'down') {
        direction = 'up';
        this.isReverse = reverse = !reverse;
      }
    }
    if (direction == 'left') {
      if (reverse) {
        easing.setConfig({startValue:containerWidth, endValue:0});
        containerElement.dom.scrollLeft = containerWidth;
        outElement.setLeft(containerWidth);
      } else {
        easing.setConfig({startValue:0, endValue:containerWidth});
        inElement.setLeft(containerWidth);
      }
    } else {
      if (reverse) {
        easing.setConfig({startValue:containerHeight, endValue:0});
        containerElement.dom.scrollTop = containerHeight;
        outElement.setTop(containerHeight);
      } else {
        easing.setConfig({startValue:0, endValue:containerHeight});
        inElement.setTop(containerHeight);
      }
    }
    this.startAnimation();
    controller.pause();
  }
}, startAnimation:function() {
  this.isAnimating = true;
  this.getEasing().setStartTime(Date.now());
  Ext.AnimationQueue.start(this.doAnimationFrame, this);
}, doAnimationFrame:function() {
  var easing = this.getEasing(), direction = this.getDirection(), scroll = 'scrollTop', value;
  if (direction == 'left' || direction == 'right') {
    scroll = 'scrollLeft';
  }
  if (easing.isEnded) {
    this.stopAnimation();
  } else {
    value = easing.getValue();
    this.containerElement.dom[scroll] = value;
  }
}, stopAnimation:function() {
  var me = this, direction = me.getDirection(), scroll = 'setTop', oldItem = me.oldItem, newItem = me.newItem;
  if (direction == 'left' || direction == 'right') {
    scroll = 'setLeft';
  }
  me.currentEventController.resume();
  if (me.isReverse && oldItem && oldItem.renderElement && oldItem.renderElement.dom) {
    oldItem.renderElement[scroll](null);
  } else {
    if (newItem && newItem.renderElement && newItem.renderElement.dom) {
      newItem.renderElement[scroll](null);
    }
  }
  Ext.AnimationQueue.stop(this.doAnimationFrame, this);
  me.isAnimating = false;
  me.fireEvent('animationend', me);
}}, 1, 0, 0, 0, ['fx.layout.card.scroll'], 0, [Ext.fx.layout.card, 'Scroll'], 0);
Ext.cmd.derive('Ext.fx.layout.Card', Ext.Base, {constructor:function(config) {
  var defaultClass = Ext.fx.layout.card.Abstract, type;
  if (!config) {
    return null;
  }
  if (typeof config == 'string') {
    type = config;
    config = {};
  } else {
    if (config.type) {
      type = config.type;
    }
  }
  config.elementBox = false;
  if (type) {
    if (Ext.browser.is.AndroidStock2) {
      if (type != 'fade') {
        type = 'scroll';
      }
    }
    defaultClass = Ext.ClassManager.getByAlias('fx.layout.card.' + type);
  }
  return Ext.factory(config, defaultClass);
}}, 1, 0, 0, 0, 0, 0, [Ext.fx.layout, 'Card'], 0);
Ext.cmd.derive('Ext.layout.Card', Ext.layout.Default, {isCard:true, layoutClass:'x-layout-card', itemClass:'x-layout-card-item', applyAnimation:function(animation) {
  return new Ext.fx.layout.Card(animation);
}, updateAnimation:function(animation, oldAnimation) {
  if (animation && animation.isAnimation) {
    animation.setLayout(this);
  }
  if (oldAnimation) {
    oldAnimation.destroy();
  }
}, setContainer:function(container) {
  Ext.layout.Default.prototype.setContainer.apply(this, arguments);
  container.innerElement.addCls(this.layoutClass);
  container.onInitialized('onContainerInitialized', this);
}, onContainerInitialized:function() {
  var container = this.container, firstItem = container.getInnerAt(0), activeItem = container.getActiveItem();
  if (activeItem) {
    activeItem.show();
    if (firstItem && firstItem !== activeItem) {
      firstItem.hide();
    }
  }
  container.on('activeitemchange', 'onContainerActiveItemChange', this);
}, onContainerActiveItemChange:function(container) {
  this.relayEvent(arguments, 'doActiveItemChange');
}, onItemInnerStateChange:function(item, isInner, destroying) {
  Ext.layout.Default.prototype.onItemInnerStateChange.apply(this, arguments);
  var container = this.container, activeItem = container.getActiveItem();
  item.toggleCls(this.itemClass, isInner);
  item.setLayoutSizeFlags(isInner ? container.LAYOUT_BOTH : 0);
  if (isInner) {
    if (activeItem !== container.innerIndexOf(item) && activeItem !== item && item !== container.pendingActiveItem) {
      item.hide();
    }
  } else {
    if (!destroying && !item.isDestroyed && item.isDestroying !== true) {
      item.show();
    }
  }
}, doActiveItemChange:function(me, newActiveItem, oldActiveItem) {
  if (oldActiveItem) {
    oldActiveItem.hide();
  }
  if (newActiveItem) {
    newActiveItem.show();
  }
}, destroy:function() {
  Ext.layout.Default.prototype.destroy.apply(this, arguments);
  Ext.destroy(this.getAnimation());
}}, 0, 0, 0, 0, ['layout.card'], 0, [Ext.layout, 'Card'], 0);
Ext.cmd.derive('Ext.layout.Fit', Ext.layout.Default, {isFit:true, layoutClass:'x-layout-fit', itemClass:'x-layout-fit-item', setContainer:function(container) {
  Ext.layout.Default.prototype.setContainer.apply(this, arguments);
  container.innerElement.addCls(this.layoutClass);
  this.onContainerSizeFlagsChange();
  this.monitorSizeFlagsChange();
}, onContainerSizeFlagsChange:function() {
  var container = this.container, sizeFlags = container.getSizeFlags(), stretched = Boolean(sizeFlags & container.LAYOUT_STRETCHED), innerItems = container.innerItems, i, ln, item;
  Ext.layout.Default.prototype.onContainerSizeFlagsChange.call(this);
  for (i = 0, ln = innerItems.length; i < ln; i++) {
    item = innerItems[i];
    item.setLayoutSizeFlags(sizeFlags);
  }
  container.innerElement.toggleCls('x-stretched', stretched);
}, onItemInnerStateChange:function(item, isInner) {
  Ext.layout.Default.prototype.onItemInnerStateChange.apply(this, arguments);
  item.toggleCls(this.itemClass, isInner);
  item.setLayoutSizeFlags(isInner ? this.container.getSizeFlags() : 0);
}}, 0, 0, 0, 0, ['layout.fit'], 0, [Ext.layout, 'Fit'], 0);
Ext.cmd.derive('Ext.layout.FlexBox', Ext.layout.Box, {config:{align:'stretch'}, layoutBaseClass:'x-layout-box', itemClass:'x-layout-box-item', setContainer:function(container) {
  Ext.layout.Box.prototype.setContainer.apply(this, arguments);
  this.monitorSizeFlagsChange();
}, applyOrient:function(orient) {
  return orient;
}, updateOrient:function(orient, oldOrient) {
  var container = this.container, delegation = {delegate:'\x3e component'};
  if (orient === 'horizontal') {
    this.sizePropertyName = 'width';
  } else {
    this.sizePropertyName = 'height';
  }
  container.innerElement.swapCls('x-' + orient, 'x-' + oldOrient);
  if (oldOrient) {
    container.un(oldOrient === 'horizontal' ? 'widthchange' : 'heightchange', 'onItemSizeChange', this, delegation);
    this.redrawContainer();
  }
  container.on(orient === 'horizontal' ? 'widthchange' : 'heightchange', 'onItemSizeChange', this, delegation);
}, onItemInnerStateChange:function(item, isInner) {
  Ext.layout.Box.prototype.onItemInnerStateChange.apply(this, arguments);
  var flex, size;
  item.toggleCls(this.itemClass, isInner);
  if (isInner) {
    flex = item.getFlex();
    size = item.get(this.sizePropertyName);
    if (flex) {
      this.doItemFlexChange(item, flex);
    } else {
      if (size) {
        this.doItemSizeChange(item, size);
      }
    }
  }
  this.refreshItemSizeState(item);
}, refreshItemSizeState:function(item) {
  var isInner = item.isInnerItem(), container = this.container, LAYOUT_HEIGHT = container.LAYOUT_HEIGHT, LAYOUT_WIDTH = container.LAYOUT_WIDTH, dimension = this.sizePropertyName, layoutSizeFlags = 0, containerSizeFlags = container.getSizeFlags();
  if (isInner) {
    layoutSizeFlags |= container.LAYOUT_STRETCHED;
    if (this.getAlign() === 'stretch') {
      layoutSizeFlags |= containerSizeFlags & (dimension === 'width' ? LAYOUT_HEIGHT : LAYOUT_WIDTH);
    }
    if (item.getFlex()) {
      layoutSizeFlags |= containerSizeFlags & (dimension === 'width' ? LAYOUT_WIDTH : LAYOUT_HEIGHT);
    }
  }
  item.setLayoutSizeFlags(layoutSizeFlags);
}, refreshAllItemSizedStates:function() {
  var innerItems = this.container.innerItems, i, ln, item;
  for (i = 0, ln = innerItems.length; i < ln; i++) {
    item = innerItems[i];
    this.refreshItemSizeState(item);
  }
}, onContainerSizeFlagsChange:function() {
  this.refreshAllItemSizedStates();
  Ext.layout.Box.prototype.onContainerSizeFlagsChange.apply(this, arguments);
}, onItemSizeChange:function(item, size) {
  if (item.isInnerItem()) {
    this.doItemSizeChange(item, size);
  }
}, doItemSizeChange:function(item, size) {
  if (size) {
    item.setFlex(null);
    this.redrawContainer();
  }
}, onItemFlexChange:function(item, flex) {
  if (item.isInnerItem()) {
    this.doItemFlexChange(item, flex);
    this.refreshItemSizeState(item);
  }
}, doItemFlexChange:function(item, flex) {
  this.setItemFlex(item, flex);
  if (flex) {
    item.set(this.sizePropertyName, null);
  } else {
    this.redrawContainer();
  }
}, redrawContainer:function() {
  var container = this.container, renderedTo = container.element.dom.parentNode;
  if (renderedTo && renderedTo.nodeType !== 11) {
    container.innerElement.redraw();
  }
}, setItemFlex:function(item, flex) {
  var element = item.element;
  element.toggleCls('x-flexed', !!flex);
  if (!flex) {
    flex = '';
  } else {
    flex = String(flex);
  }
  if (Ext.browser.is.WebKit) {
    element.dom.style.setProperty('-webkit-box-flex', flex, null);
  } else {
    if (Ext.browser.is.IE) {
      element.dom.style.setProperty('-ms-flex', flex + ' 0 0px', null);
    } else {
      element.dom.style.setProperty('flex', flex + ' 0 0px', null);
    }
  }
}, convertPosition:function(position) {
  var positionMap = this.positionMap;
  if (positionMap.hasOwnProperty(position)) {
    return positionMap[position];
  }
  return position;
}, applyAlign:function(align) {
  return this.convertPosition(align);
}, updateAlign:function(align, oldAlign) {
  var container = this.container;
  container.innerElement.swapCls(align, oldAlign, true, 'x-align');
  if (oldAlign !== undefined) {
    this.refreshAllItemSizedStates();
  }
}, applyPack:function(pack) {
  return this.convertPosition(pack);
}, updatePack:function(pack, oldPack) {
  this.container.innerElement.swapCls(pack, oldPack, true, 'x-pack');
}}, 0, 0, 0, 0, ['layout.box'], 0, [Ext.layout, 'FlexBox'], 0);
Ext.cmd.derive('Ext.layout.Float', Ext.layout.Default, {config:{direction:'left'}, layoutClass:'layout-float', itemClass:'layout-float-item', setContainer:function(container) {
  Ext.layout.Default.prototype.setContainer.apply(this, arguments);
  container.innerElement.addCls(this.layoutClass);
}, onItemInnerStateChange:function(item, isInner) {
  Ext.layout.Default.prototype.onItemInnerStateChange.apply(this, arguments);
  item.toggleCls(this.itemClass, isInner);
}, updateDirection:function(direction, oldDirection) {
  var prefix = 'direction-';
  this.container.innerElement.swapCls(prefix + direction, prefix + oldDirection);
}}, 0, 0, 0, 0, ['layout.float'], 0, [Ext.layout, 'Float'], 0);
Ext.cmd.derive('Ext.layout.HBox', Ext.layout.FlexBox, {}, 0, 0, 0, 0, ['layout.hbox'], 0, [Ext.layout, 'HBox'], 0);
Ext.cmd.derive('Ext.layout.VBox', Ext.layout.FlexBox, {config:{orient:'vertical'}}, 0, 0, 0, 0, ['layout.vbox'], 0, [Ext.layout, 'VBox'], 0);
Ext.cmd.derive('Ext.layout.wrapper.Dock', Ext.Base, {config:{direction:'horizontal', element:{className:'x-dock'}, bodyElement:{className:'x-dock-body'}, innerWrapper:null, sizeState:false, container:null}, positionMap:{top:'start', left:'start', bottom:'end', right:'end'}, constructor:function(config) {
  this.items = {start:[], end:[]};
  this.itemsCount = 0;
  this.initConfig(config);
}, addItems:function(items) {
  var i, ln, item;
  for (i = 0, ln = items.length; i < ln; i++) {
    item = items[i];
    this.addItem(item);
  }
}, addItem:function(item) {
  var docked = item.getDocked(), position = this.positionMap[docked], wrapper = item.$dockWrapper, container = this.getContainer(), index = container.indexOf(item), items = this.items, sideItems = items[position], itemWrapper, element, i, ln, sibling, referenceElement, siblingIndex;
  if (wrapper) {
    wrapper.removeItem(item);
  }
  item.$dockWrapper = this;
  itemWrapper = item.link('$dockItemWrapper', new Ext.util.Wrapper({className:'x-dock-item'}));
  item.addCls('x-docked-' + docked);
  element = itemWrapper.element;
  for (i = 0, ln = sideItems.length; i < ln; i++) {
    sibling = sideItems[i];
    siblingIndex = container.indexOf(sibling);
    if (siblingIndex > index) {
      referenceElement = sibling.element;
      sideItems.splice(i, 0, item);
      break;
    }
  }
  if (!referenceElement) {
    sideItems.push(item);
    referenceElement = this.getBodyElement();
  }
  this.itemsCount++;
  if (position === 'start') {
    element.insertBefore(referenceElement);
  } else {
    element.insertAfter(referenceElement);
  }
  itemWrapper.wrap(item.element);
  itemWrapper.bindSize(this.getDirection() === 'horizontal' ? 'width' : 'height');
}, removeItem:function(item) {
  var position = item.getDocked(), items = this.items[this.positionMap[position]];
  item.removeCls('x-docked-' + position);
  Ext.Array.remove(items, item);
  item.unlink('$dockItemWrapper');
  item.element.detach();
  delete item.$dockWrapper;
  if (--this.itemsCount === 0) {
    this.destroy();
  }
}, getItemsSlice:function(index) {
  var container = this.getContainer(), items = this.items, slice = [], sideItems, i, ln, item;
  for (sideItems = items.start, i = 0, ln = sideItems.length; i < ln; i++) {
    item = sideItems[i];
    if (container.indexOf(item) > index) {
      slice.push(item);
    }
  }
  for (sideItems = items.end, i = 0, ln = sideItems.length; i < ln; i++) {
    item = sideItems[i];
    if (container.indexOf(item) > index) {
      slice.push(item);
    }
  }
  return slice;
}, applyElement:function(element) {
  return Ext.Element.create(element);
}, updateElement:function(element) {
  element.addCls('x-dock-' + this.getDirection());
}, applyBodyElement:function(bodyElement) {
  return Ext.Element.create(bodyElement);
}, updateBodyElement:function(bodyElement) {
  this.getElement().append(bodyElement);
}, updateInnerWrapper:function(innerWrapper, oldInnerWrapper) {
  var innerElement = this.getBodyElement();
  if (oldInnerWrapper && oldInnerWrapper.$outerWrapper === this) {
    innerElement.remove(oldInnerWrapper.getElement());
    delete oldInnerWrapper.$outerWrapper;
  }
  if (innerWrapper) {
    innerWrapper.setSizeState(this.getSizeState());
    innerWrapper.$outerWrapper = this;
    innerElement.append(innerWrapper.getElement());
  }
}, updateSizeState:function(state) {
  var innerWrapper = this.getInnerWrapper();
  this.getElement().setSizeState(state);
  if (innerWrapper) {
    innerWrapper.setSizeState(state);
  }
}, destroy:function() {
  var innerWrapper = this.getInnerWrapper(), outerWrapper = this.$outerWrapper;
  if (innerWrapper) {
    if (outerWrapper) {
      outerWrapper.setInnerWrapper(innerWrapper);
    } else {
      innerWrapper.getElement().replace(this.getElement());
      delete innerWrapper.$outerWrapper;
    }
  }
  delete this.$outerWrapper;
  this.setInnerWrapper(null);
  this.unlink('_bodyElement', '_element');
  this.callSuper();
}}, 1, 0, 0, 0, 0, 0, [Ext.layout.wrapper, 'Dock'], 0);
Ext.cmd.derive('Ext.util.Filter', Ext.Base, {isFilter:true, config:{property:null, value:null, filterFn:Ext.emptyFn, anyMatch:false, exactMatch:false, caseSensitive:false, root:null, id:undefined, scope:null}, applyId:function(id) {
  if (!id) {
    if (this.getProperty()) {
      id = this.getProperty() + '-' + String(this.getValue());
    }
    if (!id) {
      id = Ext.id(null, 'ext-filter-');
    }
  }
  return id;
}, constructor:function(config) {
  this.initConfig(config);
}, applyFilterFn:function(filterFn) {
  if (filterFn === Ext.emptyFn) {
    filterFn = this.getInitialConfig('filter');
    if (filterFn) {
      return filterFn;
    }
    var value = this.getValue();
    if (!this.getProperty() && !value && value !== 0) {
      return Ext.emptyFn;
    } else {
      return this.createFilterFn();
    }
  }
  return filterFn;
}, createFilterFn:function() {
  var me = this, matcher = me.createValueMatcher();
  return function(item) {
    var root = me.getRoot(), property = me.getProperty();
    if (root) {
      item = item[root];
    }
    return matcher.test(item[property]);
  };
}, createValueMatcher:function() {
  var me = this, value = me.getValue(), anyMatch = me.getAnyMatch(), exactMatch = me.getExactMatch(), caseSensitive = me.getCaseSensitive(), escapeRe = Ext.String.escapeRegex;
  if (value === null || value === undefined || !value.exec) {
    value = String(value);
    if (anyMatch === true) {
      value = escapeRe(value);
    } else {
      value = '^' + escapeRe(value);
      if (exactMatch === true) {
        value += '$';
      }
    }
    value = new RegExp(value, caseSensitive ? '' : 'i');
  }
  return value;
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Filter'], 0);
Ext.cmd.derive('Ext.util.AbstractMixedCollection', Ext.Base, {constructor:function(allowFunctions, keyFn) {
  var me = this;
  me.items = [];
  me.map = {};
  me.keys = [];
  me.length = 0;
  me.allowFunctions = allowFunctions === true;
  if (keyFn) {
    me.getKey = keyFn;
  }
  me.mixins.observable.constructor.call(me);
}, allowFunctions:false, add:function(key, obj) {
  var me = this, myObj = obj, myKey = key, old;
  if (arguments.length == 1) {
    myObj = myKey;
    myKey = me.getKey(myObj);
  }
  if (typeof myKey != 'undefined' && myKey !== null) {
    old = me.map[myKey];
    if (typeof old != 'undefined') {
      return me.replace(myKey, myObj);
    }
    me.map[myKey] = myObj;
  }
  me.length++;
  me.items.push(myObj);
  me.keys.push(myKey);
  me.fireEvent('add', me.length - 1, myObj, myKey);
  return myObj;
}, getKey:function(o) {
  return o.id;
}, replace:function(key, o) {
  var me = this, old, index;
  if (arguments.length == 1) {
    o = arguments[0];
    key = me.getKey(o);
  }
  old = me.map[key];
  if (typeof key == 'undefined' || key === null || typeof old == 'undefined') {
    return me.add(key, o);
  }
  index = me.indexOfKey(key);
  me.items[index] = o;
  me.map[key] = o;
  me.fireEvent('replace', key, old, o);
  return o;
}, addAll:function(objs) {
  var me = this, i = 0, args, len, key;
  if (arguments.length > 1 || Ext.isArray(objs)) {
    args = arguments.length > 1 ? arguments : objs;
    for (len = args.length; i < len; i++) {
      me.add(args[i]);
    }
  } else {
    for (key in objs) {
      if (objs.hasOwnProperty(key)) {
        if (me.allowFunctions || typeof objs[key] != 'function') {
          me.add(key, objs[key]);
        }
      }
    }
  }
}, each:function(fn, scope) {
  var items = [].concat(this.items), i = 0, len = items.length, item;
  for (; i < len; i++) {
    item = items[i];
    if (fn.call(scope || item, item, i, len) === false) {
      break;
    }
  }
}, eachKey:function(fn, scope) {
  var keys = this.keys, items = this.items, i = 0, len = keys.length;
  for (; i < len; i++) {
    fn.call(scope || window, keys[i], items[i], i, len);
  }
}, findBy:function(fn, scope) {
  var keys = this.keys, items = this.items, i = 0, len = items.length;
  for (; i < len; i++) {
    if (fn.call(scope || window, items[i], keys[i])) {
      return items[i];
    }
  }
  return null;
}, insert:function(index, key, obj) {
  var me = this, myKey = key, myObj = obj;
  if (arguments.length == 2) {
    myObj = myKey;
    myKey = me.getKey(myObj);
  }
  if (me.containsKey(myKey)) {
    me.suspendEvents();
    me.removeAtKey(myKey);
    me.resumeEvents();
  }
  if (index >= me.length) {
    return me.add(myKey, myObj);
  }
  me.length++;
  Ext.Array.splice(me.items, index, 0, myObj);
  if (typeof myKey != 'undefined' && myKey !== null) {
    me.map[myKey] = myObj;
  }
  Ext.Array.splice(me.keys, index, 0, myKey);
  me.fireEvent('add', index, myObj, myKey);
  return myObj;
}, remove:function(o) {
  return this.removeAt(this.indexOf(o));
}, removeAll:function(items) {
  Ext.each(items || [], function(item) {
    this.remove(item);
  }, this);
  return this;
}, removeAt:function(index) {
  var me = this, o, key;
  if (index < me.length && index >= 0) {
    me.length--;
    o = me.items[index];
    Ext.Array.erase(me.items, index, 1);
    key = me.keys[index];
    if (typeof key != 'undefined') {
      delete me.map[key];
    }
    Ext.Array.erase(me.keys, index, 1);
    me.fireEvent('remove', o, key);
    return o;
  }
  return false;
}, removeAtKey:function(key) {
  return this.removeAt(this.indexOfKey(key));
}, getCount:function() {
  return this.length;
}, indexOf:function(o) {
  return Ext.Array.indexOf(this.items, o);
}, indexOfKey:function(key) {
  return Ext.Array.indexOf(this.keys, key);
}, get:function(key) {
  var me = this, mk = me.map[key], item = mk !== undefined ? mk : typeof key == 'number' ? me.items[key] : undefined;
  return typeof item != 'function' || me.allowFunctions ? item : null;
}, getAt:function(index) {
  return this.items[index];
}, getByKey:function(key) {
  return this.map[key];
}, contains:function(o) {
  return Ext.Array.contains(this.items, o);
}, containsKey:function(key) {
  return typeof this.map[key] != 'undefined';
}, clear:function() {
  var me = this;
  me.length = 0;
  me.items = [];
  me.keys = [];
  me.map = {};
  me.fireEvent('clear');
}, first:function() {
  return this.items[0];
}, last:function() {
  return this.items[this.length - 1];
}, sum:function(property, root, start, end) {
  var values = this.extractValues(property, root), length = values.length, sum = 0, i;
  start = start || 0;
  end = end || end === 0 ? end : length - 1;
  for (i = start; i <= end; i++) {
    sum += values[i];
  }
  return sum;
}, collect:function(property, root, allowNull) {
  var values = this.extractValues(property, root), length = values.length, hits = {}, unique = [], value, strValue, i;
  for (i = 0; i < length; i++) {
    value = values[i];
    strValue = String(value);
    if ((allowNull || !Ext.isEmpty(value)) && !hits[strValue]) {
      hits[strValue] = true;
      unique.push(value);
    }
  }
  return unique;
}, extractValues:function(property, root) {
  var values = this.items;
  if (root) {
    values = Ext.Array.pluck(values, root);
  }
  return Ext.Array.pluck(values, property);
}, getRange:function(start, end) {
  var me = this, items = me.items, range = [], i;
  if (items.length < 1) {
    return range;
  }
  start = start || 0;
  end = Math.min(typeof end == 'undefined' ? me.length - 1 : end, me.length - 1);
  if (start <= end) {
    for (i = start; i <= end; i++) {
      range[range.length] = items[i];
    }
  } else {
    for (i = start; i >= end; i--) {
      range[range.length] = items[i];
    }
  }
  return range;
}, filter:function(property, value, anyMatch, caseSensitive) {
  var filters = [], filterFn;
  if (Ext.isString(property)) {
    filters.push(Ext.create('Ext.util.Filter', {property:property, value:value, anyMatch:anyMatch, caseSensitive:caseSensitive}));
  } else {
    if (Ext.isArray(property) || property instanceof Ext.util.Filter) {
      filters = filters.concat(property);
    }
  }
  filterFn = function(record) {
    var isMatch = true, length = filters.length, i;
    for (i = 0; i < length; i++) {
      var filter = filters[i], fn = filter.getFilterFn(), scope = filter.getScope();
      isMatch = isMatch && fn.call(scope, record);
    }
    return isMatch;
  };
  return this.filterBy(filterFn);
}, filterBy:function(fn, scope) {
  var me = this, newMC = new this.self, keys = me.keys, items = me.items, length = items.length, i;
  newMC.getKey = me.getKey;
  for (i = 0; i < length; i++) {
    if (fn.call(scope || me, items[i], keys[i])) {
      newMC.add(keys[i], items[i]);
    }
  }
  return newMC;
}, findIndex:function(property, value, start, anyMatch, caseSensitive) {
  if (Ext.isEmpty(value, false)) {
    return -1;
  }
  value = this.createValueMatcher(value, anyMatch, caseSensitive);
  return this.findIndexBy(function(o) {
    return o && value.test(o[property]);
  }, null, start);
}, findIndexBy:function(fn, scope, start) {
  var me = this, keys = me.keys, items = me.items, i = start || 0, len = items.length;
  for (; i < len; i++) {
    if (fn.call(scope || me, items[i], keys[i])) {
      return i;
    }
  }
  return -1;
}, createValueMatcher:function(value, anyMatch, caseSensitive, exactMatch) {
  if (!value.exec) {
    var er = Ext.String.escapeRegex;
    value = String(value);
    if (anyMatch === true) {
      value = er(value);
    } else {
      value = '^' + er(value);
      if (exactMatch === true) {
        value += '$';
      }
    }
    value = new RegExp(value, caseSensitive ? '' : 'i');
  }
  return value;
}, clone:function() {
  var me = this, copy = new this.self, keys = me.keys, items = me.items, i = 0, len = items.length;
  for (; i < len; i++) {
    copy.add(keys[i], items[i]);
  }
  copy.getKey = me.getKey;
  return copy;
}}, 1, 0, 0, 0, 0, [['observable', Ext.mixin.Observable]], [Ext.util, 'AbstractMixedCollection'], 0);
Ext.cmd.derive('Ext.util.Sorter', Ext.Base, {isSorter:true, config:{property:null, sorterFn:null, root:null, transform:null, direction:'ASC', id:undefined}, constructor:function(config) {
  this.initConfig(config);
}, applyId:function(id) {
  if (!id) {
    id = this.getProperty();
    if (!id) {
      id = Ext.id(null, 'ext-sorter-');
    }
  }
  return id;
}, createSortFunction:function(sorterFn) {
  var me = this, modifier = me.getDirection().toUpperCase() == 'DESC' ? -1 : 1;
  return function(o1, o2) {
    return modifier * sorterFn.call(me, o1, o2);
  };
}, defaultSortFn:function(item1, item2) {
  var me = this, transform = me._transform, root = me._root, value1, value2, property = me._property;
  if (root !== null && root !== undefined) {
    item1 = item1[root];
    item2 = item2[root];
  }
  value1 = item1[property];
  value2 = item2[property];
  if (transform) {
    value1 = transform(value1);
    value2 = transform(value2);
  }
  return value1 > value2 ? 1 : value1 < value2 ? -1 : 0;
}, updateDirection:function() {
  this.updateSortFn();
}, updateSortFn:function() {
  this.sort = this.createSortFunction(this.getSorterFn() || this.defaultSortFn);
}, toggle:function() {
  this.setDirection(Ext.String.toggle(this.getDirection(), 'ASC', 'DESC'));
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'Sorter'], 0);
Ext.cmd.derive('Ext.util.Sortable', Ext.mixin.Mixin, {isSortable:true, mixinConfig:{hooks:{destroy:'destroy'}}, defaultSortDirection:'ASC', initSortable:function() {
  var me = this, sorters = me.sorters;
  me.sorters = Ext.create('Ext.util.AbstractMixedCollection', false, function(item) {
    return item.id || item.property;
  });
  if (sorters) {
    me.sorters.addAll(me.decodeSorters(sorters));
  }
}, sort:function(sorters, direction, where, doSort) {
  var me = this, sorter, sorterFn, newSorters;
  if (Ext.isArray(sorters)) {
    doSort = where;
    where = direction;
    newSorters = sorters;
  } else {
    if (Ext.isObject(sorters)) {
      doSort = where;
      where = direction;
      newSorters = [sorters];
    } else {
      if (Ext.isString(sorters)) {
        sorter = me.sorters.get(sorters);
        if (!sorter) {
          sorter = {property:sorters, direction:direction};
          newSorters = [sorter];
        } else {
          if (direction === undefined) {
            sorter.toggle();
          } else {
            sorter.setDirection(direction);
          }
        }
      }
    }
  }
  if (newSorters && newSorters.length) {
    newSorters = me.decodeSorters(newSorters);
    if (Ext.isString(where)) {
      if (where === 'prepend') {
        sorters = me.sorters.clone().items;
        me.sorters.clear();
        me.sorters.addAll(newSorters);
        me.sorters.addAll(sorters);
      } else {
        me.sorters.addAll(newSorters);
      }
    } else {
      me.sorters.clear();
      me.sorters.addAll(newSorters);
    }
    if (doSort !== false) {
      me.onBeforeSort(newSorters);
    }
  }
  if (doSort !== false) {
    sorters = me.sorters.items;
    if (sorters.length) {
      sorterFn = function(r1, r2) {
        var result = sorters[0].sort(r1, r2), length = sorters.length, i;
        for (i = 1; i < length; i++) {
          result = result || sorters[i].sort.call(this, r1, r2);
        }
        return result;
      };
      me.doSort(sorterFn);
    }
  }
  return sorters;
}, onBeforeSort:Ext.emptyFn, decodeSorters:function(sorters) {
  if (!Ext.isArray(sorters)) {
    if (sorters === undefined) {
      sorters = [];
    } else {
      sorters = [sorters];
    }
  }
  var length = sorters.length, Sorter = Ext.util.Sorter, fields = this.model ? this.model.prototype.fields : null, field, config, i;
  for (i = 0; i < length; i++) {
    config = sorters[i];
    if (!(config instanceof Sorter)) {
      if (Ext.isString(config)) {
        config = {property:config};
      }
      Ext.applyIf(config, {root:this.sortRoot, direction:'ASC'});
      if (config.fn) {
        config.sorterFn = config.fn;
      }
      if (typeof config == 'function') {
        config = {sorterFn:config};
      }
      if (fields && !config.transform) {
        field = fields.get(config.property);
        config.transform = field ? field.sortType : undefined;
      }
      sorters[i] = Ext.create('Ext.util.Sorter', config);
    }
  }
  return sorters;
}, getSorters:function() {
  return this.sorters.items;
}, destroy:function() {
  this.callSuper();
  Ext.destroy(this.sorters);
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Sortable'], 0);
Ext.cmd.derive('Ext.util.MixedCollection', Ext.util.AbstractMixedCollection, {constructor:function() {
  var me = this;
  Ext.util.AbstractMixedCollection.prototype.constructor.apply(this, arguments);
  me.mixins.sortable.initSortable.call(me);
}, doSort:function(sorterFn) {
  this.sortBy(sorterFn);
}, _sort:function(property, dir, fn) {
  var me = this, i, len, dsc = String(dir).toUpperCase() == 'DESC' ? -1 : 1, c = [], keys = me.keys, items = me.items;
  fn = fn || function(a, b) {
    return a - b;
  };
  for (i = 0, len = items.length; i < len; i++) {
    c[c.length] = {key:keys[i], value:items[i], index:i};
  }
  Ext.Array.sort(c, function(a, b) {
    var v = fn(a[property], b[property]) * dsc;
    if (v === 0) {
      v = a.index < b.index ? -1 : 1;
    }
    return v;
  });
  for (i = 0, len = c.length; i < len; i++) {
    items[i] = c[i].value;
    keys[i] = c[i].key;
  }
  me.fireEvent('sort', me);
}, sortBy:function(sorterFn) {
  var me = this, items = me.items, keys = me.keys, length = items.length, temp = [], i;
  for (i = 0; i < length; i++) {
    temp[i] = {key:keys[i], value:items[i], index:i};
  }
  Ext.Array.sort(temp, function(a, b) {
    var v = sorterFn(a.value, b.value);
    if (v === 0) {
      v = a.index < b.index ? -1 : 1;
    }
    return v;
  });
  for (i = 0; i < length; i++) {
    items[i] = temp[i].value;
    keys[i] = temp[i].key;
  }
  me.fireEvent('sort', me, items, keys);
}, reorder:function(mapping) {
  var me = this, items = me.items, index = 0, length = items.length, order = [], remaining = [], oldIndex;
  me.suspendEvents();
  for (oldIndex in mapping) {
    order[mapping[oldIndex]] = items[oldIndex];
  }
  for (index = 0; index < length; index++) {
    if (mapping[index] == undefined) {
      remaining.push(items[index]);
    }
  }
  for (index = 0; index < length; index++) {
    if (order[index] == undefined) {
      order[index] = remaining.shift();
    }
  }
  me.clear();
  me.addAll(order);
  me.resumeEvents();
  me.fireEvent('sort', me);
}, sortByKey:function(dir, fn) {
  this._sort('key', dir, fn || function(a, b) {
    var v1 = String(a).toUpperCase(), v2 = String(b).toUpperCase();
    return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
  });
}}, 1, 0, 0, 0, 0, [['sortable', Ext.util.Sortable]], [Ext.util, 'MixedCollection'], 0);
Ext.cmd.derive('Ext.ItemCollection', Ext.util.MixedCollection, {getKey:function(item) {
  return item.getItemId();
}, has:function(item) {
  return this.map.hasOwnProperty(item.getId());
}}, 0, 0, 0, 0, 0, 0, [Ext, 'ItemCollection'], 0);
Ext.cmd.derive('Ext.fx.easing.Momentum', Ext.fx.easing.Abstract, {config:{acceleration:30, friction:0, startVelocity:0}, alpha:0, updateFriction:function(friction) {
  var theta = Math.log(1 - friction / 10);
  this.theta = theta;
  this.alpha = theta / this.getAcceleration();
}, updateStartVelocity:function(velocity) {
  this.velocity = velocity * this.getAcceleration();
}, updateAcceleration:function(acceleration) {
  this.velocity = this.getStartVelocity() * acceleration;
  this.alpha = this.theta / acceleration;
}, getValue:function() {
  return this.getStartValue() - this.velocity * (1 - this.getFrictionFactor()) / this.theta;
}, getFrictionFactor:function() {
  var deltaTime = Ext.Date.now() - this.getStartTime();
  return Math.exp(deltaTime * this.alpha);
}, getVelocity:function() {
  return this.getFrictionFactor() * this.velocity;
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.easing, 'Momentum'], 0);
Ext.cmd.derive('Ext.fx.easing.Bounce', Ext.fx.easing.Abstract, {config:{springTension:0.3, acceleration:30, startVelocity:0}, getValue:function() {
  var deltaTime = Ext.Date.now() - this.getStartTime(), theta = deltaTime / this.getAcceleration(), powTime = theta * Math.pow(Math.E, -this.getSpringTension() * theta);
  return this.getStartValue() + this.getStartVelocity() * powTime;
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.easing, 'Bounce'], 0);
Ext.cmd.derive('Ext.fx.easing.BoundMomentum', Ext.fx.easing.Abstract, {config:{momentum:null, bounce:null, minMomentumValue:0, maxMomentumValue:0, minVelocity:0.01, startVelocity:0}, applyMomentum:function(config, currentEasing) {
  return Ext.factory(config, Ext.fx.easing.Momentum, currentEasing);
}, applyBounce:function(config, currentEasing) {
  return Ext.factory(config, Ext.fx.easing.Bounce, currentEasing);
}, updateStartTime:function(startTime) {
  this.getMomentum().setStartTime(startTime);
  Ext.fx.easing.Abstract.prototype.updateStartTime.apply(this, arguments);
}, updateStartVelocity:function(startVelocity) {
  this.getMomentum().setStartVelocity(startVelocity);
}, updateStartValue:function(startValue) {
  this.getMomentum().setStartValue(startValue);
}, reset:function() {
  this.lastValue = null;
  this.isBouncingBack = false;
  this.isOutOfBound = false;
  return Ext.fx.easing.Abstract.prototype.reset.apply(this, arguments);
}, getValue:function() {
  var momentum = this.getMomentum(), bounce = this.getBounce(), startVelocity = momentum.getStartVelocity(), direction = startVelocity > 0 ? 1 : -1, minValue = this.getMinMomentumValue(), maxValue = this.getMaxMomentumValue(), boundedValue = direction == 1 ? maxValue : minValue, lastValue = this.lastValue, value, velocity;
  if (startVelocity === 0) {
    return this.getStartValue();
  }
  if (!this.isOutOfBound) {
    value = momentum.getValue();
    velocity = momentum.getVelocity();
    if (Math.abs(velocity) < this.getMinVelocity()) {
      this.isEnded = true;
    }
    if (value >= minValue && value <= maxValue) {
      return value;
    }
    this.isOutOfBound = true;
    bounce.setStartTime(Ext.Date.now()).setStartVelocity(velocity).setStartValue(boundedValue);
  }
  value = bounce.getValue();
  if (!this.isEnded) {
    if (!this.isBouncingBack) {
      if (lastValue !== null) {
        if (direction == 1 && value < lastValue || direction == -1 && value > lastValue) {
          this.isBouncingBack = true;
        }
      }
    } else {
      if (Math.round(value) == boundedValue) {
        this.isEnded = true;
      }
    }
  }
  this.lastValue = value;
  return value;
}}, 0, 0, 0, 0, 0, 0, [Ext.fx.easing, 'BoundMomentum'], 0);
Ext.cmd.derive('Ext.fx.easing.EaseOut', Ext.fx.easing.Linear, {config:{exponent:4, duration:1500}, getValue:function() {
  var deltaTime = Ext.Date.now() - this.getStartTime(), duration = this.getDuration(), startValue = this.getStartValue(), endValue = this.getEndValue(), distance = this.distance, theta = deltaTime / duration, thetaC = 1 - theta, thetaEnd = 1 - Math.pow(thetaC, this.getExponent()), currentValue = startValue + thetaEnd * distance;
  if (deltaTime >= duration) {
    this.isEnded = true;
    return endValue;
  }
  return currentValue;
}}, 0, 0, 0, 0, ['easing.ease-out'], 0, [Ext.fx.easing, 'EaseOut'], 0);
Ext.cmd.derive('Ext.scroll.Scroller', Ext.Evented, {config:{element:null, direction:'auto', fps:'auto', disabled:null, directionLock:false, momentumEasing:{momentum:{acceleration:30, friction:0.5}, bounce:{acceleration:30, springTension:0.3}, minVelocity:1}, bounceEasing:{duration:400}, outOfBoundRestrictFactor:0.5, startMomentumResetTime:300, maxAbsoluteVelocity:6, containerSize:'auto', size:'auto', autoRefresh:true, initialOffset:{x:0, y:0}, slotSnapSize:{x:0, y:0}, slotSnapOffset:{x:0, y:0}, slotSnapEasing:{duration:150}, 
translatable:{translationMethod:'auto', useWrapper:false}}, cls:'x-scroll-scroller', containerCls:'x-scroll-container', dragStartTime:0, dragEndTime:0, isDragging:false, isAnimating:false, constructor:function(config) {
  var element = config && config.element;
  this.listeners = {scope:this, touchstart:'onTouchStart', touchend:'onTouchEnd', dragstart:'onDragStart', drag:'onDrag', dragend:'onDragEnd'};
  this.minPosition = {x:0, y:0};
  this.startPosition = {x:0, y:0};
  this.position = {x:0, y:0};
  this.velocity = {x:0, y:0};
  this.isAxisEnabledFlags = {x:false, y:false};
  this.flickStartPosition = {x:0, y:0};
  this.flickStartTime = {x:0, y:0};
  this.lastDragPosition = {x:0, y:0};
  this.dragDirection = {x:0, y:0};
  this.initialConfig = config;
  if (element) {
    this.setElement(element);
  }
  return this;
}, applyElement:function(element) {
  if (!element) {
    return;
  }
  return Ext.get(element);
}, updateElement:function(element) {
  this.initialize();
  if (!this.FixedHBoxStretching) {
    element.addCls(this.cls);
  }
  if (!this.getDisabled()) {
    this.attachListeneners();
  }
  this.onConfigUpdate(['containerSize', 'size'], 'refreshMaxPosition');
  this.on('maxpositionchange', 'snapToBoundary');
  this.on('minpositionchange', 'snapToBoundary');
  return this;
}, applyTranslatable:function(config, translatable) {
  return Ext.factory(config, Ext.util.Translatable, translatable);
}, updateTranslatable:function(translatable) {
  translatable.setConfig({element:this.getElement(), listeners:{animationframe:'onAnimationFrame', animationend:'onAnimationEnd', scope:this}});
}, updateFps:function(fps) {
  if (fps !== 'auto') {
    this.getTranslatable().setFps(fps);
  }
}, attachListeneners:function() {
  this.getContainer().on(this.listeners);
}, detachListeners:function() {
  this.getContainer().un(this.listeners);
}, updateDisabled:function(disabled) {
  if (disabled) {
    this.detachListeners();
  } else {
    this.attachListeneners();
  }
}, updateInitialOffset:function(initialOffset) {
  if (typeof initialOffset == 'number') {
    initialOffset = {x:initialOffset, y:initialOffset};
  }
  var position = this.position, x, y;
  position.x = x = initialOffset.x;
  position.y = y = initialOffset.y;
  this.getTranslatable().translate(-x, -y);
}, applyDirection:function(direction) {
  var minPosition = this.getMinPosition(), maxPosition = this.getMaxPosition(), isHorizontal, isVertical;
  this.givenDirection = direction;
  if (direction === 'auto') {
    isHorizontal = maxPosition.x > minPosition.x;
    isVertical = maxPosition.y > minPosition.y;
    if (isHorizontal && isVertical) {
      direction = 'both';
    } else {
      if (isHorizontal) {
        direction = 'horizontal';
      } else {
        direction = 'vertical';
      }
    }
  }
  return direction;
}, updateDirection:function(direction, oldDirection) {
  var isAxisEnabledFlags = this.isAxisEnabledFlags, verticalCls = this.cls + '-vertical', horizontalCls = this.cls + '-horizontal', element = this.getElement();
  if (oldDirection === 'both' || oldDirection === 'horizontal') {
    element.removeCls(horizontalCls);
  }
  if (oldDirection === 'both' || oldDirection === 'vertical') {
    element.removeCls(verticalCls);
  }
  isAxisEnabledFlags.x = isAxisEnabledFlags.y = false;
  if (direction === 'both' || direction === 'horizontal') {
    isAxisEnabledFlags.x = true;
    element.addCls(horizontalCls);
  }
  if (direction === 'both' || direction === 'vertical') {
    isAxisEnabledFlags.y = true;
    element.addCls(verticalCls);
  }
}, isAxisEnabled:function(axis) {
  this.getDirection();
  return this.isAxisEnabledFlags[axis];
}, applyMomentumEasing:function(easing) {
  var defaultClass = Ext.fx.easing.BoundMomentum;
  return {x:Ext.factory(easing, defaultClass), y:Ext.factory(easing, defaultClass)};
}, applyBounceEasing:function(easing) {
  var defaultClass = Ext.fx.easing.EaseOut;
  return {x:Ext.factory(easing, defaultClass), y:Ext.factory(easing, defaultClass)};
}, updateBounceEasing:function(easing) {
  this.getTranslatable().setEasingX(easing.x).setEasingY(easing.y);
}, applySlotSnapEasing:function(easing) {
  var defaultClass = Ext.fx.easing.EaseOut;
  return {x:Ext.factory(easing, defaultClass), y:Ext.factory(easing, defaultClass)};
}, getMinPosition:function() {
  var minPosition = this.minPosition;
  if (!minPosition) {
    this.minPosition = minPosition = {x:0, y:0};
    this.fireEvent('minpositionchange', this, minPosition);
  }
  return minPosition;
}, getMaxPosition:function() {
  var maxPosition = this.maxPosition, size, containerSize;
  if (!maxPosition) {
    size = this.getSize();
    containerSize = this.getContainerSize();
    this.maxPosition = maxPosition = {x:Math.max(0, size.x - containerSize.x), y:Math.max(0, size.y - containerSize.y)};
    this.fireEvent('maxpositionchange', this, maxPosition);
  }
  return maxPosition;
}, refreshMaxPosition:function() {
  this.maxPosition = null;
  this.getMaxPosition();
}, applyContainerSize:function(size) {
  var containerDom = this.getContainer().dom, x, y;
  if (!containerDom) {
    return;
  }
  this.givenContainerSize = size;
  if (size === 'auto') {
    x = containerDom.offsetWidth;
    y = containerDom.offsetHeight;
  } else {
    x = size.x;
    y = size.y;
  }
  return {x:x, y:y};
}, applySize:function(size) {
  var dom = this.getElement().dom, x, y;
  if (!dom) {
    return;
  }
  this.givenSize = size;
  if (size === 'auto') {
    x = dom.offsetWidth;
    y = dom.offsetHeight;
  } else {
    if (typeof size == 'number') {
      x = size;
      y = size;
    } else {
      x = size.x;
      y = size.y;
    }
  }
  return {x:x, y:y};
}, updateAutoRefresh:function(autoRefresh) {
  this.getElement().toggleListener(autoRefresh, 'resize', 'onElementResize', this);
  this.getContainer().toggleListener(autoRefresh, 'resize', 'onContainerResize', this);
}, applySlotSnapSize:function(snapSize) {
  if (typeof snapSize == 'number') {
    return {x:snapSize, y:snapSize};
  }
  return snapSize;
}, applySlotSnapOffset:function(snapOffset) {
  if (typeof snapOffset == 'number') {
    return {x:snapOffset, y:snapOffset};
  }
  return snapOffset;
}, getContainer:function() {
  var container = this.container, element;
  if (!container) {
    element = this.getElement().getParent();
    this.container = container = this.FixedHBoxStretching ? element.getParent() : element;
    container.addCls(this.containerCls);
  }
  return container;
}, refresh:function() {
  this.stopAnimation();
  this.getTranslatable().refresh();
  this.setSize(this.givenSize);
  this.setContainerSize(this.givenContainerSize);
  this.setDirection(this.givenDirection);
  this.fireEvent('refresh', this);
  return this;
}, onElementResize:function(element, info) {
  this.setSize({x:info.width, y:info.height});
  this.refresh();
}, onContainerResize:function(container, info) {
  this.setContainerSize({x:info.width, y:info.height});
  this.refresh();
}, scrollTo:function(x, y, animation) {
  if (this.isDestroyed) {
    return this;
  }
  var translatable = this.getTranslatable(), position = this.position, positionChanged = false, translationX, translationY;
  if (this.isAxisEnabled('x')) {
    if (isNaN(x) || typeof x != 'number') {
      x = position.x;
    } else {
      if (position.x !== x) {
        position.x = x;
        positionChanged = true;
      }
    }
    translationX = -x;
  }
  if (this.isAxisEnabled('y')) {
    if (isNaN(y) || typeof y != 'number') {
      y = position.y;
    } else {
      if (position.y !== y) {
        position.y = y;
        positionChanged = true;
      }
    }
    translationY = -y;
  }
  if (positionChanged) {
    if (animation !== undefined && animation !== false) {
      translatable.translateAnimated(translationX, translationY, animation);
    } else {
      this.fireEvent('scroll', this, position.x, position.y);
      translatable.translate(translationX, translationY);
    }
  }
  return this;
}, scrollToTop:function(animation) {
  var initialOffset = this.getInitialOffset();
  return this.scrollTo(initialOffset.x, initialOffset.y, animation);
}, scrollToEnd:function(animation) {
  var size = this.getSize(), cntSize = this.getContainerSize();
  return this.scrollTo(size.x - cntSize.x, size.y - cntSize.y, animation);
}, scrollBy:function(x, y, animation) {
  var position = this.position;
  x = typeof x == 'number' ? x + position.x : null;
  y = typeof y == 'number' ? y + position.y : null;
  return this.scrollTo(x, y, animation);
}, onTouchStart:function() {
  this.isTouching = true;
  this.stopAnimation();
}, onTouchEnd:function() {
  var position = this.position;
  this.isTouching = false;
  if (!this.isDragging && this.snapToSlot()) {
    this.fireEvent('scrollstart', this, position.x, position.y);
  }
}, onDragStart:function(e) {
  var direction = this.getDirection(), absDeltaX = e.absDeltaX, absDeltaY = e.absDeltaY, directionLock = this.getDirectionLock(), startPosition = this.startPosition, flickStartPosition = this.flickStartPosition, flickStartTime = this.flickStartTime, lastDragPosition = this.lastDragPosition, currentPosition = this.position, dragDirection = this.dragDirection, x = currentPosition.x, y = currentPosition.y, now = Ext.Date.now();
  this.isDragging = true;
  if (directionLock && direction !== 'both') {
    if (direction === 'horizontal' && absDeltaX > absDeltaY || direction === 'vertical' && absDeltaY > absDeltaX) {
      e.stopPropagation();
    } else {
      this.isDragging = false;
      return;
    }
  }
  lastDragPosition.x = x;
  lastDragPosition.y = y;
  flickStartPosition.x = x;
  flickStartPosition.y = y;
  startPosition.x = x;
  startPosition.y = y;
  flickStartTime.x = now;
  flickStartTime.y = now;
  dragDirection.x = 0;
  dragDirection.y = 0;
  this.dragStartTime = now;
  this.isDragging = true;
  this.fireEvent('scrollstart', this, x, y);
}, onAxisDrag:function(axis, delta) {
  if (!this.isAxisEnabled(axis)) {
    return;
  }
  var flickStartPosition = this.flickStartPosition, flickStartTime = this.flickStartTime, lastDragPosition = this.lastDragPosition, dragDirection = this.dragDirection, old = this.position[axis], min = this.getMinPosition()[axis], max = this.getMaxPosition()[axis], start = this.startPosition[axis], last = lastDragPosition[axis], current = start - delta, lastDirection = dragDirection[axis], restrictFactor = this.getOutOfBoundRestrictFactor(), startMomentumResetTime = this.getStartMomentumResetTime(), 
  now = Ext.Date.now(), distance;
  if (current < min) {
    current *= restrictFactor;
  } else {
    if (current > max) {
      distance = current - max;
      current = max + distance * restrictFactor;
    }
  }
  if (current > last) {
    dragDirection[axis] = 1;
  } else {
    if (current < last) {
      dragDirection[axis] = -1;
    }
  }
  if (lastDirection !== 0 && dragDirection[axis] !== lastDirection || now - flickStartTime[axis] > startMomentumResetTime) {
    flickStartPosition[axis] = old;
    flickStartTime[axis] = now;
  }
  lastDragPosition[axis] = current;
}, onDrag:function(e) {
  if (!this.isDragging) {
    return;
  }
  var lastDragPosition = this.lastDragPosition;
  this.onAxisDrag('x', e.deltaX);
  this.onAxisDrag('y', e.deltaY);
  this.scrollTo(lastDragPosition.x, lastDragPosition.y);
}, onDragEnd:function(e) {
  var easingX, easingY;
  if (!this.isDragging) {
    return;
  }
  this.dragEndTime = Ext.Date.now();
  this.onDrag(e);
  this.isDragging = false;
  easingX = this.getAnimationEasing('x', e);
  easingY = this.getAnimationEasing('y', e);
  if (easingX || easingY) {
    this.getTranslatable().animate(easingX, easingY);
  } else {
    this.onScrollEnd();
  }
}, getAnimationEasing:function(axis, e) {
  if (!this.isAxisEnabled(axis)) {
    return null;
  }
  var currentPosition = this.position[axis], minPosition = this.getMinPosition()[axis], maxPosition = this.getMaxPosition()[axis], maxAbsVelocity = this.getMaxAbsoluteVelocity(), boundValue = null, dragEndTime = this.dragEndTime, velocity = e.flick.velocity[axis], easing;
  if (currentPosition < minPosition) {
    boundValue = minPosition;
  } else {
    if (currentPosition > maxPosition) {
      boundValue = maxPosition;
    }
  }
  if (boundValue !== null) {
    easing = this.getBounceEasing()[axis];
    easing.setConfig({startTime:dragEndTime, startValue:-currentPosition, endValue:-boundValue});
    return easing;
  }
  if (velocity === 0) {
    return null;
  }
  if (velocity < -maxAbsVelocity) {
    velocity = -maxAbsVelocity;
  } else {
    if (velocity > maxAbsVelocity) {
      velocity = maxAbsVelocity;
    }
  }
  if (Ext.browser.is.IE) {
    velocity *= 2;
  }
  easing = this.getMomentumEasing()[axis];
  easing.setConfig({startTime:dragEndTime, startValue:-currentPosition, startVelocity:velocity * 1.5, minMomentumValue:-maxPosition, maxMomentumValue:0});
  return easing;
}, onAnimationFrame:function(translatable, x, y) {
  var position = this.position;
  position.x = -x;
  position.y = -y;
  this.fireEvent('scroll', this, position.x, position.y);
}, onAnimationEnd:function() {
  this.snapToBoundary();
  this.onScrollEnd();
}, stopAnimation:function() {
  this.getTranslatable().stopAnimation();
}, onScrollEnd:function() {
  var position = this.position;
  if (this.isTouching || !this.snapToSlot()) {
    this.fireEvent('scrollend', this, position.x, position.y);
  }
}, snapToSlot:function() {
  var snapX = this.getSnapPosition('x'), snapY = this.getSnapPosition('y'), easing = this.getSlotSnapEasing();
  if (snapX !== null || snapY !== null) {
    this.scrollTo(snapX, snapY, {easingX:easing.x, easingY:easing.y});
    return true;
  }
  return false;
}, getSnapPosition:function(axis) {
  var snapSize = this.getSlotSnapSize()[axis], snapPosition = null, position, snapOffset, maxPosition, mod;
  if (snapSize !== 0 && this.isAxisEnabled(axis)) {
    position = this.position[axis];
    snapOffset = this.getSlotSnapOffset()[axis];
    maxPosition = this.getMaxPosition()[axis];
    mod = Math.floor((position - snapOffset) % snapSize);
    if (mod !== 0) {
      if (position !== maxPosition) {
        if (Math.abs(mod) > snapSize / 2) {
          snapPosition = Math.min(maxPosition, position + (mod > 0 ? snapSize - mod : mod - snapSize));
        } else {
          snapPosition = position - mod;
        }
      } else {
        snapPosition = position - mod;
      }
    }
  }
  return snapPosition;
}, snapToBoundary:function() {
  var position = this.position, minPosition = this.getMinPosition(), maxPosition = this.getMaxPosition(), minX = minPosition.x, minY = minPosition.y, maxX = maxPosition.x, maxY = maxPosition.y, x = Math.round(position.x), y = Math.round(position.y);
  if (x < minX) {
    x = minX;
  } else {
    if (x > maxX) {
      x = maxX;
    }
  }
  if (y < minY) {
    y = minY;
  } else {
    if (y > maxY) {
      y = maxY;
    }
  }
  this.scrollTo(x, y);
}, destroy:function() {
  var element = this.getElement(), sizeMonitors = this.sizeMonitors, container;
  if (sizeMonitors) {
    sizeMonitors.element.destroy();
    sizeMonitors.container.destroy();
  }
  if (element && !element.isDestroyed) {
    element.removeCls(this.cls);
    container = this.getContainer();
    if (container && !container.isDestroyed) {
      container.removeCls(this.containerCls);
    }
  }
  Ext.destroy(this.getTranslatable());
  Ext.Evented.prototype.destroy.apply(this, arguments);
}}, 1, 0, 0, 0, 0, 0, [Ext.scroll, 'Scroller'], function() {
});
(function() {
  var lastTime = 0, vendors = ['ms', 'moz', 'webkit', 'o'], ln = vendors.length, i, vendor;
  for (i = 0; i < ln && !window.requestAnimationFrame; ++i) {
    vendor = vendors[i];
    if (window[vendor + 'RequestAnimationFrame']) {
      window.requestAnimationFrame = window[vendor + 'RequestAnimationFrame'];
      window.cancelAnimationFrame = window[vendor + 'CancelAnimationFrame'] || window[vendor + 'CancelRequestAnimationFrame'];
    }
  }
  if (!window.Ext) {
    window.Ext = {};
  }
  Ext.performance = {};
  if (window.performance && window.performance.now) {
    Ext.performance.now = function() {
      return window.performance.now();
    };
  } else {
    Ext.performance.now = function() {
      return Date.now();
    };
  }
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback) {
      var currTime = Ext.performance.now(), timeToCall = Math.max(0, 16 - (currTime - lastTime)), id = window.setTimeout(function() {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  } else {
    Ext.trueRequestAnimationFrames = true;
  }
  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
  }
})();
(function(global) {
  Ext.cmd.derive('Ext.AnimationQueue', Ext.Base, {singleton:true, constructor:function() {
    var bind = Ext.Function.bind;
    this.queue = [];
    this.taskQueue = [];
    this.runningQueue = [];
    this.idleQueue = [];
    this.isRunning = false;
    this.isIdle = true;
    this.run = bind(this.run, this);
    this.whenIdle = bind(this.whenIdle, this);
    this.processIdleQueueItem = bind(this.processIdleQueueItem, this);
    this.processTaskQueueItem = bind(this.processTaskQueueItem, this);
    if (Ext.os.is.iOS) {
      setInterval(this.watch, 500);
    }
  }, start:function(fn, scope, args) {
    this.queue.push(arguments);
    if (!this.isRunning) {
      if (this.hasOwnProperty('idleTimer')) {
        clearTimeout(this.idleTimer);
        delete this.idleTimer;
      }
      if (this.hasOwnProperty('idleQueueTimer')) {
        clearTimeout(this.idleQueueTimer);
        delete this.idleQueueTimer;
      }
      this.isIdle = false;
      this.isRunning = true;
      this.doStart();
    }
  }, watch:function() {
    if (this.isRunning && Date.now() - this.lastRunTime >= 500) {
      this.run();
    }
  }, run:function() {
    if (!this.isRunning) {
      return;
    }
    var queue = this.runningQueue, i, ln;
    this.lastRunTime = Date.now();
    this.frameStartTime = Ext.performance.now();
    queue.push.apply(queue, this.queue);
    for (i = 0, ln = queue.length; i < ln; i++) {
      this.invoke(queue[i]);
    }
    queue.length = 0;
    this.doIterate();
  }, doStart:function() {
    this.animationFrameId = requestAnimationFrame(this.run);
    this.lastRunTime = Date.now();
  }, doIterate:function() {
    this.animationFrameId = requestAnimationFrame(this.run);
  }, doStop:function() {
    cancelAnimationFrame(this.animationFrameId);
  }, stop:function(fn, scope, args) {
    if (!this.isRunning) {
      return;
    }
    var queue = this.queue, ln = queue.length, i, item;
    for (i = 0; i < ln; i++) {
      item = queue[i];
      if (item[0] === fn && item[1] === scope && item[2] === args) {
        queue.splice(i, 1);
        i--;
        ln--;
      }
    }
    if (ln === 0) {
      this.doStop();
      this.isRunning = false;
      this.idleTimer = setTimeout(this.whenIdle, 100);
    }
  }, onIdle:function(fn, scope, args) {
    var listeners = this.idleQueue, i, ln, listener;
    for (i = 0, ln = listeners.length; i < ln; i++) {
      listener = listeners[i];
      if (fn === listener[0] && scope === listener[1] && args === listener[2]) {
        return;
      }
    }
    listeners.push(arguments);
    if (this.isIdle) {
      this.processIdleQueue();
    }
  }, unIdle:function(fn, scope, args) {
    var listeners = this.idleQueue, i, ln, listener;
    for (i = 0, ln = listeners.length; i < ln; i++) {
      listener = listeners[i];
      if (fn === listener[0] && scope === listener[1] && args === listener[2]) {
        listeners.splice(i, 1);
        return true;
      }
    }
    return false;
  }, queueTask:function(fn, scope, args) {
    this.taskQueue.push(arguments);
    this.processTaskQueue();
  }, dequeueTask:function(fn, scope, args) {
    var listeners = this.taskQueue, i, ln, listener;
    for (i = 0, ln = listeners.length; i < ln; i++) {
      listener = listeners[i];
      if (fn === listener[0] && scope === listener[1] && args === listener[2]) {
        listeners.splice(i, 1);
        i--;
        ln--;
      }
    }
  }, invoke:function(listener) {
    var fn = listener[0], scope = listener[1], args = listener[2];
    fn = typeof fn == 'string' ? scope[fn] : fn;
    if (Ext.isArray(args)) {
      fn.apply(scope, args);
    } else {
      fn.call(scope, args);
    }
  }, whenIdle:function() {
    this.isIdle = true;
    this.processIdleQueue();
  }, processIdleQueue:function() {
    if (!this.hasOwnProperty('idleQueueTimer')) {
      this.idleQueueTimer = setTimeout(this.processIdleQueueItem, 1);
    }
  }, processIdleQueueItem:function() {
    delete this.idleQueueTimer;
    if (!this.isIdle) {
      return;
    }
    var listeners = this.idleQueue, listener;
    if (listeners.length > 0) {
      listener = listeners.shift();
      this.invoke(listener);
      this.processIdleQueue();
    }
  }, processTaskQueue:function() {
    if (!this.hasOwnProperty('taskQueueTimer')) {
      this.taskQueueTimer = setTimeout(this.processTaskQueueItem, 15);
    }
  }, processTaskQueueItem:function() {
    delete this.taskQueueTimer;
    var listeners = this.taskQueue, listener;
    if (listeners.length > 0) {
      listener = listeners.shift();
      this.invoke(listener);
      this.processTaskQueue();
    }
  }, showFps:function() {
    if (!Ext.trueRequestAnimationFrames) {
      alert('This browser does not support requestAnimationFrame. The FPS listed will not be accurate');
    }
    Ext.onReady(function() {
      Ext.Viewport.add([{xtype:'component', bottom:50, left:0, width:50, height:20, html:'Average', style:'background-color: black; color: white; text-align: center; line-height: 20px; font-size: 8px;'}, {id:'__averageFps', xtype:'component', bottom:0, left:0, width:50, height:50, html:'0', style:'background-color: red; color: white; text-align: center; line-height: 50px;'}, {xtype:'component', bottom:50, left:50, width:50, height:20, html:'Min (Last 1k)', style:'background-color: black; color: white; text-align: center; line-height: 20px; font-size: 8px;'}, 
      {id:'__minFps', xtype:'component', bottom:0, left:50, width:50, height:50, html:'0', style:'background-color: orange; color: white; text-align: center; line-height: 50px;'}, {xtype:'component', bottom:50, left:100, width:50, height:20, html:'Max (Last 1k)', style:'background-color: black; color: white; text-align: center; line-height: 20px; font-size: 8px;'}, {id:'__maxFps', xtype:'component', bottom:0, left:100, width:50, height:50, html:'0', style:'background-color: yellow; color: black; text-align: center; line-height: 50px;'}, 
      {xtype:'component', bottom:50, left:150, width:50, height:20, html:'Current', style:'background-color: black; color: white; text-align: center; line-height: 20px; font-size: 8px;'}, {id:'__currentFps', xtype:'component', bottom:0, left:150, width:50, height:50, html:'0', style:'background-color: green; color: white; text-align: center; line-height: 50px;'}]);
      Ext.AnimationQueue.resetFps();
    });
  }, resetFps:function() {
    var currentFps = Ext.getCmp('__currentFps'), averageFps = Ext.getCmp('__averageFps'), minFps = Ext.getCmp('__minFps'), maxFps = Ext.getCmp('__maxFps'), min = 1000, max = 0, count = 0, sum = 0;
    Ext.AnimationQueue.onFpsChanged = function(fps) {
      count++;
      if (!(count % 10)) {
        min = 1000;
        max = 0;
      }
      sum += fps;
      min = Math.min(min, fps);
      max = Math.max(max, fps);
      currentFps.setHtml(Math.round(fps));
      averageFps.setHtml(Math.round(sum / count));
      minFps.setHtml(Math.round(min));
      maxFps.setHtml(Math.round(max));
    };
  }}, 1, 0, 0, 0, 0, 0, [Ext, 'AnimationQueue'], function() {
  });
})(this);
Ext.cmd.derive('Ext.TaskQueue', Ext.Base, {singleton:true, pending:false, mode:true, constructor:function() {
  this.readQueue = [];
  this.writeQueue = [];
  this.run = Ext.Function.bind(this.run, this);
  this.watch = Ext.Function.bind(this.watch, this);
  if (Ext.os.is.iOS) {
    setInterval(this.watch, 500);
  }
}, requestRead:function(fn, scope, args) {
  this.request(true);
  this.readQueue.push(arguments);
}, requestWrite:function(fn, scope, args) {
  this.request(false);
  this.writeQueue.push(arguments);
}, request:function(mode) {
  if (!this.pending) {
    this.pendingTime = Date.now();
    this.pending = true;
    this.mode = mode;
    if (mode) {
      setTimeout(this.run, 1);
    } else {
      requestAnimationFrame(this.run);
    }
  }
}, watch:function() {
  if (this.pending && Date.now() - this.pendingTime >= 500) {
    this.run();
  }
}, run:function() {
  this.pending = false;
  var readQueue = this.readQueue, writeQueue = this.writeQueue, request = null, queue;
  if (this.mode) {
    queue = readQueue;
    if (writeQueue.length > 0) {
      request = false;
    }
  } else {
    queue = writeQueue;
    if (readQueue.length > 0) {
      request = true;
    }
  }
  var tasks = queue.slice(), i, ln, task, fn, scope;
  queue.length = 0;
  for (i = 0, ln = tasks.length; i < ln; i++) {
    task = tasks[i];
    fn = task[0];
    scope = task[1];
    if (typeof fn == 'string') {
      fn = scope[fn];
    }
    if (task.length > 2) {
      fn.apply(scope, task[2]);
    } else {
      fn.call(scope);
    }
  }
  tasks.length = 0;
  if (request !== null) {
    this.request(request);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext, 'TaskQueue'], 0);
Ext.cmd.derive('Ext.scroll.indicator.Abstract', Ext.Component, {config:{baseCls:'x-scroll-indicator', axis:'x', value:null, length:null, minLength:6, hidden:true, ui:'dark', autoHide:true}, cachedConfig:{ratio:1, barCls:'x-scroll-bar', active:true}, barElement:null, barLength:0, gapLength:0, getElementConfig:function() {
  return {reference:'barElement', children:[Ext.Component.prototype.getElementConfig.call(this)]};
}, applyRatio:function(ratio) {
  if (isNaN(ratio) || ratio > 1) {
    ratio = 1;
  }
  return ratio;
}, refresh:function() {
  var bar = this.barElement, barDom = bar.dom, ratio = this.getRatio(), axis = this.getAxis(), barLength = axis === 'x' ? barDom.offsetWidth : barDom.offsetHeight, length = barLength * ratio;
  this.barLength = barLength;
  this.gapLength = barLength - length;
  this.setLength(length);
  this.updateValue(this.getValue());
}, updateBarCls:function(barCls) {
  this.barElement.addCls(barCls);
}, updateAxis:function(axis) {
  this.element.addCls(this.getBaseCls(), null, axis);
  this.barElement.addCls(this.getBarCls(), null, axis);
}, updateValue:function(value) {
  var barLength = this.barLength, gapLength = this.gapLength, length = this.getLength(), newLength, offset, extra;
  if (value <= 0) {
    offset = 0;
    this.updateLength(this.applyLength(length + value * barLength));
  } else {
    if (value >= 1) {
      extra = Math.round((value - 1) * barLength);
      newLength = this.applyLength(length - extra);
      extra = length - newLength;
      this.updateLength(newLength);
      offset = gapLength + extra;
    } else {
      offset = gapLength * value;
    }
  }
  this.setOffset(offset);
}, updateActive:function(active) {
  this.barElement[active ? 'addCls' : 'removeCls']('active');
}, doSetHidden:function(hidden) {
  var me = this;
  if (hidden) {
    me.getAutoHide() && me.setOffset(-10000);
  } else {
    delete me.lastLength;
    delete me.lastOffset;
    me.updateValue(me.getValue());
  }
}, applyLength:function(length) {
  return Math.max(this.getMinLength(), length);
}, updateLength:function(length) {
  length = Math.round(length);
  if (this.lastLength === length) {
    return;
  }
  this.lastLength = length;
  Ext.TaskQueue.requestWrite('doUpdateLength', this, [length]);
}, doUpdateLength:function(length) {
  if (!this.isDestroyed) {
    var axis = this.getAxis(), element = this.element;
    if (axis === 'x') {
      element.setWidth(length);
    } else {
      element.setHeight(length);
    }
  }
}, setOffset:function(offset) {
  offset = Math.round(offset);
  if (this.lastOffset === offset || this.lastOffset === -10000) {
    return;
  }
  this.lastOffset = offset;
  Ext.TaskQueue.requestWrite('doSetOffset', this, [offset]);
}, doSetOffset:function(offset) {
  if (!this.isDestroyed) {
    var axis = this.getAxis(), element = this.element;
    if (axis === 'x') {
      element.translate(offset, 0);
    } else {
      element.translate(0, offset);
    }
  }
}}, 0, 0, ['component'], {'component':true}, 0, 0, [Ext.scroll.indicator, 'Abstract'], 0);
Ext.cmd.derive('Ext.scroll.indicator.CssTransform', Ext.scroll.indicator.Abstract, {config:{cls:'csstransform'}}, 0, 0, ['component'], {'component':true}, 0, 0, [Ext.scroll.indicator, 'CssTransform'], 0);
Ext.cmd.derive('Ext.scroll.indicator.ScrollPosition', Ext.scroll.indicator.Abstract, {config:{cls:'scrollposition'}, getElementConfig:function() {
  var config = Ext.scroll.indicator.Abstract.prototype.getElementConfig.apply(this, arguments);
  config.children.unshift({className:'x-scroll-bar-stretcher'});
  return config;
}, updateValue:function(value) {
  if (this.gapLength === 0) {
    if (value >= 1) {
      value--;
    }
    this.setOffset(this.barLength * value);
  } else {
    this.setOffset(this.gapLength * value);
  }
}, doUpdateLength:function() {
  if (!this.isDestroyed) {
    var scrollOffset = this.barLength, element = this.element;
    Ext.scroll.indicator.Abstract.prototype.doUpdateLength.apply(this, arguments);
    if (this.getAxis() === 'x') {
      element.setLeft(scrollOffset);
    } else {
      element.setTop(scrollOffset);
    }
  }
}, doSetOffset:function(offset) {
  if (!this.isDestroyed) {
    var barLength = this.barLength, minLength = this.getMinLength(), barDom = this.barElement.dom;
    if (offset !== -10000) {
      offset = Math.min(barLength - minLength, Math.max(offset, minLength - this.getLength()));
      offset = barLength - offset;
    }
    if (this.getAxis() === 'x') {
      barDom.scrollLeft = offset;
    } else {
      barDom.scrollTop = offset;
    }
  }
}}, 0, 0, ['component'], {'component':true}, 0, 0, [Ext.scroll.indicator, 'ScrollPosition'], 0);
Ext.cmd.derive('Ext.scroll.indicator.Rounded', Ext.scroll.indicator.Abstract, {config:{cls:'rounded'}, constructor:function() {
  Ext.scroll.indicator.Abstract.prototype.constructor.apply(this, arguments);
  this.transformPropertyName = Ext.browser.getVendorProperyName('transform');
}, getElementConfig:function() {
  var config = Ext.scroll.indicator.Abstract.prototype.getElementConfig.call(this);
  config.children[0].children = [{reference:'startElement'}, {reference:'middleElement'}, {reference:'endElement'}];
  return config;
}, refresh:function() {
  var axis = this.getAxis(), startElementDom = this.startElement.dom, endElementDom = this.endElement.dom, middleElement = this.middleElement, startElementLength, endElementLength;
  if (axis === 'x') {
    startElementLength = startElementDom.offsetWidth;
    endElementLength = endElementDom.offsetWidth;
    middleElement.setLeft(startElementLength);
  } else {
    startElementLength = startElementDom.offsetHeight;
    endElementLength = endElementDom.offsetHeight;
    middleElement.setTop(startElementLength);
  }
  this.startElementLength = startElementLength;
  this.endElementLength = endElementLength;
  Ext.scroll.indicator.Abstract.prototype.refresh.call(this);
}, doUpdateLength:function(length) {
  if (!this.isDestroyed) {
    var axis = this.getAxis(), endElement = this.endElement, middleElementStyle = this.middleElement.dom.style, endElementLength = this.endElementLength, endElementOffset = length - endElementLength, middleElementLength = endElementOffset - this.startElementLength, transformPropertyName = this.transformPropertyName;
    if (axis === 'x') {
      endElement.translate(endElementOffset, 0);
      middleElementStyle[transformPropertyName] = 'translate3d(0, 0, 0) scaleX(' + middleElementLength + ')';
    } else {
      endElement.translate(0, endElementOffset);
      middleElementStyle[transformPropertyName] = 'translate3d(0, 0, 0) scaleY(' + middleElementLength + ')';
    }
  }
}}, 1, 0, ['component'], {'component':true}, 0, 0, [Ext.scroll.indicator, 'Rounded'], 0);
Ext.cmd.derive('Ext.scroll.Indicator', Ext.Base, {alternateClassName:'Ext.util.Indicator', constructor:function(config) {
  var namespace = Ext.scroll.indicator;
  switch(Ext.browser.getPreferredTranslationMethod(config)) {
    case 'scrollposition':
      return new namespace.ScrollPosition(config);
    case 'csstransform':
      if (Ext.browser.is.AndroidStock4) {
        return new namespace.CssTransform(config);
      } else {
        return new namespace.Rounded(config);
      }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.scroll, 'Indicator', Ext.util, 'Indicator'], 0);
Ext.cmd.derive('Ext.scroll.View', Ext.Evented, {alternateClassName:'Ext.util.ScrollView', config:{indicatorsUi:'dark', element:null, scroller:{}, indicators:{x:{axis:'x'}, y:{axis:'y'}}, indicatorsHidingDelay:100, cls:'x-scroll-view'}, processConfig:function(config) {
  if (!config) {
    return null;
  }
  if (typeof config == 'string') {
    config = {direction:config};
  }
  config = Ext.merge({}, config);
  var scrollerConfig = config.scroller, name;
  if (!scrollerConfig) {
    config.scroller = scrollerConfig = {};
  }
  for (name in config) {
    if (config.hasOwnProperty(name)) {
      if (!this.hasConfig(name)) {
        scrollerConfig[name] = config[name];
        delete config[name];
      }
    }
  }
  return config;
}, constructor:function(config) {
  config = this.processConfig(config);
  this.useIndicators = {x:true, y:true};
  this.doHideIndicators = Ext.Function.bind(this.doHideIndicators, this);
  this.initConfig(config);
}, setConfig:function(config) {
  return this.callParent([this.processConfig(config)]);
}, updateIndicatorsUi:function(newUi) {
  var indicators = this.getIndicators();
  indicators.x.setUi(newUi);
  indicators.y.setUi(newUi);
}, applyScroller:function(config, currentScroller) {
  return Ext.factory(config, Ext.scroll.Scroller, currentScroller);
}, applyIndicators:function(config, indicators) {
  var defaultClass = Ext.scroll.Indicator, useIndicators = this.useIndicators;
  if (!config) {
    config = {};
  }
  if (!config.x) {
    useIndicators.x = false;
    config.x = {};
  }
  if (!config.y) {
    useIndicators.y = false;
    config.y = {};
  }
  return {x:Ext.factory(config.x, defaultClass, indicators && indicators.x), y:Ext.factory(config.y, defaultClass, indicators && indicators.y)};
}, updateIndicators:function(indicators) {
  this.indicatorsGrid = Ext.Element.create({className:'x-scroll-bar-grid-wrapper', children:[{className:'x-scroll-bar-grid', children:[{children:[{}, {children:[indicators.y.barElement]}]}, {children:[{children:[indicators.x.barElement]}, {}]}]}]});
}, updateScroller:function(scroller) {
  scroller.on({scope:this, scrollstart:'onScrollStart', scroll:'onScroll', scrollend:'onScrollEnd', refresh:'refreshIndicators'});
}, isAxisEnabled:function(axis) {
  return this.getScroller().isAxisEnabled(axis) && this.useIndicators[axis];
}, applyElement:function(element) {
  if (element) {
    return Ext.get(element);
  }
}, updateElement:function(element) {
  var scroller = this.getScroller(), scrollerElement;
  scrollerElement = element.getFirstChild().getFirstChild();
  if (this.FixedHBoxStretching) {
    scrollerElement = scrollerElement.getFirstChild();
  }
  element.addCls(this.getCls());
  element.insertFirst(this.indicatorsGrid);
  scroller.setElement(scrollerElement);
  this.refreshIndicators();
  return this;
}, showIndicators:function() {
  var indicators = this.getIndicators();
  if (this.hasOwnProperty('indicatorsHidingTimer')) {
    clearTimeout(this.indicatorsHidingTimer);
    delete this.indicatorsHidingTimer;
  }
  if (this.isAxisEnabled('x')) {
    indicators.x.show();
  }
  if (this.isAxisEnabled('y')) {
    indicators.y.show();
  }
}, hideIndicators:function() {
  var delay = this.getIndicatorsHidingDelay();
  if (delay > 0) {
    this.indicatorsHidingTimer = setTimeout(this.doHideIndicators, delay);
  } else {
    this.doHideIndicators();
  }
}, doHideIndicators:function() {
  var indicators = this.getIndicators();
  if (this.isAxisEnabled('x')) {
    indicators.x.hide();
  }
  if (this.isAxisEnabled('y')) {
    indicators.y.hide();
  }
}, onScrollStart:function() {
  this.onScroll.apply(this, arguments);
  this.showIndicators();
}, onScrollEnd:function() {
  this.hideIndicators();
}, onScroll:function(scroller, x, y) {
  this.setIndicatorValue('x', x);
  this.setIndicatorValue('y', y);
}, setIndicatorValue:function(axis, scrollerPosition) {
  if (!this.isAxisEnabled(axis)) {
    return this;
  }
  var scroller = this.getScroller(), scrollerMaxPosition = scroller.getMaxPosition()[axis], scrollerContainerSize = scroller.getContainerSize()[axis], value;
  if (scrollerMaxPosition === 0) {
    value = scrollerPosition / scrollerContainerSize;
    if (scrollerPosition >= 0) {
      value += 1;
    }
  } else {
    if (scrollerPosition > scrollerMaxPosition) {
      value = 1 + (scrollerPosition - scrollerMaxPosition) / scrollerContainerSize;
    } else {
      if (scrollerPosition < 0) {
        value = scrollerPosition / scrollerContainerSize;
      } else {
        value = scrollerPosition / scrollerMaxPosition;
      }
    }
  }
  this.getIndicators()[axis].setValue(value);
}, refreshIndicator:function(axis) {
  if (!this.isAxisEnabled(axis)) {
    return this;
  }
  var scroller = this.getScroller(), indicator = this.getIndicators()[axis], scrollerContainerSize = scroller.getContainerSize()[axis], scrollerSize = scroller.getSize()[axis], ratio = scrollerContainerSize / scrollerSize;
  indicator.setRatio(ratio);
  indicator.refresh();
}, refresh:function() {
  return this.getScroller().refresh();
}, refreshIndicators:function() {
  var indicators = this.getIndicators();
  indicators.x.setActive(this.isAxisEnabled('x'));
  indicators.y.setActive(this.isAxisEnabled('y'));
  this.refreshIndicator('x');
  this.refreshIndicator('y');
}, destroy:function() {
  var element = this.getElement(), indicators = this.getIndicators();
  Ext.destroy(this.getScroller(), this.indicatorsGrid);
  if (this.hasOwnProperty('indicatorsHidingTimer')) {
    clearTimeout(this.indicatorsHidingTimer);
    delete this.indicatorsHidingTimer;
  }
  if (element && !element.isDestroyed) {
    element.removeCls(this.getCls());
  }
  indicators.x.destroy();
  indicators.y.destroy();
  delete this.indicatorsGrid;
  Ext.Evented.prototype.destroy.apply(this, arguments);
}}, 1, 0, 0, 0, 0, 0, [Ext.scroll, 'View', Ext.util, 'ScrollView'], 0);
Ext.cmd.derive('Ext.behavior.Scrollable', Ext.behavior.Behavior, {constructor:function() {
  this.listeners = {painted:'onComponentPainted', scope:this};
  Ext.behavior.Behavior.prototype.constructor.apply(this, arguments);
}, onComponentPainted:function() {
  this.scrollView.refresh();
}, setConfig:function(config) {
  var scrollView = this.scrollView, component = this.component, scrollerElement, extraWrap, scroller, direction;
  if (config) {
    if (!scrollView) {
      this.scrollView = scrollView = new Ext.scroll.View(config);
      scrollView.on('destroy', 'onScrollViewDestroy', this);
      component.setUseBodyElement(true);
      this.scrollerElement = scrollerElement = component.innerElement;
      if (!Ext.feature.has.ProperHBoxStretching) {
        scroller = scrollView.getScroller();
        direction = (Ext.isObject(config) ? config.direction : config) || 'auto';
        if (direction !== 'vertical') {
          extraWrap = scrollerElement.wrap();
          extraWrap.addCls('x-translatable-hboxfix');
          if (direction == 'horizontal') {
            extraWrap.setStyle({height:'100%'});
          }
          this.scrollContainer = extraWrap.wrap();
          scrollView.FixedHBoxStretching = scroller.FixedHBoxStretching = true;
        } else {
          this.scrollContainer = scrollerElement.wrap();
        }
      } else {
        this.scrollContainer = scrollerElement.wrap();
      }
      scrollView.setElement(component.bodyElement);
      if (component.isPainted()) {
        this.onComponentPainted();
      }
      component.on(this.listeners);
    } else {
      if (Ext.isString(config) || Ext.isObject(config)) {
        scrollView.setConfig(config);
      }
    }
  } else {
    if (scrollView) {
      scrollView.destroy();
    }
  }
  return this;
}, getScrollView:function() {
  return this.scrollView;
}, onScrollViewDestroy:function() {
  var component = this.component, scrollerElement = this.scrollerElement;
  if (!scrollerElement.isDestroyed) {
    this.scrollerElement.unwrap();
  }
  this.scrollContainer.destroy();
  if (!component.isDestroyed) {
    component.un(this.listeners);
  }
  delete this.scrollerElement;
  delete this.scrollView;
  delete this.scrollContainer;
}, onComponentDestroy:function() {
  var scrollView = this.scrollView;
  if (scrollView) {
    scrollView.destroy();
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.behavior, 'Scrollable'], 0);
Ext.cmd.derive('Ext.util.InputBlocker', Ext.Base, {singleton:true, blockInputs:function() {
  if (Ext.browser.is.ie) {
    Ext.select('.x-field-text .x-field-input:not(.x-item-disabled) .x-input-el, .x-field-textarea .x-field-input:not(.x-item-disabled) .x-input-el, .x-field-search .x-field-input:not(.x-item-disabled) .x-input-el').each(function(item) {
      if (item.dom.offsetWidth > 0) {
        item.dom.setAttribute('disabled', true);
        item.dom.setAttribute('overlayfix', true);
      }
    });
  }
}, unblockInputs:function() {
  if (Ext.browser.is.ie) {
    Ext.select('[overlayfix]').each(function(item) {
      item.dom.removeAttribute('disabled');
      item.dom.removeAttribute('overlayfix');
    });
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'InputBlocker'], 0);
Ext.cmd.derive('Ext.Mask', Ext.Component, {config:{baseCls:'x-mask', transparent:false, top:0, left:0, right:0, bottom:0}, initialize:function() {
  Ext.Component.prototype.initialize.call(this);
  this.element.on('*', 'onEvent', this);
  this.on({hide:'onHide'});
}, onHide:function() {
  Ext.util.InputBlocker.unblockInputs();
  if (Ext.browser.is.AndroidStock4 && Ext.os.version.getMinor() === 0) {
    var firstChild = this.element.getFirstChild();
    if (firstChild) {
      firstChild.redraw();
    }
  }
}, onEvent:function(e) {
  var controller = arguments[arguments.length - 1];
  if (controller.info.eventName === 'tap') {
    this.fireEvent('tap', this, e);
    return false;
  }
  if (e && e.stopEvent) {
    e.stopEvent();
  }
  return false;
}, updateTransparent:function(newTransparent) {
  this[newTransparent ? 'addCls' : 'removeCls'](this.getBaseCls() + '-transparent');
}}, 0, ['mask'], ['component', 'mask'], {'component':true, 'mask':true}, ['widget.mask'], 0, [Ext, 'Mask'], 0);
Ext.cmd.derive('Ext.Container', Ext.Component, {alternateClassName:'Ext.lib.Container', eventedConfig:{activeItem:0, scrollable:null}, config:{layout:null, control:{}, defaults:null, items:null, autoDestroy:true, defaultType:null, useBodyElement:null, masked:null, modal:null, hideOnMaskTap:null}, isContainer:true, constructor:function(config) {
  var me = this;
  me._items = me.items = new Ext.ItemCollection;
  me.innerItems = [];
  me.onItemAdd = me.onFirstItemAdd;
  Ext.Component.prototype.constructor.apply(this, arguments);
}, getElementConfig:function() {
  return {reference:'element', classList:['x-container', 'x-unsized'], children:[{reference:'innerElement', className:'x-inner'}]};
}, applyMasked:function(masked) {
  var isVisible = true, currentMask;
  if (masked === false) {
    masked = true;
    isVisible = false;
  }
  currentMask = Ext.factory(masked, Ext.Mask, this.getMasked());
  if (currentMask) {
    this.add(currentMask);
    currentMask.setHidden(!isVisible);
  }
  return currentMask;
}, mask:function(mask) {
  this.setMasked(mask || true);
}, unmask:function() {
  this.setMasked(false);
}, setParent:function(container) {
  Ext.Component.prototype.setParent.apply(this, arguments);
  if (container) {
    var modal = this.getModal();
    if (modal) {
      container.insertBefore(modal, this);
      modal.setZIndex(this.getZIndex() - 1);
    }
  }
}, applyModal:function(modal, currentModal) {
  var isVisible = true;
  if (modal === false) {
    modal = true;
    isVisible = false;
  }
  currentModal = Ext.factory(modal, Ext.Mask, currentModal);
  if (currentModal) {
    currentModal.setVisibility(isVisible);
  }
  return currentModal;
}, updateModal:function(modal) {
  var container = this.getParent();
  if (container) {
    if (modal) {
      container.insertBefore(modal, this);
      modal.setZIndex(this.getZIndex() - 1);
    } else {
      container.remove(modal);
    }
  }
}, updateHideOnMaskTap:function(hide) {
  var mask = this.getModal();
  if (mask) {
    mask[hide ? 'on' : 'un'].call(mask, 'tap', 'hide', this);
  }
}, updateZIndex:function(zIndex) {
  var modal = this.getModal();
  Ext.Component.prototype.updateZIndex.apply(this, arguments);
  if (modal) {
    modal.setZIndex(zIndex - 1);
  }
}, updateBaseCls:function(newBaseCls, oldBaseCls) {
  var me = this, ui = me.getUi();
  if (oldBaseCls) {
    this.element.removeCls(oldBaseCls);
    this.innerElement.removeCls(newBaseCls, null, 'inner');
    if (ui) {
      this.element.removeCls(this.currentUi);
    }
  }
  if (newBaseCls) {
    this.element.addCls(newBaseCls);
    this.innerElement.addCls(newBaseCls, null, 'inner');
    if (ui) {
      this.element.addCls(newBaseCls, null, ui);
      this.currentUi = newBaseCls + '-' + ui;
    }
  }
}, updateUseBodyElement:function(useBodyElement) {
  if (useBodyElement) {
    this.link('bodyElement', this.innerElement.wrap({cls:'x-body'}));
  }
}, applyItems:function(items, collection) {
  if (items) {
    var me = this;
    me.getDefaultType();
    me.getDefaults();
    if (me.initialized && collection.length > 0) {
      me.removeAll();
    }
    me.add(items);
    if (me.initialized) {
      var activeItem = me.initialConfig.activeItem || me.config.activeItem || 0;
      me.setActiveItem(activeItem);
    }
  }
}, applyControl:function(selectors) {
  var selector, key, listener, listeners;
  for (selector in selectors) {
    listeners = selectors[selector];
    for (key in listeners) {
      listener = listeners[key];
      if (Ext.isObject(listener)) {
        listener.delegate = selector;
      }
    }
    listeners.delegate = selector;
    this.addListener(listeners);
  }
  return selectors;
}, onFirstItemAdd:function() {
  delete this.onItemAdd;
  if (this.innerHtmlElement && !this.getHtml()) {
    this.innerHtmlElement.destroy();
    delete this.innerHtmlElement;
  }
  this.on('innerstatechange', 'onItemInnerStateChange', this, {delegate:'\x3e component'});
  return this.onItemAdd.apply(this, arguments);
}, getLayout:function() {
  var layout = this.layout;
  if (!layout) {
    layout = this.link('_layout', this.link('layout', Ext.factory(this._layout || 'default', Ext.layout.Default, null, 'layout')));
    layout.setContainer(this);
  }
  return layout;
}, updateDefaultType:function(defaultType) {
  this.defaultItemClass = Ext.ClassManager.getByAlias('widget.' + defaultType);
}, applyDefaults:function(defaults) {
  if (defaults) {
    this.factoryItem = this.factoryItemWithDefaults;
    return defaults;
  }
}, factoryItem:function(item) {
  return Ext.factory(item, this.defaultItemClass);
}, factoryItemWithDefaults:function(item) {
  var me = this, defaults = me.getDefaults(), instance;
  if (!defaults) {
    return Ext.factory(item, me.defaultItemClass);
  }
  if (item.isComponent) {
    instance = item;
    if (defaults && item.isInnerItem() && !me.has(instance)) {
      instance.setConfig(defaults, true);
    }
  } else {
    if (defaults && !item.ignoreDefaults) {
      if (!(item.hasOwnProperty('left') && item.hasOwnProperty('right') && item.hasOwnProperty('top') && item.hasOwnProperty('bottom') && item.hasOwnProperty('docked') && item.hasOwnProperty('centered'))) {
        item = Ext.mergeIf({}, item, defaults);
      }
    }
    instance = Ext.factory(item, me.defaultItemClass);
  }
  return instance;
}, add:function(newItems) {
  var me = this, i, ln, item, newActiveItem;
  if (Ext.isArray(newItems)) {
    for (i = 0, ln = newItems.length; i < ln; i++) {
      item = me.factoryItem(newItems[i]);
      this.doAdd(item);
      if (!newActiveItem && !this.getActiveItem() && this.innerItems.length > 0 && item.isInnerItem()) {
        newActiveItem = item;
      }
    }
  } else {
    item = me.factoryItem(newItems);
    this.doAdd(item);
    if (!newActiveItem && !this.getActiveItem() && this.innerItems.length > 0 && item.isInnerItem()) {
      newActiveItem = item;
    }
  }
  if (newActiveItem) {
    this.setActiveItem(newActiveItem);
  }
  return item;
}, doAdd:function(item) {
  var me = this, items = me.getItems(), index;
  if (!items.has(item)) {
    index = items.length;
    items.add(item);
    if (item.isInnerItem()) {
      me.insertInner(item);
    }
    item.setParent(me);
    me.onItemAdd(item, index);
  }
}, remove:function(item, destroy) {
  var me = this, index = me.indexOf(item), innerItems = me.getInnerItems();
  if (destroy === undefined) {
    destroy = me.getAutoDestroy();
  }
  if (index !== -1) {
    if (!me.removingAll && innerItems.length > 1 && item === me.getActiveItem()) {
      me.on({activeitemchange:'doRemove', scope:me, single:true, order:'after', args:[item, index, destroy]});
      me.doResetActiveItem(innerItems.indexOf(item));
    } else {
      me.doRemove(item, index, destroy);
      if (innerItems.length === 0) {
        me.setActiveItem(null);
      }
    }
  }
  return me;
}, doResetActiveItem:function(innerIndex) {
  if (innerIndex === 0) {
    this.setActiveItem(1);
  } else {
    this.setActiveItem(0);
  }
}, doRemove:function(item, index, destroy) {
  var me = this;
  me.items.remove(item);
  if (item.isInnerItem()) {
    me.removeInner(item);
  }
  me.onItemRemove(item, index, destroy);
  item.setParent(null);
  if (destroy) {
    item.destroy();
  }
}, removeAll:function(destroy, everything) {
  var items = this.items, ln = items.length, i = 0, item;
  if (typeof destroy != 'boolean') {
    destroy = this.getAutoDestroy();
  }
  everything = Boolean(everything);
  this.removingAll = true;
  for (; i < ln; i++) {
    item = items.getAt(i);
    if (item && (everything || item.isInnerItem())) {
      this.doRemove(item, i, destroy);
      i--;
      ln--;
    }
  }
  this.setActiveItem(null);
  this.removingAll = false;
  return this;
}, getAt:function(index) {
  return this.items.getAt(index);
}, getInnerAt:function(index) {
  return this.innerItems[index];
}, removeAt:function(index) {
  var item = this.getAt(index);
  if (item) {
    this.remove(item);
  }
  return this;
}, removeInnerAt:function(index) {
  var item = this.getInnerItems()[index];
  if (item) {
    this.remove(item);
  }
  return this;
}, has:function(item) {
  return this.getItems().indexOf(item) != -1;
}, hasInnerItem:function(item) {
  return this.innerItems.indexOf(item) != -1;
}, indexOf:function(item) {
  return this.getItems().indexOf(item);
}, innerIndexOf:function(item) {
  return this.innerItems.indexOf(item);
}, insertInner:function(item, index) {
  var items = this.getItems().items, innerItems = this.innerItems, currentInnerIndex = innerItems.indexOf(item), newInnerIndex = -1, nextSibling;
  if (currentInnerIndex !== -1) {
    innerItems.splice(currentInnerIndex, 1);
  }
  if (typeof index == 'number') {
    do {
      nextSibling = items[++index];
    } while (nextSibling && !nextSibling.isInnerItem());
    if (nextSibling) {
      newInnerIndex = innerItems.indexOf(nextSibling);
      innerItems.splice(newInnerIndex, 0, item);
    }
  }
  if (newInnerIndex === -1) {
    innerItems.push(item);
    newInnerIndex = innerItems.length - 1;
  }
  if (currentInnerIndex !== -1) {
    this.onInnerItemMove(item, newInnerIndex, currentInnerIndex);
  }
  return this;
}, onInnerItemMove:Ext.emptyFn, removeInner:function(item) {
  Ext.Array.remove(this.innerItems, item);
  return this;
}, insert:function(index, item) {
  var me = this, i;
  if (Ext.isArray(item)) {
    for (i = item.length - 1; i >= 0; i--) {
      me.insert(index, item[i]);
    }
    return me;
  }
  item = this.factoryItem(item);
  this.doInsert(index, item);
  return item;
}, doInsert:function(index, item) {
  var me = this, items = me.items, itemsLength = items.length, currentIndex, isInnerItem;
  isInnerItem = item.isInnerItem();
  if (index > itemsLength) {
    index = itemsLength;
  }
  if (items[index - 1] === item) {
    return me;
  }
  currentIndex = me.indexOf(item);
  if (currentIndex !== -1) {
    if (currentIndex < index) {
      index -= 1;
    }
    items.removeAt(currentIndex);
  }
  items.insert(index, item);
  if (currentIndex === -1) {
    item.setParent(me);
  }
  if (isInnerItem) {
    me.insertInner(item, index);
  }
  if (currentIndex !== -1) {
    me.onItemMove(item, index, currentIndex);
  } else {
    me.onItemAdd(item, index);
  }
}, insertFirst:function(item) {
  return this.insert(0, item);
}, insertLast:function(item) {
  return this.insert(this.getItems().length, item);
}, insertBefore:function(item, relativeToItem) {
  var index = this.indexOf(relativeToItem);
  if (index !== -1) {
    this.insert(index, item);
  }
  return this;
}, insertAfter:function(item, relativeToItem) {
  var index = this.indexOf(relativeToItem);
  if (index !== -1) {
    this.insert(index + 1, item);
  }
  return this;
}, onItemAdd:function(item, index) {
  this.doItemLayoutAdd(item, index);
  if (this.initialized) {
    this.fireEvent('add', this, item, index);
  }
}, doItemLayoutAdd:function(item, index) {
  var layout = this.getLayout();
  if (this.isRendered() && item.setRendered(true)) {
    item.fireAction('renderedchange', [this, item, true], 'onItemAdd', layout, {args:[item, index]});
  } else {
    layout.onItemAdd(item, index);
  }
}, onItemRemove:function(item, index, destroying) {
  this.doItemLayoutRemove(item, index, destroying);
  this.fireEvent('remove', this, item, index);
}, doItemLayoutRemove:function(item, index, destroying) {
  var layout = this.getLayout();
  if (this.isRendered() && item.setRendered(false)) {
    item.fireAction('renderedchange', [this, item, false], 'onItemRemove', layout, {args:[item, index, destroying]});
  } else {
    layout.onItemRemove(item, index, destroying);
  }
}, onItemMove:function(item, toIndex, fromIndex) {
  if (item.isDocked()) {
    item.setDocked(null);
  }
  this.doItemLayoutMove(item, toIndex, fromIndex);
  this.fireEvent('move', this, item, toIndex, fromIndex);
}, doItemLayoutMove:function(item, toIndex, fromIndex) {
  this.getLayout().onItemMove(item, toIndex, fromIndex);
}, onItemInnerStateChange:function(item, isInner) {
  var layout = this.getLayout();
  if (isInner) {
    this.insertInner(item, this.items.indexOf(item));
  } else {
    this.removeInner(item);
  }
  layout.onItemInnerStateChange.apply(layout, arguments);
}, getInnerItems:function() {
  return this.innerItems;
}, getDockedItems:function() {
  var items = this.getItems().items, dockedItems = [], ln = items.length, item, i;
  for (i = 0; i < ln; i++) {
    item = items[i];
    if (item.isDocked()) {
      dockedItems.push(item);
    }
  }
  return dockedItems;
}, applyActiveItem:function(activeItem, currentActiveItem) {
  var innerItems = this.getInnerItems();
  this.getItems();
  if (!activeItem && innerItems.length === 0) {
    return 0;
  } else {
    if (typeof activeItem == 'number') {
      activeItem = Math.max(0, Math.min(activeItem, innerItems.length - 1));
      activeItem = innerItems[activeItem];
      if (activeItem) {
        return activeItem;
      } else {
        if (currentActiveItem) {
          return null;
        }
      }
    } else {
      if (activeItem) {
        var item;
        if (typeof activeItem == 'string') {
          item = this.child(activeItem);
          activeItem = {xtype:activeItem};
        }
        if (!item || !item.isComponent) {
          item = this.factoryItem(activeItem);
        }
        this.pendingActiveItem = item;
        if (!this.has(item)) {
          this.add(item);
        }
        return item;
      }
    }
  }
}, animateActiveItem:function(activeItem, animation) {
  var layout = this.getLayout(), defaultAnimation;
  if (this.activeItemAnimation) {
    this.activeItemAnimation.destroy();
  }
  this.activeItemAnimation = animation = new Ext.fx.layout.Card(animation);
  if (animation && layout.isCard) {
    animation.setLayout(layout);
    defaultAnimation = layout.getAnimation();
    if (defaultAnimation) {
      defaultAnimation.disable();
    }
    animation.on('animationend', function() {
      if (defaultAnimation) {
        defaultAnimation.enable();
      }
      animation.destroy();
    }, this);
  }
  return this.setActiveItem(activeItem);
}, doSetActiveItem:function(newActiveItem, oldActiveItem) {
  delete this.pendingActiveItem;
  if (oldActiveItem) {
    oldActiveItem.fireEvent('deactivate', oldActiveItem, this, newActiveItem);
  }
  if (newActiveItem) {
    newActiveItem.fireEvent('activate', newActiveItem, this, oldActiveItem);
  }
}, show:function() {
  Ext.Component.prototype.show.apply(this, arguments);
  var modal = this.getModal();
  if (modal) {
    modal.setHidden(false);
  }
  return this;
}, hide:function() {
  Ext.Component.prototype.hide.apply(this, arguments);
  var modal = this.getModal();
  if (modal) {
    modal.setHidden(true);
  }
  return this;
}, doSetHidden:function(hidden) {
  var modal = this.getModal();
  if (modal && modal.getHidden() !== hidden) {
    modal.setHidden(hidden);
  }
  Ext.Component.prototype.doSetHidden.apply(this, arguments);
}, setRendered:function(rendered) {
  if (Ext.Component.prototype.setRendered.apply(this, arguments)) {
    var items = this.items.items, i, ln;
    for (i = 0, ln = items.length; i < ln; i++) {
      items[i].setRendered(rendered);
    }
    return true;
  }
  return false;
}, getScrollableBehavior:function() {
  var behavior = this.scrollableBehavior;
  if (!behavior) {
    behavior = this.scrollableBehavior = new Ext.behavior.Scrollable(this);
  }
  return behavior;
}, applyScrollable:function(config) {
  if (typeof config === 'boolean') {
    this.getScrollableBehavior().setConfig({disabled:!config});
  } else {
    if (config && !config.isObservable) {
      this.getScrollableBehavior().setConfig(config);
    }
  }
  return config;
}, doSetScrollable:function() {
}, getScrollable:function() {
  return this.getScrollableBehavior().getScrollView();
}, getRefItems:function(deep) {
  var items = this.getItems().items.slice(), ln = items.length, i, item;
  if (deep) {
    for (i = 0; i < ln; i++) {
      item = items[i];
      if (item.getRefItems) {
        items = items.concat(item.getRefItems(true));
      }
    }
  }
  return items;
}, getComponent:function(component) {
  if (Ext.isObject(component)) {
    component = component.getItemId();
  }
  return this.getItems().get(component);
}, getDockedComponent:function(component) {
  if (Ext.isObject(component)) {
    component = component.getItemId();
  }
  var dockedItems = this.getDockedItems(), ln = dockedItems.length, item, i;
  if (Ext.isNumber(component)) {
    return dockedItems[component];
  }
  for (i = 0; i < ln; i++) {
    item = dockedItems[i];
    if (item.id == component) {
      return item;
    }
  }
  return false;
}, query:function(selector) {
  return Ext.ComponentQuery.query(selector, this);
}, child:function(selector) {
  return this.query('\x3e ' + selector)[0] || null;
}, down:function(selector) {
  return this.query(selector)[0] || null;
}, destroy:function() {
  var me = this, modal = me.getModal();
  if (modal) {
    modal.destroy();
  }
  me.removeAll(true, true);
  me.unlink('_scrollable');
  Ext.destroy(me.items);
  Ext.Component.prototype.destroy.call(this);
}}, 1, ['container'], ['component', 'container'], {'component':true, 'container':true}, ['widget.container'], 0, [Ext, 'Container', Ext.lib, 'Container'], function() {
  this.addMember('defaultItemClass', this);
});
Ext.cmd.derive('Ext.util.Point', Ext.Base, {radianToDegreeConstant:180 / Math.PI, statics:{fromEvent:function(e) {
  var changedTouches = e.changedTouches, touch = changedTouches && changedTouches.length > 0 ? changedTouches[0] : e;
  return this.fromTouch(touch);
}, fromTouch:function(touch) {
  return new this(touch.pageX, touch.pageY);
}, from:function(object) {
  if (!object) {
    return new this(0, 0);
  }
  if (!(object instanceof this)) {
    return new this(object.x, object.y);
  }
  return object;
}}, constructor:function(x, y) {
  if (typeof x == 'undefined') {
    x = 0;
  }
  if (typeof y == 'undefined') {
    y = 0;
  }
  this.x = x;
  this.y = y;
  return this;
}, clone:function() {
  return new this.self(this.x, this.y);
}, copy:function() {
  return this.clone.apply(this, arguments);
}, copyFrom:function(point) {
  this.x = point.x;
  this.y = point.y;
  return this;
}, toString:function() {
  return 'Point[' + this.x + ',' + this.y + ']';
}, equals:function(point) {
  return this.x === point.x && this.y === point.y;
}, isCloseTo:function(point, threshold) {
  if (typeof threshold == 'number') {
    threshold = {x:threshold};
    threshold.y = threshold.x;
  }
  var x = point.x, y = point.y, thresholdX = threshold.x, thresholdY = threshold.y;
  return this.x <= x + thresholdX && this.x >= x - thresholdX && this.y <= y + thresholdY && this.y >= y - thresholdY;
}, isWithin:function() {
  return this.isCloseTo.apply(this, arguments);
}, translate:function(x, y) {
  this.x += x;
  this.y += y;
  return this;
}, roundedEquals:function(point) {
  if (typeof point != 'object') {
    point = {x:0, y:0};
  }
  return Math.round(this.x) === Math.round(point.x) && Math.round(this.y) === Math.round(point.y);
}, getDistanceTo:function(point) {
  if (typeof point != 'object') {
    point = {x:0, y:0};
  }
  var deltaX = this.x - point.x, deltaY = this.y - point.y;
  return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
}, getAngleTo:function(point) {
  if (typeof point != 'object') {
    point = {x:0, y:0};
  }
  var deltaX = this.x - point.x, deltaY = this.y - point.y;
  return Math.atan2(deltaY, deltaX) * this.radianToDegreeConstant;
}}, 3, 0, 0, 0, 0, 0, [Ext.util, 'Point'], 0);
Ext.cmd.derive('Ext.util.LineSegment', Ext.Base, {constructor:function(point1, point2) {
  var Point = Ext.util.Point;
  this.point1 = Point.from(point1);
  this.point2 = Point.from(point2);
}, intersects:function(lineSegment) {
  var point1 = this.point1, point2 = this.point2, point3 = lineSegment.point1, point4 = lineSegment.point2, x1 = point1.x, x2 = point2.x, x3 = point3.x, x4 = point4.x, y1 = point1.y, y2 = point2.y, y3 = point3.y, y4 = point4.y, d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4), xi, yi;
  if (d == 0) {
    return null;
  }
  xi = ((x3 - x4) * (x1 * y2 - y1 * x2) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;
  yi = ((y3 - y4) * (x1 * y2 - y1 * x2) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d;
  if (xi < Math.min(x1, x2) || xi > Math.max(x1, x2) || xi < Math.min(x3, x4) || xi > Math.max(x3, x4) || yi < Math.min(y1, y2) || yi > Math.max(y1, y2) || yi < Math.min(y3, y4) || yi > Math.max(y3, y4)) {
    return null;
  }
  return new Ext.util.Point(xi, yi);
}, getLength:function() {
  return Math.abs(this.point1.getDistanceTo(this.point2));
}, getAngleToX:function() {
  var point1 = this.point1, point2 = this.point2, deltaY = point2.y - point1.y, deltaX = point2.x - point1.x;
  return Math.atan2(deltaY, deltaX);
}, getInBetweenPoint:function(distance) {
  var point1 = this.point1, angle = this.getAngleToX(), x = point1.x + Math.cos(angle) * distance, y = point1.y + Math.sin(angle) * distance;
  return new Ext.util.Point(x, y);
}, toString:function() {
  return this.point1.toString() + ' ' + this.point2.toString();
}}, 3, 0, 0, 0, 0, 0, [Ext.util, 'LineSegment'], 0);
Ext.cmd.derive('Ext.Panel', Ext.Container, {alternateClassName:'Ext.lib.Panel', isPanel:true, config:{baseCls:'x-panel', bodyPadding:null, bodyMargin:null, bodyBorder:null}, getElementConfig:function() {
  return {reference:'element', classList:['x-container', 'x-unsized'], children:[{reference:'innerElement', className:'x-inner'}, {reference:'tipElement', className:'x-anchor', hidden:true}]};
}, applyBodyPadding:function(bodyPadding) {
  if (bodyPadding === true) {
    bodyPadding = 5;
  }
  if (bodyPadding) {
    bodyPadding = Ext.dom.Element.unitizeBox(bodyPadding);
  }
  return bodyPadding;
}, updateBodyPadding:function(newBodyPadding) {
  this.element.setStyle('padding', newBodyPadding);
}, applyBodyMargin:function(bodyMargin) {
  if (bodyMargin === true) {
    bodyMargin = 5;
  }
  if (bodyMargin) {
    bodyMargin = Ext.dom.Element.unitizeBox(bodyMargin);
  }
  return bodyMargin;
}, updateBodyMargin:function(newBodyMargin) {
  this.element.setStyle('margin', newBodyMargin);
}, applyBodyBorder:function(bodyBorder) {
  if (bodyBorder === true) {
    bodyBorder = 1;
  }
  if (bodyBorder) {
    bodyBorder = Ext.dom.Element.unitizeBox(bodyBorder);
  }
  return bodyBorder;
}, updateBodyBorder:function(newBodyBorder) {
  this.element.setStyle('border-width', newBodyBorder);
}, alignTo:function(component, alignment) {
  var alignmentInfo = this.getAlignmentInfo(component, alignment);
  if (alignmentInfo.isAligned) {
    return;
  }
  var tipElement = this.tipElement;
  tipElement.hide();
  if (this.currentTipPosition) {
    tipElement.removeCls('x-anchor-' + this.currentTipPosition);
  }
  Ext.Container.prototype.alignTo.apply(this, arguments);
  var LineSegment = Ext.util.LineSegment, alignToElement = component.isComponent ? component.renderElement : component, element = this.renderElement, alignToBox = alignToElement.getPageBox(), box = element.getPageBox(), left = box.left, top = box.top, right = box.right, bottom = box.bottom, centerX = left + box.width / 2, centerY = top + box.height / 2, leftTopPoint = {x:left, y:top}, rightTopPoint = {x:right, y:top}, leftBottomPoint = {x:left, y:bottom}, rightBottomPoint = {x:right, y:bottom}, boxCenterPoint = 
  {x:centerX, y:centerY}, alignToCenterX = alignToBox.left + alignToBox.width / 2, alignToCenterY = alignToBox.top + alignToBox.height / 2, alignToBoxCenterPoint = {x:alignToCenterX, y:alignToCenterY}, centerLineSegment = new LineSegment(boxCenterPoint, alignToBoxCenterPoint), offsetLeft = 0, offsetTop = 0, tipSize, tipWidth, tipHeight, tipPosition, tipX, tipY;
  tipElement.setVisibility(false);
  tipElement.show();
  tipSize = tipElement.getSize();
  tipWidth = tipSize.width;
  tipHeight = tipSize.height;
  if (centerLineSegment.intersects(new LineSegment(leftTopPoint, rightTopPoint))) {
    tipX = Math.min(Math.max(alignToCenterX, left + tipWidth), right - tipWidth);
    tipY = top;
    offsetTop = tipHeight + 10;
    tipPosition = 'top';
  } else {
    if (centerLineSegment.intersects(new LineSegment(leftTopPoint, leftBottomPoint))) {
      tipX = left;
      tipY = Math.min(Math.max(alignToCenterY + tipWidth / 2, tipWidth * 1.6), bottom - tipWidth / 2.2);
      offsetLeft = tipHeight + 10;
      tipPosition = 'left';
    } else {
      if (centerLineSegment.intersects(new LineSegment(leftBottomPoint, rightBottomPoint))) {
        tipX = Math.min(Math.max(alignToCenterX, left + tipWidth), right - tipWidth);
        tipY = bottom;
        offsetTop = -tipHeight - 10;
        tipPosition = 'bottom';
      } else {
        if (centerLineSegment.intersects(new LineSegment(rightTopPoint, rightBottomPoint))) {
          tipX = right;
          tipY = Math.max(Math.min(alignToCenterY - tipHeight, bottom - tipWidth * 1.3), tipWidth / 2);
          offsetLeft = -tipHeight - 10;
          tipPosition = 'right';
        }
      }
    }
  }
  if (tipX || tipY) {
    this.currentTipPosition = tipPosition;
    tipElement.addCls('x-anchor-' + tipPosition);
    tipElement.setLeft(tipX - left);
    tipElement.setTop(tipY - top);
    tipElement.setVisibility(true);
    this.setLeft(this.getLeft() + offsetLeft);
    this.setTop(this.getTop() + offsetTop);
  }
}}, 0, ['panel'], ['component', 'container', 'panel'], {'component':true, 'container':true, 'panel':true}, ['widget.panel'], 0, [Ext, 'Panel', Ext.lib, 'Panel'], 0);
Ext.cmd.derive('Ext.Button', Ext.Component, {cachedConfig:{pressedCls:'x-button-pressing', badgeCls:'x-badge', hasBadgeCls:'x-hasbadge', labelCls:'x-button-label', iconCls:null}, config:{badgeText:null, text:null, icon:false, iconAlign:'left', pressedDelay:0, handler:null, scope:null, autoEvent:null, ui:'normal', baseCls:'x-button'}, template:[{tag:'span', reference:'badgeElement', hidden:true}, {tag:'span', className:'x-button-icon', reference:'iconElement'}, {tag:'span', reference:'textElement', 
hidden:true}], initialize:function() {
  Ext.Component.prototype.initialize.call(this);
  this.element.on({scope:this, tap:'onTap', touchstart:'onPress', touchend:'onRelease'});
}, updateBadgeText:function(badgeText) {
  var element = this.element, badgeElement = this.badgeElement;
  if (badgeText) {
    badgeElement.show();
    badgeElement.setText(badgeText);
  } else {
    badgeElement.hide();
  }
  element[badgeText ? 'addCls' : 'removeCls'](this.getHasBadgeCls());
}, updateText:function(text) {
  var textElement = this.textElement;
  if (textElement) {
    if (text) {
      textElement.show();
      textElement.setHtml(text);
    } else {
      textElement.hide();
    }
    this.refreshIconAlign();
  }
}, updateHtml:function(html) {
  var textElement = this.textElement;
  if (html) {
    textElement.show();
    textElement.setHtml(html);
  } else {
    textElement.hide();
  }
}, updateBadgeCls:function(badgeCls, oldBadgeCls) {
  this.badgeElement.replaceCls(oldBadgeCls, badgeCls);
}, updateHasBadgeCls:function(hasBadgeCls, oldHasBadgeCls) {
  var element = this.element;
  if (element.hasCls(oldHasBadgeCls)) {
    element.replaceCls(oldHasBadgeCls, hasBadgeCls);
  }
}, updateLabelCls:function(labelCls, oldLabelCls) {
  this.textElement.replaceCls(oldLabelCls, labelCls);
}, updatePressedCls:function(pressedCls, oldPressedCls) {
  var element = this.element;
  if (element.hasCls(oldPressedCls)) {
    element.replaceCls(oldPressedCls, pressedCls);
  }
}, updateIcon:function(icon) {
  var me = this, element = me.iconElement;
  if (icon) {
    me.showIconElement();
    element.setStyle('background-image', 'url(' + icon + ')');
    me.refreshIconAlign();
  } else {
    element.setStyle('background-image', '');
    me.hideIconElement();
  }
}, updateIconCls:function(iconCls, oldIconCls) {
  var me = this, element = me.iconElement;
  if (iconCls) {
    me.showIconElement();
    element.replaceCls(oldIconCls, iconCls);
    me.refreshIconAlign();
  } else {
    element.removeCls(oldIconCls);
    me.hideIconElement();
  }
}, updateIconAlign:function(alignment, oldAlignment) {
  var element = this.element, baseCls = 'x-iconalign-';
  if (!this.getText()) {
    alignment = 'center';
  }
  element.removeCls(baseCls + 'center');
  element.removeCls(baseCls + oldAlignment);
  if (this.getIcon() || this.getIconCls()) {
    element.addCls(baseCls + alignment);
  }
}, refreshIconAlign:function() {
  this.updateIconAlign(this.getIconAlign());
}, applyAutoEvent:function(autoEvent) {
  var me = this;
  if (typeof autoEvent == 'string') {
    autoEvent = {name:autoEvent, scope:me.scope || me};
  }
  return autoEvent;
}, updateAutoEvent:function(autoEvent) {
  var name = autoEvent.name, scope = autoEvent.scope;
  this.setHandler(function() {
    scope.fireEvent(name, scope, this);
  });
  this.setScope(scope);
}, hideIconElement:function() {
  this.iconElement.removeCls('x-shown');
  this.iconElement.addCls('x-hidden');
}, showIconElement:function() {
  this.iconElement.removeCls('x-hidden');
  this.iconElement.addCls('x-shown');
}, applyUi:function(config) {
  if (config && Ext.isString(config)) {
    var array = config.split('-');
    if (array && (array[1] == 'back' || array[1] == 'forward')) {
      return array;
    }
  }
  return config;
}, getUi:function() {
  var ui = this._ui;
  if (Ext.isArray(ui)) {
    return ui.join('-');
  }
  return ui;
}, applyPressedDelay:function(delay) {
  if (Ext.isNumber(delay)) {
    return delay;
  }
  return delay ? 100 : 0;
}, onPress:function() {
  var me = this, element = me.element, pressedDelay = me.getPressedDelay(), pressedCls = me.getPressedCls();
  if (!me.getDisabled()) {
    if (pressedDelay > 0) {
      me.pressedTimeout = setTimeout(function() {
        delete me.pressedTimeout;
        if (element) {
          element.addCls(pressedCls);
        }
      }, pressedDelay);
    } else {
      element.addCls(pressedCls);
    }
  }
}, onRelease:function(e) {
  this.fireAction('release', [this, e], 'doRelease');
}, doRelease:function(me, e) {
  if (!me.getDisabled()) {
    if (me.hasOwnProperty('pressedTimeout')) {
      clearTimeout(me.pressedTimeout);
      delete me.pressedTimeout;
    } else {
      me.element.removeCls(me.getPressedCls());
    }
  }
}, onTap:function(e) {
  if (this.getDisabled()) {
    return false;
  }
  this.fireAction('tap', [this, e], 'doTap');
}, doTap:function(me, e) {
  var handler = me.getHandler(), scope = me.getScope() || me;
  if (!handler) {
    return;
  }
  if (typeof handler == 'string') {
    handler = scope[handler];
  }
  if (e && e.preventDefault) {
    e.preventDefault();
  }
  handler.apply(scope, arguments);
}}, 0, ['button'], ['component', 'button'], {'component':true, 'button':true}, ['widget.button'], 0, [Ext, 'Button'], function() {
});
Ext.cmd.derive('Ext.Sheet', Ext.Panel, {config:{baseCls:'x-sheet', modal:true, centered:true, stretchX:null, stretchY:null, enter:'bottom', exit:'bottom', showAnimation:!Ext.browser.is.AndroidStock2 ? {type:'slideIn', duration:250, easing:'ease-out'} : null, hideAnimation:!Ext.browser.is.AndroidStock2 ? {type:'slideOut', duration:250, easing:'ease-in'} : null}, isInputRegex:/^(input|textarea|select|a)$/i, beforeInitialize:function() {
  var me = this;
  Ext.os.is.iOS && this.element.dom.addEventListener('touchstart', function(e) {
    if (!me.isInputRegex.test(e.target.tagName)) {
      e.preventDefault();
    }
  }, true);
}, platformConfig:[{theme:['Windows'], enter:'top', exit:'top'}], applyHideAnimation:function(config) {
  var exit = this.getExit(), direction = exit;
  if (exit === null) {
    return null;
  }
  if (config === true) {
    config = {type:'slideOut'};
  }
  if (Ext.isString(config)) {
    config = {type:config};
  }
  var anim = Ext.factory(config, Ext.fx.Animation);
  if (anim) {
    if (exit == 'bottom') {
      direction = 'down';
    }
    if (exit == 'top') {
      direction = 'up';
    }
    anim.setDirection(direction);
  }
  return anim;
}, applyShowAnimation:function(config) {
  var enter = this.getEnter(), direction = enter;
  if (enter === null) {
    return null;
  }
  if (config === true) {
    config = {type:'slideIn'};
  }
  if (Ext.isString(config)) {
    config = {type:config};
  }
  var anim = Ext.factory(config, Ext.fx.Animation);
  if (anim) {
    if (enter == 'bottom') {
      direction = 'down';
    }
    if (enter == 'top') {
      direction = 'up';
    }
    anim.setBefore({display:null});
    anim.setReverse(true);
    anim.setDirection(direction);
  }
  return anim;
}, updateStretchX:function(newStretchX) {
  this.getLeft();
  this.getRight();
  if (newStretchX) {
    this.setLeft(0);
    this.setRight(0);
  }
}, updateStretchY:function(newStretchY) {
  this.getTop();
  this.getBottom();
  if (newStretchY) {
    this.setTop(0);
    this.setBottom(0);
  }
}}, 0, ['sheet'], ['component', 'container', 'panel', 'sheet'], {'component':true, 'container':true, 'panel':true, 'sheet':true}, ['widget.sheet'], 0, [Ext, 'Sheet'], 0);
Ext.cmd.derive('Ext.data.Connection', Ext.Base, {statics:{requestId:0}, config:{url:null, async:true, method:null, username:'', password:'', disableCaching:true, disableCachingParam:'_dc', timeout:30000, extraParams:null, defaultHeaders:null, useDefaultHeader:true, defaultPostHeader:'application/x-www-form-urlencoded; charset\x3dUTF-8', useDefaultXhrHeader:true, defaultXhrHeader:'XMLHttpRequest', autoAbort:false}, textAreaRe:/textarea/i, multiPartRe:/multipart\/form-data/i, lineBreakRe:/\r\n/g, constructor:function(config) {
  this.initConfig(config);
  this.requests = {};
}, request:function(options) {
  options = options || {};
  var me = this, scope = options.scope || window, username = options.username || me.getUsername(), password = options.password || me.getPassword() || '', useXhr2 = options.xhr2 === true && Ext.feature.has.XHR2, async, requestOptions, request, headers, xhr;
  if (!Ext.isEmpty(username) && !Ext.isEmpty(password, true) && Ext.isEmpty(options.withCredentials)) {
    options.withCredentials = true;
  }
  if (me.fireEvent('beforerequest', me, options) !== false) {
    requestOptions = me.setOptions(options, scope);
    if (this.isFormUpload(options) === true) {
      this.upload(options.form, requestOptions.url, requestOptions.data, options);
      return null;
    }
    if (options.autoAbort === true || me.getAutoAbort()) {
      me.abort();
    }
    xhr = this.getXhrInstance();
    async = options.async !== false ? options.async || me.getAsync() : false;
    if (username) {
      xhr.open(requestOptions.method, requestOptions.url, async, username, password);
    } else {
      xhr.open(requestOptions.method, requestOptions.url, async);
    }
    headers = me.setupHeaders(xhr, options, requestOptions.data, requestOptions.params);
    request = {id:++Ext.data.Connection.requestId, xhr:xhr, headers:headers, options:options, async:async, timeout:setTimeout(function() {
      request.timedout = true;
      me.abort(request);
    }, options.timeout || me.getTimeout())};
    me.requests[request.id] = request;
    if (async) {
      xhr[useXhr2 ? 'onload' : 'onreadystatechange'] = Ext.Function.bind(me.onStateChange, me, [request]);
    }
    if (useXhr2) {
      xhr.onerror = Ext.Function.bind(me.onStateChange, me, [request]);
    }
    if (options.progress) {
      xhr.onprogress = function(e) {
        if (options.progress.isProgressable) {
          if (e.total === 0 && options.progress.getDynamic()) {
            Ext.Logger.warn('Server is not configured to properly return Content-Length. Dynamic progress will be disabled');
            options.progress.setState.call(options.progress, 'download');
            options.progress.setDynamic(false);
            xhr.onprogress = null;
            return;
          }
          Ext.callback(options.progress.updateProgress, options.progress, [e.loaded / e.total, 'download']);
          if (e.total > 0 && !options.progress.getDynamic() && options.progress.getInitialConfig().dynamic) {
            options.progress.setDynamic(true);
          }
        } else {
          if (Ext.isFunction(options.progress)) {
            Ext.callback(options.progress, options.progressScope || request, [e, 'download']);
          }
        }
      };
      if (Ext.feature.has.XHRUploadProgress) {
        xhr.upload.onprogress = function(e) {
          me.fireEvent('requestuploadprogress', me, request, e);
          if (options.progress.isProgressable) {
            Ext.callback(options.progress.updateProgress, options.progress, [e.loaded / e.total, 'upload']);
          } else {
            if (Ext.isFunction(options.progress)) {
              Ext.callback(options.progress, options.progressScope || request, [e, 'upload']);
            }
          }
        };
      }
      if (options.progress.isProgressable) {
        if (!Ext.feature.has.XHRUploadProgress) {
          options.progress.setDynamic(false);
        }
        Ext.callback(options.progress.startProgress, options.progress);
      }
    }
    xhr.send(requestOptions.data);
    if (!async) {
      return this.onComplete(request);
    }
    return request;
  } else {
    Ext.callback(options.callback, options.scope, [options, undefined, undefined]);
    return null;
  }
}, upload:function(form, url, params, options) {
  form = Ext.getDom(form);
  options = options || {};
  var id = Ext.id(), me = this, frame = document.createElement('iframe'), hiddens = [], encoding = 'multipart/form-data', buf = {target:form.target, method:form.method, encoding:form.encoding, enctype:form.enctype, action:form.action}, addField = function(name, value) {
    hiddenItem = document.createElement('input');
    Ext.fly(hiddenItem).set({type:'hidden', value:value, name:name});
    form.appendChild(hiddenItem);
    hiddens.push(hiddenItem);
  }, hiddenItem;
  Ext.fly(frame).set({id:id, name:id, cls:'x-hide-display', src:Ext.SSL_SECURE_URL});
  document.body.appendChild(frame);
  if (document.frames) {
    document.frames[id].name = id;
  }
  Ext.fly(form).set({target:id, method:'POST', enctype:encoding, encoding:encoding, action:url || buf.action});
  if (params) {
    Ext.iterate(Ext.Object.fromQueryString(params), function(name, value) {
      if (Ext.isArray(value)) {
        Ext.each(value, function(v) {
          addField(name, v);
        });
      } else {
        addField(name, value);
      }
    });
  }
  frame.addEventListener('load', function() {
    Ext.callback(me.onUploadComplete, me, [frame, options, id]);
    frame.removeEventListener('load', arguments.callee);
  });
  form.submit();
  Ext.fly(form).set(buf);
  Ext.each(hiddens, function(h) {
    Ext.removeNode(h);
  });
}, onUploadComplete:function(frame, options, id) {
  var response = {responseText:'', responseXML:null, request:{options:options}}, doc, body, firstChild;
  try {
    doc = frame.contentWindow && frame.contentWindow.document || frame.contentDocument || window.frames[id].document;
    if (doc) {
      if (doc.hasOwnProperty('body') && doc.body) {
        body = doc.body;
      }
      if (body) {
        firstChild = body.firstChild || {};
        if (this.textAreaRe.test(firstChild.tagName)) {
          response.responseText = firstChild.value;
        } else {
          response.responseText = firstChild.innerHTML;
        }
        response.responseXML = body.XMLDocument;
      }
    }
  } catch (e$6) {
    response.success = false;
    response.message = 'Cross-Domain access is not permitted between frames. XHR2 is recommended for this type of request.';
    response.error = e$6;
  }
  this.onAfterUploadComplete(response, frame, options);
}, onAfterUploadComplete:function(response, frame, options) {
  var me = this;
  me.fireEvent('requestcomplete', me, response, options);
  Ext.callback(options.callback, options.scope, [options, true, response]);
  setTimeout(function() {
    Ext.removeNode(frame);
  }, 100);
}, isFormUpload:function(options) {
  var form = this.getForm(options);
  if (form) {
    return options.isUpload || this.multiPartRe.test(form.getAttribute('enctype'));
  }
  return false;
}, getForm:function(options) {
  return Ext.getDom(options.form) || null;
}, setOptions:function(options, scope) {
  var me = this, params = options.params || {}, extraParams = me.getExtraParams(), urlParams = options.urlParams, url = options.url || me.getUrl(), jsonData = options.jsonData, method, disableCache, data;
  if (Ext.isFunction(params)) {
    params = params.call(scope, options);
  }
  if (Ext.isFunction(url)) {
    url = url.call(scope, options);
  }
  url = this.setupUrl(options, url);
  data = options.data || options.rawData || options.binaryData || options.xmlData || jsonData || null;
  if (jsonData && !Ext.isPrimitive(jsonData)) {
    data = Ext.encode(data);
  }
  if (options.binaryData) {
    if (data instanceof Array) {
      data = new Uint8Array(options.binaryData);
    }
    if (data instanceof Uint8Array) {
      data = data.buffer;
    }
  }
  if (Ext.isObject(params)) {
    params = Ext.Object.toQueryString(params);
  }
  if (Ext.isObject(extraParams)) {
    extraParams = Ext.Object.toQueryString(extraParams);
  }
  params = params + (extraParams ? (params ? '\x26' : '') + extraParams : '');
  urlParams = Ext.isObject(urlParams) ? Ext.Object.toQueryString(urlParams) : urlParams;
  params = this.setupParams(options, params);
  method = (options.method || me.getMethod() || (params || data ? 'POST' : 'GET')).toUpperCase();
  this.setupMethod(options, method);
  disableCache = options.disableCaching !== false ? options.disableCaching || me.getDisableCaching() : false;
  if (disableCache) {
    url = Ext.urlAppend(url, (options.disableCachingParam || me.getDisableCachingParam()) + '\x3d' + (new Date).getTime());
  }
  if ((method == 'GET' || data) && params) {
    url = Ext.urlAppend(url, params);
    params = null;
  }
  if (urlParams) {
    url = Ext.urlAppend(url, urlParams);
  }
  return {url:url, method:method, data:data || params || null};
}, setupUrl:function(options, url) {
  var form = this.getForm(options);
  if (form) {
    url = url || form.action;
  }
  return url;
}, setupParams:function(options, params) {
  var form = this.getForm(options), serializedForm;
  if (form && !this.isFormUpload(options)) {
    serializedForm = Ext.Element.serializeForm(form);
    params = params ? params + '\x26' + serializedForm : serializedForm;
  }
  return params;
}, setupMethod:function(options, method) {
  if (this.isFormUpload(options)) {
    return 'POST';
  }
  return method;
}, setupHeaders:function(xhr, options, data, params) {
  var me = this, headers = Ext.apply({}, options.headers || {}, me.getDefaultHeaders() || {}), contentType = me.getDefaultPostHeader(), jsonData = options.jsonData, xmlData = options.xmlData, key, header;
  if (!headers['Content-Type'] && (data || params)) {
    if (data) {
      if (options.rawData) {
        contentType = 'text/plain';
      } else {
        if (xmlData && Ext.isDefined(xmlData)) {
          contentType = 'text/xml';
        } else {
          if (jsonData && Ext.isDefined(jsonData)) {
            contentType = 'application/json';
          }
        }
      }
    }
    if (!(Ext.feature.has.XHR2 && data instanceof FormData)) {
      headers['Content-Type'] = contentType;
    }
  }
  if ((me.getUseDefaultXhrHeader() && options.useDefaultXhrHeader !== false || options.useDefaultXhrHeader) && !headers['X-Requested-With']) {
    headers['X-Requested-With'] = me.getDefaultXhrHeader();
  }
  if (!Ext.isEmpty(options.username) && !Ext.isEmpty(options.password)) {
    headers['Authorization'] = 'Basic ' + btoa(options.username + ':' + options.password);
  }
  try {
    for (key in headers) {
      if (headers.hasOwnProperty(key)) {
        header = headers[key];
        xhr.setRequestHeader(key, header);
      }
    }
  } catch (e$7) {
    me.fireEvent('exception', key, header);
  }
  if (options.responseType) {
    try {
      xhr.responseType = options.responseType === 'blob' && Ext.browser.is.Safari ? 'arraybuffer' : options.responseType;
    } catch (e$8) {
    }
  }
  if (options.withCredentials) {
    xhr.withCredentials = options.withCredentials;
  }
  return headers;
}, getXhrInstance:function() {
  var options = [function() {
    return new XMLHttpRequest;
  }, function() {
    return new ActiveXObject('MSXML2.XMLHTTP.3.0');
  }, function() {
    return new ActiveXObject('MSXML2.XMLHTTP');
  }, function() {
    return new ActiveXObject('Microsoft.XMLHTTP');
  }], i = 0, len = options.length, xhr;
  for (; i < len; ++i) {
    try {
      xhr = options[i];
      xhr();
      break;
    } catch (e$9) {
    }
  }
  return xhr;
}(), isLoading:function(request) {
  if (!(request && request.xhr)) {
    return false;
  }
  var state = request.xhr.readyState;
  return !(state === 0 || state == 4);
}, abort:function(request) {
  var me = this, requests = me.requests, id;
  if (request && me.isLoading(request)) {
    request.xhr.onreadystatechange = null;
    request.xhr.abort();
    me.clearTimeout(request);
    if (!request.timedout) {
      request.aborted = true;
    }
    me.onComplete(request);
    me.cleanup(request);
  } else {
    if (!request) {
      for (id in requests) {
        if (requests.hasOwnProperty(id)) {
          me.abort(requests[id]);
        }
      }
    }
  }
}, abortAll:function() {
  this.abort();
}, onStateChange:function(request) {
  if (request.xhr.readyState == 4) {
    this.clearTimeout(request);
    this.onComplete(request);
    this.cleanup(request);
  }
}, clearTimeout:function(request) {
  clearTimeout(request.timeout);
  delete request.timeout;
}, cleanup:function(request) {
  request.xhr = null;
  delete request.xhr;
}, onComplete:function(request) {
  var me = this, options = request.options, result, success, response;
  try {
    result = me.parseStatus(request.xhr.status, request.xhr);
    if (request.timedout) {
      result.success = false;
    }
  } catch (e$10) {
    result = {success:false, isException:false};
  }
  success = result.success;
  if (success) {
    response = me.createResponse(request);
    me.fireEvent('requestcomplete', me, response, options);
    Ext.callback(options.success, options.scope, [response, options]);
  } else {
    if (result.isException || request.aborted || request.timedout) {
      response = me.createException(request);
    } else {
      response = me.createResponse(request);
    }
    me.fireEvent('requestexception', me, response, options);
    Ext.callback(options.failure, options.scope, [response, options]);
  }
  Ext.callback(options.callback, options.scope, [options, success, response]);
  if (options.progress && options.progress.isProgressable) {
    Ext.callback(options.progress.endProgress, options.progress, [result]);
  }
  delete me.requests[request.id];
  return response;
}, parseStatus:function(status, xhr) {
  status = status == 1223 ? 204 : status;
  var success = status >= 200 && status < 300 || status == 304 || status == 0 && xhr.responseText && xhr.responseText.length > 0, isException = false;
  if (!success) {
    switch(status) {
      case 12002:
      case 12029:
      case 12030:
      case 12031:
      case 12152:
      case 13030:
        isException = true;
        break;
    }
  }
  return {success:success, isException:isException};
}, createResponse:function(request) {
  var xhr = request.xhr, headers = {}, lines, count, line, index, key, response, binaryResponse = xhr.responseType === 'blob' || xhr.responseType === 'arraybuffer', textResponse = xhr.responseType === 'text', documentResponse = xhr.responseType === 'document';
  if (request.timedout || request.aborted) {
    request.success = false;
    lines = [];
  } else {
    lines = xhr.getAllResponseHeaders().replace(this.lineBreakRe, '\n').split('\n');
  }
  count = lines.length;
  while (count--) {
    line = lines[count];
    index = line.indexOf(':');
    if (index >= 0) {
      key = line.substr(0, index).toLowerCase();
      if (line.charAt(index + 1) == ' ') {
        ++index;
      }
      headers[key] = line.substr(index + 1);
    }
  }
  request.xhr = null;
  delete request.xhr;
  response = {request:request, requestId:request.id, status:xhr.status, statusText:xhr.statusText, getResponseHeader:function(header) {
    return headers[header.toLowerCase()];
  }, getAllResponseHeaders:function() {
    return headers;
  }, responseText:binaryResponse ? null : documentResponse ? null : xhr.responseText, responseXML:binaryResponse ? null : textResponse ? null : xhr.responseXML, responseBytes:binaryResponse ? xhr.response : null};
  if (request.options.responseType === 'blob' && xhr.responseType === 'arraybuffer') {
    response.responseBytes = new Blob([response.responseBytes], {type:xhr.getResponseHeader('Content-Type')});
  }
  xhr = null;
  return response;
}, createException:function(request) {
  return {request:request, requestId:request.id, status:request.aborted ? -1 : 0, statusText:request.aborted ? 'transaction aborted' : 'communication failure', aborted:request.aborted, timedout:request.timedout};
}}, 1, 0, 0, 0, 0, [['observable', Ext.mixin.Observable]], [Ext.data, 'Connection'], 0);
Ext.cmd.derive('Ext.Ajax', Ext.data.Connection, {singleton:true, autoAbort:false}, 0, 0, 0, 0, 0, 0, [Ext, 'Ajax'], 0);
Ext.cmd.derive('Ext.ComponentQuery', Ext.Base, {singleton:true}, 0, 0, 0, 0, 0, 0, [Ext, 'ComponentQuery'], function() {
  var cq = this, filterFnPattern = ['var r \x3d [],', 'i \x3d 0,', 'it \x3d items,', 'l \x3d it.length,', 'c;', 'for (; i \x3c l; i++) {', 'c \x3d it[i];', 'if (c.{0}) {', 'r.push(c);', '}', '}', 'return r;'].join(''), filterItems = function(items, operation) {
    return operation.method.apply(this, [items].concat(operation.args));
  }, getItems = function(items, mode) {
    var result = [], i = 0, length = items.length, candidate, deep = mode !== '\x3e';
    for (; i < length; i++) {
      candidate = items[i];
      if (candidate.getRefItems) {
        result = result.concat(candidate.getRefItems(deep));
      }
    }
    return result;
  }, getAncestors = function(items) {
    var result = [], i = 0, length = items.length, candidate;
    for (; i < length; i++) {
      candidate = items[i];
      while (!!(candidate = candidate.ownerCt || candidate.floatParent)) {
        result.push(candidate);
      }
    }
    return result;
  }, filterByXType = function(items, xtype, shallow) {
    if (xtype === '*') {
      return items.slice();
    } else {
      var result = [], i = 0, length = items.length, candidate;
      for (; i < length; i++) {
        candidate = items[i];
        if (candidate.isXType(xtype, shallow)) {
          result.push(candidate);
        }
      }
      return result;
    }
  }, filterByClassName = function(items, className) {
    var EA = Ext.Array, result = [], i = 0, length = items.length, candidate;
    for (; i < length; i++) {
      candidate = items[i];
      if (candidate.el ? candidate.el.hasCls(className) : EA.contains(candidate.initCls(), className)) {
        result.push(candidate);
      }
    }
    return result;
  }, filterByAttribute = function(items, property, operator, value) {
    var result = [], i = 0, length = items.length, candidate, getter, getValue;
    for (; i < length; i++) {
      candidate = items[i];
      getter = Ext.Class.getConfigNameMap(property).get;
      if (operator === '~\x3d') {
        getValue = null;
        if (candidate[getter]) {
          getValue = candidate[getter]();
        } else {
          if (candidate.config && candidate.config[property]) {
            getValue = String(candidate.config[property]);
          } else {
            if (candidate[property]) {
              getValue = String(candidate[property]);
            }
          }
        }
        if (getValue) {
          if (!Ext.isArray(getValue)) {
            getValue = getValue.split(' ');
          }
          var v = 0, vLen = getValue.length, val;
          for (; v < vLen; v++) {
            val = String(getValue[v]).split(' ');
            if (Ext.Array.indexOf(val, value) !== -1) {
              result.push(candidate);
            }
          }
        }
      } else {
        if (candidate[getter]) {
          getValue = candidate[getter]();
          if (!value ? !!getValue : String(getValue) === value) {
            result.push(candidate);
          }
        } else {
          if (candidate.config && candidate.config[property]) {
            if (!value ? !!candidate.config[property] : String(candidate.config[property]) === value) {
              result.push(candidate);
            }
          } else {
            if (!value ? !!candidate[property] : String(candidate[property]) === value) {
              result.push(candidate);
            }
          }
        }
      }
    }
    return result;
  }, filterById = function(items, id) {
    var result = [], i = 0, length = items.length, candidate;
    for (; i < length; i++) {
      candidate = items[i];
      if (candidate.getId() === id || candidate.getItemId() === id) {
        result.push(candidate);
      }
    }
    return result;
  }, filterByPseudo = function(items, name, value) {
    return cq.pseudos[name](items, value);
  }, modeRe = /^(\s?([>\^])\s?|\s|$)/, tokenRe = /^(#)?([\w\-]+|\*)(?:\((true|false)\))?/, matchers = [{re:/^\.([\w\-]+)(?:\((true|false)\))?/, method:filterByXType}, {re:/^(?:[\[](?:@)?([\w\-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]])/, method:filterByAttribute}, {re:/^#([\w\-]+)/, method:filterById}, {re:/^:([\w\-]+)(?:\(((?:\{[^\}]+\})|(?:(?!\{)[^\s>\/]*?(?!\})))\))?/, method:filterByPseudo}, {re:/^(?:\{([^\}]+)\})/, method:filterFnPattern}];
  cq.Query = Ext.extend(Object, {constructor:function(cfg) {
    cfg = cfg || {};
    Ext.apply(this, cfg);
  }, execute:function(root) {
    var operations = this.operations, i = 0, length = operations.length, operation, workingItems;
    if (!root) {
      workingItems = Ext.ComponentManager.all.getArray();
    } else {
      if (Ext.isArray(root)) {
        workingItems = root;
      }
    }
    for (; i < length; i++) {
      operation = operations[i];
      if (operation.mode === '^') {
        workingItems = getAncestors(workingItems || [root]);
      } else {
        if (operation.mode) {
          workingItems = getItems(workingItems || [root], operation.mode);
        } else {
          workingItems = filterItems(workingItems || getItems([root]), operation);
        }
      }
      if (i === length - 1) {
        return workingItems;
      }
    }
    return [];
  }, is:function(component) {
    var operations = this.operations, components = Ext.isArray(component) ? component : [component], originalLength = components.length, lastOperation = operations[operations.length - 1], ln, i;
    components = filterItems(components, lastOperation);
    if (components.length === originalLength) {
      if (operations.length > 1) {
        for (i = 0, ln = components.length; i < ln; i++) {
          if (Ext.Array.indexOf(this.execute(), components[i]) === -1) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }});
  Ext.apply(this, {cache:{}, pseudos:{not:function(components, selector) {
    var CQ = Ext.ComponentQuery, i = 0, length = components.length, results = [], index = -1, component;
    for (; i < length; ++i) {
      component = components[i];
      if (!CQ.is(component, selector)) {
        results[++index] = component;
      }
    }
    return results;
  }}, query:function(selector, root) {
    var selectors = selector.split(','), length = selectors.length, i = 0, results = [], noDupResults = [], dupMatcher = {}, query, resultsLn, cmp;
    for (; i < length; i++) {
      selector = Ext.String.trim(selectors[i]);
      query = this.parse(selector);
      results = results.concat(query.execute(root));
    }
    if (length > 1) {
      resultsLn = results.length;
      for (i = 0; i < resultsLn; i++) {
        cmp = results[i];
        if (!dupMatcher[cmp.id]) {
          noDupResults.push(cmp);
          dupMatcher[cmp.id] = true;
        }
      }
      results = noDupResults;
    }
    return results;
  }, is:function(component, selector) {
    if (!selector) {
      return true;
    }
    var query = this.cache[selector];
    if (!query) {
      this.cache[selector] = query = this.parse(selector);
    }
    return query.is(component);
  }, parse:function(selector) {
    var operations = [], length = matchers.length, lastSelector, tokenMatch, matchedChar, modeMatch, selectorMatch, i, matcher, method;
    while (selector && lastSelector !== selector) {
      lastSelector = selector;
      tokenMatch = selector.match(tokenRe);
      if (tokenMatch) {
        matchedChar = tokenMatch[1];
        if (matchedChar === '#') {
          operations.push({method:filterById, args:[Ext.String.trim(tokenMatch[2])]});
        } else {
          if (matchedChar === '.') {
            operations.push({method:filterByClassName, args:[Ext.String.trim(tokenMatch[2])]});
          } else {
            operations.push({method:filterByXType, args:[Ext.String.trim(tokenMatch[2]), Boolean(tokenMatch[3])]});
          }
        }
        selector = selector.replace(tokenMatch[0], '');
      }
      while (!(modeMatch = selector.match(modeRe))) {
        for (i = 0; selector && i < length; i++) {
          matcher = matchers[i];
          selectorMatch = selector.match(matcher.re);
          method = matcher.method;
          if (selectorMatch) {
            operations.push({method:Ext.isString(matcher.method) ? Ext.functionFactory('items', Ext.String.format.apply(Ext.String, [method].concat(selectorMatch.slice(1)))) : matcher.method, args:selectorMatch.slice(1)});
            selector = selector.replace(selectorMatch[0], '');
            break;
          }
        }
      }
      if (modeMatch[1]) {
        operations.push({mode:modeMatch[2] || modeMatch[1]});
        selector = selector.replace(modeMatch[0], '');
      }
    }
    return new cq.Query({operations:operations});
  }});
});
Ext.cmd.derive('Ext.Decorator', Ext.Component, {isDecorator:true, config:{component:{}}, statics:{generateProxySetter:function(name) {
  return function(value) {
    var component = this.getComponent();
    component[name].call(component, value);
    return this;
  };
}, generateProxyGetter:function(name) {
  return function() {
    var component = this.getComponent();
    return component[name].call(component);
  };
}}, onClassExtended:function(Class, members) {
  if (!members.hasOwnProperty('proxyConfig')) {
    return;
  }
  var ExtClass = Ext.Class, proxyConfig = members.proxyConfig, config = members.config;
  members.config = config ? Ext.applyIf(config, proxyConfig) : proxyConfig;
  var name, nameMap, setName, getName;
  for (name in proxyConfig) {
    if (proxyConfig.hasOwnProperty(name)) {
      nameMap = ExtClass.getConfigNameMap(name);
      setName = nameMap.set;
      getName = nameMap.get;
      members[setName] = this.generateProxySetter(setName);
      members[getName] = this.generateProxyGetter(getName);
    }
  }
}, applyComponent:function(config) {
  return Ext.factory(config, Ext.Component);
}, updateComponent:function(newComponent, oldComponent) {
  if (oldComponent) {
    if (this.isRendered() && oldComponent.setRendered(false)) {
      oldComponent.fireAction('renderedchange', [this, oldComponent, false], 'doUnsetComponent', this, {args:[oldComponent]});
    } else {
      this.doUnsetComponent(oldComponent);
    }
  }
  if (newComponent) {
    if (this.isRendered() && newComponent.setRendered(true)) {
      newComponent.fireAction('renderedchange', [this, newComponent, true], 'doSetComponent', this, {args:[newComponent]});
    } else {
      this.doSetComponent(newComponent);
    }
  }
}, doUnsetComponent:function(component) {
  if (component.renderElement.dom) {
    component.setLayoutSizeFlags(0);
    this.innerElement.dom.removeChild(component.renderElement.dom);
  }
}, doSetComponent:function(component) {
  if (component.renderElement.dom) {
    component.setLayoutSizeFlags(this.getSizeFlags());
    this.innerElement.dom.appendChild(component.renderElement.dom);
  }
}, setRendered:function(rendered) {
  var component;
  if (Ext.Component.prototype.setRendered.apply(this, arguments)) {
    component = this.getComponent();
    if (component) {
      component.setRendered(rendered);
    }
    return true;
  }
  return false;
}, setDisabled:function(disabled) {
  this.callParent(arguments);
  this.getComponent().setDisabled(disabled);
}, destroy:function() {
  Ext.destroy(this.getComponent());
  Ext.Component.prototype.destroy.call(this);
}}, 0, 0, ['component'], {'component':true}, 0, 0, [Ext, 'Decorator'], 0);
Ext.cmd.derive('Ext.Img', Ext.Component, {config:{src:null, baseCls:'x-img', imageCls:'x-img-image', backgroundCls:'x-img-background', mode:'background'}, beforeInitialize:function() {
  var me = this;
  me.onLoad = Ext.Function.bind(me.onLoad, me);
  me.onError = Ext.Function.bind(me.onError, me);
}, initialize:function() {
  var me = this;
  Ext.Component.prototype.initialize.call(this);
  me.relayEvents(me.renderElement, '*');
  me.element.on({tap:'onTap', scope:me});
}, hide:function() {
  Ext.Component.prototype.hide.apply(this, arguments);
  this.hiddenSrc = this.hiddenSrc || this.getSrc();
  this.setSrc(null);
}, show:function() {
  Ext.Component.prototype.show.apply(this, arguments);
  if (this.hiddenSrc) {
    this.setSrc(this.hiddenSrc);
    delete this.hiddenSrc;
  }
}, updateMode:function(mode) {
  var me = this, imageCls = me.getImageCls(), backgroundCls = me.getBackgroundCls();
  if (mode === 'background') {
    if (me.imageElement) {
      me.imageElement.destroy();
      delete me.imageElement;
      me.updateSrc(me.getSrc());
    }
    me.replaceCls(imageCls, backgroundCls);
  } else {
    me.imageElement = me.element.createChild({tag:'img'});
    me.replaceCls(backgroundCls, imageCls);
  }
}, updateImageCls:function(newCls, oldCls) {
  this.replaceCls(oldCls, newCls);
}, updateBackgroundCls:function(newCls, oldCls) {
  this.replaceCls(oldCls, newCls);
}, onTap:function(e) {
  this.fireEvent('tap', this, e);
}, onAfterRender:function() {
  this.updateSrc(this.getSrc());
}, updateSrc:function(newSrc) {
  var me = this, dom;
  if (me.getMode() === 'background') {
    dom = this.imageObject || new Image;
  } else {
    dom = me.imageElement.dom;
  }
  this.imageObject = dom;
  dom.setAttribute('src', Ext.isString(newSrc) ? newSrc : '');
  dom.addEventListener('load', me.onLoad, false);
  dom.addEventListener('error', me.onError, false);
}, detachListeners:function() {
  var dom = this.imageObject;
  if (dom) {
    dom.removeEventListener('load', this.onLoad, false);
    dom.removeEventListener('error', this.onError, false);
  }
}, onLoad:function(e) {
  this.detachListeners();
  if (this.getMode() === 'background') {
    this.element.dom.style.backgroundImage = 'url("' + this.imageObject.src + '")';
  }
  this.fireEvent('load', this, e);
}, onError:function(e) {
  this.detachListeners();
  if (this.getMode() === 'background') {
    this.element.dom.style.backgroundImage = 'url("' + this.imageObject.src + '")';
  }
  this.fireEvent('error', this, e);
}, doSetWidth:function(width) {
  var sizingElement = this.getMode() === 'background' ? this.element : this.imageElement;
  sizingElement.setWidth(width);
  Ext.Component.prototype.doSetWidth.apply(this, arguments);
}, doSetHeight:function(height) {
  var sizingElement = this.getMode() === 'background' ? this.element : this.imageElement;
  sizingElement.setHeight(height);
  Ext.Component.prototype.doSetHeight.apply(this, arguments);
}, destroy:function() {
  this.detachListeners();
  Ext.destroy(this.imageObject, this.imageElement);
  delete this.imageObject;
  delete this.imageElement;
  Ext.Component.prototype.destroy.call(this);
}}, 0, ['image', 'img'], ['component', 'image', 'img'], {'component':true, 'image':true, 'img':true}, ['widget.image', 'widget.img'], 0, [Ext, 'Img'], 0);
Ext.cmd.derive('Ext.Label', Ext.Component, {config:{baseCls:'x-label'}}, 0, ['label'], ['component', 'label'], {'component':true, 'label':true}, ['widget.label'], 0, [Ext, 'Label'], 0);
Ext.cmd.derive('Ext.LoadMask', Ext.Mask, {config:{message:'Loading...', cls:'x-loading-mask', messageCls:'x-mask-message', indicator:true}, getTemplate:function() {
  var prefix = 'x-';
  return [{reference:'innerElement', cls:prefix + 'mask-inner', children:[{reference:'indicatorElement', cls:prefix + 'loading-spinner-outer', children:[{cls:prefix + 'loading-spinner', children:[{tag:'span', cls:prefix + 'loading-top'}, {tag:'span', cls:prefix + 'loading-right'}, {tag:'span', cls:prefix + 'loading-bottom'}, {tag:'span', cls:prefix + 'loading-left'}]}]}, {reference:'messageElement'}]}];
}, updateMessage:function(newMessage) {
  var cls = 'x-has-message';
  if (newMessage) {
    this.addCls(cls);
  } else {
    this.removeCls(cls);
  }
  this.messageElement.setHtml(newMessage);
}, updateMessageCls:function(newMessageCls, oldMessageCls) {
  this.messageElement.replaceCls(oldMessageCls, newMessageCls);
}, updateIndicator:function(newIndicator) {
  this[newIndicator ? 'removeCls' : 'addCls']('x-indicator-hidden');
}}, 0, ['loadmask'], ['component', 'mask', 'loadmask'], {'component':true, 'mask':true, 'loadmask':true}, ['widget.loadmask'], 0, [Ext, 'LoadMask'], function() {
});
Ext.cmd.derive('Ext.Menu', Ext.Sheet, {config:{baseCls:'x-menu', left:0, right:0, bottom:0, height:'auto', width:'auto', defaultType:'button', showAnimation:null, hideAnimation:null, centered:false, modal:true, hidden:true, hideOnMaskTap:true, translatable:{translationMethod:null}}, constructor:function() {
  this.config.translatable.translationMethod = Ext.browser.is.AndroidStock2 ? 'cssposition' : 'csstransform';
  Ext.Sheet.prototype.constructor.apply(this, arguments);
}, platformConfig:[{theme:['Windows']}, {theme:['Blackberry', 'Blackberry103'], ui:'context', layout:{pack:'center'}}], updateUi:function(newUi, oldUi) {
  Ext.Sheet.prototype.updateUi.apply(this, arguments);
  if (newUi != oldUi && (Ext.theme.is.Blackberry || Ext.theme.is.Blackberry103)) {
    if (newUi == 'context') {
      this.innerElement.swapCls('x-vertical', 'x-horizontal');
    } else {
      if (newUi == 'application') {
        this.innerElement.swapCls('x-horizontal', 'x-vertical');
      }
    }
  }
}, updateHideOnMaskTap:function(hide) {
  var mask = this.getModal();
  if (mask) {
    mask[hide ? 'on' : 'un'].call(mask, 'tap', function() {
      Ext.Viewport.hideMenu(this.$side);
    }, this);
  }
}, doSetHidden:function() {
  if (this.initialized) {
    Ext.Sheet.prototype.doSetHidden.apply(this, arguments);
  }
}}, 1, ['menu'], ['component', 'container', 'panel', 'sheet', 'menu'], {'component':true, 'container':true, 'panel':true, 'sheet':true, 'menu':true}, ['widget.menu'], 0, [Ext, 'Menu'], 0);
Ext.cmd.derive('Ext.Title', Ext.Component, {config:{baseCls:'x-title', title:''}, updateTitle:function(newTitle) {
  this.setHtml(newTitle);
}}, 0, ['title'], ['component', 'title'], {'component':true, 'title':true}, ['widget.title'], 0, [Ext, 'Title'], 0);
Ext.cmd.derive('Ext.Spacer', Ext.Component, {config:{}, constructor:function(config) {
  config = config || {};
  if (!config.width) {
    config.flex = 1;
  }
  Ext.Component.prototype.constructor.call(this, config);
}}, 1, ['spacer'], ['component', 'spacer'], {'component':true, 'spacer':true}, ['widget.spacer'], 0, [Ext, 'Spacer'], 0);
Ext.cmd.derive('Ext.Toolbar', Ext.Container, {isToolbar:true, config:{baseCls:'x-toolbar', ui:'dark', title:null, defaultType:'button', minHeight:null, layout:{type:'hbox', align:'center'}}, hasCSSMinHeight:true, constructor:function(config) {
  config = config || {};
  if (config.docked == 'left' || config.docked == 'right') {
    config.layout = {type:'vbox', align:'stretch'};
  }
  Ext.Container.prototype.constructor.call(this, config);
}, applyTitle:function(title) {
  if (typeof title == 'string') {
    title = {title:title, centered:Ext.theme.is.Tizen ? false : true};
  }
  return Ext.factory(title, Ext.Title, this.getTitle());
}, updateTitle:function(newTitle, oldTitle) {
  if (newTitle) {
    this.add(newTitle);
  }
  if (oldTitle) {
    oldTitle.destroy();
  }
}, showTitle:function() {
  var title = this.getTitle();
  if (title) {
    title.show();
  }
}, hideTitle:function() {
  var title = this.getTitle();
  if (title) {
    title.hide();
  }
}}, 1, ['toolbar'], ['component', 'container', 'toolbar'], {'component':true, 'container':true, 'toolbar':true}, ['widget.toolbar'], 0, [Ext, 'Toolbar'], function() {
});
Ext.cmd.derive('Ext.field.Input', Ext.Component, {tag:'input', cachedConfig:{cls:'x-form-field', focusCls:'x-field-focus', maskCls:'x-field-mask', useMask:'auto', type:'text', checked:false}, config:{baseCls:'x-field-input', name:null, value:null, isFocused:false, tabIndex:null, placeHolder:null, minValue:null, maxValue:null, stepValue:null, maxLength:null, autoComplete:null, autoCapitalize:null, autoCorrect:null, readOnly:null, maxRows:null, pattern:null, startValue:false, fastFocus:true}, getTemplate:function() {
  var items = [{reference:'input', tag:this.tag}, {reference:'mask', classList:[this.config.maskCls]}, {reference:'clearIcon', cls:'x-clear-icon'}];
  return items;
}, initElement:function() {
  var me = this;
  Ext.Component.prototype.initElement.call(this);
  me.input.on({scope:me, keyup:'onKeyUp', keydown:'onKeyDown', focus:'onFocus', blur:'onBlur', input:'onInput', paste:'onPaste', tap:'onInputTap'});
  if (Ext.browser.is.AndroidStock) {
    me.input.dom.addEventListener('mousedown', function(e) {
      if (document.activeElement != e.target) {
        e.preventDefault();
      }
    });
    me.input.dom.addEventListener('touchend', function() {
      me.focus();
    });
  }
  me.mask.on({scope:me, tap:'onMaskTap'});
  if (me.clearIcon) {
    me.clearIcon.on({tap:'onClearIconTap', touchstart:'onClearIconPress', touchend:'onClearIconRelease', scope:me});
  }
  if (Ext.browser.is.ie && Ext.browser.version.major >= 10) {
    me.input.on({scope:me, keypress:'onKeyPress'});
  }
}, updateFastFocus:function(newValue) {
  if (newValue) {
    if (this.getFastFocus() && Ext.os.is.iOS) {
      this.input.on({scope:this, touchstart:'onTouchStart'});
    }
  } else {
    this.input.un({scope:this, touchstart:'onTouchStart'});
  }
}, useManualMaxLength:function() {
  return Boolean(Ext.os.is.Android && !Ext.browser.is.Chrome);
}, applyUseMask:function(useMask) {
  if (useMask === 'auto') {
    useMask = Ext.os.is.iOS && Ext.os.version.lt('5');
  }
  return Boolean(useMask);
}, updateUseMask:function(newUseMask) {
  this.mask[newUseMask ? 'show' : 'hide']();
}, updatePattern:function(pattern) {
  this.updateFieldAttribute('pattern', pattern);
}, updateFieldAttribute:function(attribute, newValue) {
  var input = this.input;
  if (!Ext.isEmpty(newValue, true)) {
    input.dom.setAttribute(attribute, newValue);
  } else {
    input.dom.removeAttribute(attribute);
  }
}, updateCls:function(newCls, oldCls) {
  this.input.addCls('x-input-el');
  this.input.replaceCls(oldCls, newCls);
}, updateType:function(newType, oldType) {
  var prefix = 'x-input-';
  this.input.replaceCls(prefix + oldType, prefix + newType);
  this.updateFieldAttribute('type', newType);
}, updateName:function(newName) {
  this.updateFieldAttribute('name', newName);
}, getValue:function() {
  var input = this.input;
  if (input) {
    this._value = input.dom.value;
  }
  return this._value;
}, applyValue:function(value) {
  return Ext.isEmpty(value) ? '' : value;
}, updateValue:function(newValue) {
  var input = this.input;
  if (input) {
    input.dom.value = newValue;
  }
}, setValue:function(newValue) {
  var oldValue = this._value;
  this.updateValue(this.applyValue(newValue));
  newValue = this.getValue();
  if (String(newValue) != String(oldValue) && this.initialized) {
    this.onChange(this, newValue, oldValue);
  }
  return this;
}, updateTabIndex:function(newTabIndex) {
  this.updateFieldAttribute('tabIndex', newTabIndex);
}, testAutoFn:function(value) {
  return [true, 'on'].indexOf(value) !== -1;
}, updateMaxLength:function(newMaxLength) {
  if (!this.useManualMaxLength()) {
    this.updateFieldAttribute('maxlength', newMaxLength);
  }
}, updatePlaceHolder:function(newPlaceHolder) {
  this.updateFieldAttribute('placeholder', newPlaceHolder);
}, applyAutoComplete:function(autoComplete) {
  return this.testAutoFn(autoComplete);
}, updateAutoComplete:function(newAutoComplete) {
  var value = newAutoComplete ? 'on' : 'off';
  this.updateFieldAttribute('autocomplete', value);
}, applyAutoCapitalize:function(autoCapitalize) {
  return this.testAutoFn(autoCapitalize);
}, updateAutoCapitalize:function(newAutoCapitalize) {
  var value = newAutoCapitalize ? 'on' : 'off';
  this.updateFieldAttribute('autocapitalize', value);
}, applyAutoCorrect:function(autoCorrect) {
  return this.testAutoFn(autoCorrect);
}, updateAutoCorrect:function(newAutoCorrect) {
  var value = newAutoCorrect ? 'on' : 'off';
  this.updateFieldAttribute('autocorrect', value);
}, updateMinValue:function(newMinValue) {
  this.updateFieldAttribute('min', newMinValue);
}, updateMaxValue:function(newMaxValue) {
  this.updateFieldAttribute('max', newMaxValue);
}, updateStepValue:function(newStepValue) {
  this.updateFieldAttribute('step', newStepValue);
}, checkedRe:/^(true|1|on)/i, getChecked:function() {
  var el = this.input, checked;
  if (el) {
    checked = el.dom.checked;
    this._checked = checked;
  }
  return checked;
}, applyChecked:function(checked) {
  return !!this.checkedRe.test(String(checked));
}, setChecked:function(newChecked) {
  this.updateChecked(this.applyChecked(newChecked));
  this._checked = newChecked;
}, updateChecked:function(newChecked) {
  this.input.dom.checked = newChecked;
}, updateReadOnly:function(readOnly) {
  this.updateFieldAttribute('readonly', readOnly ? true : null);
}, updateMaxRows:function(newRows) {
  this.updateFieldAttribute('rows', newRows);
}, doSetDisabled:function(disabled) {
  Ext.Component.prototype.doSetDisabled.apply(this, arguments);
  if (Ext.browser.is.Safari && !Ext.os.is.BlackBerry) {
    this.input.dom.tabIndex = disabled ? -1 : 0;
  }
  this.input.dom.disabled = Ext.browser.is.Safari && !Ext.os.is.BlackBerry ? false : disabled;
  if (!disabled) {
    this.blur();
  }
}, isDirty:function() {
  if (this.getDisabled()) {
    return false;
  }
  return String(this.getValue()) !== String(this.originalValue);
}, reset:function() {
  this.setValue(this.originalValue);
}, onInputTap:function(e) {
  this.fireAction('inputtap', [this, e], 'doInputTap');
}, doInputTap:function(me, e) {
  if (me.getDisabled()) {
    return false;
  }
  if (this.getFastFocus() && Ext.os.is.iOS) {
    me.focus();
  }
}, onMaskTap:function(e) {
  this.fireAction('masktap', [this, e], 'doMaskTap');
}, doMaskTap:function(me, e) {
  if (me.getDisabled()) {
    return false;
  }
  me.focus();
}, showMask:function() {
  if (this.getUseMask()) {
    this.mask.setStyle('display', 'block');
  }
}, hideMask:function() {
  if (this.getUseMask()) {
    this.mask.setStyle('display', 'none');
  }
}, focus:function() {
  var me = this, el = me.input;
  if (el && el.dom.focus) {
    el.dom.focus();
  }
  return me;
}, blur:function() {
  var me = this, el = this.input;
  if (el && el.dom.blur) {
    el.dom.blur();
  }
  return me;
}, select:function() {
  var me = this, el = me.input;
  if (el && el.dom.setSelectionRange) {
    el.dom.setSelectionRange(0, 9999);
  }
  return me;
}, onFocus:function(e) {
  this.fireAction('focus', [e], 'doFocus');
}, doFocus:function(e) {
  var me = this;
  me.hideMask();
  if (!me.getIsFocused()) {
    me.setStartValue(me.getValue());
  }
  me.setIsFocused(true);
}, onTouchStart:function(e) {
  if (document.activeElement != e.target) {
    e.preventDefault();
  }
}, onBlur:function(e) {
  this.fireAction('blur', [e], 'doBlur');
}, doBlur:function(e) {
  var me = this, value = me.getValue(), startValue = me.getStartValue();
  me.showMask();
  me.setIsFocused(false);
  if (String(value) != String(startValue)) {
    me.onChange(me, value, startValue);
  }
}, onClearIconTap:function(e) {
  this.fireEvent('clearicontap', this, e);
  if (Ext.os.is.Android) {
    this.focus();
  }
}, onClearIconPress:function() {
  this.clearIcon.addCls('x-pressing');
}, onClearIconRelease:function() {
  this.clearIcon.removeCls('x-pressing');
}, onClick:function(e) {
  this.fireEvent('click', e);
}, onChange:function(me, value, startValue) {
  if (this.useManualMaxLength()) {
    this.trimValueToMaxLength();
  }
  this.fireEvent('change', me, value, startValue);
}, onPaste:function(e) {
  if (this.useManualMaxLength()) {
    this.trimValueToMaxLength();
  }
  this.fireEvent('paste', e);
}, onKeyUp:function(e) {
  if (this.useManualMaxLength()) {
    this.trimValueToMaxLength();
  }
  this.fireEvent('keyup', e);
}, onKeyDown:function() {
  this.ignoreInput = true;
}, onInput:function(e) {
  var me = this;
  if (me.ignoreInput) {
    me.ignoreInput = false;
    return;
  }
  setTimeout(function() {
    if (!me.ignoreInput) {
      me.fireEvent('keyup', e);
      me.ignoreInput = false;
    }
  }, 10);
}, onKeyPress:function(e) {
  if (e.browserEvent.keyCode == 13) {
    this.fireEvent('keyup', e);
  }
}, onMouseDown:function(e) {
  this.fireEvent('mousedown', e);
}, trimValueToMaxLength:function() {
  var maxLength = this.getMaxLength();
  if (maxLength) {
    var value = this.getValue();
    if (value.length > this.getMaxLength()) {
      this.setValue(value.slice(0, maxLength));
    }
  }
}}, 0, ['input'], ['component', 'input'], {'component':true, 'input':true}, ['widget.input'], 0, [Ext.field, 'Input'], 0);
Ext.cmd.derive('Ext.field.Field', Ext.Decorator, {alternateClassName:'Ext.form.Field', isField:true, isFormField:true, config:{baseCls:'x-field', label:null, labelAlign:'left', labelWidth:'30%', labelWrap:false, clearIcon:null, required:false, inputType:null, name:null, value:null, tabIndex:null}, platformConfig:[{theme:['Windows', 'MountainView', 'Blackberry', 'Blackberry103', 'Tizen'], labelAlign:'top'}], cachedConfig:{labelCls:null, requiredCls:'x-field-required', inputCls:null}, getElementConfig:function() {
  var prefix = 'x-';
  return {reference:'element', className:'x-container', children:[{reference:'label', cls:prefix + 'form-label', children:[{reference:'labelspan', tag:'span'}]}, {reference:'innerElement', cls:prefix + 'component-outer'}]};
}, updateLabel:function(newLabel, oldLabel) {
  var renderElement = this.renderElement, prefix = 'x-';
  if (newLabel) {
    this.labelspan.setHtml(newLabel);
    renderElement.addCls(prefix + 'field-labeled');
  } else {
    renderElement.removeCls(prefix + 'field-labeled');
  }
}, updateLabelAlign:function(newLabelAlign, oldLabelAlign) {
  var renderElement = this.renderElement, prefix = 'x-';
  if (newLabelAlign) {
    renderElement.addCls(prefix + 'label-align-' + newLabelAlign);
    if (newLabelAlign == 'top' || newLabelAlign == 'bottom') {
      this.label.setWidth('100%');
    } else {
      this.updateLabelWidth(this.getLabelWidth());
    }
  }
  if (oldLabelAlign) {
    renderElement.removeCls(prefix + 'label-align-' + oldLabelAlign);
  }
}, updateLabelCls:function(newLabelCls, oldLabelCls) {
  if (newLabelCls) {
    this.label.addCls(newLabelCls);
  }
  if (oldLabelCls) {
    this.label.removeCls(oldLabelCls);
  }
}, updateLabelWidth:function(newLabelWidth) {
  var labelAlign = this.getLabelAlign();
  if (newLabelWidth) {
    if (labelAlign == 'top' || labelAlign == 'bottom') {
      this.label.setWidth('100%');
    } else {
      this.label.setWidth(newLabelWidth);
    }
  }
}, updateLabelWrap:function(newLabelWrap, oldLabelWrap) {
  var cls = 'x-form-label-nowrap';
  if (!newLabelWrap) {
    this.addCls(cls);
  } else {
    this.removeCls(cls);
  }
}, updateRequired:function(newRequired) {
  this.renderElement[newRequired ? 'addCls' : 'removeCls'](this.getRequiredCls());
}, updateRequiredCls:function(newRequiredCls, oldRequiredCls) {
  if (this.getRequired()) {
    this.renderElement.replaceCls(oldRequiredCls, newRequiredCls);
  }
}, initialize:function() {
  var me = this;
  Ext.Decorator.prototype.initialize.call(this);
  me.doInitValue();
}, doInitValue:function() {
  this.originalValue = this.getInitialConfig().value;
}, reset:function() {
  this.setValue(this.originalValue);
  return this;
}, resetOriginalValue:function() {
  this.originalValue = this.getValue();
}, isDirty:function() {
  return false;
}}, 0, ['field'], ['component', 'field'], {'component':true, 'field':true}, ['widget.field'], 0, [Ext.field, 'Field', Ext.form, 'Field'], function() {
});
Ext.cmd.derive('Ext.field.Text', Ext.field.Field, {alternateClassName:'Ext.form.Text', config:{ui:'text', clearIcon:true, placeHolder:null, maxLength:null, autoComplete:null, autoCapitalize:null, autoCorrect:null, readOnly:null, component:{xtype:'input', type:'text', fastFocus:true}, bubbleEvents:['action']}, initialize:function() {
  var me = this;
  Ext.field.Field.prototype.initialize.call(this);
  me.getComponent().on({scope:this, keyup:'onKeyUp', change:'onChange', focus:'onFocus', blur:'onBlur', paste:'onPaste', mousedown:'onMouseDown', clearicontap:'onClearIconTap'});
  me.originalValue = me.getValue() || '';
  me.getComponent().originalValue = me.originalValue;
  me.syncEmptyCls();
}, syncEmptyCls:function() {
  var empty = this._value ? this._value.length : false, cls = 'x-empty';
  if (empty) {
    this.removeCls(cls);
  } else {
    this.addCls(cls);
  }
}, updateValue:function(newValue) {
  var component = this.getComponent(), valueValid = newValue !== undefined && newValue !== null && newValue !== '';
  if (component) {
    component.setValue(newValue);
  }
  this[valueValid && this.isDirty() ? 'showClearIcon' : 'hideClearIcon']();
  this.syncEmptyCls();
}, getValue:function() {
  var me = this;
  me._value = me.getComponent().getValue();
  me.syncEmptyCls();
  return me._value;
}, updatePlaceHolder:function(newPlaceHolder) {
  this.getComponent().setPlaceHolder(newPlaceHolder);
}, updateMaxLength:function(newMaxLength) {
  this.getComponent().setMaxLength(newMaxLength);
}, updateAutoComplete:function(newAutoComplete) {
  this.getComponent().setAutoComplete(newAutoComplete);
}, updateAutoCapitalize:function(newAutoCapitalize) {
  this.getComponent().setAutoCapitalize(newAutoCapitalize);
}, updateAutoCorrect:function(newAutoCorrect) {
  this.getComponent().setAutoCorrect(newAutoCorrect);
}, updateReadOnly:function(newReadOnly) {
  if (newReadOnly) {
    this.hideClearIcon();
  } else {
    this.showClearIcon();
  }
  this.getComponent().setReadOnly(newReadOnly);
}, updateInputType:function(newInputType) {
  var component = this.getComponent();
  if (component) {
    component.setType(newInputType);
  }
}, updateName:function(newName) {
  var component = this.getComponent();
  if (component) {
    component.setName(newName);
  }
}, updateTabIndex:function(newTabIndex) {
  var component = this.getComponent();
  if (component) {
    component.setTabIndex(newTabIndex);
  }
}, updateInputCls:function(newInputCls, oldInputCls) {
  var component = this.getComponent();
  if (component) {
    component.replaceCls(oldInputCls, newInputCls);
  }
}, doSetDisabled:function(disabled) {
  var me = this;
  Ext.field.Field.prototype.doSetDisabled.apply(this, arguments);
  var component = me.getComponent();
  if (component) {
    component.setDisabled(disabled);
  }
  if (disabled) {
    me.hideClearIcon();
  } else {
    me.showClearIcon();
  }
}, showClearIcon:function() {
  var me = this, value = me.getValue(), valueValid = value !== undefined && value !== null && value !== '';
  if (me.getClearIcon() && !me.getDisabled() && !me.getReadOnly() && valueValid) {
    me.element.addCls('x-field-clearable');
  }
  return me;
}, hideClearIcon:function() {
  if (this.getClearIcon()) {
    this.element.removeCls('x-field-clearable');
  }
}, onKeyUp:function(e) {
  this.fireAction('keyup', [this, e], 'doKeyUp');
}, doKeyUp:function(me, e) {
  var value = me.getValue(), valueValid = value !== undefined && value !== null && value !== '';
  this[valueValid ? 'showClearIcon' : 'hideClearIcon']();
  if (e.browserEvent.keyCode === 13) {
    me.fireAction('action', [me, e], 'doAction');
  }
}, doAction:function() {
  this.blur();
}, onClearIconTap:function(input, e) {
  this.fireAction('clearicontap', [this, input, e], 'doClearIconTap');
}, doClearIconTap:function(me, e) {
  me.setValue('');
  me.getValue();
}, onChange:function(me, value, startValue) {
  me.fireEvent('change', this, value, startValue);
}, onFocus:function(e) {
  this.addCls('x-field-focused');
  this.isFocused = true;
  this.fireEvent('focus', this, e);
}, onBlur:function(e) {
  var me = this;
  this.removeCls('x-field-focused');
  this.isFocused = false;
  me.fireEvent('blur', me, e);
  setTimeout(function() {
    me.isFocused = false;
  }, 50);
}, onPaste:function(e) {
  this.fireEvent('paste', this, e);
}, onMouseDown:function(e) {
  this.fireEvent('mousedown', this, e);
}, focus:function() {
  this.getComponent().focus();
  return this;
}, blur:function() {
  this.getComponent().blur();
  return this;
}, select:function() {
  this.getComponent().select();
  return this;
}, resetOriginalValue:function() {
  Ext.field.Field.prototype.resetOriginalValue.call(this);
  var component = this.getComponent();
  if (component && component.hasOwnProperty('originalValue')) {
    this.getComponent().originalValue = this.originalValue;
  }
  this.reset();
}, reset:function() {
  this.getComponent().reset();
  this.getValue();
  this[this.isDirty() ? 'showClearIcon' : 'hideClearIcon']();
}, isDirty:function() {
  var component = this.getComponent();
  if (component) {
    return component.isDirty();
  }
  return false;
}}, 0, ['textfield'], ['component', 'field', 'textfield'], {'component':true, 'field':true, 'textfield':true}, ['widget.textfield'], 0, [Ext.field, 'Text', Ext.form, 'Text'], 0);
Ext.cmd.derive('Ext.field.TextAreaInput', Ext.field.Input, {tag:'textarea'}, 0, ['textareainput'], ['component', 'input', 'textareainput'], {'component':true, 'input':true, 'textareainput':true}, ['widget.textareainput'], 0, [Ext.field, 'TextAreaInput'], 0);
Ext.cmd.derive('Ext.field.TextArea', Ext.field.Text, {alternateClassName:'Ext.form.TextArea', config:{ui:'textarea', autoCapitalize:false, component:{xtype:'textareainput'}, maxRows:null}, updateMaxRows:function(newRows) {
  this.getComponent().setMaxRows(newRows);
}, doSetHeight:function(newHeight) {
  Ext.field.Text.prototype.doSetHeight.apply(this, arguments);
  var component = this.getComponent();
  component.input.setHeight(newHeight);
}, doSetWidth:function(newWidth) {
  Ext.field.Text.prototype.doSetWidth.apply(this, arguments);
  var component = this.getComponent();
  component.input.setWidth(newWidth);
}, doKeyUp:function(me) {
  var value = me.getValue();
  me[value ? 'showClearIcon' : 'hideClearIcon']();
}}, 0, ['textareafield'], ['component', 'field', 'textfield', 'textareafield'], {'component':true, 'field':true, 'textfield':true, 'textareafield':true}, ['widget.textareafield'], 0, [Ext.field, 'TextArea', Ext.form, 'TextArea'], 0);
Ext.cmd.derive('Ext.MessageBox', Ext.Sheet, {config:{ui:'dark', baseCls:'x-msgbox', iconCls:null, showAnimation:{type:'popIn', duration:250, easing:'ease-out'}, hideAnimation:{type:'popOut', duration:250, easing:'ease-out'}, zIndex:999, defaultTextHeight:75, title:null, buttons:null, message:null, prompt:null, modal:true, layout:{type:'vbox', pack:'center'}}, platformConfig:[{theme:['Windows'], ui:'light', showAnimation:{type:'fadeIn'}, hideAnimation:{type:'fadeOut'}}, {theme:['Blackberry', 'Blackberry103'], 
ui:'plain'}, {theme:['MoutainView']}], statics:{OK:{text:'OK', itemId:'ok', ui:'action'}, YES:{text:'Yes', itemId:'yes', ui:'action'}, NO:{text:'No', itemId:'no'}, CANCEL:{text:'Cancel', itemId:'cancel'}, INFO:'x-msgbox-info', WARNING:'x-msgbox-warning', QUESTION:'x-msgbox-question', ERROR:'x-msgbox-error', OKCANCEL:[{text:'Cancel', itemId:'cancel'}, {text:'OK', itemId:'ok', ui:'action'}], YESNOCANCEL:[{text:'Cancel', itemId:'cancel'}, {text:'No', itemId:'no'}, {text:'Yes', itemId:'yes', ui:'action'}], 
YESNO:[{text:'No', itemId:'no'}, {text:'Yes', itemId:'yes', ui:'action'}]}, constructor:function(config) {
  config = config || {};
  if (config.hasOwnProperty('promptConfig')) {
    Ext.applyIf(config, {prompt:config.promptConfig});
    delete config.promptConfig;
  }
  if (config.hasOwnProperty('multiline') || config.hasOwnProperty('multiLine')) {
    config.prompt = config.prompt || {};
    Ext.applyIf(config.prompt, {multiLine:config.multiline || config.multiLine});
    delete config.multiline;
    delete config.multiLine;
  }
  this.defaultAllowedConfig = {};
  var allowedConfigs = ['ui', 'showAnimation', 'hideAnimation', 'title', 'message', 'prompt', 'iconCls', 'buttons', 'defaultTextHeight'], ln = allowedConfigs.length, i, allowedConfig;
  for (i = 0; i < ln; i++) {
    allowedConfig = allowedConfigs[i];
    this.defaultAllowedConfig[allowedConfig] = this.defaultConfig[allowedConfig];
  }
  Ext.Sheet.prototype.constructor.call(this, config);
}, applyTitle:function(config) {
  if (typeof config == 'string') {
    config = {title:config};
  }
  var minHeight = '1.3em';
  if (Ext.theme.is.Cupertino) {
    minHeight = '1.5em';
  } else {
    if (Ext.filterPlatform('blackberry') || Ext.filterPlatform('ie10')) {
      minHeight = '2.6em';
    }
  }
  Ext.applyIf(config, {docked:'top', minHeight:minHeight, ui:Ext.filterPlatform('blackberry') ? 'light' : 'dark', cls:this.getBaseCls() + '-title'});
  if (Ext.theme.is.Tizen) {
    Ext.applyIf(config, {centered:false});
  }
  return Ext.factory(config, Ext.Toolbar, this.getTitle());
}, updateTitle:function(newTitle) {
  if (newTitle) {
    this.add(newTitle);
  }
}, updateButtons:function(newButtons) {
  var me = this;
  newButtons = !newButtons || newButtons.length === 0 ? false : newButtons;
  if (newButtons) {
    if (me.buttonsToolbar) {
      me.buttonsToolbar.show();
      me.buttonsToolbar.removeAll();
      me.buttonsToolbar.setItems(newButtons);
    } else {
      var layout = {type:'hbox', pack:'center'};
      var isFlexed = Ext.theme.is.CupertinoClassic || Ext.theme.is.MountainView || Ext.theme.is.Blackberry || Ext.theme.is.Blackberry103;
      me.buttonsToolbar = Ext.create('Ext.Toolbar', {docked:'bottom', defaultType:'button', defaults:{flex:isFlexed ? 1 : undefined, ui:Ext.theme.is.Blackberry || Ext.theme.is.Blackberry103 ? 'action' : undefined}, layout:layout, ui:me.getUi(), cls:me.getBaseCls() + '-buttons', items:newButtons});
      me.add(me.buttonsToolbar);
    }
  } else {
    if (me.buttonsToolbar) {
      me.buttonsToolbar.hide();
    }
  }
}, applyMessage:function(config) {
  config = {html:config, cls:this.getBaseCls() + '-text'};
  return Ext.factory(config, Ext.Component, this._message);
}, updateMessage:function(newMessage) {
  if (newMessage) {
    this.add(newMessage);
  }
}, getMessage:function() {
  if (this._message) {
    return this._message.getHtml();
  }
  return null;
}, applyIconCls:function(config) {
  config = {xtype:'component', docked:'left', width:40, height:40, baseCls:'x-icon', hidden:config ? false : true, cls:config};
  return Ext.factory(config, Ext.Component, this._iconCls);
}, updateIconCls:function(newIconCls, oldIconCls) {
  this.getTitle();
  this.getButtons();
  if (newIconCls) {
    this.add(newIconCls);
  } else {
    this.remove(oldIconCls);
  }
}, getIconCls:function() {
  var icon = this._iconCls, iconCls;
  if (icon) {
    iconCls = icon.getCls();
    return iconCls ? iconCls[0] : null;
  }
  return null;
}, applyPrompt:function(prompt) {
  if (prompt) {
    var config = {label:false};
    if (Ext.isObject(prompt)) {
      Ext.apply(config, prompt);
    }
    if (config.multiLine) {
      config.height = Ext.isNumber(config.multiLine) ? parseFloat(config.multiLine) : this.getDefaultTextHeight();
      return Ext.factory(config, Ext.field.TextArea, this.getPrompt());
    } else {
      return Ext.factory(config, Ext.field.Text, this.getPrompt());
    }
  }
  return prompt;
}, updatePrompt:function(newPrompt, oldPrompt) {
  if (newPrompt) {
    this.add(newPrompt);
  }
  if (oldPrompt) {
    this.remove(oldPrompt);
  }
}, onClick:function(button) {
  if (button) {
    var config = button.config.userConfig || {}, initialConfig = button.getInitialConfig(), prompt = this.getPrompt();
    if (typeof config.fn == 'function') {
      button.disable();
      this.on({hiddenchange:function() {
        config.fn.call(config.scope || null, initialConfig.itemId || initialConfig.text, prompt ? prompt.getValue() : null, config);
        button.enable();
      }, single:true, scope:this});
    }
    if (config.input) {
      config.input.dom.blur();
    }
  }
  this.hide();
}, show:function(initialConfig) {
  Ext.util.InputBlocker.blockInputs();
  if (!this.getParent() && Ext.Viewport) {
    Ext.Viewport.add(this);
  }
  if (!initialConfig) {
    return Ext.Sheet.prototype.show.call(this);
  }
  var config = Ext.Object.merge({}, {value:''}, initialConfig);
  var buttons = initialConfig.buttons || Ext.MessageBox.OK || [], buttonBarItems = [], userConfig = initialConfig;
  Ext.each(buttons, function(buttonConfig) {
    if (!buttonConfig) {
      return;
    }
    buttonBarItems.push(Ext.apply({userConfig:userConfig, scope:this, handler:'onClick'}, buttonConfig));
  }, this);
  config.buttons = buttonBarItems;
  if (config.promptConfig) {
  }
  config.prompt = config.promptConfig || config.prompt || null;
  if (config.multiLine) {
    config.prompt = config.prompt || {};
    config.prompt.multiLine = config.multiLine;
    delete config.multiLine;
  }
  config = Ext.merge({}, this.defaultAllowedConfig, config);
  this.setConfig(config);
  var prompt = this.getPrompt();
  if (prompt) {
    prompt.setValue(initialConfig.value || '');
  }
  Ext.Sheet.prototype.show.call(this);
  return this;
}, alert:function(title, message, fn, scope) {
  return this.show({title:title || null, message:message || null, buttons:Ext.MessageBox.OK, promptConfig:false, fn:function() {
    if (fn) {
      fn.apply(scope, arguments);
    }
  }, scope:scope});
}, confirm:function(title, message, fn, scope) {
  return this.show({title:title || null, message:message || null, buttons:Ext.MessageBox.YESNO, promptConfig:false, scope:scope, fn:function() {
    if (fn) {
      fn.apply(scope, arguments);
    }
  }});
}, prompt:function(title, message, fn, scope, multiLine, value, prompt) {
  return this.show({title:title || null, message:message || null, buttons:Ext.MessageBox.OKCANCEL, scope:scope, prompt:prompt || true, multiLine:multiLine, value:value, fn:function() {
    if (fn) {
      fn.apply(scope, arguments);
    }
  }});
}}, 1, 0, ['component', 'container', 'panel', 'sheet'], {'component':true, 'container':true, 'panel':true, 'sheet':true}, 0, 0, [Ext, 'MessageBox'], function(MessageBox) {
  Ext.onSetup(function() {
    Ext.Msg = new MessageBox;
  });
});
Ext.cmd.derive('Ext.mixin.Progressable', Ext.mixin.Mixin, {isProgressable:true, mixinConfig:{id:'progressable'}, config:{minProgressInput:0, maxProgressInput:1, minProgressOutput:0, maxProgressOutput:100, dynamic:true, state:null}, _progressActive:false, _progress:0, _rawProgress:0, onStartProgress:Ext.emptyFn, onUpdateProgress:Ext.emptyFn, onEndProgress:Ext.emptyFn, startProgress:function() {
  if (!this._progressActive) {
    this._progressActive = true;
    this.onStartProgress();
    this.updateProgress(this.getMinProgressInput());
  }
}, updateProgress:function(value, state) {
  if (state && state != this.getState()) {
    this.setState(state);
  }
  if (value > this.getMaxProgressInput()) {
    value = this.getMaxProgressInput();
  }
  if (value < this.getMinProgressInput()) {
    value = this.getMinProgressInput();
  }
  var mappedValue = this.mapValues(value, this.getMinProgressInput(), this.getMaxProgressInput(), this.getMinProgressOutput(), this.getMaxProgressOutput());
  this._progress = mappedValue;
  this._rawProgress = value;
  if (this.getDynamic()) {
    this.onUpdateProgress(mappedValue);
  }
}, endProgress:function() {
  if (this._progressActive) {
    this._progressActive = false;
    this.updateProgress(this.getMaxProgressInput());
    this.onEndProgress();
  }
}, mapValues:function(value, inputMin, inputMax, outputMin, outputMax) {
  return (value - inputMin) / (inputMax - inputMin) * (outputMax - outputMin) + outputMin;
}, setProgress:function(value) {
  this.updateProgress(value);
}, getProgress:function() {
  return this._progress;
}, getRawProgress:function() {
  return this._rawProgress;
}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Progressable'], 0);
Ext.cmd.derive('Ext.ProgressIndicator', Ext.Container, {config:{baseCls:'x-progressindicator', hidden:true, modal:true, centered:true, loadingText:{any:'Loading: {percent}%', upload:'Uploading: {percent}%', download:'Downloading: {percent}%'}, fallbackText:{any:'Loading', upload:'Uploading', download:'Downloading'}, monitoredStates:{upload:true, download:true}, showAnimation:!Ext.browser.is.AndroidStock ? {type:'slideIn', direction:'left', duration:250, easing:'ease-out'} : null, hideAnimation:!Ext.browser.is.AndroidStock ? 
{type:'slideOut', direction:'left', duration:250, easing:'ease-in'} : null, minProgressOutput:0, maxProgressOutput:1, state:null}, constructor:function() {
  this.emptyTpl = new Ext.XTemplate('');
  Ext.Container.prototype.constructor.apply(this, arguments);
}, getElementConfig:function() {
  return {reference:'element', classList:['x-container', 'x-unsized'], children:[{reference:'innerElement', className:'x-progressindicator-inner', children:[{reference:'progressBarText', className:'x-progressindicator-text'}, {reference:'progressBar', className:'x-progressindicator-bar', children:[{reference:'progressBarFill', className:'x-progressindicator-bar-fill'}]}]}]};
}, onStartProgress:function() {
  if (!this.getParent()) {
    Ext.Viewport.add(this);
  }
  this.show();
}, onEndProgress:function() {
  this.hide();
}, onUpdateProgress:function() {
  this.updateBar();
}, getLoadingText:function() {
  var state = this.getState();
  if (this._loadingText[state]) {
    return this._loadingText[state];
  }
  if (this._loadingText['any']) {
    return this._loadingText['any'];
  }
  return this.emptyTpl;
}, applyLoadingText:function(loadingText) {
  var tpl = {}, property, value;
  if (Ext.isString(loadingText)) {
    tpl = {any:new Ext.XTemplate(loadingText)};
  } else {
    if (loadingText instanceof Ext.XTemplate) {
      tpl = {any:loadingText};
    } else {
      for (property in loadingText) {
        value = loadingText[property];
        tpl[property] = new Ext.XTemplate(value);
      }
    }
  }
  if (!tpl.any) {
    tpl.any = this.emptyTpl;
  }
  return tpl;
}, getFallbackText:function() {
  var state = this.getState();
  if (this._fallbackText[state]) {
    return this._fallbackText[state];
  }
  if (this._fallbackText['any']) {
    return this._fallbackText['any'];
  }
  return '';
}, applyFallbackText:function(fallbackText) {
  var obj = {}, property, value;
  if (Ext.isString(fallbackText)) {
    obj = {any:fallbackText};
  } else {
    for (property in fallbackText) {
      value = fallbackText[property];
      obj[property] = value;
    }
  }
  if (!obj.any) {
    obj.any = this.emptyTpl;
  }
  return obj;
}, updateDynamic:function(value) {
  if (!value) {
    this.progressBarText.setHtml(this.getFallbackText());
    this.progressBar.setWidth('100%');
  } else {
    this.updateBar();
  }
  return value;
}, updateBar:function() {
  var state = this.getState();
  if (this.getMonitoredStates()[state] !== true) {
    this.progressBarText.setHtml(this.getFallbackText());
    this.progressBar.setWidth('100%');
    return;
  }
  var percent = this.getProgress() * 100;
  if (!Ext.isNumber(percent)) {
    percent = 0;
  }
  this.progressBar.setWidth(percent + '%');
  var loadingText = this.getLoadingText();
  if (loadingText) {
    this.progressBarText.setHtml(this.getLoadingText().apply({state:state, percent:Math.ceil(percent) || 0}));
  } else {
    this.progressBarText.setHtml('');
  }
}}, 1, ['progressindicator'], ['component', 'container', 'progressindicator'], {'component':true, 'container':true, 'progressindicator':true}, ['widget.progressindicator'], [[Ext.mixin.Progressable.prototype.mixinId || Ext.mixin.Progressable.$className, Ext.mixin.Progressable]], [Ext, 'ProgressIndicator'], 0);
Ext.cmd.derive('Ext.TitleBar', Ext.Container, {isToolbar:true, config:{baseCls:'x-toolbar', cls:'x-navigation-bar', ui:'dark', title:null, titleAlign:'center', defaultType:'button', minHeight:null, layout:{type:'hbox'}, items:[], maxButtonWidth:'40%'}, platformConfig:[{theme:['Blackberry', 'Blackberry103', 'Tizen'], titleAlign:'left'}, {theme:['Cupertino'], maxButtonWidth:'80%'}], hasCSSMinHeight:true, beforeInitialize:function() {
  this.applyItems = this.applyInitialItems;
}, initialize:function() {
  delete this.applyItems;
  this.add(this.initialItems);
  delete this.initialItems;
  this.on({painted:'refreshTitlePosition', single:true});
}, applyInitialItems:function(items) {
  var me = this, titleAlign = me.getTitleAlign(), defaults = me.getDefaults() || {};
  me.initialItems = items;
  me.leftBox = me.add({xtype:'container', style:'position: relative', layout:{type:'hbox', align:'center'}, listeners:{resize:'refreshTitlePosition', scope:me}});
  me.spacer = me.add({xtype:'component', style:'position: relative', flex:1, listeners:{resize:'refreshTitlePosition', scope:me}});
  me.rightBox = me.add({xtype:'container', style:'position: relative', layout:{type:'hbox', align:'center'}, listeners:{resize:'refreshTitlePosition', scope:me}});
  switch(titleAlign) {
    case 'left':
      me.titleComponent = me.leftBox.add({xtype:'title', cls:'x-title-align-left', hidden:defaults.hidden});
      me.refreshTitlePosition = Ext.emptyFn;
      break;
    case 'right':
      me.titleComponent = me.rightBox.add({xtype:'title', cls:'x-title-align-right', hidden:defaults.hidden});
      me.refreshTitlePosition = Ext.emptyFn;
      break;
    default:
      me.titleComponent = me.add({xtype:'title', hidden:defaults.hidden, centered:true});
      break;
  }
  me.doAdd = me.doBoxAdd;
  me.remove = me.doBoxRemove;
  me.doInsert = me.doBoxInsert;
}, doBoxAdd:function(item) {
  if (item.config.align == 'right') {
    this.rightBox.add(item);
  } else {
    this.leftBox.add(item);
  }
}, doBoxRemove:function(item, destroy) {
  if (item.config.align == 'right') {
    this.rightBox.remove(item, destroy);
  } else {
    this.leftBox.remove(item, destroy);
  }
}, doBoxInsert:function(index, item) {
  if (item.config.align == 'right') {
    this.rightBox.insert(index, item);
  } else {
    this.leftBox.insert(index, item);
  }
}, calculateMaxButtonWidth:function() {
  var maxButtonWidth = this.getMaxButtonWidth();
  if (Ext.isString(maxButtonWidth)) {
    maxButtonWidth = parseInt(maxButtonWidth.replace('%', ''), 10);
  }
  maxButtonWidth = Math.round(this.element.getWidth() / 100 * maxButtonWidth);
  return maxButtonWidth;
}, refreshTitlePosition:function() {
  if (this.isDestroyed) {
    return;
  }
  var titleElement = this.titleComponent.renderElement;
  titleElement.setWidth(null);
  titleElement.setLeft(null);
  var leftBox = this.leftBox, leftButton = leftBox.down('button'), singleButton = leftBox.getItems().getCount() == 1, leftBoxWidth, maxButtonWidth;
  if (leftButton && singleButton) {
    if (leftButton.getWidth() == null) {
      leftButton.renderElement.setWidth('auto');
    }
    leftBoxWidth = leftBox.renderElement.getWidth();
    maxButtonWidth = this.calculateMaxButtonWidth();
    if (leftBoxWidth > maxButtonWidth) {
      leftButton.renderElement.setWidth(maxButtonWidth);
    }
  }
  var spacerBox = this.spacer.renderElement.getPageBox();
  if (Ext.browser.is.IE) {
    titleElement.setWidth(spacerBox.width);
  }
  var titleBox = titleElement.getPageBox(), widthDiff = titleBox.width - spacerBox.width, titleLeft = titleBox.left, titleRight = titleBox.right, halfWidthDiff, leftDiff, rightDiff;
  if (widthDiff > 0) {
    halfWidthDiff = widthDiff / 2;
    titleLeft += halfWidthDiff;
    titleRight -= halfWidthDiff;
    titleElement.setWidth(spacerBox.width);
  }
  leftDiff = spacerBox.left - titleLeft;
  rightDiff = titleRight - spacerBox.right;
  if (leftDiff > 0) {
    titleElement.setLeft(leftDiff);
  } else {
    if (rightDiff > 0) {
      titleElement.setLeft(-rightDiff);
    }
  }
  titleElement.repaint();
}, updateTitle:function(newTitle) {
  this.titleComponent.setTitle(newTitle);
  if (this.isPainted()) {
    this.refreshTitlePosition();
  }
}}, 0, ['titlebar'], ['component', 'container', 'titlebar'], {'component':true, 'container':true, 'titlebar':true}, ['widget.titlebar'], 0, [Ext, 'TitleBar'], 0);
Ext.cmd.derive('Ext.app.Action', Ext.Base, {config:{scope:null, application:null, controller:null, action:null, args:[], url:undefined, data:{}, title:null, beforeFilters:[], currentFilterIndex:-1}, constructor:function(config) {
  this.initConfig(config);
  this.getUrl();
}, applyBeforeFilters:function(filters) {
  return filters || [];
}, execute:function() {
  this.resume();
}, resume:function() {
  var index = this.getCurrentFilterIndex() + 1, filters = this.getBeforeFilters(), controller = this.getController(), nextFilter = filters[index];
  if (nextFilter) {
    this.setCurrentFilterIndex(index);
    nextFilter.call(controller, this);
  } else {
    controller[this.getAction()].apply(controller, this.getArgs());
  }
}, applyUrl:function(url) {
  if (url === null || url === undefined) {
    url = this.urlEncode();
  }
  return url;
}, applyController:function(controller) {
  var app = this.getApplication(), profile = app.getCurrentProfile();
  if (Ext.isString(controller)) {
    controller = app.getController(controller, profile ? profile.getNamespace() : null);
  }
  return controller;
}, urlEncode:function() {
  var controller = this.getController(), splits;
  if (controller instanceof Ext.app.Controller) {
    splits = controller.$className.split('.');
    controller = splits[splits.length - 1];
  }
  return controller + '/' + this.getAction();
}}, 1, 0, 0, 0, 0, 0, [Ext.app, 'Action'], 0);
Ext.cmd.derive('Ext.app.Controller', Ext.Base, {config:{refs:{}, routes:{}, control:{}, before:{}, application:{}, stores:[], models:[], views:[]}, constructor:function(config) {
  this.initConfig(config);
  this.mixins.observable.constructor.call(this, config);
}, init:Ext.emptyFn, launch:Ext.emptyFn, redirectTo:function(place) {
  return this.getApplication().redirectTo(place);
}, execute:function(action, skipFilters) {
  action.setBeforeFilters(this.getBefore()[action.getAction()]);
  action.execute();
}, applyBefore:function(before) {
  var filters, name, length, i;
  for (name in before) {
    filters = Ext.Array.from(before[name]);
    length = filters.length;
    for (i = 0; i < length; i++) {
      filters[i] = this[filters[i]];
    }
    before[name] = filters;
  }
  return before;
}, applyControl:function(config) {
  this.control(config, this);
  return config;
}, applyRefs:function(refs) {
  this.ref(refs);
  return refs;
}, applyRoutes:function(routes) {
  var app = this instanceof Ext.app.Application ? this : this.getApplication(), router = app.getRouter(), route, url, config;
  for (url in routes) {
    route = routes[url];
    config = {controller:this.$className};
    if (Ext.isString(route)) {
      config.action = route;
    } else {
      Ext.apply(config, route);
    }
    router.connect(url, config);
  }
  return routes;
}, applyStores:function(stores) {
  return this.getFullyQualified(stores, 'store');
}, applyModels:function(models) {
  return this.getFullyQualified(models, 'model');
}, applyViews:function(views) {
  return this.getFullyQualified(views, 'view');
}, getFullyQualified:function(items, namespace) {
  var length = items.length, appName = this.getApplication().getName(), name, i;
  for (i = 0; i < length; i++) {
    name = items[i];
    if (Ext.isString(name) && (Ext.Loader.getPrefix(name) === '' || name === appName)) {
      items[i] = appName + '.' + namespace + '.' + name;
    }
  }
  return items;
}, control:function(selectors) {
  this.getApplication().control(selectors, this);
}, ref:function(refs) {
  var me = this, refName, getterName, selector, info;
  for (refName in refs) {
    selector = refs[refName];
    getterName = 'get' + Ext.String.capitalize(refName);
    if (!this[getterName]) {
      if (Ext.isString(refs[refName])) {
        info = {ref:refName, selector:selector};
      } else {
        info = refs[refName];
      }
      this[getterName] = function(refName, info) {
        var args = [refName, info];
        return function() {
          return me.getRef.apply(me, args.concat.apply(args, arguments));
        };
      }(refName, info);
    }
    this.references = this.references || [];
    this.references.push(refName.toLowerCase());
  }
}, getRef:function(ref, info, config) {
  this.refCache = this.refCache || {};
  info = info || {};
  config = config || {};
  Ext.apply(info, config);
  if (info.forceCreate) {
    return Ext.ComponentManager.create(info, 'component');
  }
  var me = this, cached = me.refCache[ref];
  if (!cached) {
    me.refCache[ref] = cached = Ext.ComponentQuery.query(info.selector)[0];
    if (!cached && info.autoCreate) {
      me.refCache[ref] = cached = Ext.ComponentManager.create(info, 'component');
    }
    if (cached) {
      cached.on('destroy', function() {
        me.refCache[ref] = null;
      });
    }
  }
  return cached;
}, hasRef:function(ref) {
  return this.references && this.references.indexOf(ref.toLowerCase()) !== -1;
}}, 1, 0, 0, 0, 0, [['observable', Ext.mixin.Observable]], [Ext.app, 'Controller'], function() {
});
Ext.cmd.derive('Ext.app.History', Ext.Base, {config:{actions:[], updateUrl:true, token:''}, constructor:function(config) {
  if (Ext.feature.has.History) {
    window.addEventListener('hashchange', Ext.bind(this.detectStateChange, this));
  } else {
    setInterval(Ext.bind(this.detectStateChange, this), 100);
  }
  this.initConfig(config);
  if (config && Ext.isEmpty(config.token)) {
    this.setToken(window.location.hash.substr(1));
  }
}, add:function(action, silent) {
  action = Ext.factory(action, Ext.app.Action);
  this.getActions().push(action);
  var url = action.getUrl();
  if (this.getUpdateUrl()) {
    this.setToken(url);
    window.location.hash = url;
  }
  if (silent !== true) {
    this.fireEvent('change', url);
  }
  this.setToken(url);
}, back:function() {
  var actions = this.getActions(), previousAction = actions[actions.length - 2];
  if (previousAction) {
    actions.pop();
    previousAction.getController().getApplication().redirectTo(previousAction.getUrl());
  } else {
    actions[actions.length - 1].getController().getApplication().redirectTo('');
  }
}, applyToken:function(token) {
  return token[0] == '#' ? token.substr(1) : token;
}, detectStateChange:function() {
  var newToken = this.applyToken(window.location.hash), oldToken = this.getToken();
  if (newToken != oldToken) {
    this.onStateChange();
    this.setToken(newToken);
  }
}, onStateChange:function() {
  this.fireEvent('change', window.location.hash.substr(1));
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.app, 'History'], 0);
Ext.cmd.derive('Ext.app.Profile', Ext.Base, {config:{namespace:'auto', name:'auto', controllers:[], models:[], views:[], stores:[], application:null}, constructor:function(config) {
  this.initConfig(config);
  this.mixins.observable.constructor.apply(this, arguments);
}, isActive:function() {
  return false;
}, launch:Ext.emptyFn, applyNamespace:function(name) {
  if (name == 'auto') {
    name = this.getName();
  }
  return name.toLowerCase();
}, applyName:function(name) {
  if (name == 'auto') {
    var pieces = this.$className.split('.');
    name = pieces[pieces.length - 1];
  }
  return name;
}, getDependencies:function() {
  var allClasses = [], format = Ext.String.format, appName = this.getApplication().getName(), namespace = this.getNamespace(), map = {model:this.getModels(), view:this.getViews(), controller:this.getControllers(), store:this.getStores()}, classType, classNames, fullyQualified;
  for (classType in map) {
    classNames = [];
    Ext.each(map[classType], function(className) {
      if (Ext.isString(className)) {
        if (Ext.isString(className) && (Ext.Loader.getPrefix(className) === '' || className === appName)) {
          className = appName + '.' + classType + '.' + namespace + '.' + className;
        }
        classNames.push(className);
        allClasses.push(className);
      }
    }, this);
    map[classType] = classNames;
  }
  map.all = allClasses;
  return map;
}}, 1, 0, 0, 0, 0, [['observable', Ext.mixin.Observable]], [Ext.app, 'Profile'], 0);
Ext.cmd.derive('Ext.app.Route', Ext.Base, {config:{conditions:{}, url:null, controller:null, action:null, initialized:false}, constructor:function(config) {
  this.initConfig(config);
}, recognize:function(url) {
  if (!this.getInitialized()) {
    this.initialize();
  }
  if (this.recognizes(url)) {
    var matches = this.matchesFor(url), args = url.match(this.matcherRegex);
    args.shift();
    return Ext.applyIf(matches, {controller:this.getController(), action:this.getAction(), url:url, args:args, historyUrl:url});
  }
}, initialize:function() {
  this.paramMatchingRegex = new RegExp(/:([0-9A-Za-z_]*)/g);
  this.paramsInMatchString = this.getUrl().match(this.paramMatchingRegex) || [];
  this.matcherRegex = this.createMatcherRegex(this.getUrl());
  this.setInitialized(true);
}, recognizes:function(url) {
  return this.matcherRegex.test(url);
}, matchesFor:function(url) {
  var params = {}, keys = this.paramsInMatchString, values = url.match(this.matcherRegex), length = keys.length, i;
  values.shift();
  for (i = 0; i < length; i++) {
    params[keys[i].replace(':', '')] = values[i];
  }
  return params;
}, argsFor:function(url) {
  var args = [], keys = this.paramsInMatchString, values = url.match(this.matcherRegex), length = keys.length, i;
  values.shift();
  for (i = 0; i < length; i++) {
    args.push(keys[i].replace(':', ''));
    params[keys[i].replace(':', '')] = values[i];
  }
  return params;
}, urlFor:function(config) {
  var url = this.getUrl();
  for (var key in config) {
    url = url.replace(':' + key, config[key]);
  }
  return url;
}, createMatcherRegex:function(url) {
  var paramsInMatchString = this.paramsInMatchString, length = paramsInMatchString.length, i, cond, matcher;
  for (i = 0; i < length; i++) {
    cond = this.getConditions()[paramsInMatchString[i]];
    matcher = Ext.util.Format.format('({0})', cond || '[%a-zA-Z0-9\\-\\_\\s,]+');
    url = url.replace(new RegExp(paramsInMatchString[i]), matcher);
  }
  return new RegExp('^' + url + '$');
}}, 1, 0, 0, 0, 0, 0, [Ext.app, 'Route'], 0);
Ext.cmd.derive('Ext.app.Router', Ext.Base, {config:{routes:[], defaults:{action:'index'}}, constructor:function(config) {
  this.initConfig(config);
}, connect:function(url, params) {
  params = Ext.apply({url:url}, params || {}, this.getDefaults());
  var route = Ext.create('Ext.app.Route', params);
  this.getRoutes().push(route);
  return route;
}, recognize:function(url) {
  var routes = this.getRoutes(), length = routes.length, i, result;
  for (i = 0; i < length; i++) {
    result = routes[i].recognize(url);
    if (result !== undefined) {
      return result;
    }
  }
  return undefined;
}, draw:function(fn) {
  fn.call(this, this);
}, clear:function() {
  this.setRoutes([]);
}}, 1, 0, 0, 0, 0, 0, [Ext.app, 'Router'], function() {
});
Ext.cmd.derive('Ext.app.Application', Ext.app.Controller, {config:{profiles:[], controllers:[], history:{}, name:null, appFolder:'app', router:{}, controllerInstances:[], profileInstances:[], currentProfile:null, launch:Ext.emptyFn, enableLoader:true, requires:[], themeVariationPrefix:'x-theme-variation-', themeVariationTransitionCls:null, themeVariation:null}, constructor:function(config) {
  config = config || {};
  Ext.applyIf(config, {application:this});
  this.initConfig(config);
  for (var key in config) {
    this[key] = config[key];
  }
  Ext.require(this.getRequires(), function() {
    if (this.getEnableLoader() !== false) {
      Ext.require(this.getProfiles(), this.onProfilesLoaded, this);
    }
  }, this);
}, dispatch:function(action, addToHistory) {
  action = action || {};
  Ext.applyIf(action, {application:this});
  action = Ext.factory(action, Ext.app.Action);
  if (action) {
    var profile = this.getCurrentProfile(), profileNS = profile ? profile.getNamespace() : undefined, controller = this.getController(action.getController(), profileNS);
    if (controller) {
      if (addToHistory !== false) {
        this.getHistory().add(action, true);
      }
      controller.execute(action);
    }
  }
}, redirectTo:function(url) {
  if (Ext.data && Ext.data.Model && url instanceof Ext.data.Model) {
    var record = url;
    url = record.toUrl();
  }
  var decoded = this.getRouter().recognize(url);
  if (decoded) {
    decoded.url = url;
    if (record) {
      decoded.data = {};
      decoded.data.record = record;
    }
    return this.dispatch(decoded);
  }
}, control:function(selectors, controller) {
  controller = controller || this;
  var dispatcher = this.getEventDispatcher(), refs = controller ? controller.getRefs() : {}, selector, eventName, listener, listeners, ref;
  for (selector in selectors) {
    if (selectors.hasOwnProperty(selector)) {
      listeners = selectors[selector];
      ref = refs[selector];
      if (ref) {
        selector = ref.selector || ref;
      }
      for (eventName in listeners) {
        listener = listeners[eventName];
        if (Ext.isString(listener)) {
          listener = controller[listener];
        }
        dispatcher.addListener('component', selector, eventName, listener, controller);
      }
    }
  }
}, getController:function(name, profileName) {
  var instances = this.getControllerInstances(), appName = this.getName(), format = Ext.String.format, topLevelName;
  if (name instanceof Ext.app.Controller) {
    return name;
  }
  if (instances[name]) {
    return instances[name];
  } else {
    topLevelName = format('{0}.controller.{1}', appName, name);
    profileName = format('{0}.controller.{1}.{2}', appName, profileName, name);
    return instances[profileName] || instances[topLevelName];
  }
}, onProfilesLoaded:function() {
  var profiles = this.getProfiles(), length = profiles.length, instances = [], requires = this.gatherDependencies(), current, i, profileDeps;
  for (i = 0; i < length; i++) {
    instances[i] = Ext.create(profiles[i], {application:this});
    profileDeps = instances[i].getDependencies();
    requires = requires.concat(profileDeps.all);
    if (instances[i].isActive() && !current) {
      current = instances[i];
      this.setCurrentProfile(current);
      this.setControllers(this.getControllers().concat(profileDeps.controller));
      this.setModels(this.getModels().concat(profileDeps.model));
      this.setViews(this.getViews().concat(profileDeps.view));
      this.setStores(this.getStores().concat(profileDeps.store));
    }
  }
  this.setProfileInstances(instances);
  Ext.require(requires, this.loadControllerDependencies, this);
}, loadControllerDependencies:function() {
  this.instantiateControllers();
  var controllers = this.getControllerInstances(), classes = [], stores = [], i, controller, controllerStores, name;
  for (name in controllers) {
    controller = controllers[name];
    controllerStores = controller.getStores();
    stores = stores.concat(controllerStores);
    classes = classes.concat(controller.getModels().concat(controller.getViews()).concat(controllerStores));
  }
  this.setStores(this.getStores().concat(stores));
  Ext.require(classes, this.onDependenciesLoaded, this);
}, onDependenciesLoaded:function() {
  var me = this, profile = this.getCurrentProfile(), launcher = this.getLaunch(), controllers, name;
  this.instantiateStores();
  controllers = this.getControllerInstances();
  for (name in controllers) {
    controllers[name].init(this);
  }
  if (profile) {
    profile.launch();
  }
  launcher.call(me);
  for (name in controllers) {
    controllers[name].launch(this);
  }
  me.redirectTo(window.location.hash.substr(1));
}, gatherDependencies:function() {
  var classes = this.getModels().concat(this.getViews()).concat(this.getControllers());
  Ext.each(this.getStores(), function(storeName) {
    if (Ext.isString(storeName)) {
      classes.push(storeName);
    }
  }, this);
  return classes;
}, instantiateStores:function() {
  var stores = this.getStores(), length = stores.length, store, storeClass, storeName, splits, i;
  for (i = 0; i < length; i++) {
    store = stores[i];
    if (Ext.data && Ext.data.Store && !(store instanceof Ext.data.Store)) {
      if (Ext.isString(store)) {
        storeName = store;
        storeClass = Ext.ClassManager.classes[store];
        store = {xclass:store};
        if (storeClass.prototype.defaultConfig.storeId === undefined) {
          splits = storeName.split('.');
          store.id = splits[splits.length - 1];
        }
      }
      stores[i] = Ext.factory(store, Ext.data.Store);
    }
  }
  this.setStores(stores);
}, instantiateControllers:function() {
  var controllerNames = this.getControllers(), instances = {}, length = controllerNames.length, name, i;
  for (i = 0; i < length; i++) {
    name = controllerNames[i];
    instances[name] = Ext.create(name, {application:this});
  }
  return this.setControllerInstances(instances);
}, applyControllers:function(controllers) {
  return this.getFullyQualified(controllers, 'controller');
}, applyProfiles:function(profiles) {
  return this.getFullyQualified(profiles, 'profile');
}, applyName:function(name) {
  var oldName;
  if (name && name.match(/ /g)) {
    oldName = name;
    name = name.replace(/ /g, '');
  }
  return name;
}, updateName:function(newName) {
  Ext.ClassManager.setNamespace(newName + '.app', this);
  if (!Ext.Loader.config.paths[newName]) {
    Ext.Loader.setPath(newName, this.getAppFolder());
  }
}, applyRouter:function(config) {
  return Ext.factory(config, Ext.app.Router, this.getRouter());
}, applyHistory:function(config) {
  var history = Ext.factory(config, Ext.app.History, this.getHistory());
  history.on('change', this.onHistoryChange, this);
  return history;
}, onHistoryChange:function(url) {
  this.dispatch(this.getRouter().recognize(url), false);
}, updateThemeVariation:function(newVariation, oldVariation) {
  var html = Ext.getBody().getParent(), themeVariationPrefix = this.getThemeVariationPrefix() || '', transitionCls = this.getThemeVariationTransitionCls();
  if (Ext.isFunction(newVariation)) {
    newVariation = newVariation.call(this);
  }
  if (!Ext.isString(newVariation)) {
    Ext.Error.raise("Theme variation must be a String.'");
  }
  if (transitionCls) {
    var css = '', duration = 0, rules = document.styleSheets[0].cssRules, i, rule, times, time;
    html.addCls(transitionCls);
    for (i in rules) {
      rule = rules[i];
      if (rule.selectorText && rule.selectorText.indexOf('.' + transitionCls) >= 1) {
        css += rule.cssText;
      }
    }
    times = css.match(/[0-9]+s/g);
    for (i in times) {
      time = parseInt(times[i]);
      if (time > duration) {
        duration = time;
      }
    }
    if (this.$themeVariationChangeTimeout) {
      clearTimeout(this.$themeVariationChangeTimeout);
      this.$themeVariationChangeTimeout = null;
    }
    this.$themeVariationChangeTimeout = Ext.defer(function() {
      html.removeCls(transitionCls);
    }, time * 1000);
  }
  html.removeCls(themeVariationPrefix + oldVariation);
  html.addCls(themeVariationPrefix + newVariation);
}}, 1, 0, 0, 0, 0, 0, [Ext.app, 'Application'], function() {
});
Ext.cmd.derive('Ext.mixin.Sortable', Ext.mixin.Mixin, {mixinConfig:{id:'sortable'}, config:{sorters:null, defaultSortDirection:'ASC', sortRoot:null}, dirtySortFn:false, sortFn:null, sorted:false, applySorters:function(sorters, collection) {
  if (!collection) {
    collection = this.createSortersCollection();
  }
  collection.clear();
  this.sorted = false;
  if (sorters) {
    this.addSorters(sorters);
  }
  return collection;
}, createSortersCollection:function() {
  this._sorters = Ext.create('Ext.util.Collection', function(sorter) {
    return sorter.getId();
  });
  return this._sorters;
}, addSorter:function(sorter, defaultDirection) {
  this.addSorters([sorter], defaultDirection);
}, addSorters:function(sorters, defaultDirection) {
  var currentSorters = this.getSorters();
  return this.insertSorters(currentSorters ? currentSorters.length : 0, sorters, defaultDirection);
}, insertSorter:function(index, sorter, defaultDirection) {
  return this.insertSorters(index, [sorter], defaultDirection);
}, insertSorters:function(index, sorters, defaultDirection) {
  if (!Ext.isArray(sorters)) {
    sorters = [sorters];
  }
  var ln = sorters.length, direction = defaultDirection || this.getDefaultSortDirection(), sortRoot = this.getSortRoot(), currentSorters = this.getSorters(), newSorters = [], sorterConfig, i, sorter, currentSorter;
  if (!currentSorters) {
    currentSorters = this.createSortersCollection();
  }
  for (i = 0; i < ln; i++) {
    sorter = sorters[i];
    sorterConfig = {direction:direction, root:sortRoot};
    if (typeof sorter === 'string') {
      currentSorter = currentSorters.get(sorter);
      if (!currentSorter) {
        sorterConfig.property = sorter;
      } else {
        if (defaultDirection) {
          currentSorter.setDirection(defaultDirection);
        } else {
          currentSorter.toggle();
        }
        continue;
      }
    } else {
      if (Ext.isFunction(sorter)) {
        sorterConfig.sorterFn = sorter;
      } else {
        if (Ext.isObject(sorter)) {
          if (!sorter.isSorter) {
            if (sorter.fn) {
              sorter.sorterFn = sorter.fn;
              delete sorter.fn;
            }
            sorterConfig = Ext.apply(sorterConfig, sorter);
          } else {
            newSorters.push(sorter);
            if (!sorter.getRoot()) {
              sorter.setRoot(sortRoot);
            }
            continue;
          }
        }
      }
    }
    sorter = Ext.create('Ext.util.Sorter', sorterConfig);
    newSorters.push(sorter);
  }
  for (i = 0, ln = newSorters.length; i < ln; i++) {
    currentSorters.insert(index + i, newSorters[i]);
  }
  this.dirtySortFn = true;
  if (currentSorters.length) {
    this.sorted = true;
  }
  return currentSorters;
}, removeSorter:function(sorter) {
  return this.removeSorters([sorter]);
}, removeSorters:function(sorters) {
  if (!Ext.isArray(sorters)) {
    sorters = [sorters];
  }
  var ln = sorters.length, currentSorters = this.getSorters(), i, sorter;
  for (i = 0; i < ln; i++) {
    sorter = sorters[i];
    if (typeof sorter === 'string') {
      currentSorters.removeAtKey(sorter);
    } else {
      if (typeof sorter === 'function') {
        currentSorters.each(function(item) {
          if (item.getSorterFn() === sorter) {
            currentSorters.remove(item);
          }
        });
      } else {
        if (sorter.isSorter) {
          currentSorters.remove(sorter);
        }
      }
    }
  }
  if (!currentSorters.length) {
    this.sorted = false;
  }
}, updateSortFn:function() {
  var sorters = this.getSorters().items;
  this.sortFn = function(r1, r2) {
    var ln = sorters.length, result, i;
    for (i = 0; i < ln; i++) {
      result = sorters[i].sort.call(this, r1, r2);
      if (result !== 0) {
        break;
      }
    }
    return result;
  };
  this.dirtySortFn = false;
  return this.sortFn;
}, getSortFn:function() {
  if (this.dirtySortFn) {
    return this.updateSortFn();
  }
  return this.sortFn;
}, sort:function(data) {
  Ext.Array.sort(data, this.getSortFn());
  return data;
}, findInsertionIndex:function(items, item, sortFn) {
  var start = 0, end = items.length - 1, sorterFn = sortFn || this.getSortFn(), middle, comparison;
  while (start <= end) {
    middle = start + end >> 1;
    comparison = sorterFn(item, items[middle]);
    if (comparison >= 0) {
      start = middle + 1;
    } else {
      if (comparison < 0) {
        end = middle - 1;
      }
    }
  }
  return start;
}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Sortable'], 0);
Ext.cmd.derive('Ext.mixin.Filterable', Ext.mixin.Mixin, {mixinConfig:{id:'filterable'}, config:{filters:null, filterRoot:null}, dirtyFilterFn:false, filterFn:null, filtered:false, applyFilters:function(filters, collection) {
  if (!collection) {
    collection = this.createFiltersCollection();
  }
  collection.clear();
  this.filtered = false;
  this.dirtyFilterFn = true;
  if (filters) {
    this.addFilters(filters);
  }
  return collection;
}, createFiltersCollection:function() {
  this._filters = Ext.create('Ext.util.Collection', function(filter) {
    return filter.getId();
  });
  return this._filters;
}, addFilter:function(filter) {
  this.addFilters([filter]);
}, addFilters:function(filters) {
  var currentFilters = this.getFilters();
  return this.insertFilters(currentFilters ? currentFilters.length : 0, filters);
}, insertFilter:function(index, filter) {
  return this.insertFilters(index, [filter]);
}, insertFilters:function(index, filters) {
  if (!Ext.isArray(filters)) {
    filters = [filters];
  }
  var ln = filters.length, filterRoot = this.getFilterRoot(), currentFilters = this.getFilters(), newFilters = [], filterConfig, i, filter;
  if (!currentFilters) {
    currentFilters = this.createFiltersCollection();
  }
  for (i = 0; i < ln; i++) {
    filter = filters[i];
    filterConfig = {root:filterRoot};
    if (Ext.isFunction(filter)) {
      filterConfig.filterFn = filter;
    } else {
      if (Ext.isObject(filter)) {
        if (!filter.isFilter) {
          if (filter.fn) {
            filter.filterFn = filter.fn;
            delete filter.fn;
          }
          filterConfig = Ext.apply(filterConfig, filter);
        } else {
          newFilters.push(filter);
          if (!filter.getRoot()) {
            filter.setRoot(filterRoot);
          }
          continue;
        }
      }
    }
    filter = Ext.create('Ext.util.Filter', filterConfig);
    newFilters.push(filter);
  }
  for (i = 0, ln = newFilters.length; i < ln; i++) {
    currentFilters.insert(index + i, newFilters[i]);
  }
  this.dirtyFilterFn = true;
  if (currentFilters.length) {
    this.filtered = true;
  }
  return currentFilters;
}, removeFilters:function(filters) {
  if (!Ext.isArray(filters)) {
    filters = [filters];
  }
  var ln = filters.length, currentFilters = this.getFilters(), i, filter;
  for (i = 0; i < ln; i++) {
    filter = filters[i];
    if (typeof filter === 'string') {
      currentFilters.each(function(item) {
        if (item.getProperty() === filter) {
          currentFilters.remove(item);
        }
      });
    } else {
      if (typeof filter === 'function') {
        currentFilters.each(function(item) {
          if (item.getFilterFn() === filter) {
            currentFilters.remove(item);
          }
        });
      } else {
        if (filter.isFilter) {
          currentFilters.remove(filter);
        } else {
          if (filter.property !== undefined && filter.value !== undefined) {
            currentFilters.each(function(item) {
              if (item.getProperty() === filter.property && item.getValue() === filter.value) {
                currentFilters.remove(item);
              }
            });
          }
        }
      }
    }
  }
  if (!currentFilters.length) {
    this.filtered = false;
  }
}, updateFilterFn:function() {
  var filters = this.getFilters().items;
  this.filterFn = function(item) {
    var isMatch = true, length = filters.length, i;
    for (i = 0; i < length; i++) {
      var filter = filters[i], fn = filter.getFilterFn(), scope = filter.getScope() || this;
      isMatch = isMatch && fn.call(scope, item);
    }
    return isMatch;
  };
  this.dirtyFilterFn = false;
  return this.filterFn;
}, filter:function(data) {
  return this.getFilters().length ? Ext.Array.filter(data, this.getFilterFn()) : data;
}, isFiltered:function(item) {
  return this.getFilters().length ? !this.getFilterFn()(item) : false;
}, getFilterFn:function() {
  if (this.dirtyFilterFn) {
    return this.updateFilterFn();
  }
  return this.filterFn;
}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Filterable'], 0);
Ext.cmd.derive('Ext.util.Collection', Ext.Base, {config:{autoFilter:true, autoSort:true}, constructor:function(keyFn, config) {
  var me = this;
  me.all = [];
  me.items = [];
  me.keys = [];
  me.indices = {};
  me.map = {};
  me.length = 0;
  if (keyFn) {
    me.getKey = keyFn;
  }
  this.initConfig(config);
}, updateAutoSort:function(autoSort, oldAutoSort) {
  if (oldAutoSort === false && autoSort && this.items.length) {
    this.sort();
  }
}, updateAutoFilter:function(autoFilter, oldAutoFilter) {
  if (oldAutoFilter === false && autoFilter && this.all.length) {
    this.filter();
  }
}, insertSorters:function() {
  this.mixins.sortable.insertSorters.apply(this, arguments);
  if (this.getAutoSort() && this.items.length) {
    this.sort();
  }
  return this;
}, removeSorters:function(sorters) {
  this.mixins.sortable.removeSorters.call(this, sorters);
  if (this.sorted && this.getAutoSort() && this.items.length) {
    this.sort();
  }
  return this;
}, applyFilters:function(filters) {
  var collection = this.mixins.filterable.applyFilters.call(this, filters);
  if (!filters && this.all.length && this.getAutoFilter()) {
    this.filter();
  }
  return collection;
}, addFilters:function(filters) {
  this.mixins.filterable.addFilters.call(this, filters);
  if (this.items.length && this.getAutoFilter()) {
    this.filter();
  }
  return this;
}, removeFilters:function(filters) {
  this.mixins.filterable.removeFilters.call(this, filters);
  if (this.filtered && this.all.length && this.getAutoFilter()) {
    this.filter();
  }
  return this;
}, filter:function(property, value, anyMatch, caseSensitive) {
  if (property) {
    if (Ext.isString(property)) {
      this.addFilters({property:property, value:value, anyMatch:anyMatch, caseSensitive:caseSensitive});
      return this.items;
    } else {
      this.addFilters(property);
      return this.items;
    }
  }
  this.items = this.mixins.filterable.filter.call(this, this.all.slice());
  this.updateAfterFilter();
  if (this.sorted && this.getAutoSort()) {
    this.sort();
  }
}, updateAfterFilter:function() {
  var items = this.items, keys = this.keys, indices = this.indices = {}, ln = items.length, i, item, key;
  keys.length = 0;
  for (i = 0; i < ln; i++) {
    item = items[i];
    key = this.getKey(item);
    indices[key] = i;
    keys[i] = key;
  }
  this.length = items.length;
  this.dirtyIndices = false;
}, sort:function(sorters, defaultDirection) {
  var items = this.items, keys = this.keys, indices = this.indices, ln = items.length, i, item, key;
  if (sorters) {
    this.addSorters(sorters, defaultDirection);
    return this.items;
  }
  for (i = 0; i < ln; i++) {
    items[i]._current_key = keys[i];
  }
  this.handleSort(items);
  for (i = 0; i < ln; i++) {
    item = items[i];
    key = item._current_key;
    keys[i] = key;
    indices[key] = i;
    delete item._current_key;
  }
  this.dirtyIndices = true;
}, handleSort:function(items) {
  this.mixins.sortable.sort.call(this, items);
}, add:function(key, item) {
  var me = this, filtered = this.filtered, sorted = this.sorted, all = this.all, items = this.items, keys = this.keys, indices = this.indices, filterable = this.mixins.filterable, currentLength = items.length, index = currentLength;
  if (arguments.length == 1) {
    item = key;
    key = me.getKey(item);
  }
  if (typeof key != 'undefined' && key !== null) {
    if (typeof me.map[key] != 'undefined') {
      return me.replace(key, item);
    }
    me.map[key] = item;
  }
  all.push(item);
  if (filtered && this.getAutoFilter() && filterable.isFiltered.call(me, item)) {
    return null;
  }
  me.length++;
  if (sorted && this.getAutoSort()) {
    index = this.findInsertionIndex(items, item);
  }
  if (index !== currentLength) {
    this.dirtyIndices = true;
    Ext.Array.splice(keys, index, 0, key);
    Ext.Array.splice(items, index, 0, item);
  } else {
    indices[key] = currentLength;
    keys.push(key);
    items.push(item);
  }
  return item;
}, getKey:function(item) {
  return item.id;
}, replace:function(oldKey, item) {
  var me = this, sorted = me.sorted, filtered = me.filtered, filterable = me.mixins.filterable, items = me.items, keys = me.keys, all = me.all, map = me.map, returnItem = null, oldItemsLn = items.length, oldItem, index, newKey;
  if (arguments.length == 1) {
    item = oldKey;
    oldKey = newKey = me.getKey(item);
  } else {
    newKey = me.getKey(item);
  }
  oldItem = map[oldKey];
  if (typeof oldKey == 'undefined' || oldKey === null || typeof oldItem == 'undefined') {
    return me.add(newKey, item);
  }
  me.map[newKey] = item;
  if (newKey !== oldKey) {
    delete me.map[oldKey];
  }
  if (sorted && me.getAutoSort()) {
    Ext.Array.remove(items, oldItem);
    Ext.Array.remove(keys, oldKey);
    Ext.Array.remove(all, oldItem);
    all.push(item);
    me.dirtyIndices = true;
    if (filtered && me.getAutoFilter()) {
      if (filterable.isFiltered.call(me, item)) {
        if (oldItemsLn !== items.length) {
          me.length--;
        }
        return null;
      } else {
        if (oldItemsLn === items.length) {
          me.length++;
          returnItem = item;
        }
      }
    }
    index = this.findInsertionIndex(items, item);
    Ext.Array.splice(keys, index, 0, newKey);
    Ext.Array.splice(items, index, 0, item);
  } else {
    if (filtered) {
      if (me.getAutoFilter() && filterable.isFiltered.call(me, item)) {
        if (me.indexOf(oldItem) !== -1) {
          Ext.Array.remove(items, oldItem);
          Ext.Array.remove(keys, oldKey);
          me.length--;
          me.dirtyIndices = true;
        }
        return null;
      } else {
        if (me.indexOf(oldItem) === -1) {
          items.push(item);
          keys.push(newKey);
          me.indices[newKey] = me.length;
          me.length++;
          return item;
        }
      }
    }
    index = me.indexOf(oldItem);
    keys[index] = newKey;
    items[index] = item;
    if (newKey !== oldKey) {
      this.dirtyIndices = true;
    }
  }
  return returnItem;
}, addAll:function(addItems) {
  var me = this, filtered = me.filtered, sorted = me.sorted, all = me.all, items = me.items, keys = me.keys, map = me.map, autoFilter = me.getAutoFilter(), autoSort = me.getAutoSort(), newKeys = [], newItems = [], filterable = me.mixins.filterable, addedItems = [], ln, key, i, item;
  if (Ext.isObject(addItems)) {
    for (key in addItems) {
      if (addItems.hasOwnProperty(key)) {
        newItems.push(items[key]);
        newKeys.push(key);
      }
    }
  } else {
    newItems = addItems;
    ln = addItems.length;
    for (i = 0; i < ln; i++) {
      newKeys.push(me.getKey(addItems[i]));
    }
  }
  for (i = 0; i < ln; i++) {
    key = newKeys[i];
    item = newItems[i];
    if (typeof key != 'undefined' && key !== null) {
      if (typeof map[key] != 'undefined') {
        me.replace(key, item);
        continue;
      }
      map[key] = item;
    }
    all.push(item);
    if (filtered && autoFilter && filterable.isFiltered.call(me, item)) {
      continue;
    }
    me.length++;
    keys.push(key);
    items.push(item);
    addedItems.push(item);
  }
  if (addedItems.length) {
    me.dirtyIndices = true;
    if (sorted && autoSort) {
      me.sort();
    }
    return addedItems;
  }
  return null;
}, each:function(fn, scope) {
  var items = this.items.slice(), i = 0, len = items.length, item;
  for (; i < len; i++) {
    item = items[i];
    if (fn.call(scope || item, item, i, len) === false) {
      break;
    }
  }
}, eachKey:function(fn, scope) {
  var keys = this.keys, items = this.items, ln = keys.length, i;
  for (i = 0; i < ln; i++) {
    fn.call(scope || window, keys[i], items[i], i, ln);
  }
}, findBy:function(fn, scope) {
  var keys = this.keys, items = this.items, i = 0, len = items.length;
  for (; i < len; i++) {
    if (fn.call(scope || window, items[i], keys[i])) {
      return items[i];
    }
  }
  return null;
}, filterBy:function(fn, scope) {
  var me = this, newCollection = new this.self, keys = me.keys, items = me.all, length = items.length, i;
  newCollection.getKey = me.getKey;
  for (i = 0; i < length; i++) {
    if (fn.call(scope || me, items[i], me.getKey(items[i]))) {
      newCollection.add(keys[i], items[i]);
    }
  }
  return newCollection;
}, insert:function(index, key, item) {
  var me = this, sorted = this.sorted, map = this.map, filtered = this.filtered;
  if (arguments.length == 2) {
    item = key;
    key = me.getKey(item);
  }
  if (index >= me.length || sorted && me.getAutoSort()) {
    return me.add(key, item);
  }
  if (typeof key != 'undefined' && key !== null) {
    if (typeof map[key] != 'undefined') {
      me.replace(key, item);
      return false;
    }
    map[key] = item;
  }
  this.all.push(item);
  if (filtered && this.getAutoFilter() && this.mixins.filterable.isFiltered.call(me, item)) {
    return null;
  }
  me.length++;
  Ext.Array.splice(me.items, index, 0, item);
  Ext.Array.splice(me.keys, index, 0, key);
  me.dirtyIndices = true;
  return item;
}, insertAll:function(index, insertItems) {
  if (index >= this.items.length || this.sorted && this.getAutoSort()) {
    return this.addAll(insertItems);
  }
  var me = this, filtered = this.filtered, sorted = this.sorted, all = this.all, items = this.items, keys = this.keys, map = this.map, autoFilter = this.getAutoFilter(), autoSort = this.getAutoSort(), newKeys = [], newItems = [], addedItems = [], filterable = this.mixins.filterable, insertedUnfilteredItem = false, ln, key, i, item;
  if (sorted && this.getAutoSort()) {
  }
  if (Ext.isObject(insertItems)) {
    for (key in insertItems) {
      if (insertItems.hasOwnProperty(key)) {
        newItems.push(items[key]);
        newKeys.push(key);
      }
    }
  } else {
    newItems = insertItems;
    ln = insertItems.length;
    for (i = 0; i < ln; i++) {
      newKeys.push(me.getKey(insertItems[i]));
    }
  }
  for (i = 0; i < ln; i++) {
    key = newKeys[i];
    item = newItems[i];
    if (typeof key != 'undefined' && key !== null) {
      if (typeof map[key] != 'undefined') {
        me.replace(key, item);
        continue;
      }
      map[key] = item;
    }
    all.push(item);
    if (filtered && autoFilter && filterable.isFiltered.call(me, item)) {
      continue;
    }
    me.length++;
    Ext.Array.splice(items, index + i, 0, item);
    Ext.Array.splice(keys, index + i, 0, key);
    insertedUnfilteredItem = true;
    addedItems.push(item);
  }
  if (insertedUnfilteredItem) {
    this.dirtyIndices = true;
    if (sorted && autoSort) {
      this.sort();
    }
    return addedItems;
  }
  return null;
}, remove:function(item) {
  var index = this.items.indexOf(item);
  if (index === -1) {
    Ext.Array.remove(this.all, item);
    if (typeof this.getKey == 'function') {
      var key = this.getKey(item);
      if (key !== undefined) {
        delete this.map[key];
      }
    }
    return item;
  }
  return this.removeAt(this.items.indexOf(item));
}, removeAll:function(items) {
  if (items) {
    var ln = items.length, i;
    for (i = 0; i < ln; i++) {
      this.remove(items[i]);
    }
  }
  return this;
}, removeAt:function(index) {
  var me = this, items = me.items, keys = me.keys, all = me.all, item, key;
  if (index < me.length && index >= 0) {
    item = items[index];
    key = keys[index];
    if (typeof key != 'undefined') {
      delete me.map[key];
    }
    Ext.Array.erase(items, index, 1);
    Ext.Array.erase(keys, index, 1);
    Ext.Array.remove(all, item);
    delete me.indices[key];
    me.length--;
    this.dirtyIndices = true;
    return item;
  }
  return false;
}, removeAtKey:function(key) {
  return this.removeAt(this.indexOfKey(key));
}, getCount:function() {
  return this.length;
}, indexOf:function(item) {
  if (this.dirtyIndices) {
    this.updateIndices();
  }
  var index = item ? this.indices[this.getKey(item)] : -1;
  return index === undefined ? -1 : index;
}, indexOfKey:function(key) {
  if (this.dirtyIndices) {
    this.updateIndices();
  }
  var index = this.indices[key];
  return index === undefined ? -1 : index;
}, updateIndices:function() {
  var items = this.items, ln = items.length, indices = this.indices = {}, i, item, key;
  for (i = 0; i < ln; i++) {
    item = items[i];
    key = this.getKey(item);
    indices[key] = i;
  }
  this.dirtyIndices = false;
}, get:function(key) {
  var me = this, fromMap = me.map[key], item;
  if (fromMap !== undefined) {
    item = fromMap;
  } else {
    if (typeof key == 'number') {
      item = me.items[key];
    }
  }
  return typeof item != 'function' || me.getAllowFunctions() ? item : null;
}, getAt:function(index) {
  return this.items[index];
}, getByKey:function(key) {
  return this.map[key];
}, contains:function(item) {
  var key = this.getKey(item);
  if (key) {
    return this.containsKey(key);
  } else {
    return Ext.Array.contains(this.items, item);
  }
}, containsKey:function(key) {
  return typeof this.map[key] != 'undefined';
}, clear:function() {
  var me = this;
  me.length = 0;
  me.items.length = 0;
  me.keys.length = 0;
  me.all.length = 0;
  me.dirtyIndices = true;
  me.indices = {};
  me.map = {};
}, first:function() {
  return this.items[0];
}, last:function() {
  return this.items[this.length - 1];
}, getRange:function(start, end) {
  var me = this, items = me.items, range = [], i;
  if (items.length < 1) {
    return range;
  }
  start = start || 0;
  end = Math.min(typeof end == 'undefined' ? me.length - 1 : end, me.length - 1);
  if (start <= end) {
    for (i = start; i <= end; i++) {
      range[range.length] = items[i];
    }
  } else {
    for (i = start; i >= end; i--) {
      range[range.length] = items[i];
    }
  }
  return range;
}, findIndexBy:function(fn, scope, start) {
  var me = this, keys = me.keys, items = me.items, i = start || 0, ln = items.length;
  for (; i < ln; i++) {
    if (fn.call(scope || me, items[i], keys[i])) {
      return i;
    }
  }
  return -1;
}, clone:function() {
  var me = this, copy = new this.self, keys = me.keys, items = me.items, i = 0, ln = items.length;
  for (; i < ln; i++) {
    copy.add(keys[i], items[i]);
  }
  copy.getKey = me.getKey;
  return copy;
}, destroy:function() {
  this.callSuper();
  this.clear();
}}, 1, 0, 0, 0, 0, [['sortable', Ext.mixin.Sortable], ['filterable', Ext.mixin.Filterable]], [Ext.util, 'Collection'], 0);
Ext.cmd.derive('Ext.data.Operation', Ext.Base, {config:{synchronous:true, action:null, filters:null, sorters:null, grouper:null, start:null, limit:null, batch:null, callback:null, scope:null, resultSet:null, records:null, request:null, response:null, withCredentials:null, params:null, url:null, page:null, node:null, model:undefined, addRecords:false}, started:false, running:false, complete:false, success:undefined, exception:false, error:undefined, constructor:function(config) {
  this.initConfig(config);
}, applyModel:function(model) {
  if (typeof model == 'string') {
    model = Ext.data.ModelManager.getModel(model);
    if (!model) {
      Ext.Logger.error('Model with name ' + arguments[0] + ' doesnt exist.');
    }
  }
  if (model && !model.prototype.isModel && Ext.isObject(model)) {
    model = Ext.data.ModelManager.registerType(model.storeId || model.id || Ext.id(), model);
  }
  return model;
}, getRecords:function() {
  var resultSet = this.getResultSet();
  return this._records || (resultSet ? resultSet.getRecords() : []);
}, setStarted:function() {
  this.started = true;
  this.running = true;
}, setCompleted:function() {
  this.complete = true;
  this.running = false;
}, setSuccessful:function() {
  this.success = true;
}, setException:function(error) {
  this.exception = true;
  this.success = false;
  this.running = false;
  this.error = error;
}, hasException:function() {
  return this.exception === true;
}, getError:function() {
  return this.error;
}, isStarted:function() {
  return this.started === true;
}, isRunning:function() {
  return this.running === true;
}, isComplete:function() {
  return this.complete === true;
}, wasSuccessful:function() {
  return this.isComplete() && this.success === true;
}, allowWrite:function() {
  return this.getAction() != 'read';
}, process:function(action, resultSet, request, response) {
  if (resultSet.getSuccess() !== false) {
    this.setResponse(response);
    this.setResultSet(resultSet);
    this.setCompleted();
    this.setSuccessful();
  } else {
    this.setResponse(response);
    this.setResultSet(resultSet);
    return false;
  }
  return this['process' + Ext.String.capitalize(action)].call(this, resultSet, request, response);
}, processRead:function(resultSet) {
  var records = resultSet.getRecords(), processedRecords = [], Model = this.getModel(), ln = records.length, i, record;
  for (i = 0; i < ln; i++) {
    record = records[i];
    processedRecords.push(new Model(record.data, record.id, record.node));
  }
  this.setRecords(processedRecords);
  resultSet.setRecords(processedRecords);
  return true;
}, processCreate:function(resultSet) {
  var updatedRecords = resultSet.getRecords(), currentRecords = this.getRecords(), ln = updatedRecords.length, i, currentRecord, updatedRecord;
  for (i = 0; i < ln; i++) {
    updatedRecord = updatedRecords[i];
    if (updatedRecord.clientId === null && currentRecords.length == 1 && updatedRecords.length == 1) {
      currentRecord = currentRecords[i];
    } else {
      currentRecord = this.findCurrentRecord(updatedRecord.clientId);
    }
    if (currentRecord) {
      this.updateRecord(currentRecord, updatedRecord);
    }
  }
  return true;
}, processUpdate:function(resultSet) {
  var updatedRecords = resultSet.getRecords(), currentRecords = this.getRecords(), ln = updatedRecords.length, i, currentRecord, updatedRecord;
  for (i = 0; i < ln; i++) {
    updatedRecord = updatedRecords[i];
    currentRecord = currentRecords[i];
    if (currentRecord) {
      this.updateRecord(currentRecord, updatedRecord);
    }
  }
  return true;
}, processDestroy:function(resultSet) {
  var updatedRecords = resultSet.getRecords(), ln = updatedRecords.length, i, currentRecord, updatedRecord;
  for (i = 0; i < ln; i++) {
    updatedRecord = updatedRecords[i];
    currentRecord = this.findCurrentRecord(updatedRecord.id);
    if (currentRecord) {
      currentRecord.setIsErased(true);
      currentRecord.notifyStores('afterErase', currentRecord);
    }
  }
}, findCurrentRecord:function(clientId) {
  var currentRecords = this.getRecords(), ln = currentRecords.length, i, currentRecord;
  for (i = 0; i < ln; i++) {
    currentRecord = currentRecords[i];
    if (currentRecord.getId() === clientId) {
      return currentRecord;
    }
  }
}, updateRecord:function(currentRecord, updatedRecord) {
  var recordData = updatedRecord.data, recordId = updatedRecord.id;
  currentRecord.beginEdit();
  currentRecord.set(recordData);
  if (recordId !== null) {
    currentRecord.setId(recordId);
  }
  currentRecord.endEdit(true);
  currentRecord.commit();
}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'Operation'], 0);
Ext.cmd.derive('Ext.data.ResultSet', Ext.Base, {config:{loaded:true, count:null, total:null, success:false, records:null, message:null}, constructor:function(config) {
  this.initConfig(config);
}, applyCount:function(count) {
  if (!count && count !== 0) {
    return this.getRecords().length;
  }
  return count;
}, updateRecords:function(records) {
  this.setCount(records.length);
}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'ResultSet'], 0);
Ext.cmd.derive('Ext.data.reader.Reader', Ext.Base, {alternateClassName:['Ext.data.Reader', 'Ext.data.DataReader'], isReader:true, config:{idProperty:undefined, clientIdProperty:'clientId', totalProperty:'total', successProperty:'success', messageProperty:null, rootProperty:'', implicitIncludes:true, model:undefined}, constructor:function(config) {
  this.initConfig(config);
}, fieldCount:0, applyModel:function(model) {
  if (typeof model == 'string') {
    model = Ext.data.ModelManager.getModel(model);
    if (!model) {
      Ext.Logger.error('Model with name ' + arguments[0] + ' doesnt exist.');
    }
  }
  if (model && !model.prototype.isModel && Ext.isObject(model)) {
    model = Ext.data.ModelManager.registerType(model.storeId || model.id || Ext.id(), model);
  }
  return model;
}, applyIdProperty:function(idProperty) {
  if (!idProperty && this.getModel()) {
    idProperty = this.getModel().getIdProperty();
  }
  return idProperty;
}, updateModel:function(model) {
  if (model) {
    if (!this.getIdProperty()) {
      this.setIdProperty(model.getIdProperty());
    }
    this.buildExtractors();
  }
}, createAccessor:Ext.emptyFn, createFieldAccessExpression:function() {
  return 'undefined';
}, buildExtractors:function() {
  if (!this.getModel()) {
    return;
  }
  var me = this, totalProp = me.getTotalProperty(), successProp = me.getSuccessProperty(), messageProp = me.getMessageProperty();
  if (totalProp) {
    me.getTotal = me.createAccessor(totalProp);
  }
  if (successProp) {
    me.getSuccess = me.createAccessor(successProp);
  }
  if (messageProp) {
    me.getMessage = me.createAccessor(messageProp);
  }
  me.extractRecordData = me.buildRecordDataExtractor();
}, buildRecordDataExtractor:function() {
  var me = this, model = me.getModel(), fields = model.getFields(), ln = fields.length, fieldVarName = [], clientIdProp = me.getModel().getClientIdProperty(), prefix = '__field', code = ['var me \x3d this,\n', '    fields \x3d me.getModel().getFields(),\n', '    idProperty \x3d me.getIdProperty(),\n', '    idPropertyIsFn \x3d (typeof idProperty \x3d\x3d "function"),', '    value,\n', '    internalId'], i, field, varName, fieldName;
  fields = fields.items;
  for (i = 0; i < ln; i++) {
    field = fields[i];
    fieldName = field.getName();
    if (fieldName === model.getIdProperty()) {
      fieldVarName[i] = 'idField';
    } else {
      fieldVarName[i] = prefix + i;
    }
    code.push(',\n    ', fieldVarName[i], ' \x3d fields.get("', field.getName(), '")');
  }
  code.push(';\n\n    return function(source) {\n        var dest \x3d {};\n');
  code.push('        if (idPropertyIsFn) {\n');
  code.push('            idField.setMapping(idProperty);\n');
  code.push('        }\n');
  for (i = 0; i < ln; i++) {
    field = fields[i];
    varName = fieldVarName[i];
    fieldName = field.getName();
    if (fieldName === model.getIdProperty() && field.getMapping() === null && model.getIdProperty() !== this.getIdProperty()) {
      field.setMapping(this.getIdProperty());
    }
    code.push('        try {\n');
    code.push('            value \x3d ', me.createFieldAccessExpression(field, varName, 'source'), ';\n');
    code.push('            if (value !\x3d\x3d undefined) {\n');
    code.push('                dest["' + field.getName() + '"] \x3d value;\n');
    code.push('            }\n');
    code.push('        } catch(e){}\n');
  }
  if (clientIdProp) {
    code.push('        internalId \x3d ' + me.createFieldAccessExpression(Ext.create('Ext.data.Field', {name:clientIdProp}), null, 'source') + ';\n');
    code.push('        if (internalId !\x3d\x3d undefined) {\n');
    code.push('            dest["_clientId"] \x3d internalId;\n        }\n');
  }
  code.push('        return dest;\n');
  code.push('    };');
  return Ext.functionFactory(code.join('')).call(me);
}, getFields:function() {
  return this.getModel().getFields().items;
}, getData:function(data) {
  return data;
}, getResponseData:function(response) {
  return response;
}, getRoot:function(data) {
  return data;
}, read:function(response) {
  var data = response, Model = this.getModel(), resultSet, records, i, ln, record;
  if (response) {
    data = this.getResponseData(response);
  }
  if (data) {
    resultSet = this.readRecords(data);
    records = resultSet.getRecords();
    for (i = 0, ln = records.length; i < ln; i++) {
      record = records[i];
      records[i] = new Model(record.data, record.id, record.node);
    }
    return resultSet;
  } else {
    return this.nullResultSet;
  }
}, process:function(response) {
  var data = response;
  if (response) {
    data = this.getResponseData(response);
  }
  if (data) {
    return this.readRecords(data);
  } else {
    return this.nullResultSet;
  }
}, readRecords:function(data) {
  var me = this;
  me.rawData = data;
  data = me.getData(data);
  if (data.metaData) {
    me.onMetaChange(data.metaData);
  }
  var isArray = Ext.isArray(data), root = isArray ? data : me.getRoot(data), success = true, recordCount = 0, total, value, records, message;
  if (isArray && Ext.isEmpty(data.length)) {
    return me.nullResultSet;
  }
  if (me.getTotal) {
    value = parseInt(me.getTotal(data), 10);
    if (!isNaN(value)) {
      total = value;
    }
  }
  if (me.getSuccess) {
    value = me.getSuccess(data);
    if (value === false || value === 'false') {
      success = false;
    }
  }
  if (me.getMessage) {
    message = me.getMessage(data);
  }
  if (root) {
    records = me.extractData(root);
    recordCount = records.length;
  } else {
    recordCount = 0;
    records = [];
  }
  return new Ext.data.ResultSet({total:total, count:recordCount, records:records, success:success, message:message});
}, extractData:function(root) {
  var me = this, records = [], length = root.length, model = me.getModel(), idProperty = model.getIdProperty(), fieldsCollection = model.getFields(), node, i, data, id, clientId;
  if (fieldsCollection.isDirty) {
    me.buildExtractors(true);
    delete fieldsCollection.isDirty;
  }
  if (!root.length && Ext.isObject(root)) {
    root = [root];
    length = 1;
  }
  for (i = 0; i < length; i++) {
    clientId = null;
    id = null;
    node = root[i];
    if (node.isModel) {
      data = node.data;
    } else {
      data = me.extractRecordData(node);
    }
    if (data._clientId !== undefined) {
      clientId = data._clientId;
      delete data._clientId;
    }
    if (data[idProperty] !== undefined) {
      id = data[idProperty];
    }
    if (me.getImplicitIncludes()) {
      me.readAssociated(data, node);
    }
    records.push({clientId:clientId, id:id, data:data, node:node});
  }
  return records;
}, readAssociated:function(record, data) {
  var associations = this.getModel().associations.items, length = associations.length, i = 0, association, associationData, associationKey;
  for (; i < length; i++) {
    association = associations[i];
    associationKey = association.getAssociationKey();
    associationData = this.getAssociatedDataRoot(data, associationKey);
    if (associationData) {
      record[associationKey] = associationData;
    }
  }
}, getAssociatedDataRoot:function(data, associationName) {
  var re = /[\[\.]/, i = String(associationName).search(re);
  if (i >= 0) {
    return Ext.functionFactory('obj', 'return obj' + (i > 0 ? '.' : '') + associationName)(data);
  }
  return data[associationName];
}, onMetaChange:function(meta) {
  var fields = meta.fields, me = this, newModel, config, idProperty;
  me.metaData = meta;
  if (meta.rootProperty !== undefined) {
    me.setRootProperty(meta.rootProperty);
  } else {
    if (meta.root !== undefined) {
      me.setRootProperty(meta.root);
    }
  }
  if (meta.idProperty !== undefined) {
    me.setIdProperty(meta.idProperty);
  }
  if (meta.totalProperty !== undefined) {
    me.setTotalProperty(meta.totalProperty);
  }
  if (meta.successProperty !== undefined) {
    me.setSuccessProperty(meta.successProperty);
  }
  if (meta.messageProperty !== undefined) {
    me.setMessageProperty(meta.messageProperty);
  }
  if (fields) {
    if (me.getModel()) {
      me.getModel().setFields(fields);
      me.buildExtractors();
    } else {
      idProperty = me.getIdProperty();
      config = {fields:fields};
      if (idProperty) {
        config.idProperty = idProperty;
      }
      newModel = Ext.define('Ext.data.reader.MetaModel' + Ext.id(), {extend:'Ext.data.Model', config:config});
      me.setModel(newModel);
    }
  } else {
    me.buildExtractors();
  }
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Observable.prototype.mixinId || Ext.mixin.Observable.$className, Ext.mixin.Observable]], [Ext.data.reader, 'Reader', Ext.data, 'Reader', Ext.data, 'DataReader'], function() {
  Ext.apply(this.prototype, {nullResultSet:new Ext.data.ResultSet({total:0, count:0, records:[], success:false})});
});
Ext.cmd.derive('Ext.data.reader.Json', Ext.data.reader.Reader, {alternateClassName:'Ext.data.JsonReader', config:{record:null, useSimpleAccessors:false}, objectRe:/[\[\.]/, getResponseData:function(response) {
  var responseText = response;
  if (response && response.responseText) {
    responseText = response.responseText;
  }
  if (typeof responseText !== 'string') {
    return responseText;
  }
  var data;
  try {
    data = Ext.decode(responseText);
  } catch (ex) {
    this.fireEvent('exception', this, response, 'Unable to parse the JSON returned by the server: ' + ex.toString());
    Ext.Logger.warn('Unable to parse the JSON returned by the server: ' + ex.toString());
  }
  return data;
}, buildExtractors:function() {
  var me = this, root = me.getRootProperty();
  Ext.data.reader.Reader.prototype.buildExtractors.apply(this, arguments);
  if (root) {
    me.rootAccessor = me.createAccessor(root);
  } else {
    delete me.rootAccessor;
  }
}, getRoot:function(data) {
  var fieldsCollection = this.getModel().getFields();
  if (fieldsCollection.isDirty) {
    this.buildExtractors(true);
    delete fieldsCollection.isDirty;
  }
  if (this.rootAccessor) {
    return this.rootAccessor.call(this, data);
  } else {
    return data;
  }
}, extractData:function(root) {
  var recordName = this.getRecord(), data = [], length, i;
  if (recordName) {
    length = root.length;
    if (!length && Ext.isObject(root)) {
      length = 1;
      root = [root];
    }
    for (i = 0; i < length; i++) {
      data[i] = root[i][recordName];
    }
  } else {
    data = root;
  }
  return Ext.data.reader.Reader.prototype.extractData.call(this, data);
}, createAccessor:function() {
  var re = /[\[\.]/;
  return function(expr) {
    if (Ext.isEmpty(expr)) {
      return Ext.emptyFn;
    }
    if (Ext.isFunction(expr)) {
      return expr;
    }
    if (this.getUseSimpleAccessors() !== true) {
      var i = String(expr).search(re);
      if (i >= 0) {
        return Ext.functionFactory('obj', 'var value; try {value \x3d obj' + (i > 0 ? '.' : '') + expr + '} catch(e) {}; return value;');
      }
    }
    return function(obj) {
      return obj[expr];
    };
  };
}(), createFieldAccessExpression:function(field, fieldVarName, dataName) {
  var me = this, re = me.objectRe, hasMap = field.getMapping() !== null, map = hasMap ? field.getMapping() : field.getName(), result, operatorSearch;
  if (typeof map === 'function') {
    result = fieldVarName + '.getMapping()(' + dataName + ', this)';
  } else {
    if (me.getUseSimpleAccessors() === true || (operatorSearch = String(map).search(re)) < 0) {
      if (!hasMap || isNaN(map)) {
        map = '"' + map + '"';
      }
      result = dataName + '[' + map + ']';
    } else {
      result = dataName + (operatorSearch > 0 ? '.' : '') + map;
    }
  }
  return result;
}}, 0, 0, 0, 0, ['reader.json'], 0, [Ext.data.reader, 'Json', Ext.data, 'JsonReader'], 0);
Ext.cmd.derive('Ext.data.writer.Writer', Ext.Base, {alternateClassName:['Ext.data.DataWriter', 'Ext.data.Writer'], config:{writeAllFields:true, nameProperty:'name'}, constructor:function(config) {
  this.initConfig(config);
}, write:function(request) {
  var operation = request.getOperation(), records = operation.getRecords() || [], len = records.length, i = 0, data = [];
  for (; i < len; i++) {
    data.push(this.getRecordData(records[i]));
  }
  return this.writeRecords(request, data);
}, writeDate:function(field, date) {
  if (!date) {
    return null;
  }
  var dateFormat = field.getDateFormat() || 'timestamp';
  switch(dateFormat) {
    case 'timestamp':
      return date.getTime() / 1000;
    case 'time':
      return date.getTime();
    default:
      return Ext.Date.format(date, dateFormat);
  }
}, getRecordData:function(record) {
  var isPhantom = record.phantom === true, writeAll = this.getWriteAllFields() || isPhantom, nameProperty = this.getNameProperty(), fields = record.getFields(), data = {}, changes, name, field, key, value;
  if (writeAll) {
    fields.each(function(field) {
      if (field.getPersist()) {
        name = field.config[nameProperty] || field.getName();
        value = record.get(field.getName());
        if (field.getType().type == 'date') {
          value = this.writeDate(field, value);
        }
        data[name] = value;
      }
    }, this);
  } else {
    changes = record.getChanges();
    for (key in changes) {
      if (changes.hasOwnProperty(key)) {
        field = fields.get(key);
        if (field.getPersist()) {
          name = field.config[nameProperty] || field.getName();
          value = changes[key];
          if (field.getType().type == 'date') {
            value = this.writeDate(field, value);
          }
          data[name] = value;
        }
      }
    }
    if (!isPhantom) {
      data[record.getIdProperty()] = record.getId();
    }
  }
  return data;
}}, 1, 0, 0, 0, ['writer.base'], 0, [Ext.data.writer, 'Writer', Ext.data, 'DataWriter', Ext.data, 'Writer'], 0);
Ext.cmd.derive('Ext.data.writer.Json', Ext.data.writer.Writer, {alternateClassName:'Ext.data.JsonWriter', config:{rootProperty:undefined, encode:false, allowSingle:true, encodeRequest:false}, applyRootProperty:function(root) {
  if (!root && (this.getEncode() || this.getEncodeRequest())) {
    root = 'data';
  }
  return root;
}, writeRecords:function(request, data) {
  var root = this.getRootProperty(), params = request.getParams(), allowSingle = this.getAllowSingle(), jsonData;
  if (this.getAllowSingle() && data && data.length == 1) {
    data = data[0];
  }
  if (this.getEncodeRequest()) {
    jsonData = request.getJsonData() || {};
    if (data && (data.length || allowSingle && Ext.isObject(data))) {
      jsonData[root] = data;
    }
    request.setJsonData(Ext.apply(jsonData, params || {}));
    request.setParams(null);
    request.setMethod('POST');
    return request;
  }
  if (!data || !(data.length || allowSingle && Ext.isObject(data))) {
    return request;
  }
  if (this.getEncode()) {
    if (root) {
      params[root] = Ext.encode(data);
    } else {
    }
  } else {
    jsonData = request.getJsonData() || {};
    if (root) {
      jsonData[root] = data;
    } else {
      jsonData = data;
    }
    request.setJsonData(jsonData);
  }
  return request;
}}, 0, 0, 0, 0, ['writer.json'], 0, [Ext.data.writer, 'Json', Ext.data, 'JsonWriter'], 0);
Ext.cmd.derive('Ext.data.Batch', Ext.Base, {config:{autoStart:false, pauseOnException:true, proxy:null}, current:-1, total:0, isRunning:false, isComplete:false, hasException:false, constructor:function(config) {
  var me = this;
  me.initConfig(config);
  me.operations = [];
}, add:function(operation) {
  this.total++;
  operation.setBatch(this);
  this.operations.push(operation);
}, start:function() {
  this.hasException = false;
  this.isRunning = true;
  this.runNextOperation();
}, runNextOperation:function() {
  this.runOperation(this.current + 1);
}, pause:function() {
  this.isRunning = false;
}, runOperation:function(index) {
  var me = this, operations = me.operations, operation = operations[index], onProxyReturn;
  if (operation === undefined) {
    me.isRunning = false;
    me.isComplete = true;
    me.fireEvent('complete', me, operations[operations.length - 1]);
  } else {
    me.current = index;
    onProxyReturn = function(operation) {
      var hasException = operation.hasException();
      if (hasException) {
        me.hasException = true;
        me.fireEvent('exception', me, operation);
      } else {
        me.fireEvent('operationcomplete', me, operation);
      }
      if (hasException && me.getPauseOnException()) {
        me.pause();
      } else {
        operation.setCompleted();
        me.runNextOperation();
      }
    };
    operation.setStarted();
    me.getProxy()[operation.getAction()](operation, onProxyReturn, me);
  }
}}, 1, 0, 0, 0, 0, [['observable', Ext.mixin.Observable]], [Ext.data, 'Batch'], 0);
Ext.cmd.derive('Ext.data.proxy.Proxy', Ext.Evented, {alternateClassName:['Ext.data.DataProxy', 'Ext.data.Proxy'], config:{batchOrder:'create,update,destroy', batchActions:true, model:null, reader:{type:'json'}, writer:{type:'json'}}, isProxy:true, applyModel:function(model) {
  if (typeof model == 'string') {
    model = Ext.data.ModelManager.getModel(model);
    if (!model) {
      Ext.Logger.error('Model with name ' + arguments[0] + ' doesnt exist.');
    }
  }
  if (model && !model.prototype.isModel && Ext.isObject(model)) {
    model = Ext.data.ModelManager.registerType(model.storeId || model.id || Ext.id(), model);
  }
  return model;
}, updateModel:function(model) {
  if (model) {
    var reader = this.getReader();
    if (reader && !reader.getModel()) {
      reader.setModel(model);
    }
  }
}, applyReader:function(reader, currentReader) {
  return Ext.factory(reader, Ext.data.Reader, currentReader, 'reader');
}, updateReader:function(reader) {
  if (reader) {
    var model = this.getModel();
    if (!model) {
      model = reader.getModel();
      if (model) {
        this.setModel(model);
      }
    } else {
      reader.setModel(model);
    }
    if (reader.onMetaChange) {
      reader.onMetaChange = Ext.Function.createSequence(reader.onMetaChange, this.onMetaChange, this);
    }
  }
}, onMetaChange:function(data) {
  var model = this.getReader().getModel();
  if (!this.getModel() && model) {
    this.setModel(model);
  }
  this.fireEvent('metachange', this, data);
}, applyWriter:function(writer, currentWriter) {
  return Ext.factory(writer, Ext.data.Writer, currentWriter, 'writer');
}, create:Ext.emptyFn, read:Ext.emptyFn, update:Ext.emptyFn, destroy:Ext.emptyFn, onDestroy:function() {
  Ext.destroy(this.getReader(), this.getWriter());
  Ext.Evented.prototype.destroy.apply(this, arguments);
}, batch:function(options, listeners) {
  var me = this, useBatch = me.getBatchActions(), model = me.getModel(), batch, records;
  if (options.operations === undefined) {
    options = {operations:options, listeners:listeners};
  }
  if (options.batch && options.batch.isBatch) {
    batch = options.batch;
  } else {
    batch = new Ext.data.Batch(options.batch || {});
  }
  batch.setProxy(me);
  batch.on('complete', Ext.bind(me.onBatchComplete, me, [options], 0));
  if (options.listeners) {
    batch.on(options.listeners);
  }
  Ext.each(me.getBatchOrder().split(','), function(action) {
    records = options.operations[action];
    if (records) {
      if (useBatch) {
        batch.add(new Ext.data.Operation({action:action, records:records, model:model}));
      } else {
        Ext.each(records, function(record) {
          batch.add(new Ext.data.Operation({action:action, records:[record], model:model}));
        });
      }
    }
  }, me);
  batch.start();
  return batch;
}, onBatchComplete:function(batchOptions, batch) {
  var scope = batchOptions.scope || this;
  if (batch.hasException) {
    if (Ext.isFunction(batchOptions.failure)) {
      Ext.callback(batchOptions.failure, scope, [batch, batchOptions]);
    }
  } else {
    if (Ext.isFunction(batchOptions.success)) {
      Ext.callback(batchOptions.success, scope, [batch, batchOptions]);
    }
  }
  if (Ext.isFunction(batchOptions.callback)) {
    Ext.callback(batchOptions.callback, scope, [batch, batchOptions]);
  }
  Ext.destroy(batch);
}}, 0, 0, 0, 0, ['proxy.proxy'], 0, [Ext.data.proxy, 'Proxy', Ext.data, 'DataProxy', Ext.data, 'Proxy'], function() {
});
Ext.cmd.derive('Ext.data.proxy.Client', Ext.data.proxy.Proxy, {alternateClassName:'Ext.proxy.ClientProxy', clear:function() {
}}, 0, 0, 0, 0, 0, 0, [Ext.data.proxy, 'Client', Ext.proxy, 'ClientProxy'], 0);
Ext.cmd.derive('Ext.data.proxy.Memory', Ext.data.proxy.Client, {alternateClassName:'Ext.data.MemoryProxy', isMemoryProxy:true, config:{data:[]}, finishOperation:function(operation, callback, scope) {
  if (operation) {
    var i = 0, recs = operation.getRecords(), len = recs.length;
    for (i; i < len; i++) {
      recs[i].commit();
    }
    operation.setCompleted();
    operation.setSuccessful();
    Ext.callback(callback, scope || this, [operation]);
  }
}, create:function() {
  this.finishOperation.apply(this, arguments);
}, update:function() {
  this.finishOperation.apply(this, arguments);
}, destroy:function() {
  this.finishOperation.apply(this, arguments);
}, read:function(operation, callback, scope) {
  var me = this, reader = me.getReader();
  if (operation.process('read', reader.process(me.getData())) === false) {
    this.fireEvent('exception', this, null, operation);
  }
  Ext.callback(callback, scope || me, [operation]);
}, clear:Ext.emptyFn}, 0, 0, 0, 0, ['proxy.memory'], 0, [Ext.data.proxy, 'Memory', Ext.data, 'MemoryProxy'], 0);
Ext.cmd.derive('Ext.data.SortTypes', Ext.Base, {singleton:true, stripTagsRE:/<\/?[^>]+>/gi, none:function(value) {
  return value;
}, asText:function(value) {
  return String(value).replace(this.stripTagsRE, '');
}, asUCText:function(value) {
  return String(value).toUpperCase().replace(this.stripTagsRE, '');
}, asUCString:function(value) {
  return String(value).toUpperCase();
}, asDate:function(value) {
  if (!value) {
    return 0;
  }
  if (Ext.isDate(value)) {
    return value.getTime();
  }
  return Date.parse(String(value));
}, asFloat:function(value) {
  value = parseFloat(String(value).replace(/,/g, ''));
  return isNaN(value) ? 0 : value;
}, asInt:function(value) {
  value = parseInt(String(value).replace(/,/g, ''), 10);
  return isNaN(value) ? 0 : value;
}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'SortTypes'], 0);
Ext.cmd.derive('Ext.data.Types', Ext.Base, {singleton:true, stripRe:/[\$,%]/g, dashesRe:/-/g, iso8601TestRe:/\d\dT\d\d/, iso8601SplitRe:/[- :T\.Z\+]/}, 0, 0, 0, 0, 0, 0, [Ext.data, 'Types'], function() {
  var Types = this, sortTypes = Ext.data.SortTypes;
  Ext.apply(Types, {AUTO:{convert:function(value) {
    return value;
  }, sortType:sortTypes.none, type:'auto'}, STRING:{convert:function(value) {
    return value === undefined || value === null ? this.getAllowNull() ? null : '' : String(value);
  }, sortType:sortTypes.asUCString, type:'string'}, INT:{convert:function(value) {
    return value !== undefined && value !== null && value !== '' ? typeof value === 'number' ? parseInt(value, 10) : parseInt(String(value).replace(Types.stripRe, ''), 10) : this.getAllowNull() ? null : 0;
  }, sortType:sortTypes.none, type:'int'}, FLOAT:{convert:function(value) {
    return value !== undefined && value !== null && value !== '' ? typeof value === 'number' ? value : parseFloat(String(value).replace(Types.stripRe, ''), 10) : this.getAllowNull() ? null : 0;
  }, sortType:sortTypes.none, type:'float'}, BOOL:{convert:function(value) {
    if ((value === undefined || value === null || value === '') && this.getAllowNull()) {
      return null;
    }
    return value !== 'false' && value !== '0' && !!value;
  }, sortType:sortTypes.none, type:'bool'}, DATE:{convert:function(value) {
    var dateFormat = this.getDateFormat(), parsed;
    if (!value) {
      return null;
    }
    if (Ext.isDate(value)) {
      return value;
    }
    if (dateFormat) {
      if (dateFormat == 'timestamp') {
        return new Date(value * 1000);
      }
      if (dateFormat == 'time') {
        return new Date(parseInt(value, 10));
      }
      return Ext.Date.parse(value, dateFormat);
    }
    parsed = new Date(Date.parse(value));
    if (isNaN(parsed)) {
      if (Types.iso8601TestRe.test(value)) {
        parsed = value.split(Types.iso8601SplitRe);
        parsed = new Date(parsed[0], parsed[1] - 1, parsed[2], parsed[3], parsed[4], parsed[5]);
      }
      if (isNaN(parsed)) {
        parsed = new Date(Date.parse(value.replace(Types.dashesRe, '/')));
      }
    }
    return isNaN(parsed) ? null : parsed;
  }, sortType:sortTypes.asDate, type:'date'}});
  Ext.apply(Types, {BOOLEAN:this.BOOL, INTEGER:this.INT, NUMBER:this.FLOAT});
});
Ext.cmd.derive('Ext.data.Field', Ext.Base, {isField:true, config:{name:null, type:'auto', convert:undefined, dateFormat:null, allowNull:true, defaultValue:undefined, mapping:null, sortType:undefined, sortDir:'ASC', allowBlank:true, persist:true, encode:null, decode:null, bubbleEvents:'action'}, constructor:function(config) {
  if (Ext.isString(config)) {
    config = {name:config};
  }
  this.initConfig(config);
}, applyType:function(type) {
  var types = Ext.data.Types, autoType = types.AUTO;
  if (type) {
    if (Ext.isString(type)) {
      return types[type.toUpperCase()] || autoType;
    } else {
      return type;
    }
  }
  return autoType;
}, updateType:function(newType, oldType) {
  var convert = this.getConvert();
  if (oldType && convert === oldType.convert) {
    this.setConvert(newType.convert);
  }
}, applySortType:function(sortType) {
  var sortTypes = Ext.data.SortTypes, type = this.getType(), defaultSortType = type.sortType;
  if (sortType) {
    if (Ext.isString(sortType)) {
      return sortTypes[sortType] || defaultSortType;
    } else {
      return sortType;
    }
  }
  return defaultSortType;
}, applyConvert:function(convert) {
  var defaultConvert = this.getType().convert;
  if (convert && convert !== defaultConvert) {
    this._hasCustomConvert = true;
    return convert;
  } else {
    this._hasCustomConvert = false;
    return defaultConvert;
  }
}, hasCustomConvert:function() {
  return this._hasCustomConvert;
}}, 1, 0, 0, 0, ['data.field'], 0, [Ext.data, 'Field'], 0);
Ext.cmd.derive('Ext.data.identifier.Simple', Ext.Base, {statics:{AUTO_ID:1}, config:{prefix:'ext-record-'}, constructor:function(config) {
  this.initConfig(config);
}, generate:function(record) {
  return this._prefix + this.self.AUTO_ID++;
}}, 1, 0, 0, 0, ['data.identifier.simple'], 0, [Ext.data.identifier, 'Simple'], 0);
Ext.cmd.derive('Ext.data.ModelManager', Ext.AbstractManager, {alternateClassName:['Ext.ModelMgr', 'Ext.ModelManager'], singleton:true, modelNamespace:null, registerType:function(name, config) {
  var proto = config.prototype, model;
  if (proto && proto.isModel) {
    model = config;
  } else {
    config = {extend:config.extend || 'Ext.data.Model', config:config};
    model = Ext.define(name, config);
  }
  this.types[name] = model;
  return model;
}, onModelDefined:Ext.emptyFn, getModel:function(id) {
  var model = id;
  if (typeof model == 'string') {
    model = this.types[model];
    if (!model && this.modelNamespace) {
      model = this.types[this.modelNamespace + '.' + model];
    }
  }
  return model;
}, create:function(config, name, id) {
  var con = typeof name == 'function' ? name : this.types[name || config.name];
  return new con(config, id);
}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'ModelManager', Ext, 'ModelMgr', Ext, 'ModelManager'], function() {
  Ext.regModel = function() {
    return this.ModelManager.registerType.apply(this.ModelManager, arguments);
  };
});
Ext.cmd.derive('Ext.data.Request', Ext.Base, {config:{action:null, params:null, method:'GET', url:null, operation:null, proxy:null, disableCaching:false, headers:{}, callbackKey:null, jsonP:null, jsonData:null, xmlData:null, withCredentials:null, username:null, password:null, callback:null, scope:null, timeout:30000, records:null, directFn:null, args:null, useDefaultXhrHeader:null}, constructor:function(config) {
  this.initConfig(config);
}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'Request'], 0);
Ext.cmd.derive('Ext.data.proxy.Server', Ext.data.proxy.Proxy, {alternateClassName:'Ext.data.ServerProxy', config:{url:null, pageParam:'page', startParam:'start', limitParam:'limit', groupParam:'group', sortParam:'sort', filterParam:'filter', directionParam:'dir', enablePagingParams:true, simpleSortMode:false, noCache:true, cacheString:'_dc', timeout:30000, api:{create:undefined, read:undefined, update:undefined, destroy:undefined}, extraParams:{}}, constructor:function(config) {
  config = config || {};
  if (config.nocache !== undefined) {
    config.noCache = config.nocache;
  }
  Ext.data.proxy.Proxy.prototype.constructor.call(this, config);
}, create:function() {
  return this.doRequest.apply(this, arguments);
}, read:function() {
  return this.doRequest.apply(this, arguments);
}, update:function() {
  return this.doRequest.apply(this, arguments);
}, destroy:function() {
  return this.doRequest.apply(this, arguments);
}, setExtraParam:function(name, value) {
  this.getExtraParams()[name] = value;
}, buildRequest:function(operation) {
  var me = this, params = Ext.applyIf(operation.getParams() || {}, me.getExtraParams() || {}), request;
  params = Ext.applyIf(params, me.getParams(operation));
  request = Ext.create('Ext.data.Request', {params:params, action:operation.getAction(), records:operation.getRecords(), url:operation.getUrl(), operation:operation, proxy:me});
  request.setUrl(me.buildUrl(request));
  operation.setRequest(request);
  return request;
}, processResponse:function(success, operation, request, response, callback, scope) {
  var me = this, action = operation.getAction(), reader, resultSet;
  if (success === true) {
    reader = me.getReader();
    try {
      resultSet = reader.process(me.getResponseResult(response));
    } catch (e$11) {
      operation.setException(e$11.message);
      me.fireEvent('exception', me, response, operation);
      return;
    }
    if (!operation.getModel()) {
      operation.setModel(this.getModel());
    }
    if (operation.process(action, resultSet, request, response) === false) {
      me.setException(operation, response);
      me.fireEvent('exception', me, response, operation);
    }
  } else {
    me.setException(operation, response);
    me.fireEvent('exception', this, response, operation);
  }
  if (typeof callback == 'function') {
    callback.call(scope || me, operation);
  }
  me.afterRequest(request, success);
}, getResponseResult:function(response) {
  return response;
}, setException:function(operation, response) {
  if (Ext.isObject(response)) {
    operation.setException({status:response.status, statusText:response.statusText});
  }
}, applyEncoding:function(value) {
  return Ext.encode(value);
}, encodeSorters:function(sorters) {
  var min = [], length = sorters.length, i = 0;
  for (; i < length; i++) {
    min[i] = {property:sorters[i].getProperty(), direction:sorters[i].getDirection()};
  }
  return this.applyEncoding(min);
}, encodeFilters:function(filters) {
  var min = [], length = filters.length, i = 0;
  for (; i < length; i++) {
    min[i] = {property:filters[i].getProperty(), value:filters[i].getValue()};
  }
  return this.applyEncoding(min);
}, getParams:function(operation) {
  var me = this, params = {}, grouper = operation.getGrouper(), sorters = operation.getSorters(), filters = operation.getFilters(), page = operation.getPage(), start = operation.getStart(), limit = operation.getLimit(), simpleSortMode = me.getSimpleSortMode(), pageParam = me.getPageParam(), startParam = me.getStartParam(), limitParam = me.getLimitParam(), groupParam = me.getGroupParam(), sortParam = me.getSortParam(), filterParam = me.getFilterParam(), directionParam = me.getDirectionParam();
  if (me.getEnablePagingParams()) {
    if (pageParam && page !== null) {
      params[pageParam] = page;
    }
    if (startParam && start !== null) {
      params[startParam] = start;
    }
    if (limitParam && limit !== null) {
      params[limitParam] = limit;
    }
  }
  if (groupParam && grouper) {
    params[groupParam] = me.encodeSorters([grouper]);
  }
  if (sortParam && sorters && sorters.length > 0) {
    if (simpleSortMode) {
      params[sortParam] = sorters[0].getProperty();
      params[directionParam] = sorters[0].getDirection();
    } else {
      params[sortParam] = me.encodeSorters(sorters);
    }
  }
  if (filterParam && filters && filters.length > 0) {
    params[filterParam] = me.encodeFilters(filters);
  }
  return params;
}, buildUrl:function(request) {
  var me = this, url = me.getUrl(request);
  if (me.getNoCache()) {
    url = Ext.urlAppend(url, Ext.String.format('{0}\x3d{1}', me.getCacheString(), Ext.Date.now()));
  }
  return url;
}, getUrl:function(request) {
  return request ? request.getUrl() || this.getApi()[request.getAction()] || this._url : this._url;
}, doRequest:function() {
}, afterRequest:Ext.emptyFn}, 1, 0, 0, 0, ['proxy.server'], 0, [Ext.data.proxy, 'Server', Ext.data, 'ServerProxy'], 0);
Ext.cmd.derive('Ext.data.proxy.Ajax', Ext.data.proxy.Server, {alternateClassName:['Ext.data.HttpProxy', 'Ext.data.AjaxProxy'], config:{withCredentials:false, useDefaultXhrHeader:true, username:null, password:null, actionMethods:{create:'POST', read:'GET', update:'POST', destroy:'POST'}, headers:{}}, doRequest:function(operation, callback, scope) {
  var me = this, writer = me.getWriter(), request = me.buildRequest(operation);
  request.setConfig({headers:me.getHeaders(), timeout:me.getTimeout(), method:me.getMethod(request), callback:me.createRequestCallback(request, operation, callback, scope), scope:me, proxy:me, useDefaultXhrHeader:me.getUseDefaultXhrHeader()});
  if (operation.getWithCredentials() || me.getWithCredentials()) {
    request.setWithCredentials(true);
    request.setUsername(me.getUsername());
    request.setPassword(me.getPassword());
  }
  request = writer.write(request);
  Ext.Ajax.request(request.getCurrentConfig());
  return request;
}, getMethod:function(request) {
  return this.getActionMethods()[request.getAction()];
}, createRequestCallback:function(request, operation, callback, scope) {
  var me = this;
  return function(options, success, response) {
    me.processResponse(success, operation, request, response, callback, scope);
  };
}}, 0, 0, 0, 0, ['proxy.ajax'], 0, [Ext.data.proxy, 'Ajax', Ext.data, 'HttpProxy', Ext.data, 'AjaxProxy'], 0);
Ext.cmd.derive('Ext.data.association.Association', Ext.Base, {alternateClassName:'Ext.data.Association', config:{ownerModel:null, ownerName:undefined, associatedModel:null, associatedName:undefined, associationKey:undefined, primaryKey:'id', reader:null, type:null, name:undefined}, statics:{create:function(association) {
  if (!association.isAssociation) {
    if (Ext.isString(association)) {
      association = {type:association};
    }
    association.type = association.type.toLowerCase();
    return Ext.factory(association, Ext.data.association.Association, null, 'association');
  }
  return association;
}}, constructor:function(config) {
  this.initConfig(config);
}, applyName:function(name) {
  if (!name) {
    name = this.getAssociatedName();
  }
  return name;
}, applyOwnerModel:function(ownerName) {
  var ownerModel = Ext.data.ModelManager.getModel(ownerName);
  if (ownerModel === undefined) {
    Ext.Logger.error('The configured ownerModel was not valid (you tried ' + ownerName + ')');
  }
  return ownerModel;
}, applyOwnerName:function(ownerName) {
  if (!ownerName) {
    ownerName = this.getOwnerModel().modelName;
  }
  ownerName = ownerName.slice(ownerName.lastIndexOf('.') + 1);
  return ownerName;
}, updateOwnerModel:function(ownerModel, oldOwnerModel) {
  if (oldOwnerModel) {
    this.setOwnerName(ownerModel.modelName);
  }
}, applyAssociatedModel:function(associatedName) {
  var associatedModel = Ext.data.ModelManager.types[associatedName];
  if (associatedModel === undefined) {
    Ext.Logger.error('The configured associatedModel was not valid (you tried ' + associatedName + ')');
  }
  return associatedModel;
}, applyAssociatedName:function(associatedName) {
  if (!associatedName) {
    associatedName = this.getAssociatedModel().modelName;
  }
  associatedName = associatedName.slice(associatedName.lastIndexOf('.') + 1);
  return associatedName;
}, updateAssociatedModel:function(associatedModel, oldAssociatedModel) {
  if (oldAssociatedModel) {
    this.setAssociatedName(associatedModel.modelName);
  }
}, applyReader:function(reader) {
  if (reader) {
    if (Ext.isString(reader)) {
      reader = {type:reader};
    }
    if (!reader.isReader) {
      Ext.applyIf(reader, {type:'json'});
    }
  }
  return Ext.factory(reader, Ext.data.Reader, this.getReader(), 'reader');
}, updateReader:function(reader) {
  reader.setModel(this.getAssociatedModel());
}}, 1, 0, 0, 0, 0, 0, [Ext.data.association, 'Association', Ext.data, 'Association'], 0);
Ext.cmd.derive('Ext.util.Inflector', Ext.Base, {singleton:true, plurals:[[/(quiz)$/i, '$1zes'], [/^(ox)$/i, '$1en'], [/([m|l])ouse$/i, '$1ice'], [/(matr|vert|ind)ix|ex$/i, '$1ices'], [/(x|ch|ss|sh)$/i, '$1es'], [/([^aeiouy]|qu)y$/i, '$1ies'], [/(hive)$/i, '$1s'], [/(?:([^f])fe|([lr])f)$/i, '$1$2ves'], [/sis$/i, 'ses'], [/([ti])um$/i, '$1a'], [/(buffal|tomat|potat)o$/i, '$1oes'], [/(bu)s$/i, '$1ses'], [/(alias|status|sex)$/i, '$1es'], [/(octop|vir)us$/i, '$1i'], [/(ax|test)is$/i, '$1es'], [/^person$/, 
'people'], [/^man$/, 'men'], [/^(child)$/, '$1ren'], [/s$/i, 's'], [/$/, 's']], singulars:[[/(quiz)zes$/i, '$1'], [/(matr)ices$/i, '$1ix'], [/(vert|ind)ices$/i, '$1ex'], [/^(ox)en/i, '$1'], [/(alias|status)es$/i, '$1'], [/(octop|vir)i$/i, '$1us'], [/(cris|ax|test)es$/i, '$1is'], [/(shoe)s$/i, '$1'], [/(o)es$/i, '$1'], [/(bus)es$/i, '$1'], [/([m|l])ice$/i, '$1ouse'], [/(x|ch|ss|sh)es$/i, '$1'], [/(m)ovies$/i, '$1ovie'], [/(s)eries$/i, '$1eries'], [/([^aeiouy]|qu)ies$/i, '$1y'], [/([lr])ves$/i, '$1f'], 
[/(tive)s$/i, '$1'], [/(hive)s$/i, '$1'], [/([^f])ves$/i, '$1fe'], [/(^analy)ses$/i, '$1sis'], [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i, '$1$2sis'], [/([ti])a$/i, '$1um'], [/(n)ews$/i, '$1ews'], [/people$/i, 'person'], [/s$/i, '']], uncountable:['sheep', 'fish', 'series', 'species', 'money', 'rice', 'information', 'equipment', 'grass', 'mud', 'offspring', 'deer', 'means'], singular:function(matcher, replacer) {
  this.singulars.unshift([matcher, replacer]);
}, plural:function(matcher, replacer) {
  this.plurals.unshift([matcher, replacer]);
}, clearSingulars:function() {
  this.singulars = [];
}, clearPlurals:function() {
  this.plurals = [];
}, isTransnumeral:function(word) {
  return Ext.Array.indexOf(this.uncountable, word) != -1;
}, pluralize:function(word) {
  if (this.isTransnumeral(word)) {
    return word;
  }
  var plurals = this.plurals, length = plurals.length, tuple, regex, i;
  for (i = 0; i < length; i++) {
    tuple = plurals[i];
    regex = tuple[0];
    if (regex == word || regex.test && regex.test(word)) {
      return word.replace(regex, tuple[1]);
    }
  }
  return word;
}, singularize:function(word) {
  if (this.isTransnumeral(word)) {
    return word;
  }
  var singulars = this.singulars, length = singulars.length, tuple, regex, i;
  for (i = 0; i < length; i++) {
    tuple = singulars[i];
    regex = tuple[0];
    if (regex == word || regex.test && regex.test(word)) {
      return word.replace(regex, tuple[1]);
    }
  }
  return word;
}, classify:function(word) {
  return Ext.String.capitalize(this.singularize(word));
}, ordinalize:function(number) {
  var parsed = parseInt(number, 10), mod10 = parsed % 10, mod100 = parsed % 100;
  if (11 <= mod100 && mod100 <= 13) {
    return number + 'th';
  } else {
    switch(mod10) {
      case 1:
        return number + 'st';
      case 2:
        return number + 'nd';
      case 3:
        return number + 'rd';
      default:
        return number + 'th';
    }
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Inflector'], function() {
  var irregulars = {alumnus:'alumni', cactus:'cacti', focus:'foci', nucleus:'nuclei', radius:'radii', stimulus:'stimuli', ellipsis:'ellipses', paralysis:'paralyses', oasis:'oases', appendix:'appendices', index:'indexes', beau:'beaux', bureau:'bureaux', tableau:'tableaux', woman:'women', child:'children', man:'men', corpus:'corpora', criterion:'criteria', curriculum:'curricula', genus:'genera', memorandum:'memoranda', phenomenon:'phenomena', foot:'feet', goose:'geese', tooth:'teeth', antenna:'antennae', 
  formula:'formulae', nebula:'nebulae', vertebra:'vertebrae', vita:'vitae'}, singular;
  for (singular in irregulars) {
    this.plural(singular, irregulars[singular]);
    this.singular(irregulars[singular], singular);
  }
});
Ext.cmd.derive('Ext.data.association.HasMany', Ext.data.association.Association, {alternateClassName:'Ext.data.HasManyAssociation', config:{foreignKey:undefined, store:undefined, storeName:undefined, filterProperty:null, autoLoad:false, autoSync:false}, constructor:function(config) {
  config = config || {};
  if (config.storeConfig) {
    config.store = config.storeConfig;
    delete config.storeConfig;
  }
  Ext.data.association.Association.prototype.constructor.call(this, config);
}, applyName:function(name) {
  if (!name) {
    name = Ext.util.Inflector.pluralize(this.getAssociatedName().toLowerCase());
  }
  return name;
}, applyStoreName:function(name) {
  if (!name) {
    name = this.getName() + 'Store';
  }
  return name;
}, applyForeignKey:function(foreignKey) {
  if (!foreignKey) {
    var inverse = this.getInverseAssociation();
    if (inverse) {
      foreignKey = inverse.getForeignKey();
    } else {
      foreignKey = this.getOwnerName().toLowerCase() + '_id';
    }
  }
  return foreignKey;
}, applyAssociationKey:function(associationKey) {
  if (!associationKey) {
    var associatedName = this.getAssociatedName();
    associationKey = Ext.util.Inflector.pluralize(associatedName[0].toLowerCase() + associatedName.slice(1));
  }
  return associationKey;
}, updateForeignKey:function(foreignKey, oldForeignKey) {
  var fields = this.getAssociatedModel().getFields(), field = fields.get(foreignKey);
  if (!field) {
    field = new Ext.data.Field({name:foreignKey});
    fields.add(field);
    fields.isDirty = true;
  }
  if (oldForeignKey) {
    field = fields.get(oldForeignKey);
    if (field) {
      fields.remove(field);
      fields.isDirty = true;
    }
  }
}, applyStore:function(storeConfig) {
  var me = this, associatedModel = me.getAssociatedModel(), storeName = me.getStoreName(), foreignKey = me.getForeignKey(), primaryKey = me.getPrimaryKey(), filterProperty = me.getFilterProperty(), autoLoad = me.getAutoLoad(), autoSync = me.getAutoSync();
  return function() {
    var record = this, config, filter, store, modelDefaults = {}, listeners = {addrecords:me.onAddRecords, removerecords:me.onRemoveRecords, scope:me};
    if (record[storeName] === undefined) {
      if (filterProperty) {
        filter = {property:filterProperty, value:record.get(filterProperty), exactMatch:true};
      } else {
        filter = {property:foreignKey, value:record.get(primaryKey), exactMatch:true};
      }
      modelDefaults[foreignKey] = record.get(primaryKey);
      config = Ext.apply({}, storeConfig, {model:associatedModel, filters:[filter], remoteFilter:true, autoSync:autoSync, modelDefaults:modelDefaults});
      store = record[storeName] = Ext.create('Ext.data.Store', config);
      store.boundTo = record;
      store.onAfter(listeners);
      if (autoLoad) {
        record[storeName].load();
      }
    }
    return record[storeName];
  };
}, onAddRecords:function(store, records) {
  var ln = records.length, id = store.boundTo.getId(), i, record;
  for (i = 0; i < ln; i++) {
    record = records[i];
    record.set(this.getForeignKey(), id);
  }
  this.updateInverseInstances(store.boundTo);
}, onRemoveRecords:function(store, records) {
  var ln = records.length, i, record;
  for (i = 0; i < ln; i++) {
    record = records[i];
    record.set(this.getForeignKey(), null);
  }
}, updateStore:function(store) {
  this.getOwnerModel().prototype[this.getName()] = store;
}, read:function(record, reader, associationData) {
  var store = record[this.getName()](), records = reader.read(associationData).getRecords();
  store.add(records);
}, updateInverseInstances:function(record) {
  var store = record[this.getName()](), inverse = this.getInverseAssociation();
  if (inverse) {
    store.each(function(associatedRecord) {
      associatedRecord[inverse.getInstanceName()] = record;
    });
  }
}, getInverseAssociation:function() {
  var ownerName = this.getOwnerModel().modelName;
  return this.getAssociatedModel().associations.findBy(function(assoc) {
    return assoc.getType().toLowerCase() === 'belongsto' && assoc.getAssociatedModel().modelName === ownerName;
  });
}}, 1, 0, 0, 0, ['association.hasmany'], 0, [Ext.data.association, 'HasMany', Ext.data, 'HasManyAssociation'], 0);
Ext.cmd.derive('Ext.data.association.BelongsTo', Ext.data.association.Association, {alternateClassName:'Ext.data.BelongsToAssociation', config:{foreignKey:undefined, getterName:undefined, setterName:undefined, instanceName:undefined}, applyForeignKey:function(foreignKey) {
  if (!foreignKey) {
    foreignKey = this.getAssociatedName().toLowerCase() + '_id';
  }
  return foreignKey;
}, updateForeignKey:function(foreignKey, oldForeignKey) {
  var fields = this.getOwnerModel().getFields(), field = fields.get(foreignKey);
  if (!field) {
    field = new Ext.data.Field({name:foreignKey});
    fields.add(field);
    fields.isDirty = true;
  }
  if (oldForeignKey) {
    field = fields.get(oldForeignKey);
    if (field) {
      fields.isDirty = true;
      fields.remove(field);
    }
  }
}, applyInstanceName:function(instanceName) {
  if (!instanceName) {
    instanceName = this.getAssociatedName() + 'BelongsToInstance';
  }
  return instanceName;
}, applyAssociationKey:function(associationKey) {
  if (!associationKey) {
    var associatedName = this.getAssociatedName();
    associationKey = associatedName[0].toLowerCase() + associatedName.slice(1);
  }
  return associationKey;
}, applyGetterName:function(getterName) {
  if (!getterName) {
    var associatedName = this.getAssociatedName();
    getterName = 'get' + associatedName[0].toUpperCase() + associatedName.slice(1);
  }
  return getterName;
}, applySetterName:function(setterName) {
  if (!setterName) {
    var associatedName = this.getAssociatedName();
    setterName = 'set' + associatedName[0].toUpperCase() + associatedName.slice(1);
  }
  return setterName;
}, updateGetterName:function(getterName, oldGetterName) {
  var ownerProto = this.getOwnerModel().prototype;
  if (oldGetterName) {
    delete ownerProto[oldGetterName];
  }
  if (getterName) {
    ownerProto[getterName] = this.createGetter();
  }
}, updateSetterName:function(setterName, oldSetterName) {
  var ownerProto = this.getOwnerModel().prototype;
  if (oldSetterName) {
    delete ownerProto[oldSetterName];
  }
  if (setterName) {
    ownerProto[setterName] = this.createSetter();
  }
}, createSetter:function() {
  var me = this, foreignKey = me.getForeignKey(), associatedModel = me.getAssociatedModel(), currentOwner, newOwner, store;
  return function(value, options, scope) {
    var inverse = me.getInverseAssociation(), record = this;
    if (value && value.isModel) {
      value = value.getId();
    }
    if (Ext.isFunction(options)) {
      options = {callback:options, scope:scope || record};
    }
    delete record[me.getInstanceName()];
    currentOwner = Ext.data.Model.cache[Ext.data.Model.generateCacheId(associatedModel.modelName, this.get(foreignKey))];
    newOwner = Ext.data.Model.cache[Ext.data.Model.generateCacheId(associatedModel.modelName, value)];
    record.set(foreignKey, value);
    if (inverse) {
      if (newOwner) {
        if (inverse.getType().toLowerCase() === 'hasmany') {
          store = newOwner[inverse.getName()]();
          store.add(record);
        } else {
          newOwner[inverse.getInstanceName()] = record;
        }
      }
      if (currentOwner) {
        if (inverse.getType().toLowerCase() === 'hasmany') {
          store = currentOwner[inverse.getName()]();
          store.remove(record);
        } else {
          delete value[inverse.getInstanceName()];
        }
      }
    }
    if (newOwner) {
      record[me.getInstanceName()] = newOwner;
    }
    if (Ext.isObject(options)) {
      return record.save(options);
    }
    return record;
  };
}, createGetter:function() {
  var me = this, associatedModel = me.getAssociatedModel(), foreignKey = me.getForeignKey(), instanceName = me.getInstanceName();
  return function(options, scope) {
    options = options || {};
    var model = this, foreignKeyId = model.get(foreignKey), success, instance, args;
    instance = model[instanceName];
    if (!instance) {
      instance = Ext.data.Model.cache[Ext.data.Model.generateCacheId(associatedModel.modelName, foreignKeyId)];
      if (instance) {
        model[instanceName] = instance;
      }
    }
    if (options.reload === true || instance === undefined) {
      if (typeof options == 'function') {
        options = {callback:options, scope:scope || model};
      }
      success = options.success;
      options.success = function(rec) {
        model[instanceName] = rec;
        if (success) {
          success.apply(this, arguments);
        }
      };
      associatedModel.load(foreignKeyId, options);
    } else {
      args = [instance];
      scope = scope || model;
      Ext.callback(options, scope, args);
      Ext.callback(options.success, scope, args);
      Ext.callback(options.failure, scope, args);
      Ext.callback(options.callback, scope, args);
      return instance;
    }
  };
}, read:function(record, reader, associationData) {
  record[this.getInstanceName()] = reader.read([associationData]).getRecords()[0];
}, getInverseAssociation:function() {
  var ownerName = this.getOwnerModel().modelName, foreignKey = this.getForeignKey();
  return this.getAssociatedModel().associations.findBy(function(assoc) {
    var type = assoc.getType().toLowerCase();
    return (type === 'hasmany' || type === 'hasone') && assoc.getAssociatedModel().modelName === ownerName && assoc.getForeignKey() === foreignKey;
  });
}}, 0, 0, 0, 0, ['association.belongsto'], 0, [Ext.data.association, 'BelongsTo', Ext.data, 'BelongsToAssociation'], 0);
Ext.cmd.derive('Ext.data.association.HasOne', Ext.data.association.Association, {alternateClassName:'Ext.data.HasOneAssociation', config:{foreignKey:undefined, getterName:undefined, setterName:undefined, instanceName:undefined}, applyForeignKey:function(foreignKey) {
  if (!foreignKey) {
    var inverse = this.getInverseAssociation();
    if (inverse) {
      foreignKey = inverse.getForeignKey();
    } else {
      foreignKey = this.getAssociatedName().toLowerCase() + '_id';
    }
  }
  return foreignKey;
}, updateForeignKey:function(foreignKey, oldForeignKey) {
  var fields = this.getOwnerModel().getFields(), field = fields.get(foreignKey);
  if (!field) {
    field = new Ext.data.Field({name:foreignKey});
    fields.add(field);
    fields.isDirty = true;
  }
  if (oldForeignKey) {
    field = fields.get(oldForeignKey);
    if (field) {
      fields.remove(field);
      fields.isDirty = true;
    }
  }
}, applyInstanceName:function(instanceName) {
  if (!instanceName) {
    instanceName = this.getAssociatedName() + 'HasOneInstance';
  }
  return instanceName;
}, applyAssociationKey:function(associationKey) {
  if (!associationKey) {
    var associatedName = this.getAssociatedName();
    associationKey = associatedName[0].toLowerCase() + associatedName.slice(1);
  }
  return associationKey;
}, applyGetterName:function(getterName) {
  if (!getterName) {
    var associatedName = this.getAssociatedName();
    getterName = 'get' + associatedName[0].toUpperCase() + associatedName.slice(1);
  }
  return getterName;
}, applySetterName:function(setterName) {
  if (!setterName) {
    var associatedName = this.getAssociatedName();
    setterName = 'set' + associatedName[0].toUpperCase() + associatedName.slice(1);
  }
  return setterName;
}, updateGetterName:function(getterName, oldGetterName) {
  var ownerProto = this.getOwnerModel().prototype;
  if (oldGetterName) {
    delete ownerProto[oldGetterName];
  }
  if (getterName) {
    ownerProto[getterName] = this.createGetter();
  }
}, updateSetterName:function(setterName, oldSetterName) {
  var ownerProto = this.getOwnerModel().prototype;
  if (oldSetterName) {
    delete ownerProto[oldSetterName];
  }
  if (setterName) {
    ownerProto[setterName] = this.createSetter();
  }
}, createSetter:function() {
  var me = this, foreignKey = me.getForeignKey(), instanceName = me.getInstanceName(), associatedModel = me.getAssociatedModel();
  return function(value, options, scope) {
    var Model = Ext.data.Model, record;
    if (value && value.isModel) {
      value = value.getId();
    }
    this.set(foreignKey, value);
    if (value || value === 0) {
      record = Model.cache[Model.generateCacheId(associatedModel.modelName, value)];
      if (record) {
        this[instanceName] = record;
      }
    } else {
      delete this[instanceName];
    }
    if (Ext.isFunction(options)) {
      options = {callback:options, scope:scope || this};
    }
    if (Ext.isObject(options)) {
      return this.save(options);
    }
    return this;
  };
}, createGetter:function() {
  var me = this, associatedModel = me.getAssociatedModel(), foreignKey = me.getForeignKey(), instanceName = me.getInstanceName();
  return function(options, scope) {
    options = options || {};
    var model = this, foreignKeyId = model.get(foreignKey), success, instance, args;
    if (options.reload === true || model[instanceName] === undefined) {
      if (typeof options == 'function') {
        options = {callback:options, scope:scope || model};
      }
      success = options.success;
      options.success = function(rec) {
        model[instanceName] = rec;
        if (success) {
          success.apply(this, arguments);
        }
      };
      associatedModel.load(foreignKeyId, options);
    } else {
      instance = model[instanceName];
      args = [instance];
      scope = scope || model;
      Ext.callback(options, scope, args);
      Ext.callback(options.success, scope, args);
      Ext.callback(options.failure, scope, args);
      Ext.callback(options.callback, scope, args);
      return instance;
    }
  };
}, read:function(record, reader, associationData) {
  var inverse = this.getInverseAssociation(), newRecord = reader.read([associationData]).getRecords()[0];
  record[this.getSetterName()].call(record, newRecord);
  if (inverse) {
    newRecord[inverse.getInstanceName()] = record;
  }
}, getInverseAssociation:function() {
  var ownerName = this.getOwnerModel().modelName;
  return this.getAssociatedModel().associations.findBy(function(assoc) {
    return assoc.getType().toLowerCase() === 'belongsto' && assoc.getAssociatedModel().modelName === ownerName;
  });
}}, 0, 0, 0, 0, ['association.hasone'], 0, [Ext.data.association, 'HasOne', Ext.data, 'HasOneAssociation'], 0);
Ext.cmd.derive('Ext.data.Error', Ext.Base, {config:{field:null, message:''}, constructor:function(config) {
  this.initConfig(config);
}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'Error'], 0);
Ext.cmd.derive('Ext.data.Errors', Ext.util.Collection, {isValid:function() {
  return this.length === 0;
}, getByField:function(fieldName) {
  var errors = [], error, i;
  for (i = 0; i < this.length; i++) {
    error = this.items[i];
    if (error.getField() == fieldName) {
      errors.push(error);
    }
  }
  return errors;
}, add:function() {
  var obj = arguments.length == 1 ? arguments[0] : arguments[1];
  if (!(obj instanceof Ext.data.Error)) {
    obj = Ext.create('Ext.data.Error', {field:obj.field || obj.name, message:obj.error || obj.message});
  }
  return Ext.util.Collection.prototype.add.call(this, obj);
}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'Errors'], 0);
Ext.cmd.derive('Ext.data.Model', Ext.Base, {alternateClassName:'Ext.data.Record', isModel:true, config:{idProperty:'id', data:null, fields:undefined, validations:null, associations:null, hasMany:null, hasOne:null, belongsTo:null, proxy:null, identifier:{type:'simple'}, clientIdProperty:'clientId', isErased:false, useCache:true}, staticConfigs:['idProperty', 'fields', 'validations', 'associations', 'hasMany', 'hasOne', 'belongsTo', 'clientIdProperty', 'identifier', 'useCache', 'proxy'], statics:{EDIT:'edit', 
REJECT:'reject', COMMIT:'commit', cache:{}, generateProxyMethod:function(name) {
  return function() {
    var prototype = this.prototype;
    return prototype[name].apply(prototype, arguments);
  };
}, generateCacheId:function(record, id) {
  var modelName;
  if (record && record.isModel) {
    modelName = record.modelName;
    if (id === undefined) {
      id = record.getId();
    }
  } else {
    modelName = record;
  }
  return modelName.replace(/\./g, '-').toLowerCase() + '-' + id;
}}, inheritableStatics:{load:function(id, config, scope) {
  var proxy = this.getProxy(), idProperty = this.getIdProperty(), record = null, params = {}, callback, operation;
  scope = scope || config && config.scope || this;
  if (Ext.isFunction(config)) {
    config = {callback:config, scope:scope};
  }
  params[idProperty] = id;
  config = Ext.apply({}, config);
  config = Ext.applyIf(config, {action:'read', params:params, model:this});
  operation = Ext.create('Ext.data.Operation', config);
  if (!proxy) {
    Ext.Logger.error("You are trying to load a model that doesn't have a Proxy specified");
  }
  callback = function(operation) {
    if (operation.wasSuccessful()) {
      record = operation.getRecords()[0] || null;
      Ext.callback(config.success, scope, [record, operation]);
    } else {
      Ext.callback(config.failure, scope, [record, operation]);
    }
    Ext.callback(config.callback, scope, [record, operation]);
  };
  proxy.read(operation, callback, this);
}}, editing:false, dirty:false, phantom:false, constructor:function(data, id, raw, convertedData) {
  var me = this, cached = null, useCache = me.getUseCache(), idProperty = me.getIdProperty();
  data = data || convertedData || {};
  if (id || id === 0) {
    data[idProperty] = me.internalId = id;
  }
  id = data[idProperty];
  if (useCache && (id || id === 0)) {
    cached = Ext.data.Model.cache[Ext.data.Model.generateCacheId(this, id)];
    if (cached) {
      cached.raw = raw || cached.raw;
      return cached.mergeData(convertedData || data || {});
    }
  }
  me.modified = {};
  me.raw = raw || data || {};
  me.stores = [];
  if (convertedData) {
    me.setConvertedData(data);
  } else {
    me.setData(data);
  }
  me.id = me.getIdentifier().generate(me);
  id = me.data[idProperty];
  if (!id && id !== 0) {
    me.data[idProperty] = me.internalId = me.id;
    me.phantom = true;
    if (this.associations.length) {
      this.handleInlineAssociationData(data);
    }
  } else {
    this.internalId = id;
  }
  if (useCache) {
    Ext.data.Model.cache[Ext.data.Model.generateCacheId(me)] = me;
  }
  if (this.init && typeof this.init == 'function') {
    this.init();
  }
}, mergeData:function(rawData) {
  var me = this, fields = me.getFields().items, ln = fields.length, modified = me.modified, modifiedFieldNames = [], data = me.data, i, field, fieldName, value, id;
  for (i = 0; i < ln; i++) {
    field = fields[i];
    fieldName = field._name;
    value = rawData[fieldName];
    if (value !== undefined && !modified.hasOwnProperty(fieldName)) {
      if (field._convert) {
        value = field._convert(value, me);
      }
      if (data[fieldName] !== value) {
        if (modifiedFieldNames.length === 0 && !me.editing) {
          this.beginEdit();
        }
        modifiedFieldNames.push(fieldName);
      }
      data[fieldName] = value;
    } else {
      if (Ext.isFunction(field._convert)) {
        value = field._convert(value, me);
        data[fieldName] = value;
      }
    }
  }
  if (me.associations.length) {
    me.handleInlineAssociationData(rawData);
  }
  if (modifiedFieldNames.length > 0 && me.editing) {
    this.endEdit(false, modifiedFieldNames);
  }
  return this;
}, setData:function(rawData) {
  var me = this, fields = me.fields.items, ln = fields.length, isArray = Ext.isArray(rawData), data = me._data = me.data = {}, i, field, name, value, convert, id;
  if (!rawData) {
    return me;
  }
  for (i = 0; i < ln; i++) {
    field = fields[i];
    name = field._name;
    convert = field._convert;
    if (isArray) {
      value = rawData[i];
    } else {
      value = rawData[name];
      if (typeof value == 'undefined') {
        value = field._defaultValue;
      }
    }
    if (convert) {
      value = field._convert(value, me);
    }
    data[name] = value;
  }
  id = me.getId();
  if (me.associations.length && (id || id === 0)) {
    me.handleInlineAssociationData(rawData);
  }
  return me;
}, handleInlineAssociationData:function(data) {
  var associations = this.associations.items, ln = associations.length, i, association, associationData, reader, proxy, associationKey;
  data = Ext.apply({}, data, this.raw);
  for (i = 0; i < ln; i++) {
    association = associations[i];
    associationKey = association.getAssociationKey();
    associationData = data[associationKey];
    if (associationData) {
      reader = association.getReader();
      if (!reader) {
        proxy = association.getAssociatedModel().getProxy();
        if (proxy) {
          reader = proxy.getReader();
        } else {
          reader = new Ext.data.JsonReader({model:association.getAssociatedModel()});
        }
      }
      association.read(this, reader, associationData);
    }
  }
}, setId:function(id) {
  var currentId = this.getId();
  this.set(this.getIdProperty(), id);
  this.internalId = id;
  if (this.getUseCache()) {
    delete Ext.data.Model.cache[Ext.data.Model.generateCacheId(this, currentId)];
    Ext.data.Model.cache[Ext.data.Model.generateCacheId(this)] = this;
  }
}, getId:function() {
  return this.get(this.getIdProperty());
}, setConvertedData:function(data) {
  this._data = this.data = data;
  return this;
}, get:function(fieldName) {
  return this.data[fieldName];
}, set:function(fieldName, value) {
  var me = this, fieldMap = me.fields.map, modified = me.modified, notEditing = !me.editing, modifiedCount = 0, modifiedFieldNames = [], field, key, i, currentValue, ln, convert;
  if (arguments.length == 1) {
    for (key in fieldName) {
      if (fieldName.hasOwnProperty(key)) {
        field = fieldMap[key];
        if (field && field.hasCustomConvert()) {
          modifiedFieldNames.push(key);
          continue;
        }
        if (!modifiedCount && notEditing) {
          me.beginEdit();
        }
        ++modifiedCount;
        me.set(key, fieldName[key]);
      }
    }
    ln = modifiedFieldNames.length;
    if (ln) {
      if (!modifiedCount && notEditing) {
        me.beginEdit();
      }
      modifiedCount += ln;
      for (i = 0; i < ln; i++) {
        field = modifiedFieldNames[i];
        me.set(field, fieldName[field]);
      }
    }
    if (notEditing && modifiedCount) {
      me.endEdit(false, modifiedFieldNames);
    }
  } else {
    if (modified) {
      field = fieldMap[fieldName];
      convert = field && field.getConvert();
      if (convert) {
        value = convert.call(field, value, me);
      }
      currentValue = me.data[fieldName];
      me.data[fieldName] = value;
      if (field && !me.isEqual(currentValue, value)) {
        if (modified.hasOwnProperty(fieldName)) {
          if (me.isEqual(modified[fieldName], value)) {
            delete modified[fieldName];
            me.dirty = false;
            for (key in modified) {
              if (modified.hasOwnProperty(key)) {
                me.dirty = true;
                break;
              }
            }
          }
        } else {
          me.dirty = true;
          modified[fieldName] = currentValue;
        }
      }
      if (notEditing) {
        me.afterEdit([fieldName], modified);
      }
    }
  }
}, isEqual:function(a, b) {
  if (Ext.isDate(a) && Ext.isDate(b)) {
    return a.getTime() === b.getTime();
  }
  return a === b;
}, beginEdit:function() {
  var me = this;
  if (!me.editing) {
    me.editing = true;
    me.dirtySave = me.dirty;
    me.dataSave = Ext.apply({}, me.data);
    me.modifiedSave = Ext.apply({}, me.modified);
  }
}, cancelEdit:function() {
  var me = this;
  if (me.editing) {
    me.editing = false;
    me.modified = me.modifiedSave;
    me.data = me.dataSave;
    me.dirty = me.dirtySave;
    delete me.modifiedSave;
    delete me.dataSave;
    delete me.dirtySave;
  }
}, endEdit:function(silent, modifiedFieldNames) {
  var me = this;
  if (me.editing) {
    me.editing = false;
    if (silent !== true && me.changedWhileEditing()) {
      me.afterEdit(modifiedFieldNames || Ext.Object.getKeys(this.modified), this.modified);
    }
    delete me.modifiedSave;
    delete me.dataSave;
    delete me.dirtySave;
  }
}, changedWhileEditing:function() {
  var me = this, saved = me.dataSave, data = me.data, key;
  for (key in data) {
    if (data.hasOwnProperty(key)) {
      if (!me.isEqual(data[key], saved[key])) {
        return true;
      }
    }
  }
  return false;
}, getChanges:function() {
  var modified = this.modified, changes = {}, field;
  for (field in modified) {
    if (modified.hasOwnProperty(field)) {
      changes[field] = this.get(field);
    }
  }
  return changes;
}, isModified:function(fieldName) {
  return this.modified.hasOwnProperty(fieldName);
}, save:function(options, scope) {
  var me = this, action = me.phantom ? 'create' : 'update', proxy = me.getProxy(), operation, callback;
  if (!proxy) {
    Ext.Logger.error("You are trying to save a model instance that doesn't have a Proxy specified");
  }
  options = options || {};
  scope = scope || me;
  if (Ext.isFunction(options)) {
    options = {callback:options, scope:scope};
  }
  Ext.applyIf(options, {records:[me], action:action, model:me.self});
  operation = Ext.create('Ext.data.Operation', options);
  callback = function(operation) {
    if (operation.wasSuccessful()) {
      Ext.callback(options.success, scope, [me, operation]);
    } else {
      Ext.callback(options.failure, scope, [me, operation]);
    }
    Ext.callback(options.callback, scope, [me, operation]);
  };
  proxy[action](operation, callback, me);
  return me;
}, erase:function(options, scope) {
  var me = this, proxy = this.getProxy(), operation, callback;
  if (!proxy) {
    Ext.Logger.error("You are trying to erase a model instance that doesn't have a Proxy specified");
  }
  options = options || {};
  scope = scope || me;
  if (Ext.isFunction(options)) {
    options = {callback:options, scope:scope};
  }
  Ext.applyIf(options, {records:[me], action:'destroy', model:this.self});
  operation = Ext.create('Ext.data.Operation', options);
  callback = function(operation) {
    if (operation.wasSuccessful()) {
      Ext.callback(options.success, scope, [me, operation]);
    } else {
      Ext.callback(options.failure, scope, [me, operation]);
    }
    Ext.callback(options.callback, scope, [me, operation]);
  };
  proxy.destroy(operation, callback, me);
  return me;
}, reject:function(silent) {
  var me = this, modified = me.modified, field;
  for (field in modified) {
    if (modified.hasOwnProperty(field)) {
      if (typeof modified[field] != 'function') {
        me.data[field] = modified[field];
      }
    }
  }
  me.dirty = false;
  me.editing = false;
  me.modified = {};
  if (silent !== true) {
    me.afterReject();
  }
}, commit:function(silent) {
  var me = this, modified = this.modified;
  me.phantom = me.dirty = me.editing = false;
  me.modified = {};
  if (silent !== true) {
    me.afterCommit(modified);
  }
}, afterEdit:function(modifiedFieldNames, modified) {
  this.notifyStores('afterEdit', modifiedFieldNames, modified);
}, afterReject:function() {
  this.notifyStores('afterReject');
}, afterCommit:function(modified) {
  this.notifyStores('afterCommit', Ext.Object.getKeys(modified || {}), modified);
}, notifyStores:function(fn) {
  var args = Ext.Array.clone(arguments), stores = this.stores;
  if (Ext.isArray(stores)) {
    var ln = stores.length, i, store;
    args[0] = this;
    for (i = 0; i < ln; ++i) {
      store = stores[i];
      if (store !== undefined && typeof store[fn] == 'function') {
        store[fn].apply(store, args);
      }
    }
  }
}, copy:function(newId) {
  var me = this, idProperty = me.getIdProperty(), raw = Ext.apply({}, me.raw), data = Ext.apply({}, me.data);
  delete raw[idProperty];
  delete data[idProperty];
  return new me.self(null, newId, raw, data);
}, getData:function(includeAssociated) {
  var data = this.data;
  if (includeAssociated === true) {
    Ext.apply(data, this.getAssociatedData());
  }
  return data;
}, getAssociatedData:function() {
  return this.prepareAssociatedData(this, [], null);
}, prepareAssociatedData:function(record, ids, associationType) {
  var associations = record.associations.items, associationCount = associations.length, associationData = {}, recursiveAssociationQueue = [], associatedStore, associationName, associatedRecords, associatedRecord, associatedRecordCount, association, id, i, j, type, allow, recursiveAssociationItem;
  for (i = 0; i < associationCount; i++) {
    association = associations[i];
    associationName = association.getName();
    type = association.getType();
    allow = true;
    if (associationType) {
      allow = type == associationType;
    }
    if (allow && type.toLowerCase() == 'hasmany') {
      associatedStore = record[association.getStoreName()];
      associationData[associationName] = [];
      if (associatedStore && associatedStore.getCount() > 0) {
        associatedRecords = associatedStore.data.items;
        associatedRecordCount = associatedRecords.length;
        recursiveAssociationQueue.length = 0;
        for (j = 0; j < associatedRecordCount; j++) {
          associatedRecord = associatedRecords[j];
          id = associatedRecord.id;
          if (Ext.Array.indexOf(ids, id) == -1) {
            ids.push(id);
            associationData[associationName][j] = associatedRecord.getData();
            recursiveAssociationQueue.push({associationName:associationName, j:j, associatedRecord:associatedRecord, ids:ids, associationType:associationType});
          }
        }
        while (recursiveAssociationQueue.length > 0) {
          recursiveAssociationItem = recursiveAssociationQueue.shift();
          Ext.apply(associationData[recursiveAssociationItem.associationName][recursiveAssociationItem.j], this.prepareAssociatedData(recursiveAssociationItem.associatedRecord, recursiveAssociationItem.ids, recursiveAssociationItem.associationType));
        }
      }
    } else {
      if (allow && (type.toLowerCase() == 'belongsto' || type.toLowerCase() == 'hasone')) {
        associatedRecord = record[association.getInstanceName()];
        if (associatedRecord !== undefined) {
          id = associatedRecord.id;
          if (Ext.Array.indexOf(ids, id) === -1) {
            ids.push(id);
            associationData[associationName] = associatedRecord.getData();
            Ext.apply(associationData[associationName], this.prepareAssociatedData(associatedRecord, ids, associationType));
          }
        }
      }
    }
  }
  return associationData;
}, join:function(store) {
  Ext.Array.include(this.stores, store);
}, unjoin:function(store) {
  Ext.Array.remove(this.stores, store);
}, setDirty:function() {
  var me = this, name;
  me.dirty = true;
  me.fields.each(function(field) {
    if (field.getPersist()) {
      name = field.getName();
      me.modified[name] = me.get(name);
    }
  });
}, validate:function() {
  var errors = Ext.create('Ext.data.Errors'), validations = this.getValidations().items, validators = Ext.data.Validations, length, validation, field, valid, type, i;
  if (validations) {
    length = validations.length;
    for (i = 0; i < length; i++) {
      validation = validations[i];
      field = validation.field || validation.name;
      type = validation.type;
      valid = validators[type](validation, this.get(field));
      if (!valid) {
        errors.add(Ext.create('Ext.data.Error', {field:field, message:validation.message || validators.getMessage(type)}));
      }
    }
  }
  return errors;
}, isValid:function() {
  return this.validate().isValid();
}, toUrl:function() {
  var pieces = this.$className.split('.'), name = pieces[pieces.length - 1].toLowerCase();
  return name + '/' + this.getId();
}, destroy:function() {
  var me = this;
  me.notifyStores('afterErase', me);
  if (me.getUseCache()) {
    delete Ext.data.Model.cache[Ext.data.Model.generateCacheId(me)];
  }
  me.raw = me.stores = me.modified = null;
  me.callParent(arguments);
}, applyProxy:function(proxy, currentProxy) {
  return Ext.factory(proxy, Ext.data.Proxy, currentProxy, 'proxy');
}, updateProxy:function(proxy) {
  if (proxy) {
    proxy.setModel(this.self);
  }
}, applyAssociations:function(associations) {
  if (associations) {
    this.addAssociations(associations, 'hasMany');
  }
}, applyBelongsTo:function(belongsTo) {
  if (belongsTo) {
    this.addAssociations(belongsTo, 'belongsTo');
  }
}, applyHasMany:function(hasMany) {
  if (hasMany) {
    this.addAssociations(hasMany, 'hasMany');
  }
}, applyHasOne:function(hasOne) {
  if (hasOne) {
    this.addAssociations(hasOne, 'hasOne');
  }
}, addAssociations:function(associations, defaultType) {
  var ln, i, association, name = this.self.modelName, associationsCollection = this.self.associations, onCreatedFn;
  associations = Ext.Array.from(associations);
  for (i = 0, ln = associations.length; i < ln; i++) {
    association = associations[i];
    if (!Ext.isObject(association)) {
      association = {model:association};
    }
    Ext.applyIf(association, {type:defaultType, ownerModel:name, associatedModel:association.model});
    delete association.model;
    onCreatedFn = Ext.Function.bind(function(associationName) {
      associationsCollection.add(Ext.data.association.Association.create(this));
    }, association);
    Ext.ClassManager.onCreated(onCreatedFn, this, typeof association.associatedModel === 'string' ? association.associatedModel : Ext.getClassName(association.associatedModel));
  }
}, applyValidations:function(validations) {
  if (validations) {
    if (!Ext.isArray(validations)) {
      validations = [validations];
    }
    this.addValidations(validations);
  }
}, addValidations:function(validations) {
  this.self.validations.addAll(validations);
}, applyFields:function(fields) {
  var superFields = this.superclass.fields;
  if (superFields) {
    fields = superFields.items.concat(fields || []);
  }
  return fields || [];
}, updateFields:function(fields) {
  var ln = fields.length, me = this, prototype = me.self.prototype, idProperty = this.getIdProperty(), idField, fieldsCollection, field, i;
  fieldsCollection = me._fields = me.fields = new Ext.util.Collection(prototype.getFieldName);
  for (i = 0; i < ln; i++) {
    field = fields[i];
    if (!field.isField) {
      field = new Ext.data.Field(fields[i]);
    }
    fieldsCollection.add(field);
  }
  idField = fieldsCollection.get(idProperty);
  if (!idField) {
    fieldsCollection.add(new Ext.data.Field(idProperty));
  } else {
    idField.setType('auto');
  }
  fieldsCollection.addSorter(prototype.sortConvertFields);
}, applyIdentifier:function(identifier) {
  if (typeof identifier === 'string') {
    identifier = {type:identifier};
  }
  return Ext.factory(identifier, Ext.data.identifier.Simple, this.getIdentifier(), 'data.identifier');
}, getFieldName:function(field) {
  return field.getName();
}, sortConvertFields:function(field1, field2) {
  var f1SpecialConvert = field1.hasCustomConvert(), f2SpecialConvert = field2.hasCustomConvert();
  if (f1SpecialConvert && !f2SpecialConvert) {
    return 1;
  }
  if (!f1SpecialConvert && f2SpecialConvert) {
    return -1;
  }
  return 0;
}, onClassExtended:function(cls, data, hooks) {
  var onBeforeClassCreated = hooks.onBeforeCreated, Model = this, prototype = Model.prototype, configNameCache = Ext.Class.configNameCache, staticConfigs = prototype.staticConfigs.concat(data.staticConfigs || []), defaultConfig = prototype.config, config = data.config || {}, key;
  data.config = config;
  hooks.onBeforeCreated = function(cls, data) {
    var dependencies = [], prototype = cls.prototype, statics = {}, config = prototype.config, staticConfigsLn = staticConfigs.length, copyMethods = ['set', 'get'], copyMethodsLn = copyMethods.length, associations = config.associations || [], name = Ext.getClassName(cls), key, methodName, i, j, ln;
    for (i = 0; i < staticConfigsLn; i++) {
      key = staticConfigs[i];
      for (j = 0; j < copyMethodsLn; j++) {
        methodName = configNameCache[key][copyMethods[j]];
        if (methodName in prototype) {
          statics[methodName] = Model.generateProxyMethod(methodName);
        }
      }
    }
    cls.addStatics(statics);
    cls.modelName = name;
    prototype.modelName = name;
    if (config.belongsTo) {
      dependencies.push('association.belongsto');
    }
    if (config.hasMany) {
      dependencies.push('association.hasmany');
    }
    if (config.hasOne) {
      dependencies.push('association.hasone');
    }
    for (i = 0, ln = associations.length; i < ln; ++i) {
      dependencies.push('association.' + associations[i].type.toLowerCase());
    }
    if (config.identifier) {
      if (typeof config.identifier === 'string') {
        dependencies.push('data.identifier.' + config.identifier);
      } else {
        if (typeof config.identifier.type === 'string') {
          dependencies.push('data.identifier.' + config.identifier.type);
        }
      }
    }
    if (config.proxy) {
      if (typeof config.proxy === 'string') {
        dependencies.push('proxy.' + config.proxy);
      } else {
        if (typeof config.proxy.type === 'string') {
          dependencies.push('proxy.' + config.proxy.type);
        }
      }
    }
    if (config.validations) {
      dependencies.push('Ext.data.Validations');
    }
    Ext.require(dependencies, function() {
      Ext.Function.interceptBefore(hooks, 'onCreated', function() {
        Ext.data.ModelManager.registerType(name, cls);
        var superCls = cls.prototype.superclass;
        cls.prototype.associations = cls.associations = cls.prototype._associations = superCls && superCls.associations ? superCls.associations.clone() : new Ext.util.Collection(function(association) {
          return association.getName();
        });
        cls.prototype.validations = cls.validations = cls.prototype._validations = superCls && superCls.validations ? superCls.validations.clone() : new Ext.util.Collection(function(validation) {
          return validation.field ? validation.field + '-' + validation.type : validation.name + '-' + validation.type;
        });
        cls.prototype = Ext.Object.chain(cls.prototype);
        cls.prototype.initConfig.call(cls.prototype, config);
        delete cls.prototype.initConfig;
      });
      onBeforeClassCreated.call(Model, cls, data, hooks);
    });
  };
}}, 1, 0, 0, 0, 0, [['observable', Ext.mixin.Observable]], [Ext.data, 'Model', Ext.data, 'Record'], 0);
Ext.cmd.derive('Ext.data.StoreManager', Ext.util.Collection, {alternateClassName:['Ext.StoreMgr', 'Ext.data.StoreMgr', 'Ext.StoreManager'], singleton:true, register:function() {
  for (var i = 0, s; s = arguments[i]; i++) {
    this.add(s);
  }
}, unregister:function() {
  for (var i = 0, s; s = arguments[i]; i++) {
    this.remove(this.lookup(s));
  }
}, lookup:function(store) {
  if (Ext.isArray(store)) {
    var fields = ['field1'], expand = !Ext.isArray(store[0]), data = store, i, len;
    if (expand) {
      data = [];
      for (i = 0, len = store.length; i < len; ++i) {
        data.push([store[i]]);
      }
    } else {
      for (i = 2, len = store[0].length; i <= len; ++i) {
        fields.push('field' + i);
      }
    }
    return Ext.create('Ext.data.ArrayStore', {data:data, fields:fields, autoDestroy:true, autoCreated:true, expanded:expand});
  }
  if (Ext.isString(store)) {
    return this.get(store);
  } else {
    if (store instanceof Ext.data.Store) {
      return store;
    } else {
      return Ext.factory(store, Ext.data.Store, null, 'store');
    }
  }
}, getKey:function(o) {
  return o.getStoreId();
}}, 0, 0, 0, 0, 0, 0, [Ext.data, 'StoreManager', Ext, 'StoreMgr', Ext.data, 'StoreMgr', Ext, 'StoreManager'], function() {
  Ext.regStore = function(name, config) {
    var store;
    if (Ext.isObject(name)) {
      config = name;
    } else {
      if (config instanceof Ext.data.Store) {
        config.setStoreId(name);
      } else {
        config.storeId = name;
      }
    }
    if (config instanceof Ext.data.Store) {
      store = config;
    } else {
      store = Ext.create('Ext.data.Store', config);
    }
    return Ext.data.StoreManager.register(store);
  };
  Ext.getStore = function(name) {
    return Ext.data.StoreManager.lookup(name);
  };
});
Ext.cmd.derive('Ext.util.Grouper', Ext.util.Sorter, {isGrouper:true, config:{groupFn:null, sortProperty:null, sorterFn:function(item1, item2) {
  var property = this.getSortProperty(), groupFn, group1, group2, modifier;
  groupFn = this.getGroupFn();
  group1 = groupFn.call(this, item1);
  group2 = groupFn.call(this, item2);
  if (property) {
    if (group1 !== group2) {
      return this.defaultSortFn.call(this, item1, item2);
    } else {
      return 0;
    }
  }
  return group1 > group2 ? 1 : group1 < group2 ? -1 : 0;
}}, defaultSortFn:function(item1, item2) {
  var me = this, transform = me._transform, root = me._root, value1, value2, property = me._sortProperty;
  if (root !== null) {
    item1 = item1[root];
    item2 = item2[root];
  }
  value1 = item1[property];
  value2 = item2[property];
  if (transform) {
    value1 = transform(value1);
    value2 = transform(value2);
  }
  return value1 > value2 ? 1 : value1 < value2 ? -1 : 0;
}, updateProperty:function(property) {
  this.setGroupFn(this.standardGroupFn);
}, standardGroupFn:function(item) {
  var root = this.getRoot(), property = this.getProperty(), data = item;
  if (root) {
    data = item[root];
  }
  return data[property];
}, getGroupString:function(item) {
  var group = this.getGroupFn().call(this, item);
  return group !== null && typeof group != 'undefined' ? group.toString() : '';
}}, 0, 0, 0, 0, 0, 0, [Ext.util, 'Grouper'], 0);
Ext.cmd.derive('Ext.data.Store', Ext.Evented, {statics:{create:function(store) {
  if (!store.isStore) {
    if (!store.type) {
      store.type = 'store';
    }
    store = Ext.createByAlias('store.' + store.type, store);
  }
  return store;
}}, isStore:true, config:{storeId:undefined, data:null, autoLoad:null, autoSync:false, model:undefined, proxy:undefined, fields:null, remoteSort:false, remoteFilter:false, remoteGroup:false, filters:null, sorters:null, grouper:null, groupField:null, groupDir:null, getGroupString:null, pageSize:25, totalCount:null, clearOnPageLoad:true, params:{}, modelDefaults:{}, autoDestroy:false, syncRemovedRecords:true, destroyRemovedRecords:true, buffered:false, plugins:null}, currentPage:1, constructor:function(config) {
  config = config || {};
  this.data = this._data = this.createDataCollection();
  this.data.setSortRoot('data');
  this.data.setFilterRoot('data');
  this.removed = [];
  if (config.id && !config.storeId) {
    config.storeId = config.id;
    delete config.id;
  }
  this.initConfig(config);
  Ext.Evented.prototype.constructor.apply(this, arguments);
}, applyPlugins:function(config) {
  var ln, i, configObj;
  if (!config) {
    return config;
  }
  config = [].concat(config);
  for (i = 0, ln = config.length; i < ln; i++) {
    configObj = config[i];
    config[i] = Ext.factory(configObj, 'Ext.plugin.Plugin', null, 'plugin');
  }
  return config;
}, updatePlugins:function(newPlugins, oldPlugins) {
  var ln, i;
  if (newPlugins) {
    for (i = 0, ln = newPlugins.length; i < ln; i++) {
      newPlugins[i].init(this);
    }
  }
  if (oldPlugins) {
    for (i = 0, ln = oldPlugins.length; i < ln; i++) {
      Ext.destroy(oldPlugins[i]);
    }
  }
}, createDataCollection:function() {
  return new Ext.util.Collection(function(record) {
    return record.getId();
  });
}, applyStoreId:function(storeId) {
  if (storeId === undefined || storeId === null) {
    storeId = this.getUniqueId();
  }
  return storeId;
}, updateStoreId:function(storeId, oldStoreId) {
  if (oldStoreId) {
    Ext.data.StoreManager.unregister(this);
  }
  if (storeId) {
    Ext.data.StoreManager.register(this);
  }
}, applyModel:function(model) {
  if (typeof model == 'string') {
    var registeredModel = Ext.data.ModelManager.getModel(model);
    if (!registeredModel) {
      Ext.Logger.error('Model with name "' + model + '" does not exist.');
    }
    model = registeredModel;
  }
  if (model && !model.prototype.isModel && Ext.isObject(model)) {
    model = Ext.data.ModelManager.registerType(model.storeId || model.id || Ext.id(), model);
  }
  if (!model) {
    var fields = this.getFields(), data = this.config.data;
    if (!fields && data && data.length) {
      fields = Ext.Object.getKeys(data[0]);
    }
    if (fields) {
      model = Ext.define('Ext.data.Store.ImplicitModel-' + (this.getStoreId() || Ext.id()), {extend:'Ext.data.Model', config:{fields:fields, useCache:false, proxy:this.getProxy()}});
      this.implicitModel = true;
    }
  }
  if (!model && this.getProxy()) {
    model = this.getProxy().getModel();
  }
  return model;
}, updateModel:function(model) {
  var proxy = this.getProxy();
  if (proxy && !proxy.getModel()) {
    proxy.setModel(model);
  }
}, applyProxy:function(proxy, currentProxy) {
  proxy = Ext.factory(proxy, Ext.data.Proxy, currentProxy, 'proxy');
  if (!proxy && this.getModel()) {
    proxy = this.getModel().getProxy();
  }
  if (!proxy) {
    proxy = new Ext.data.proxy.Memory({model:this.getModel()});
  }
  if (proxy.isMemoryProxy) {
    this.setSyncRemovedRecords(false);
  }
  return proxy;
}, updateProxy:function(proxy, oldProxy) {
  if (proxy) {
    if (!proxy.getModel()) {
      proxy.setModel(this.getModel());
    }
    proxy.on('metachange', 'onMetaChange', this);
  }
  if (oldProxy) {
    proxy.un('metachange', 'onMetaChange', this);
  }
}, applyData:function(data) {
  var me = this, proxy;
  if (data) {
    proxy = me.getProxy();
    if (proxy instanceof Ext.data.proxy.Memory) {
      proxy.setData(data);
      me.load();
      return;
    } else {
      me.removeAll(true);
      me.fireEvent('clear', me);
      me.suspendEvents();
      me.add(data);
      me.resumeEvents();
      me.dataLoaded = true;
    }
  } else {
    me.removeAll(true);
    me.fireEvent('clear', me);
  }
  me.fireEvent('refresh', me, me.data);
}, clearData:function() {
  this.setData(null);
}, addData:function(data) {
  var reader = this.getProxy().getReader(), resultSet = reader.read(data), records = resultSet.getRecords();
  this.add(records);
}, updateAutoLoad:function(autoLoad) {
  var proxy = this.getProxy();
  if (autoLoad && (proxy && !proxy.isMemoryProxy)) {
    this.load(Ext.isObject(autoLoad) ? autoLoad : null);
  }
}, isAutoLoading:function() {
  var proxy = this.getProxy();
  return this.getAutoLoad() || proxy && proxy.isMemoryProxy || this.dataLoaded;
}, updateGroupField:function(groupField) {
  var grouper = this.getGrouper();
  if (groupField) {
    if (!grouper) {
      this.setGrouper({property:groupField, direction:this.getGroupDir() || 'ASC'});
    } else {
      grouper.setProperty(groupField);
    }
  } else {
    if (grouper) {
      this.setGrouper(null);
    }
  }
}, updateGroupDir:function(groupDir) {
  var grouper = this.getGrouper();
  if (grouper) {
    grouper.setDirection(groupDir);
  }
}, applyGetGroupString:function(getGroupStringFn) {
  var grouper = this.getGrouper();
  if (getGroupStringFn) {
    if (grouper) {
      grouper.setGroupFn(getGroupStringFn);
    } else {
      this.setGrouper({groupFn:getGroupStringFn});
    }
  } else {
    if (grouper) {
      this.setGrouper(null);
    }
  }
}, applyGrouper:function(grouper) {
  if (typeof grouper == 'string') {
    grouper = {property:grouper};
  } else {
    if (typeof grouper == 'function') {
      grouper = {groupFn:grouper};
    }
  }
  grouper = Ext.factory(grouper, Ext.util.Grouper);
  return grouper;
}, updateGrouper:function(grouper, oldGrouper) {
  var data = this.data;
  if (oldGrouper) {
    data.removeSorter(oldGrouper);
    if (!grouper) {
      data.getSorters().removeSorter('isGrouper');
    }
  }
  if (grouper) {
    data.insertSorter(0, grouper);
    if (!oldGrouper) {
      data.getSorters().addSorter({direction:'DESC', property:'isGrouper', transform:function(value) {
        return value === true ? 1 : -1;
      }});
    }
  }
  this.fireEvent('refresh', this, data);
}, isGrouped:function() {
  return !!this.getGrouper();
}, updateSorters:function(sorters) {
  var grouper = this.getGrouper(), data = this.data, autoSort = data.getAutoSort();
  data.setAutoSort(false);
  data.setSorters(sorters);
  if (grouper) {
    data.insertSorter(0, grouper);
  }
  this.updateSortTypes();
  data.setAutoSort(autoSort);
}, updateSortTypes:function() {
  var model = this.getModel(), fields = model && model.getFields(), data = this.data;
  if (fields) {
    data.getSorters().each(function(sorter) {
      var property = sorter.getProperty(), field;
      if (!sorter.isGrouper && property && !sorter.getTransform()) {
        field = fields.get(property);
        if (field) {
          sorter.setTransform(field.getSortType());
        }
      }
    });
  }
}, updateFilters:function(filters) {
  this.data.setFilters(filters);
}, add:function(records) {
  if (!Ext.isArray(records)) {
    records = Array.prototype.slice.call(arguments);
  }
  return this.insert(this.data.length, records);
}, insert:function(index, records) {
  if (!Ext.isArray(records)) {
    records = Array.prototype.slice.call(arguments, 1);
  }
  var me = this, sync = false, data = this.data, ln = records.length, Model = this.getModel(), modelDefaults = me.getModelDefaults(), added = false, i, record;
  records = records.slice();
  for (i = 0; i < ln; i++) {
    record = records[i];
    if (!record.isModel) {
      record = new Model(record);
    } else {
      if (this.removed.indexOf(record) != -1) {
        Ext.Array.remove(this.removed, record);
      }
    }
    record.set(modelDefaults);
    record.join(me);
    records[i] = record;
    sync = sync || record.phantom === true;
  }
  if (records.length === 1) {
    added = data.insert(index, records[0]);
    if (added) {
      added = [added];
    }
  } else {
    added = data.insertAll(index, records);
  }
  if (added) {
    me.fireEvent('addrecords', me, added);
  }
  if (me.getAutoSync() && sync) {
    me.sync();
  }
  return records;
}, remove:function(records) {
  if (records.isModel) {
    records = [records];
  }
  var me = this, sync = false, i = 0, autoSync = this.getAutoSync(), syncRemovedRecords = me.getSyncRemovedRecords(), destroyRemovedRecords = this.getDestroyRemovedRecords(), ln = records.length, indices = [], removed = [], isPhantom, items = me.data.items, record, index;
  for (; i < ln; i++) {
    record = records[i];
    if (me.data.contains(record)) {
      isPhantom = record.phantom === true;
      index = items.indexOf(record);
      if (index !== -1) {
        removed.push(record);
        indices.push(index);
      }
      record.unjoin(me);
      me.data.remove(record);
      if (destroyRemovedRecords && !syncRemovedRecords && !record.stores.length) {
        record.destroy();
      } else {
        if (!isPhantom && syncRemovedRecords) {
          me.removed.push(record);
        }
      }
      sync = sync || !isPhantom;
    }
  }
  me.fireEvent('removerecords', me, removed, indices);
  if (autoSync && sync) {
    me.sync();
  }
}, removeAt:function(index) {
  var record = this.getAt(index);
  if (record) {
    this.remove(record);
  }
}, removeAll:function(silent) {
  if (silent !== true && this.eventFiringSuspended !== true) {
    this.fireAction('clear', [this], 'doRemoveAll');
  } else {
    this.doRemoveAll.call(this, true);
  }
}, doRemoveAll:function(silent) {
  var me = this, destroyRemovedRecords = this.getDestroyRemovedRecords(), syncRemovedRecords = this.getSyncRemovedRecords(), records = me.data.all.slice(), ln = records.length, i, record;
  for (i = 0; i < ln; i++) {
    record = records[i];
    record.unjoin(me);
    if (destroyRemovedRecords && !syncRemovedRecords && !record.stores.length) {
      record.destroy();
    } else {
      if (record.phantom !== true && syncRemovedRecords) {
        me.removed.push(record);
      }
    }
  }
  me.data.clear();
  if (silent !== true) {
    me.fireEvent('refresh', me, me.data);
  }
  if (me.getAutoSync()) {
    this.sync();
  }
}, each:function(fn, scope) {
  this.data.each(fn, scope);
}, getCount:function() {
  return this.data.items.length || 0;
}, getAllCount:function() {
  return this.data.all.length || 0;
}, getAt:function(index) {
  return this.data.getAt(index);
}, getRange:function(start, end) {
  return this.data.getRange(start, end);
}, getById:function(id) {
  return this.data.findBy(function(record) {
    return record.getId() == id;
  });
}, indexOf:function(record) {
  return this.data.indexOf(record);
}, indexOfId:function(id) {
  return this.data.indexOfKey(id);
}, afterEdit:function(record, modifiedFieldNames, modified) {
  var me = this, data = me.data, currentId = modified[record.getIdProperty()] || record.getId(), currentIndex = data.keys.indexOf(currentId), newIndex;
  if (currentIndex === -1 && data.map[currentId] === undefined) {
    return;
  }
  if (me.getAutoSync()) {
    me.sync();
  }
  if (currentId !== record.getId()) {
    data.replace(currentId, record);
  } else {
    data.replace(record);
  }
  newIndex = data.indexOf(record);
  if (currentIndex === -1 && newIndex !== -1) {
    me.fireEvent('addrecords', me, [record]);
  } else {
    if (currentIndex !== -1 && newIndex === -1) {
      me.fireEvent('removerecords', me, [record], [currentIndex]);
    } else {
      if (newIndex !== -1) {
        me.fireEvent('updaterecord', me, record, newIndex, currentIndex, modifiedFieldNames, modified);
      }
    }
  }
}, afterReject:function(record) {
  var index = this.data.indexOf(record);
  this.fireEvent('updaterecord', this, record, index, index, [], {});
}, afterCommit:function(record, modifiedFieldNames, modified) {
  var me = this, data = me.data, currentId = modified[record.getIdProperty()] || record.getId(), currentIndex = data.keys.indexOf(currentId), newIndex;
  if (currentIndex === -1 && data.map[currentId] === undefined) {
    return;
  }
  if (currentId !== record.getId()) {
    data.replace(currentId, record);
  } else {
    data.replace(record);
  }
  newIndex = data.indexOf(record);
  if (currentIndex === -1 && newIndex !== -1) {
    me.fireEvent('addrecords', me, [record]);
  } else {
    if (currentIndex !== -1 && newIndex === -1) {
      me.fireEvent('removerecords', me, [record], [currentIndex]);
    } else {
      if (newIndex !== -1) {
        me.fireEvent('updaterecord', me, record, newIndex, currentIndex, modifiedFieldNames, modified);
      }
    }
  }
}, afterErase:function(record) {
  var me = this, data = me.data, index = data.indexOf(record);
  if (index !== -1) {
    data.remove(record);
    me.fireEvent('removerecords', me, [record], [index]);
  }
}, applyRemoteFilter:function(value) {
  var proxy = this.getProxy();
  return value || proxy && proxy.isSQLProxy === true;
}, applyRemoteSort:function(value) {
  var proxy = this.getProxy();
  return value || proxy && proxy.isSQLProxy === true;
}, applyRemoteGroup:function(value) {
  var proxy = this.getProxy();
  return value || proxy && proxy.isSQLProxy === true;
}, updateRemoteFilter:function(remoteFilter) {
  this.data.setAutoFilter(!remoteFilter);
}, updateRemoteSort:function(remoteSort) {
  this.data.setAutoSort(!remoteSort);
}, sort:function(sorters, defaultDirection, where) {
  var data = this.data, grouper = this.getGrouper(), autoSort = data.getAutoSort();
  if (sorters) {
    data.setAutoSort(false);
    if (typeof where === 'string') {
      if (where == 'prepend') {
        data.insertSorters(grouper ? 1 : 0, sorters, defaultDirection);
      } else {
        data.addSorters(sorters, defaultDirection);
      }
    } else {
      data.setSorters(null);
      if (grouper) {
        data.addSorters(grouper);
      }
      data.addSorters(sorters, defaultDirection);
    }
    this.updateSortTypes();
    data.setAutoSort(autoSort);
  }
  if (!this.getRemoteSort()) {
    if (!sorters) {
      this.data.sort();
    }
    this.fireEvent('sort', this, this.data, this.data.getSorters());
    if (data.length) {
      this.fireEvent('refresh', this, this.data);
    }
  }
}, filter:function(property, value, anyMatch, caseSensitive) {
  var data = this.data, filter = null;
  if (property) {
    if (Ext.isFunction(property)) {
      filter = {filterFn:property};
    } else {
      if (Ext.isArray(property) || property.isFilter) {
        filter = property;
      } else {
        filter = {property:property, value:value, anyMatch:anyMatch, caseSensitive:caseSensitive, id:property};
      }
    }
  }
  if (this.getRemoteFilter()) {
    data.addFilters(filter);
  } else {
    data.filter(filter);
    this.fireEvent('filter', this, data, data.getFilters());
    this.fireEvent('refresh', this, data);
  }
}, filterBy:function(fn, scope) {
  var me = this, data = me.data, ln = data.length;
  data.filter({filterFn:function(record) {
    return fn.call(scope || me, record, record.getId());
  }});
  this.fireEvent('filter', this, data, data.getFilters());
  if (data.length !== ln) {
    this.fireEvent('refresh', this, data);
  }
}, queryBy:function(fn, scope) {
  return this.data.filterBy(fn, scope || this);
}, clearFilter:function(suppressEvent) {
  var ln = this.data.length;
  if (suppressEvent) {
    this.suspendEvents();
  }
  this.data.setFilters(null);
  if (suppressEvent) {
    this.resumeEvents(true);
  } else {
    if (ln !== this.data.length) {
      this.fireEvent('refresh', this, this.data);
    }
  }
}, isFiltered:function() {
  return this.data.filtered;
}, isSorted:function() {
  return this.data.sorted;
}, getSorters:function() {
  var sorters = this.data.getSorters();
  return sorters ? sorters.items : [];
}, getFilters:function() {
  var filters = this.data.getFilters();
  return filters ? filters.items : [];
}, getGroups:function(requestGroupString) {
  var records = this.data.items, length = records.length, grouper = this.getGrouper(), groups = [], pointers = {}, record, groupStr, group, i;
  for (i = 0; i < length; i++) {
    record = records[i];
    groupStr = grouper.getGroupString(record);
    group = pointers[groupStr];
    if (group === undefined) {
      group = {name:groupStr, children:[]};
      groups.push(group);
      pointers[groupStr] = group;
    }
    group.children.push(record);
  }
  return requestGroupString ? pointers[requestGroupString] : groups;
}, getGroupString:function(record) {
  var grouper = this.getGrouper();
  if (grouper) {
    return grouper.getGroupString(record);
  }
  return null;
}, find:function(fieldName, value, startIndex, anyMatch, caseSensitive, exactMatch) {
  var filter = Ext.create('Ext.util.Filter', {property:fieldName, value:value, anyMatch:anyMatch, caseSensitive:caseSensitive, exactMatch:exactMatch, root:'data'});
  return this.data.findIndexBy(filter.getFilterFn(), null, startIndex);
}, findRecord:function() {
  var me = this, index = me.find.apply(me, arguments);
  return index !== -1 ? me.getAt(index) : null;
}, findExact:function(fieldName, value, startIndex) {
  return this.data.findIndexBy(function(record) {
    return record.get(fieldName) === value;
  }, this, startIndex);
}, findBy:function(fn, scope, startIndex) {
  return this.data.findIndexBy(fn, scope, startIndex);
}, load:function(options, scope) {
  var me = this, operation, currentPage = me.currentPage, pageSize = me.getPageSize();
  options = options || {};
  if (Ext.isFunction(options)) {
    options = {callback:options, scope:scope || this};
  }
  if (me.getRemoteSort()) {
    options.sorters = options.sorters || this.getSorters();
  }
  if (me.getRemoteFilter()) {
    options.filters = options.filters || this.getFilters();
  }
  if (me.getRemoteGroup()) {
    options.grouper = options.grouper || this.getGrouper();
  }
  Ext.applyIf(options, {page:currentPage, start:(currentPage - 1) * pageSize, limit:pageSize, addRecords:false, action:'read', params:this.getParams(), model:this.getModel()});
  operation = Ext.create('Ext.data.Operation', options);
  if (me.fireEvent('beforeload', me, operation) !== false) {
    me.loading = true;
    me.getProxy().read(operation, me.onProxyLoad, me);
  }
  return me;
}, isLoading:function() {
  return Boolean(this.loading);
}, isLoaded:function() {
  return Boolean(this.loaded);
}, sync:function(options) {
  var me = this, operations = {}, toCreate = me.getNewRecords(), toUpdate = me.getUpdatedRecords(), toDestroy = me.getRemovedRecords(), needsSync = false;
  if (toCreate.length > 0) {
    operations.create = toCreate;
    needsSync = true;
  }
  if (toUpdate.length > 0) {
    operations.update = toUpdate;
    needsSync = true;
  }
  if (toDestroy.length > 0) {
    operations.destroy = toDestroy;
    needsSync = true;
  }
  if (needsSync && me.fireEvent('beforesync', this, operations) !== false) {
    me.getProxy().batch(Ext.merge({operations:operations, listeners:me.getBatchListeners()}, options || {}));
  }
  return {added:toCreate, updated:toUpdate, removed:toDestroy};
}, first:function() {
  return this.data.first();
}, last:function() {
  return this.data.last();
}, sum:function(field) {
  var total = 0, i = 0, records = this.data.items, len = records.length;
  for (; i < len; ++i) {
    total += records[i].get(field);
  }
  return total;
}, min:function(field) {
  var i = 1, records = this.data.items, len = records.length, value, min;
  if (len > 0) {
    min = records[0].get(field);
  }
  for (; i < len; ++i) {
    value = records[i].get(field);
    if (value < min) {
      min = value;
    }
  }
  return min;
}, max:function(field) {
  var i = 1, records = this.data.items, len = records.length, value, max;
  if (len > 0) {
    max = records[0].get(field);
  }
  for (; i < len; ++i) {
    value = records[i].get(field);
    if (value > max) {
      max = value;
    }
  }
  return max;
}, average:function(field) {
  var i = 0, records = this.data.items, len = records.length, sum = 0;
  if (records.length > 0) {
    for (; i < len; ++i) {
      sum += records[i].get(field);
    }
    return sum / len;
  }
  return 0;
}, getBatchListeners:function() {
  return {scope:this, exception:this.onBatchException, complete:this.onBatchComplete};
}, onBatchComplete:function(batch) {
  var me = this, operations = batch.operations, length = operations.length, i;
  for (i = 0; i < length; i++) {
    me.onProxyWrite(operations[i]);
  }
}, onBatchException:function(batch, operation) {
}, onProxyLoad:function(operation) {
  var me = this, records = operation.getRecords(), resultSet = operation.getResultSet(), successful = operation.wasSuccessful();
  if (resultSet) {
    me.setTotalCount(resultSet.getTotal());
  }
  if (successful) {
    this.fireAction('datarefresh', [this, this.data, operation], 'doDataRefresh');
  }
  me.loaded = true;
  me.loading = false;
  me.fireEvent('load', this, records, successful, operation);
  Ext.callback(operation.getCallback(), operation.getScope() || me, [records, operation, successful]);
}, doDataRefresh:function(store, data, operation) {
  var records = operation.getRecords(), me = this, destroyRemovedRecords = me.getDestroyRemovedRecords(), currentRecords = data.all.slice(), ln = currentRecords.length, ln2 = records.length, ids = {}, i, record;
  if (operation.getAddRecords() !== true) {
    for (i = 0; i < ln2; i++) {
      ids[records[i].id] = true;
    }
    for (i = 0; i < ln; i++) {
      record = currentRecords[i];
      record.unjoin(me);
      if (ids[record.id] !== true && destroyRemovedRecords && !record.stores.length) {
        record.destroy();
      }
    }
    data.clear();
    me.fireEvent('clear', me);
  }
  if (records && records.length) {
    me.suspendEvents();
    me.add(records);
    me.resumeEvents(true);
  }
  me.fireEvent('refresh', me, data);
}, onProxyWrite:function(operation) {
  var me = this, success = operation.wasSuccessful(), records = operation.getRecords();
  switch(operation.getAction()) {
    case 'create':
      me.onCreateRecords(records, operation, success);
      break;
    case 'update':
      me.onUpdateRecords(records, operation, success);
      break;
    case 'destroy':
      me.onDestroyRecords(records, operation, success);
      break;
  }
  if (success) {
    me.fireEvent('write', me, operation);
  }
  Ext.callback(operation.getCallback(), operation.getScope() || me, [records, operation, success]);
}, onCreateRecords:function(records, operation, success) {
}, onUpdateRecords:function(records, operation, success) {
}, onDestroyRecords:function(records, operation, success) {
  this.removed = [];
}, onMetaChange:function(data) {
  var model = this.getProxy().getModel();
  if (!this.getModel() && model) {
    this.setModel(model);
  }
  this.fireEvent('metachange', this, data);
}, getNewRecords:function() {
  return this.data.filterBy(function(item) {
    return item.phantom === true && item.isValid();
  }).items;
}, getUpdatedRecords:function() {
  return this.data.filterBy(function(item) {
    return item.dirty === true && item.phantom !== true && item.isValid();
  }).items;
}, getRemovedRecords:function() {
  return this.removed;
}, loadPage:function(page, options, scope) {
  if (typeof options === 'function') {
    options = {callback:options, scope:scope || this};
  }
  var me = this, pageSize = me.getPageSize(), clearOnPageLoad = me.getClearOnPageLoad();
  options = Ext.apply({}, options);
  me.currentPage = page;
  me.load(Ext.applyIf(options, {page:page, start:(page - 1) * pageSize, limit:pageSize, addRecords:!clearOnPageLoad}));
}, nextPage:function(options) {
  this.loadPage(this.currentPage + 1, options);
}, previousPage:function(options) {
  this.loadPage(this.currentPage - 1, options);
}, destroy:function() {
  this.clearData();
  var proxy = this.getProxy();
  if (proxy) {
    proxy.onDestroy();
  }
  Ext.data.StoreManager.unregister(this);
  Ext.destroy(this.getPlugins());
  if (this.implicitModel && this.getModel()) {
    delete Ext.data.ModelManager.types[this.getModel().getName()];
  }
  Ext.destroy(this.data);
  Ext.Evented.prototype.destroy.apply(this, arguments);
}}, 1, 0, 0, 0, ['store.store'], 0, [Ext.data, 'Store'], 0);
Ext.cmd.derive('Ext.data.ArrayStore', Ext.data.Store, {config:{proxy:{type:'memory', reader:'array'}}, loadData:function(data, append) {
  this.callParent([data, append]);
}}, 0, 0, 0, 0, ['store.array'], 0, [Ext.data, 'ArrayStore'], function() {
  Ext.data.SimpleStore = Ext.data.ArrayStore;
});
Ext.define('Ext.direct.Manager', {singleton:true, mixins:{observable:Ext.mixin.Observable}, alternateClassName:'Ext.Direct', exceptions:{TRANSPORT:'xhr', PARSE:'parse', LOGIN:'login', SERVER:'exception'}, constructor:function() {
  var me = this;
  me.transactions = Ext.create('Ext.util.Collection', this.getKey);
  me.providers = Ext.create('Ext.util.Collection', this.getKey);
}, getKey:function(item) {
  return item.getId();
}, addProvider:function(provider) {
  var me = this, args = Ext.toArray(arguments), i = 0, ln;
  if (args.length > 1) {
    for (ln = args.length; i < ln; ++i) {
      me.addProvider(args[i]);
    }
    return;
  }
  if (!provider.isProvider) {
    provider = Ext.create('direct.' + provider.type + 'provider', provider);
  }
  me.providers.add(provider);
  provider.on('data', me.onProviderData, me);
  if (!provider.isConnected()) {
    provider.connect();
  }
  return provider;
}, getProvider:function(id) {
  return id.isProvider ? id : this.providers.get(id);
}, removeProvider:function(provider) {
  var me = this, providers = me.providers;
  provider = provider.isProvider ? provider : providers.get(provider);
  if (provider) {
    provider.un('data', me.onProviderData, me);
    providers.remove(provider);
    return provider;
  }
  return null;
}, addTransaction:function(transaction) {
  this.transactions.add(transaction);
  return transaction;
}, removeTransaction:function(transaction) {
  transaction = this.getTransaction(transaction);
  this.transactions.remove(transaction);
  return transaction;
}, getTransaction:function(transaction) {
  return Ext.isObject(transaction) ? transaction : this.transactions.get(transaction);
}, onProviderData:function(provider, event) {
  var me = this, i = 0, ln, name;
  if (Ext.isArray(event)) {
    for (ln = event.length; i < ln; ++i) {
      me.onProviderData(provider, event[i]);
    }
    return;
  }
  name = event.getName();
  if (name && name != 'event' && name != 'exception') {
    me.fireEvent(name, event);
  } else {
    if (event.getStatus() === false) {
      me.fireEvent('exception', event);
    }
  }
  me.fireEvent('event', event, provider);
}, parseMethod:function(fn) {
  if (Ext.isString(fn)) {
    var parts = fn.split('.'), i = 0, ln = parts.length, current = window;
    while (current && i < ln) {
      current = current[parts[i]];
      ++i;
    }
    fn = Ext.isFunction(current) ? current : null;
  }
  return fn || null;
}});
Ext.cmd.derive('Ext.data.Validations', Ext.Base, {alternateClassName:'Ext.data.validations', singleton:true, config:{presenceMessage:'must be present', lengthMessage:'is the wrong length', formatMessage:'is the wrong format', inclusionMessage:'is not included in the list of acceptable values', exclusionMessage:'is not an acceptable value', emailMessage:'is not a valid email address'}, constructor:function(config) {
  this.initConfig(config);
}, getMessage:function(type) {
  var getterFn = this['get' + type[0].toUpperCase() + type.slice(1) + 'Message'];
  if (getterFn) {
    return getterFn.call(this);
  }
  return '';
}, emailRe:/^\s*[\w\-\+_]+(\.[\w\-\+_]+)*@[\w\-\+_]+\.[\w\-\+_]+(\.[\w\-\+_]+)*\s*$/, presence:function(config, value) {
  if (arguments.length === 1) {
    value = config;
  }
  return !!value || value === 0;
}, length:function(config, value) {
  if (value === undefined || value === null) {
    return false;
  }
  var length = value.length, min = config.min, max = config.max;
  if (min && length < min || max && length > max) {
    return false;
  } else {
    return true;
  }
}, email:function(config, email) {
  return Ext.data.validations.emailRe.test(email);
}, format:function(config, value) {
  if (value === undefined || value === null) {
    value = '';
  }
  return !!(config.matcher && config.matcher.test(value));
}, inclusion:function(config, value) {
  return config.list && Ext.Array.indexOf(config.list, value) != -1;
}, exclusion:function(config, value) {
  return config.list && Ext.Array.indexOf(config.list, value) == -1;
}}, 1, 0, 0, 0, 0, 0, [Ext.data, 'Validations', Ext.data, 'validations'], 0);
Ext.cmd.derive('Ext.data.proxy.Rest', Ext.data.proxy.Ajax, {alternateClassName:'Ext.data.RestProxy', config:{appendId:true, format:null, batchActions:false, actionMethods:{create:'POST', read:'GET', update:'PUT', destroy:'DELETE'}}, buildUrl:function(request) {
  var me = this, operation = request.getOperation(), records = operation.getRecords() || [], record = records[0], model = me.getModel(), idProperty = model.getIdProperty(), format = me.getFormat(), url = me.getUrl(request), params = request.getParams() || {}, id = record && !record.phantom ? record.getId() : params[idProperty];
  if (me.getAppendId() && id) {
    if (!url.match(/\/$/)) {
      url += '/';
    }
    url += id;
    delete params[idProperty];
  }
  if (format) {
    if (!url.match(/\.$/)) {
      url += '.';
    }
    url += format;
  }
  request.setUrl(url);
  return Ext.data.proxy.Ajax.prototype.buildUrl.call(this, request);
}}, 0, 0, 0, 0, ['proxy.rest'], 0, [Ext.data.proxy, 'Rest', Ext.data, 'RestProxy'], 0);
Ext.cmd.derive('Ext.data.reader.Array', Ext.data.reader.Json, {alternateClassName:'Ext.data.ArrayReader', config:{totalProperty:undefined, successProperty:undefined}, createFieldAccessExpression:function(field, fieldVarName, dataName) {
  var me = this, mapping = field.getMapping(), index = mapping == null ? me.getModel().getFields().indexOf(field) : mapping, result;
  if (typeof index === 'function') {
    result = fieldVarName + '.getMapping()(' + dataName + ', this)';
  } else {
    if (isNaN(index)) {
      index = '"' + index + '"';
    }
    result = dataName + '[' + index + ']';
  }
  return result;
}}, 0, 0, 0, 0, ['reader.array'], 0, [Ext.data.reader, 'Array', Ext.data, 'ArrayReader'], 0);
Ext.cmd.derive('Ext.mixin.Selectable', Ext.mixin.Mixin, {mixinConfig:{id:'selectable', hooks:{updateStore:'updateStore'}}, config:{disableSelection:null, mode:'SINGLE', allowDeselect:false, lastSelected:null, lastFocused:null, deselectOnContainerClick:true}, modes:{SINGLE:true, SIMPLE:true, MULTI:true}, selectableEventHooks:{addrecords:'onSelectionStoreAdd', removerecords:'onSelectionStoreRemove', updaterecord:'onSelectionStoreUpdate', load:'refreshSelection', refresh:'refreshSelection'}, constructor:function() {
  this.selected = new Ext.util.MixedCollection;
  this.callParent(arguments);
}, applyMode:function(mode) {
  mode = mode ? mode.toUpperCase() : 'SINGLE';
  return this.modes[mode] ? mode : 'SINGLE';
}, updateStore:function(newStore, oldStore) {
  var me = this, bindEvents = Ext.apply({}, me.selectableEventHooks, {scope:me});
  if (oldStore && Ext.isObject(oldStore) && oldStore.isStore) {
    if (oldStore.autoDestroy) {
      oldStore.destroy();
    } else {
      oldStore.un(bindEvents);
      if (newStore) {
        newStore.un('clear', 'onSelectionStoreClear', this);
      }
    }
  }
  if (newStore) {
    newStore.on(bindEvents);
    newStore.onBefore('clear', 'onSelectionStoreClear', this);
    me.refreshSelection();
  }
}, selectAll:function(silent) {
  var me = this, selections = me.getStore().getRange();
  me.select(selections, true, silent);
}, deselectAll:function(supress) {
  var me = this, selections = me.getStore().getRange();
  me.deselect(selections, supress);
  me.selected.clear();
  me.setLastSelected(null);
  me.setLastFocused(null);
}, selectWithEvent:function(record) {
  var me = this, isSelected = me.isSelected(record);
  switch(me.getMode()) {
    case 'MULTI':
    case 'SIMPLE':
      if (isSelected) {
        me.deselect(record);
      } else {
        me.select(record, true);
      }
      break;
    case 'SINGLE':
      if (me.getAllowDeselect() && isSelected) {
        me.deselect(record);
      } else {
        me.select(record, false);
      }
      break;
  }
}, selectRange:function(startRecord, endRecord, keepExisting) {
  var me = this, store = me.getStore(), records = [], tmp, i;
  if (me.getDisableSelection()) {
    return;
  }
  if (startRecord > endRecord) {
    tmp = endRecord;
    endRecord = startRecord;
    startRecord = tmp;
  }
  for (i = startRecord; i <= endRecord; i++) {
    records.push(store.getAt(i));
  }
  this.doMultiSelect(records, keepExisting);
}, select:function(records, keepExisting, suppressEvent) {
  var me = this, record;
  if (me.getDisableSelection()) {
    return;
  }
  if (typeof records === 'number') {
    records = [me.getStore().getAt(records)];
  }
  if (!records) {
    return;
  }
  if (me.getMode() == 'SINGLE' && records) {
    record = records.length ? records[0] : records;
    me.doSingleSelect(record, suppressEvent);
  } else {
    me.doMultiSelect(records, keepExisting, suppressEvent);
  }
}, doSingleSelect:function(record, suppressEvent) {
  var me = this, selected = me.selected;
  if (me.getDisableSelection()) {
    return;
  }
  if (me.isSelected(record)) {
    return;
  }
  if (selected.getCount() > 0) {
    me.deselect(me.getLastSelected(), suppressEvent);
  }
  selected.add(record);
  me.setLastSelected(record);
  me.onItemSelect(record, suppressEvent);
  me.setLastFocused(record);
  if (!suppressEvent) {
    me.fireSelectionChange([record]);
  }
}, doMultiSelect:function(records, keepExisting, suppressEvent) {
  if (records === null || this.getDisableSelection()) {
    return;
  }
  records = !Ext.isArray(records) ? [records] : records;
  var me = this, selected = me.selected, ln = records.length, change = false, i = 0, record;
  if (!keepExisting && selected.getCount() > 0) {
    change = true;
    me.deselect(me.getSelection(), true);
  }
  for (; i < ln; i++) {
    record = records[i];
    if (keepExisting && me.isSelected(record)) {
      continue;
    }
    change = true;
    me.setLastSelected(record);
    selected.add(record);
    if (!suppressEvent) {
      me.setLastFocused(record);
    }
    me.onItemSelect(record, suppressEvent);
  }
  if (change && !suppressEvent) {
    this.fireSelectionChange(records);
  }
}, deselect:function(records, suppressEvent) {
  var me = this;
  if (me.getDisableSelection()) {
    return;
  }
  records = Ext.isArray(records) ? records : [records];
  var selected = me.selected, change = false, i = 0, store = me.getStore(), ln = records.length, record;
  for (; i < ln; i++) {
    record = records[i];
    if (typeof record === 'number') {
      record = store.getAt(record);
    }
    if (selected.remove(record)) {
      if (me.getLastSelected() == record) {
        me.setLastSelected(selected.last());
      }
      change = true;
    }
    if (record) {
      me.onItemDeselect(record, suppressEvent);
    }
  }
  if (change && !suppressEvent) {
    me.fireSelectionChange(records);
  }
}, updateLastFocused:function(newRecord, oldRecord) {
  this.onLastFocusChanged(oldRecord, newRecord);
}, fireSelectionChange:function(records) {
  var me = this;
  me.fireAction('selectionchange', [me, records], 'getSelection');
}, getSelection:function() {
  return this.selected.getRange();
}, isSelected:function(record) {
  record = Ext.isNumber(record) ? this.getStore().getAt(record) : record;
  return this.selected.indexOf(record) !== -1;
}, hasSelection:function() {
  return this.selected.getCount() > 0;
}, refreshSelection:function() {
  var me = this, selections = me.getSelection();
  me.deselectAll(true);
  if (selections.length) {
    me.select(selections, false, true);
  }
}, onSelectionStoreRemove:function(store, records) {
  var me = this, selected = me.selected, ln = records.length, record, i;
  if (me.getDisableSelection()) {
    return;
  }
  for (i = 0; i < ln; i++) {
    record = records[i];
    if (selected.remove(record)) {
      if (me.getLastSelected() == record) {
        me.setLastSelected(null);
      }
      if (me.getLastFocused() == record) {
        me.setLastFocused(null);
      }
      me.fireSelectionChange([record]);
    }
  }
}, onSelectionStoreClear:function(store) {
  var records = store.getData().items;
  this.onSelectionStoreRemove(store, records);
}, getSelectionCount:function() {
  return this.selected.getCount();
}, onSelectionStoreAdd:Ext.emptyFn, onSelectionStoreUpdate:Ext.emptyFn, onItemSelect:Ext.emptyFn, onItemDeselect:Ext.emptyFn, onLastFocusChanged:Ext.emptyFn, onEditorKey:Ext.emptyFn}, 1, 0, 0, 0, 0, 0, [Ext.mixin, 'Selectable'], function() {
});
Ext.cmd.derive('Ext.dataview.component.DataItem', Ext.Container, {config:{baseCls:'x-data-item', defaultType:'component', record:null, itemCls:null, dataMap:{}, dataview:null, width:'100%', items:[{xtype:'component'}]}, updateBaseCls:function(newBaseCls, oldBaseCls) {
  var me = this;
  Ext.Container.prototype.updateBaseCls.apply(this, arguments);
}, updateItemCls:function(newCls, oldCls) {
  if (oldCls) {
    this.removeCls(oldCls);
  }
  if (newCls) {
    this.addCls(newCls);
  }
}, doMapData:function(dataMap, data, item) {
  var componentName, component, setterMap, setterName;
  for (componentName in dataMap) {
    setterMap = dataMap[componentName];
    component = this[componentName]();
    if (component) {
      for (setterName in setterMap) {
        if (data && component[setterName] && data[setterMap[setterName]] !== undefined && data[setterMap[setterName]] !== null) {
          component[setterName](data[setterMap[setterName]]);
        }
      }
    }
  }
  if (item) {
    item.updateData(data);
  }
}, updateRecord:function(newRecord) {
  if (!newRecord) {
    return;
  }
  this._record = newRecord;
  var me = this, dataview = me.dataview || this.getDataview(), data = dataview.prepareData(newRecord.getData(true), dataview.getStore().indexOf(newRecord), newRecord), items = me.getItems(), item = items.first(), dataMap = me.getDataMap();
  if (!item) {
    return;
  }
  if (dataMap) {
    this.doMapData(dataMap, data, item);
  }
  me.fireEvent('updatedata', me, data);
}}, 0, ['dataitem'], ['component', 'container', 'dataitem'], {'component':true, 'container':true, 'dataitem':true}, ['widget.dataitem'], 0, [Ext.dataview.component, 'DataItem'], 0);
Ext.cmd.derive('Ext.dataview.component.Container', Ext.Container, {constructor:function() {
  this.itemCache = [];
  Ext.Container.prototype.constructor.apply(this, arguments);
}, doInitialize:function() {
  this.innerElement.on({touchstart:'onItemTouchStart', touchend:'onItemTouchEnd', tap:'onItemTap', taphold:'onItemTapHold', touchmove:'onItemTouchMove', singletap:'onItemSingleTap', doubletap:'onItemDoubleTap', swipe:'onItemSwipe', delegate:'\x3e .x-data-item', scope:this});
}, initialize:function() {
  Ext.Container.prototype.initialize.call(this);
  this.doInitialize();
}, onItemTouchStart:function(e) {
  var me = this, target = e.getTarget(), item = Ext.getCmp(target.id);
  item.on({touchmove:'onItemTouchMove', scope:me, single:true});
  me.fireEvent('itemtouchstart', me, item, me.indexOf(item), e);
}, onItemTouchMove:function(e) {
  var me = this, target = e.getTarget(), item = Ext.getCmp(target.id);
  me.fireEvent('itemtouchmove', me, item, me.indexOf(item), e);
}, onItemTouchEnd:function(e) {
  var me = this, target = e.getTarget(), item = Ext.getCmp(target.id);
  item.un({touchmove:'onItemTouchMove', scope:me});
  me.fireEvent('itemtouchend', me, item, me.indexOf(item), e);
}, onItemTap:function(e) {
  var me = this, target = e.getTarget(), item = Ext.getCmp(target.id);
  me.fireEvent('itemtap', me, item, me.indexOf(item), e);
}, onItemTapHold:function(e) {
  var me = this, target = e.getTarget(), item = Ext.getCmp(target.id);
  me.fireEvent('itemtaphold', me, item, me.indexOf(item), e);
}, onItemSingleTap:function(e) {
  var me = this, target = e.getTarget(), item = Ext.getCmp(target.id);
  me.fireEvent('itemsingletap', me, item, me.indexOf(item), e);
}, onItemDoubleTap:function(e) {
  var me = this, target = e.getTarget(), item = Ext.getCmp(target.id);
  me.fireEvent('itemdoubletap', me, item, me.indexOf(item), e);
}, onItemSwipe:function(e) {
  var me = this, target = e.getTarget(), item = Ext.getCmp(target.id);
  me.fireEvent('itemswipe', me, item, me.indexOf(item), e);
}, moveItemsToCache:function(from, to) {
  var me = this, dataview = me.dataview, maxItemCache = dataview.getMaxItemCache(), items = me.getViewItems(), itemCache = me.itemCache, cacheLn = itemCache.length, pressedCls = dataview.getPressedCls(), selectedCls = dataview.getSelectedCls(), i = to - from, item;
  for (; i >= 0; i--) {
    item = items[from + i];
    if (cacheLn !== maxItemCache) {
      me.remove(item, false);
      item.removeCls([pressedCls, selectedCls]);
      itemCache.push(item);
      cacheLn++;
    } else {
      item.destroy();
    }
  }
  if (me.getViewItems().length == 0) {
    this.dataview.showEmptyText();
  }
}, moveItemsFromCache:function(records) {
  var me = this, dataview = me.dataview, store = dataview.getStore(), ln = records.length, xtype = dataview.getDefaultType(), itemConfig = dataview.getItemConfig(), itemCache = me.itemCache, cacheLn = itemCache.length, items = [], i, item, record;
  if (ln) {
    dataview.hideEmptyText();
  }
  for (i = 0; i < ln; i++) {
    records[i]._tmpIndex = store.indexOf(records[i]);
  }
  Ext.Array.sort(records, function(record1, record2) {
    return record1._tmpIndex > record2._tmpIndex ? 1 : -1;
  });
  for (i = 0; i < ln; i++) {
    record = records[i];
    if (cacheLn) {
      cacheLn--;
      item = itemCache.pop();
      this.updateListItem(record, item);
    } else {
      item = me.getDataItemConfig(xtype, record, itemConfig);
    }
    item = this.insert(record._tmpIndex, item);
    delete record._tmpIndex;
  }
  return items;
}, getViewItems:function() {
  return this.getInnerItems();
}, updateListItem:function(record, item) {
  if (item.updateRecord) {
    if (item.getRecord() === record) {
      item.updateRecord(record);
    } else {
      item.setRecord(record);
    }
  }
}, getDataItemConfig:function(xtype, record, itemConfig) {
  var dataview = this.dataview, dataItemConfig = {xtype:xtype, record:record, itemCls:dataview.getItemCls(), defaults:itemConfig, dataview:dataview};
  return Ext.merge(dataItemConfig, itemConfig);
}, doRemoveItemCls:function(cls) {
  var items = this.getViewItems(), ln = items.length, i = 0;
  for (; i < ln; i++) {
    items[i].removeCls(cls);
  }
}, doAddItemCls:function(cls) {
  var items = this.getViewItems(), ln = items.length, i = 0;
  for (; i < ln; i++) {
    items[i].addCls(cls);
  }
}, updateAtNewIndex:function(oldIndex, newIndex, record) {
  this.moveItemsToCache(oldIndex, oldIndex);
  this.moveItemsFromCache([record]);
}, destroy:function() {
  var me = this, itemCache = me.itemCache, ln = itemCache.length, i = 0;
  for (; i < ln; i++) {
    itemCache[i].destroy();
  }
  Ext.Container.prototype.destroy.call(this);
}}, 1, 0, ['component', 'container'], {'component':true, 'container':true}, 0, 0, [Ext.dataview.component, 'Container'], 0);
Ext.cmd.derive('Ext.dataview.element.Container', Ext.Component, {doInitialize:function() {
  this.element.on({touchstart:'onItemTouchStart', touchend:'onItemTouchEnd', tap:'onItemTap', taphold:'onItemTapHold', touchmove:'onItemTouchMove', singletap:'onItemSingleTap', doubletap:'onItemDoubleTap', swipe:'onItemSwipe', delegate:'\x3e div', scope:this});
}, initialize:function() {
  Ext.Component.prototype.initialize.call(this);
  this.doInitialize();
}, updateBaseCls:function(newBaseCls, oldBaseCls) {
  var me = this;
  Ext.Component.prototype.updateBaseCls.call(this, newBaseCls + '-container', oldBaseCls);
}, onItemTouchStart:function(e) {
  var me = this, target = e.getTarget(), index = me.getViewItems().indexOf(target);
  Ext.get(target).on({touchmove:'onItemTouchMove', scope:me, single:true});
  me.fireEvent('itemtouchstart', me, Ext.get(target), index, e);
}, onItemTouchEnd:function(e) {
  var me = this, target = e.getTarget(), index = me.getViewItems().indexOf(target);
  Ext.get(target).un({touchmove:'onItemTouchMove', scope:me});
  me.fireEvent('itemtouchend', me, Ext.get(target), index, e);
}, onItemTouchMove:function(e) {
  var me = this, target = e.getTarget(), index = me.getViewItems().indexOf(target);
  me.fireEvent('itemtouchmove', me, Ext.get(target), index, e);
}, onItemTap:function(e) {
  var me = this, target = e.getTarget(), index = me.getViewItems().indexOf(target);
  me.fireEvent('itemtap', me, Ext.get(target), index, e);
}, onItemTapHold:function(e) {
  var me = this, target = e.getTarget(), index = me.getViewItems().indexOf(target);
  me.fireEvent('itemtaphold', me, Ext.get(target), index, e);
}, onItemDoubleTap:function(e) {
  var me = this, target = e.getTarget(), index = me.getViewItems().indexOf(target);
  me.fireEvent('itemdoubletap', me, Ext.get(target), index, e);
}, onItemSingleTap:function(e) {
  var me = this, target = e.getTarget(), index = me.getViewItems().indexOf(target);
  me.fireEvent('itemsingletap', me, Ext.get(target), index, e);
}, onItemSwipe:function(e) {
  var me = this, target = e.getTarget(), index = me.getViewItems().indexOf(target);
  me.fireEvent('itemswipe', me, Ext.get(target), index, e);
}, updateListItem:function(record, item) {
  var me = this, dataview = me.dataview, store = dataview.getStore(), index = store.indexOf(record), data = dataview.prepareData(record.getData(true), index, record);
  data.xcount = store.getCount();
  data.xindex = typeof data.xindex === 'number' ? data.xindex : index;
  item.innerHTML = dataview.getItemTpl().apply(data);
}, addListItem:function(index, record) {
  var me = this, dataview = me.dataview, store = dataview.getStore(), data = dataview.prepareData(record.getData(true), index, record), element = me.element, childNodes = element.dom.childNodes, ln = childNodes.length, wrapElement;
  data.xcount = typeof data.xcount === 'number' ? data.xcount : store.getCount();
  data.xindex = typeof data.xindex === 'number' ? data.xindex : index;
  wrapElement = Ext.Element.create(this.getItemElementConfig(index, data));
  if (!ln || index == ln) {
    wrapElement.appendTo(element);
  } else {
    wrapElement.insertBefore(childNodes[index]);
  }
}, getItemElementConfig:function(index, data) {
  var dataview = this.dataview, itemCls = dataview.getItemCls(), cls = dataview.getBaseCls() + '-item';
  if (itemCls) {
    cls += ' ' + itemCls;
  }
  return {cls:cls, html:dataview.getItemTpl().apply(data)};
}, doRemoveItemCls:function(cls) {
  var elements = this.getViewItems(), ln = elements.length, i = 0;
  for (; i < ln; i++) {
    Ext.fly(elements[i]).removeCls(cls);
  }
}, doAddItemCls:function(cls) {
  var elements = this.getViewItems(), ln = elements.length, i = 0;
  for (; i < ln; i++) {
    Ext.fly(elements[i]).addCls(cls);
  }
}, moveItemsToCache:function(from, to) {
  var me = this, items = me.getViewItems(), i = to - from, item;
  for (; i >= 0; i--) {
    item = items[from + i];
    Ext.get(item).destroy();
  }
  if (me.getViewItems().length == 0) {
    this.dataview.showEmptyText();
  }
}, moveItemsFromCache:function(records) {
  var me = this, dataview = me.dataview, store = dataview.getStore(), ln = records.length, i, record;
  if (ln) {
    dataview.hideEmptyText();
  }
  for (i = 0; i < ln; i++) {
    records[i]._tmpIndex = store.indexOf(records[i]);
  }
  Ext.Array.sort(records, function(record1, record2) {
    return record1._tmpIndex > record2._tmpIndex ? 1 : -1;
  });
  for (i = 0; i < ln; i++) {
    record = records[i];
    me.addListItem(record._tmpIndex, record);
    delete record._tmpIndex;
  }
}, getViewItems:function() {
  return Array.prototype.slice.call(this.element.dom.childNodes);
}, updateAtNewIndex:function(oldIndex, newIndex, record) {
  this.moveItemsToCache(oldIndex, oldIndex);
  this.moveItemsFromCache([record]);
}, destroy:function() {
  var elements = this.getViewItems(), ln = elements.length, i = 0;
  for (; i < ln; i++) {
    Ext.get(elements[i]).destroy();
  }
  Ext.Component.prototype.destroy.call(this);
}}, 0, 0, ['component'], {'component':true}, 0, 0, [Ext.dataview.element, 'Container'], 0);
Ext.cmd.derive('Ext.dataview.DataView', Ext.Container, {alternateClassName:'Ext.DataView', config:{store:null, data:null, baseCls:'x-dataview', emptyText:null, deferEmptyText:true, itemTpl:'\x3cdiv\x3e{text}\x3c/div\x3e', pressedCls:'x-item-pressed', itemCls:null, selectedCls:'x-item-selected', triggerEvent:'itemtap', triggerCtEvent:'tap', deselectOnContainerClick:true, scrollable:true, inline:null, pressedDelay:100, loadingText:'Loading...', useComponents:null, itemConfig:{}, maxItemCache:20, defaultType:'dataitem', 
scrollToTopOnRefresh:true}, constructor:function(config) {
  var me = this, layout;
  me.hasLoadedStore = false;
  me.mixins.selectable.constructor.apply(me, arguments);
  me.indexOffset = 0;
  Ext.Container.prototype.constructor.apply(this, arguments);
}, updateItemCls:function(newCls, oldCls) {
  var container = this.container;
  if (container) {
    if (oldCls) {
      container.doRemoveItemCls(oldCls);
    }
    if (newCls) {
      container.doAddItemCls(newCls);
    }
  }
}, storeEventHooks:{beforeload:'onBeforeLoad', load:'onLoad', refresh:'refresh', addrecords:'onStoreAdd', removerecords:'onStoreRemove', updaterecord:'onStoreUpdate'}, initialize:function() {
  Ext.Container.prototype.initialize.call(this);
  var me = this, container, triggerEvent = me.getTriggerEvent();
  me.on(me.getTriggerCtEvent(), me.onContainerTrigger, me);
  container = me.container = this.add(new (Ext.dataview[me.getUseComponents() ? 'component' : 'element'].Container)({baseCls:this.getBaseCls()}));
  container.dataview = me;
  if (triggerEvent) {
    me.on(triggerEvent, me.onItemTrigger, me);
  }
  container.on({itemtouchstart:'onItemTouchStart', itemtouchend:'onItemTouchEnd', itemtap:'onItemTap', itemtaphold:'onItemTapHold', itemtouchmove:'onItemTouchMove', itemsingletap:'onItemSingleTap', itemdoubletap:'onItemDoubleTap', itemswipe:'onItemSwipe', scope:me});
  if (me.getStore()) {
    if (me.isPainted()) {
      me.refresh();
    } else {
      me.on({painted:'refresh', single:true});
    }
  }
}, applyInline:function(config) {
  if (Ext.isObject(config)) {
    config = Ext.apply({}, config);
  }
  return config;
}, updateInline:function(newInline, oldInline) {
  var baseCls = this.getBaseCls();
  if (oldInline) {
    this.removeCls([baseCls + '-inlineblock', baseCls + '-nowrap']);
  }
  if (newInline) {
    this.addCls(baseCls + '-inlineblock');
    if (Ext.isObject(newInline) && newInline.wrap === false) {
      this.addCls(baseCls + '-nowrap');
    } else {
      this.removeCls(baseCls + '-nowrap');
    }
  }
}, prepareData:function(data, index, record) {
  return data;
}, onContainerTrigger:function(e) {
  var me = this;
  if (e.target != me.element.dom) {
    return;
  }
  if (me.getDeselectOnContainerClick() && me.getStore()) {
    me.deselectAll();
  }
}, onItemTrigger:function(me, index) {
  if (!this.isDestroyed) {
    this.selectWithEvent(this.getStore().getAt(index));
  }
}, doAddPressedCls:function(record) {
  var me = this, item = me.getItemAt(me.getStore().indexOf(record));
  if (Ext.isElement(item)) {
    item = Ext.get(item);
  }
  if (item) {
    if (item.isComponent) {
      item.renderElement.addCls(me.getPressedCls());
    } else {
      item.addCls(me.getPressedCls());
    }
  }
}, onItemTouchStart:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  me.fireAction('itemtouchstart', [me, index, target, record, e], 'doItemTouchStart');
}, doItemTouchStart:function(me, index, target, record) {
  var pressedDelay = me.getPressedDelay();
  if (record) {
    if (pressedDelay > 0) {
      me.pressedTimeout = Ext.defer(me.doAddPressedCls, pressedDelay, me, [record]);
    } else {
      me.doAddPressedCls(record);
    }
  }
}, onItemTouchEnd:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  if (this.hasOwnProperty('pressedTimeout')) {
    clearTimeout(this.pressedTimeout);
    delete this.pressedTimeout;
  }
  if (record && target) {
    if (target.isComponent) {
      target.renderElement.removeCls(me.getPressedCls());
    } else {
      target.removeCls(me.getPressedCls());
    }
  }
  me.fireEvent('itemtouchend', me, index, target, record, e);
}, onItemTouchMove:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  if (me.hasOwnProperty('pressedTimeout')) {
    clearTimeout(me.pressedTimeout);
    delete me.pressedTimeout;
  }
  if (record && target) {
    if (target.isComponent) {
      target.renderElement.removeCls(me.getPressedCls());
    } else {
      target.removeCls(me.getPressedCls());
    }
  }
  me.fireEvent('itemtouchmove', me, index, target, record, e);
}, onItemTap:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  me.fireEvent('itemtap', me, index, target, record, e);
}, onItemTapHold:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  me.fireEvent('itemtaphold', me, index, target, record, e);
}, onItemSingleTap:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  me.fireEvent('itemsingletap', me, index, target, record, e);
}, onItemDoubleTap:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  me.fireEvent('itemdoubletap', me, index, target, record, e);
}, onItemSwipe:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  me.fireEvent('itemswipe', me, index, target, record, e);
}, onItemSelect:function(record, suppressEvent) {
  var me = this;
  if (suppressEvent) {
    me.doItemSelect(me, record);
  } else {
    me.fireAction('select', [me, record], 'doItemSelect');
  }
}, doItemSelect:function(me, record) {
  if (me.container && !me.isDestroyed) {
    var item = me.getItemAt(me.getStore().indexOf(record));
    if (Ext.isElement(item)) {
      item = Ext.get(item);
    }
    if (item) {
      if (item.isComponent) {
        item.renderElement.removeCls(me.getPressedCls());
        item.renderElement.addCls(me.getSelectedCls());
      } else {
        item.removeCls(me.getPressedCls());
        item.addCls(me.getSelectedCls());
      }
    }
  }
}, onItemDeselect:function(record, suppressEvent) {
  var me = this;
  if (me.container && !me.isDestroyed) {
    if (suppressEvent) {
      me.doItemDeselect(me, record);
    } else {
      me.fireAction('deselect', [me, record, suppressEvent], 'doItemDeselect');
    }
  }
}, doItemDeselect:function(me, record) {
  var item = me.getItemAt(me.getStore().indexOf(record));
  if (Ext.isElement(item)) {
    item = Ext.get(item);
  }
  if (item) {
    if (item.isComponent) {
      item.renderElement.removeCls([me.getPressedCls(), me.getSelectedCls()]);
    } else {
      item.removeCls([me.getPressedCls(), me.getSelectedCls()]);
    }
  }
}, updateData:function(data) {
  var store = this.getStore();
  if (!store) {
    this.setStore(Ext.create('Ext.data.Store', {data:data, autoDestroy:true}));
  } else {
    store.add(data);
  }
}, applyStore:function(store) {
  var me = this, bindEvents = Ext.apply({}, me.storeEventHooks, {scope:me}), proxy, reader;
  if (store) {
    store = Ext.data.StoreManager.lookup(store);
    if (store && Ext.isObject(store) && store.isStore) {
      store.on(bindEvents);
      proxy = store.getProxy();
      if (proxy) {
        reader = proxy.getReader();
        if (reader) {
          reader.on('exception', 'handleException', this);
        }
      }
    }
  }
  return store;
}, handleException:function() {
  this.setMasked(false);
}, updateStore:function(newStore, oldStore) {
  var me = this, bindEvents = Ext.apply({}, me.storeEventHooks, {scope:me}), proxy, reader;
  if (oldStore && Ext.isObject(oldStore) && oldStore.isStore) {
    oldStore.un(bindEvents);
    if (!me.isDestroyed) {
      me.onStoreClear();
    }
    if (oldStore.getAutoDestroy()) {
      oldStore.destroy();
    } else {
      proxy = oldStore.getProxy();
      if (proxy) {
        reader = proxy.getReader();
        if (reader) {
          reader.un('exception', 'handleException', this);
        }
      }
    }
  }
  if (newStore) {
    if (newStore.isLoaded()) {
      this.hasLoadedStore = true;
    }
    if (newStore.isLoading()) {
      me.onBeforeLoad();
    }
    if (me.container) {
      me.refresh();
    }
  }
}, onBeforeLoad:function() {
  var loadingText = this.getLoadingText();
  if (loadingText && this.isPainted()) {
    this.setMasked({xtype:'loadmask', message:loadingText});
  }
  this.hideEmptyText();
}, updateEmptyText:function(newEmptyText, oldEmptyText) {
  var me = this, store;
  if (oldEmptyText && me.emptyTextCmp) {
    me.remove(me.emptyTextCmp, true);
    delete me.emptyTextCmp;
  }
  if (newEmptyText) {
    me.emptyTextCmp = me.add({xtype:'component', cls:me.getBaseCls() + '-emptytext', html:newEmptyText, hidden:true});
    store = me.getStore();
    if (store && me.hasLoadedStore && !store.getCount()) {
      this.showEmptyText();
    }
  }
}, onLoad:function(store) {
  this.hasLoadedStore = true;
  this.setMasked(false);
  if (!store.getCount()) {
    this.showEmptyText();
  }
}, refresh:function() {
  var me = this, container = me.container;
  if (!me.getStore()) {
    if (!me.hasLoadedStore && !me.getDeferEmptyText()) {
      me.showEmptyText();
    }
    return;
  }
  if (container) {
    me.fireAction('refresh', [me], 'doRefresh');
  }
}, applyItemTpl:function(config) {
  return Ext.isObject(config) && config.isTemplate ? config : new Ext.XTemplate(config);
}, onAfterRender:function() {
  var me = this;
  me.callParent(arguments);
  me.updateStore(me.getStore());
}, getItemAt:function(index) {
  return this.getViewItems()[index - this.indexOffset];
}, getItemIndex:function(item) {
  var index = this.getViewItems().indexOf(item);
  return index === -1 ? index : this.indexOffset + index;
}, getViewItems:function() {
  return this.container.getViewItems();
}, doRefresh:function(me) {
  var container = me.container, store = me.getStore(), records = store.getRange(), items = me.getViewItems(), recordsLn = records.length, itemsLn = items.length, deltaLn = recordsLn - itemsLn, scrollable = me.getScrollable(), i, item;
  if (this.getScrollToTopOnRefresh() && scrollable) {
    scrollable.getScroller().scrollToTop();
  }
  if (recordsLn < 1) {
    me.onStoreClear();
    return;
  } else {
    me.hideEmptyText();
  }
  if (deltaLn < 0) {
    container.moveItemsToCache(itemsLn + deltaLn, itemsLn - 1);
    items = me.getViewItems();
    itemsLn = items.length;
  } else {
    if (deltaLn > 0) {
      container.moveItemsFromCache(store.getRange(itemsLn));
    }
  }
  for (i = 0; i < itemsLn; i++) {
    item = items[i];
    container.updateListItem(records[i], item);
  }
  if (this.hasSelection()) {
    var selection = this.getSelection(), selectionLn = this.getSelectionCount(), record;
    for (i = 0; i < selectionLn; i++) {
      record = selection[i];
      this.doItemSelect(this, record);
    }
  }
}, showEmptyText:function() {
  if (this.getEmptyText() && (this.hasLoadedStore || !this.getDeferEmptyText())) {
    this.emptyTextCmp.show();
  }
}, hideEmptyText:function() {
  if (this.getEmptyText()) {
    this.emptyTextCmp.hide();
  }
}, destroy:function() {
  var store = this.getStore(), proxy = store && store.getProxy(), reader = proxy && proxy.getReader();
  if (reader) {
    reader.clearListeners();
  }
  Ext.Container.prototype.destroy.apply(this, arguments);
  this.setStore(null);
}, onStoreClear:function() {
  var me = this, container = me.container, items = me.getViewItems();
  container.moveItemsToCache(0, items.length - 1);
  this.showEmptyText();
}, onStoreAdd:function(store, records) {
  if (records) {
    this.hideEmptyText();
    this.container.moveItemsFromCache(records);
  }
}, onStoreRemove:function(store, records, indices) {
  var container = this.container, ln = records.length, i;
  for (i = 0; i < ln; i++) {
    container.moveItemsToCache(indices[i], indices[i]);
  }
}, onStoreUpdate:function(store, record, newIndex, oldIndex) {
  var me = this, container = me.container, item;
  oldIndex = typeof oldIndex === 'undefined' ? newIndex : oldIndex;
  if (oldIndex !== newIndex) {
    container.updateAtNewIndex(oldIndex, newIndex, record);
    if (me.isSelected(record)) {
      me.doItemSelect(me, record);
    }
  } else {
    item = me.getViewItems()[newIndex];
    if (item) {
      container.updateListItem(record, item);
    }
  }
}}, 1, ['dataview'], ['component', 'container', 'dataview'], {'component':true, 'container':true, 'dataview':true}, ['widget.dataview'], [[Ext.mixin.Selectable.prototype.mixinId || Ext.mixin.Selectable.$className, Ext.mixin.Selectable]], [Ext.dataview, 'DataView', Ext, 'DataView'], 0);
Ext.cmd.derive('Ext.dataview.IndexBar', Ext.Component, {alternateClassName:'Ext.IndexBar', config:{baseCls:'x-indexbar', direction:'vertical', letters:['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'], ui:'alphabet', listPrefix:null}, platformConfig:[{theme:['Blackberry', 'Blackberry103'], direction:'vertical', letters:['*', '#', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 
'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']}], itemCls:'x-', updateDirection:function(newDirection, oldDirection) {
  var baseCls = this.getBaseCls();
  this.element.replaceCls(baseCls + '-' + oldDirection, baseCls + '-' + newDirection);
}, getElementConfig:function() {
  if (Ext.theme.is.Blackberry || Ext.theme.is.Blackberry103) {
    return {reference:'wrapper', classList:['x-centered', 'x-indexbar-wrapper'], children:[{reference:'indicator', classList:['x-indexbar-indicator'], hidden:true, children:[{reference:'indicatorInner', classList:['x-indexbar-indicator-inner']}]}, Ext.Component.prototype.getElementConfig.call(this)]};
  } else {
    return {reference:'wrapper', classList:['x-centered', 'x-indexbar-wrapper'], children:[Ext.Component.prototype.getElementConfig.call(this)]};
  }
}, updateLetters:function(letters) {
  this.innerElement.setHtml('');
  if (letters) {
    var ln = letters.length, i;
    for (i = 0; i < ln; i++) {
      this.innerElement.createChild({html:letters[i]});
    }
  }
}, updateListPrefix:function(listPrefix) {
  if (listPrefix && listPrefix.length) {
    this.innerElement.createChild({html:listPrefix}, 0);
  }
}, initialize:function() {
  Ext.Component.prototype.initialize.call(this);
  this.innerElement.on({touchstart:this.onTouchStart, touchend:this.onTouchEnd, dragend:this.onDragEnd, drag:this.onDrag, scope:this});
}, onTouchStart:function(e) {
  e.stopPropagation();
  this.innerElement.addCls(this.getBaseCls() + '-pressed');
  this.pageBox = this.innerElement.getPageBox();
  this.onDrag(e);
}, onTouchEnd:function(e) {
  this.onDragEnd();
}, onDragEnd:function() {
  this.innerElement.removeCls(this.getBaseCls() + '-pressed');
  if (this.indicator) {
    this.indicator.hide();
  }
}, onDrag:function(e) {
  var point = Ext.util.Point.fromEvent(e), target, isValidTarget, pageBox = this.pageBox;
  if (!pageBox) {
    pageBox = this.pageBox = this.el.getPageBox();
  }
  if (this.getDirection() === 'vertical') {
    if (point.y > pageBox.bottom || point.y < pageBox.top) {
      return;
    }
    target = Ext.Element.fromPoint(pageBox.left + pageBox.width / 2, point.y);
    isValidTarget = target.getParent() == this.element;
    if (this.indicator) {
      this.indicator.show();
      var halfIndicatorHeight = this.indicator.getHeight() / 2, y = point.y - this.element.getY();
      y = Math.min(Math.max(y, halfIndicatorHeight), this.element.getHeight() - halfIndicatorHeight);
      if (this.indicatorInner && isValidTarget) {
        this.indicatorInner.setHtml(target.getHtml().toUpperCase());
      }
      this.indicator.setTop(y - halfIndicatorHeight);
    }
  } else {
    if (point.x > pageBox.right || point.x < pageBox.left) {
      return;
    }
    target = Ext.Element.fromPoint(point.x, pageBox.top + pageBox.height / 2);
    isValidTarget = target.getParent() == this.element;
  }
  if (target && isValidTarget) {
    this.fireEvent('index', this, target.dom.innerHTML, target);
  }
}, destroy:function() {
  var me = this, elements = Array.prototype.slice.call(me.innerElement.dom.childNodes), ln = elements.length, i = 0;
  for (; i < ln; i++) {
    Ext.removeNode(elements[i]);
  }
  Ext.Component.prototype.destroy.call(this);
}}, 0, 0, ['component'], {'component':true}, 0, 0, [Ext.dataview, 'IndexBar', Ext, 'IndexBar'], function() {
});
Ext.cmd.derive('Ext.dataview.ListItemHeader', Ext.Component, {config:{baseCls:'x-list-header'}}, 0, ['listitemheader'], ['component', 'listitemheader'], {'component':true, 'listitemheader':true}, ['widget.listitemheader'], 0, [Ext.dataview, 'ListItemHeader'], 0);
Ext.cmd.derive('Ext.dataview.component.ListItem', Ext.dataview.component.DataItem, {config:{baseCls:'x-list-item', dataMap:null, body:{xtype:'component', cls:'x-list-item-body'}, disclosure:{xtype:'component', cls:'x-list-disclosure', hidden:true, docked:'right'}, header:{xtype:'component', cls:'x-list-header', html:' '}, tpl:null, items:null}, applyBody:function(body) {
  if (body && !body.isComponent) {
    body = Ext.factory(body, Ext.Component, this.getBody());
  }
  return body;
}, updateBody:function(body, oldBody) {
  if (body) {
    this.add(body);
  } else {
    if (oldBody) {
      oldBody.destroy();
    }
  }
}, applyHeader:function(header) {
  if (header && !header.isComponent) {
    header = Ext.factory(header, Ext.Component, this.getHeader());
  }
  return header;
}, updateHeader:function(header, oldHeader) {
  if (oldHeader) {
    oldHeader.destroy();
  }
}, applyDisclosure:function(disclosure) {
  if (disclosure && !disclosure.isComponent) {
    disclosure = Ext.factory(disclosure, Ext.Component, this.getDisclosure());
  }
  return disclosure;
}, updateDisclosure:function(disclosure, oldDisclosure) {
  if (disclosure) {
    this.add(disclosure);
  } else {
    if (oldDisclosure) {
      oldDisclosure.destroy();
    }
  }
}, updateTpl:function(tpl) {
  this.getBody().setTpl(tpl);
}, updateRecord:function(record) {
  var me = this, dataview = me.dataview || this.getDataview(), data = record && dataview.prepareData(record.getData(true), dataview.getStore().indexOf(record), record), dataMap = me.getDataMap(), body = this.getBody(), disclosure = this.getDisclosure();
  me._record = record;
  if (dataMap) {
    me.doMapData(dataMap, data, body);
  } else {
    if (body) {
      body.updateData(data || null);
    }
  }
  if (disclosure && record && dataview.getOnItemDisclosure()) {
    var disclosureProperty = dataview.getDisclosureProperty();
    disclosure[data.hasOwnProperty(disclosureProperty) && data[disclosureProperty] === false ? 'hide' : 'show']();
  }
  me.fireEvent('updatedata', me, data);
}, destroy:function() {
  Ext.destroy(this.getHeader());
  Ext.dataview.component.DataItem.prototype.destroy.apply(this, arguments);
}}, 0, ['listitem'], ['component', 'container', 'dataitem', 'listitem'], {'component':true, 'container':true, 'dataitem':true, 'listitem':true}, ['widget.listitem'], 0, [Ext.dataview.component, 'ListItem'], 0);
Ext.cmd.derive('Ext.dataview.component.SimpleListItem', Ext.Component, {config:{baseCls:'x-list-item', disclosure:{xtype:'component', cls:'x-list-disclosure', hidden:true}, header:{xtype:'component', cls:'x-list-header', html:' '}, dataview:null, record:null}, initialize:function() {
  this.element.addCls(this.getBaseCls() + '-tpl');
}, applyHeader:function(header) {
  if (header && !header.isComponent) {
    header = Ext.factory(header, Ext.Component, this.getHeader());
  }
  return header;
}, updateHeader:function(header, oldHeader) {
  if (oldHeader) {
    oldHeader.destroy();
  }
}, applyDisclosure:function(disclosure) {
  if (disclosure && !disclosure.isComponent) {
    disclosure = Ext.factory(disclosure, Ext.Component, this.getDisclosure());
  }
  return disclosure;
}, updateDisclosure:function(disclosure, oldDisclosure) {
  if (disclosure) {
    this.element.appendChild(disclosure.renderElement);
  } else {
    if (oldDisclosure) {
      oldDisclosure.destroy();
    }
  }
}, updateRecord:function(record) {
  var me = this, dataview = me.dataview || this.getDataview(), data = record && dataview.prepareData(record.getData(true), dataview.getStore().indexOf(record), record), disclosure = this.getDisclosure();
  me.updateData(data || null);
  if (disclosure && record && dataview.getOnItemDisclosure()) {
    var disclosureProperty = dataview.getDisclosureProperty();
    disclosure[data.hasOwnProperty(disclosureProperty) && data[disclosureProperty] === false ? 'hide' : 'show']();
  }
}, destroy:function() {
  Ext.destroy(this.getHeader(), this.getDisclosure());
  Ext.Component.prototype.destroy.apply(this, arguments);
}}, 0, ['simplelistitem'], ['component', 'simplelistitem'], {'component':true, 'simplelistitem':true}, ['widget.simplelistitem'], 0, [Ext.dataview.component, 'SimpleListItem'], 0);
Ext.cmd.derive('Ext.util.PositionMap', Ext.Base, {config:{minimumHeight:50}, constructor:function(config) {
  this.map = [];
  this.adjustments = {};
  this.offset = 0;
  this.initConfig(config);
}, populate:function(count, offset) {
  var map = this.map = this.map || [], minimumHeight = this.getMinimumHeight(), i, previousIndex, ln;
  offset = offset || 0;
  count++;
  map.length = count;
  map[0] = 0;
  for (i = offset + 1, ln = count - 1; i <= ln; i++) {
    previousIndex = i - 1;
    map[i] = map[previousIndex] + minimumHeight;
  }
  this.adjustments = {indices:[], heights:{}};
  this.offset = 0;
  for (i = 1, ln = count - 1; i <= ln; i++) {
    previousIndex = i - 1;
    this.offset += map[i] - map[previousIndex] - minimumHeight;
  }
}, setItemHeight:function(index, height) {
  height = Math.max(height, this.getMinimumHeight());
  if (height !== this.getItemHeight(index)) {
    var adjustments = this.adjustments;
    adjustments.indices.push(parseInt(index, 10));
    adjustments.heights[index] = height;
  }
}, update:function() {
  var adjustments = this.adjustments, indices = adjustments.indices, heights = adjustments.heights, map = this.map, ln = indices.length, minimumHeight = this.getMinimumHeight(), difference = 0, i, j, height, index, nextIndex, currentHeight;
  if (!adjustments.indices.length) {
    return false;
  }
  Ext.Array.sort(indices, function(a, b) {
    return a - b;
  });
  for (i = 0; i < ln; i++) {
    index = indices[i];
    nextIndex = indices[i + 1] || map.length - 1;
    currentHeight = map[index + 1] !== undefined ? map[index + 1] - map[index] + difference : minimumHeight;
    height = heights[index];
    difference += height - currentHeight;
    for (j = index + 1; j <= nextIndex; j++) {
      map[j] += difference;
    }
  }
  this.offset += difference;
  this.adjustments = {indices:[], heights:{}};
  return true;
}, getItemHeight:function(index) {
  return this.map[index + 1] - this.map[index];
}, getTotalHeight:function() {
  return (this.map.length - 1) * this.getMinimumHeight() + this.offset;
}, findIndex:function(pos) {
  return this.map.length ? this.binarySearch(this.map, pos) : 0;
}, binarySearch:function(sorted, value) {
  var start = 0, end = sorted.length;
  if (value < sorted[0]) {
    return 0;
  }
  if (value > sorted[end - 1]) {
    return end - 1;
  }
  while (start + 1 < end) {
    var mid = start + end >> 1, val = sorted[mid];
    if (val == value) {
      return mid;
    } else {
      if (val < value) {
        start = mid;
      } else {
        end = mid;
      }
    }
  }
  return start;
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'PositionMap'], 0);
Ext.cmd.derive('Ext.dataview.List', Ext.dataview.DataView, {alternateClassName:'Ext.List', config:{layout:'fit', indexBar:false, icon:null, preventSelectionOnDisclose:true, baseCls:'x-list', pinHeaders:true, grouped:null, onItemDisclosure:null, disclosureProperty:'disclosure', ui:'normal', defaultType:undefined, itemMap:{}, itemHeight:42, variableHeights:false, refreshHeightOnUpdate:true, infinite:false, useSimpleItems:true, scrollable:null, bufferSize:20, minimumBufferDistance:5, striped:false}, 
platformConfig:[{theme:['Windows'], itemHeight:44}, {theme:['Cupertino'], itemHeight:43}], topRenderedIndex:0, topVisibleIndex:0, visibleCount:0, constructor:function() {
  var me = this, layout;
  Ext.dataview.DataView.prototype.constructor.apply(this, arguments);
}, beforeInitialize:function() {
  var me = this, container = me.container, baseCls = me.getBaseCls(), scrollable, scrollViewElement, pinnedHeader;
  Ext.apply(me, {listItems:[], headerItems:[], updatedItems:[], headerMap:[], scrollDockItems:{top:[], bottom:[]}});
  this.translationMethod = Ext.browser.is.AndroidStock2 ? 'cssposition' : 'csstransform';
  if (!container) {
    container = me.container = Ext.factory({xtype:'container', scrollable:{scroller:{autoRefresh:!me.getInfinite(), direction:'vertical'}}});
  }
  me.add(container);
  scrollable = container.getScrollable();
  scrollViewElement = me.scrollViewElement = scrollable.getElement();
  me.scrollElement = scrollable.getScroller().getElement();
  me.setScrollable(scrollable);
  me.scrollableBehavior = container.getScrollableBehavior();
  pinnedHeader = me.pinnedHeader = Ext.factory({xtype:'listitemheader', html:'\x26nbsp;', translatable:{translationMethod:this.translationMethod}, cls:[baseCls + '-header', baseCls + '-header-swap']});
  pinnedHeader.translate(0, -10000);
  pinnedHeader.$position = -10000;
  scrollViewElement.insertFirst(pinnedHeader.renderElement);
  me.bind(scrollable.getScroller().getTranslatable(), 'doTranslate', 'onTranslate');
}, initialize:function() {
  var me = this, container = me.container, scrollViewElement = me.scrollViewElement, indexBar = me.getIndexBar(), triggerEvent = me.getTriggerEvent(), triggerCtEvent = me.getTriggerCtEvent();
  if (indexBar) {
    scrollViewElement.appendChild(indexBar.renderElement);
  }
  if (triggerEvent) {
    me.on(triggerEvent, me.onItemTrigger, me);
  }
  if (triggerCtEvent) {
    me.on(triggerCtEvent, me.onContainerTrigger, me);
  }
  container.element.on({delegate:'.' + me.getBaseCls() + '-disclosure', tap:'handleItemDisclosure', scope:me});
  container.element.on({resize:'onContainerResize', scope:me});
  container.innerElement.on({touchstart:'onItemTouchStart', touchend:'onItemTouchEnd', tap:'onItemTap', taphold:'onItemTapHold', singletap:'onItemSingleTap', doubletap:'onItemDoubleTap', swipe:'onItemSwipe', delegate:'.x-list-item', scope:me});
  if (me.getStore()) {
    me.refresh();
  }
}, onTranslate:function(x, y) {
  var me = this, pinnedHeader = me.pinnedHeader, store = me.getStore(), storeCount = store && store.getCount(), grouped = me.getGrouped(), infinite = me.getInfinite();
  if (!storeCount) {
    me.showEmptyText();
    me.showEmptyScrollDock();
    pinnedHeader.$position = -10000;
    pinnedHeader.translate(0, -10000);
  } else {
    if (infinite && me.itemsCount) {
      me.handleItemUpdates(y);
      me.handleItemHeights();
      me.handleItemTransforms();
      if (!me.onIdleBound) {
        Ext.AnimationQueue.onIdle(me.onAnimationIdle, me);
        me.onIdleBound = true;
      }
    }
  }
  if (grouped && me.groups && me.groups.length && me.getPinHeaders()) {
    me.handlePinnedHeader(y);
  }
  this.onScrollBinder(x, y);
}, onScrollBinder:function() {
}, handleItemUpdates:function(y) {
  var me = this, listItems = me.listItems, itemsCount = listItems.length, info = me.getListItemInfo(), itemMap = me.getItemMap(), bufferSize = me.getBufferSize(), lastIndex = me.getStore().getCount() - 1, minimumBufferDistance = me.getMinimumBufferDistance(), currentTopVisibleIndex = me.topVisibleIndex, topRenderedIndex = me.topRenderedIndex, updateCount, i, item, topVisibleIndex, bufferDistance, itemIndex;
  me.topVisibleIndex = topVisibleIndex = Math.max(0, itemMap.findIndex(-y) || 0);
  if (currentTopVisibleIndex !== topVisibleIndex) {
    if (currentTopVisibleIndex > topVisibleIndex) {
      bufferDistance = topVisibleIndex - topRenderedIndex;
      if (bufferDistance < minimumBufferDistance) {
        updateCount = Math.min(itemsCount, minimumBufferDistance - bufferDistance);
        if (updateCount == itemsCount) {
          me.topRenderedIndex = topRenderedIndex = Math.max(0, topVisibleIndex - (bufferSize - minimumBufferDistance));
          for (i = 0; i < updateCount; i++) {
            itemIndex = topRenderedIndex + i;
            item = listItems[i];
            me.updateListItem(item, itemIndex, info);
          }
        } else {
          for (i = 0; i < updateCount; i++) {
            itemIndex = topRenderedIndex - i - 1;
            if (itemIndex < 0) {
              break;
            }
            item = listItems.pop();
            listItems.unshift(item);
            me.updateListItem(item, itemIndex, info);
            me.topRenderedIndex--;
          }
        }
      }
    } else {
      bufferDistance = bufferSize - (topVisibleIndex - topRenderedIndex);
      if (bufferDistance < minimumBufferDistance) {
        updateCount = Math.min(itemsCount, minimumBufferDistance - bufferDistance);
        if (updateCount == itemsCount) {
          me.topRenderedIndex = topRenderedIndex = Math.min(lastIndex - itemsCount, topVisibleIndex - minimumBufferDistance);
          for (i = 0; i < updateCount; i++) {
            itemIndex = topRenderedIndex + i;
            item = listItems[i];
            me.updateListItem(item, itemIndex, info);
          }
        } else {
          for (i = 0; i < updateCount; i++) {
            itemIndex = topRenderedIndex + itemsCount + i;
            if (itemIndex > lastIndex) {
              break;
            }
            item = listItems.shift();
            listItems.push(item);
            me.updateListItem(item, itemIndex, info);
            me.topRenderedIndex++;
          }
        }
      }
    }
  }
}, onAnimationIdle:function() {
  var me = this, info = me.getListItemInfo(), bufferSize = me.getBufferSize(), topVisibleIndex = me.topVisibleIndex, topRenderedIndex = me.topRenderedIndex, lastIndex = me.getStore().getCount() - 1, listItems = me.listItems, itemsCount = listItems.length, topBufferDistance, bottomBufferDistance, i, ln, item, itemIndex;
  topBufferDistance = topVisibleIndex - topRenderedIndex;
  bottomBufferDistance = topRenderedIndex + bufferSize - topVisibleIndex;
  if (topBufferDistance < bottomBufferDistance) {
    if (topVisibleIndex > 0) {
      ln = bottomBufferDistance - topBufferDistance;
      for (i = 0; i < ln; i++) {
        itemIndex = topRenderedIndex - i - 1;
        if (itemIndex < 0) {
          break;
        }
        item = listItems.pop();
        listItems.unshift(item);
        me.updateListItem(item, itemIndex, info);
        me.topRenderedIndex--;
      }
    }
  } else {
    ln = topBufferDistance - bottomBufferDistance;
    for (i = 0; i < ln; i++) {
      itemIndex = topRenderedIndex + itemsCount + i;
      if (itemIndex > lastIndex) {
        break;
      }
      item = listItems.shift();
      listItems.push(item);
      me.updateListItem(item, itemIndex, info);
      me.topRenderedIndex++;
    }
  }
  me.handleItemHeights();
  me.handleItemTransforms();
  me.onIdleBound = false;
}, handleItemHeights:function() {
  var me = this, updatedItems = me.updatedItems, ln = updatedItems.length, itemMap = me.getItemMap(), useSimpleItems = me.getUseSimpleItems(), minimumHeight = itemMap.getMinimumHeight(), headerIndices = me.headerIndices, headerMap = me.headerMap, variableHeights = me.getVariableHeights(), itemIndex, i, j, jln, item, height, scrollDockHeight;
  for (i = 0; i < ln; i++) {
    item = updatedItems[i];
    itemIndex = item.$dataIndex;
    if (itemIndex !== null) {
      if (variableHeights) {
        height = useSimpleItems ? item.element.getHeight() : item.element.getFirstChild().getHeight();
        height = Math.max(height, minimumHeight);
      } else {
        height = minimumHeight;
      }
      item.$ownItemHeight = height;
      jln = me.scrollDockItems.top.length;
      if (item.isFirst) {
        me.totalScrollDockTopHeight = 0;
        for (j = 0; j < jln; j++) {
          scrollDockHeight = me.scrollDockItems.top[j].$scrollDockHeight;
          height += scrollDockHeight;
          me.totalScrollDockTopHeight += scrollDockHeight;
        }
      }
      jln = me.scrollDockItems.bottom.length;
      if (item.isLast) {
        for (j = 0; j < jln; j++) {
          scrollDockHeight = me.scrollDockItems.bottom[j].$scrollDockHeight;
          height += scrollDockHeight;
        }
      }
      if (headerIndices && headerIndices[itemIndex]) {
        height += me.headerHeight;
      }
      itemMap.setItemHeight(itemIndex, height);
      item.$height = height;
    }
  }
  itemMap.update();
  height = itemMap.getTotalHeight();
  headerMap.length = 0;
  for (i in headerIndices) {
    if (headerIndices.hasOwnProperty(i)) {
      headerMap.push(itemMap.map[i]);
    }
  }
  me.setScrollerHeight(height);
  me.updatedItems.length = 0;
}, setScrollerHeight:function(height) {
  var me = this, scroller = me.container.getScrollable().getScroller(), translatable = scroller.getTranslatable();
  if (height != scroller.givenSize) {
    scroller.setSize(height);
    scroller.refreshMaxPosition();
    scroller.fireEvent('refresh', scroller);
    if (translatable.isAnimating && translatable.activeEasingY && translatable.activeEasingY.setMinMomentumValue) {
      translatable.activeEasingY.setMinMomentumValue(-scroller.getMaxPosition().y);
    }
  }
}, handleItemTransforms:function() {
  var me = this, listItems = me.listItems, itemsCount = listItems.length, itemMap = me.getItemMap(), scrollDockItems = me.scrollDockItems, grouped = me.getGrouped(), item, transY, i, jln, j;
  for (i = 0; i < itemsCount; i++) {
    item = listItems[i];
    transY = itemMap.map[item.$dataIndex];
    if (!item.$hidden && item.$position !== transY) {
      item.$position = transY;
      jln = scrollDockItems.top.length;
      if (item.isFirst && jln) {
        for (j = 0; j < jln; j++) {
          scrollDockItems.top[j].translate(0, transY);
          transY += scrollDockItems.top[j].$scrollDockHeight;
        }
      }
      if (grouped && me.headerIndices && me.headerIndices[item.$dataIndex]) {
        item.getHeader().translate(0, transY);
        transY += me.headerHeight;
      }
      item.translate(0, transY);
      transY += item.$ownItemHeight;
      jln = scrollDockItems.bottom.length;
      if (item.isLast && jln) {
        for (j = 0; j < jln; j++) {
          scrollDockItems.bottom[j].translate(0, transY);
          transY += scrollDockItems.bottom[j].$scrollDockHeight;
        }
      }
    }
  }
}, handlePinnedHeader:function(y) {
  var me = this, pinnedHeader = me.pinnedHeader, itemMap = me.getItemMap(), groups = me.groups, headerMap = me.headerMap, headerHeight = me.headerHeight, store = me.getStore(), totalScrollDockTopHeight = me.totalScrollDockTopHeight, record, closestHeader, pushedHeader, transY, headerString;
  closestHeader = itemMap.binarySearch(headerMap, -y);
  record = groups[closestHeader].children[0];
  if (record) {
    pushedHeader = y + headerMap[closestHeader + 1] - headerHeight;
    if (y >= 0 || closestHeader === 0 && totalScrollDockTopHeight + y >= 0 || closestHeader === 0 && -y <= headerMap[closestHeader]) {
      transY = -10000;
    } else {
      if (pushedHeader < 0) {
        transY = pushedHeader;
      } else {
        transY = Math.max(0, y);
      }
    }
    headerString = store.getGroupString(record);
    if (pinnedHeader.$currentHeader != headerString) {
      pinnedHeader.setHtml(headerString);
      pinnedHeader.$currentHeader = headerString;
    }
    if (pinnedHeader.$position != transY) {
      pinnedHeader.translate(0, transY);
      pinnedHeader.$position = transY;
    }
  }
}, createItem:function(config) {
  var me = this, container = me.container, listItems = me.listItems, infinite = me.getInfinite(), scrollElement = me.scrollElement, item, header, itemCls;
  item = Ext.factory(config);
  item.dataview = me;
  item.$height = config.minHeight;
  if (!infinite) {
    itemCls = me.getBaseCls() + '-item-relative';
    item.addCls(itemCls);
  }
  header = item.getHeader();
  if (!infinite) {
    header.addCls(itemCls);
  } else {
    header.setTranslatable({translationMethod:this.translationMethod});
    header.translate(0, -10000);
    scrollElement.insertFirst(header.renderElement);
  }
  container.doAdd(item);
  listItems.push(item);
  return item;
}, setItemsCount:function(itemsCount) {
  var me = this, listItems = me.listItems, config = me.getListItemConfig(), difference = itemsCount - listItems.length, i;
  for (i = 0; i < difference; i++) {
    me.createItem(config);
  }
  for (i = difference; i < 0; i++) {
    listItems.pop().destroy();
  }
  me.itemsCount = itemsCount;
  me.updateAllListItems();
  if (Ext.browser.is.AndroidStock && me.container.element && itemsCount === 0 && difference !== 0) {
    me.container.element.redraw();
  }
  return me.listItems;
}, updateUi:function(newUi, oldUi) {
  if (newUi && newUi != oldUi && newUi == 'round') {
    this.setPinHeaders(false);
  }
  Ext.dataview.DataView.prototype.updateUi.apply(this, arguments);
}, updateListItem:function(item, index, info) {
  var me = this, record = info.store.getAt(index), headerIndices = me.headerIndices, footerIndices = me.footerIndices, header = item.getHeader(), scrollDockItems = me.scrollDockItems, updatedItems = me.updatedItems, currentItemCls = item.renderElement.classList.slice(), currentHeaderCls = header.renderElement.classList.slice(), infinite = me.getInfinite(), storeCount = info.store.getCount(), itemCls = [], headerCls = [], itemRemoveCls = [info.headerCls, info.footerCls, info.firstCls, info.lastCls, 
  info.selectedCls, info.stripeCls], headerRemoveCls = [info.headerCls, info.footerCls, info.firstCls, info.lastCls], ln, i, scrollDockItem, classCache;
  if (infinite) {
    item.$position = -10000;
  }
  if (!record) {
    item.setRecord(null);
    if (infinite) {
      item.translate(0, -10000);
    } else {
      item.hide();
    }
    if (infinite) {
      header.translate(0, -10000);
    } else {
      header.hide();
    }
    item.$hidden = true;
    return;
  } else {
    if (item.$hidden) {
      if (!infinite) {
        item.show();
      }
      item.$hidden = false;
    }
  }
  if (infinite) {
    updatedItems.push(item);
  }
  if (item.isFirst && index !== 0 && scrollDockItems.top.length) {
    for (i = 0, ln = scrollDockItems.top.length; i < ln; i++) {
      scrollDockItem = scrollDockItems.top[i];
      if (infinite) {
        scrollDockItem.translate(0, -10000);
      }
    }
    item.isFirst = false;
  }
  if (item.isLast && index !== storeCount - 1 && scrollDockItems.bottom.length) {
    for (i = 0, ln = scrollDockItems.bottom.length; i < ln; i++) {
      scrollDockItem = scrollDockItems.bottom[i];
      if (infinite) {
        scrollDockItem.translate(0, -10000);
      }
    }
    item.isLast = false;
  }
  if (item.$dataIndex !== index) {
    item.$dataIndex = index;
    me.fireEvent('itemindexchange', me, record, index, item);
  }
  if (item.getRecord() === record) {
    item.updateRecord(record);
  } else {
    item.setRecord(record);
  }
  if (me.isSelected(record)) {
    itemCls.push(info.selectedCls);
  }
  if (info.grouped) {
    if (headerIndices[index]) {
      itemCls.push(info.headerCls);
      headerCls.push(info.headerCls);
      header.setHtml(info.store.getGroupString(record));
      if (!infinite) {
        header.renderElement.insertBefore(item.renderElement);
      }
      header.show();
    } else {
      if (infinite) {
        header.translate(0, -10000);
      } else {
        header.hide();
      }
    }
    if (footerIndices[index]) {
      itemCls.push(info.footerCls);
      headerCls.push(info.footerCls);
    }
  }
  if (!info.grouped) {
    header.hide();
  }
  if (index === 0) {
    item.isFirst = true;
    itemCls.push(info.firstCls);
    headerCls.push(info.firstCls);
    if (!info.grouped) {
      itemCls.push(info.headerCls);
      headerCls.push(info.headerCls);
    }
    if (!infinite) {
      for (i = 0, ln = scrollDockItems.top.length; i < ln; i++) {
        scrollDockItem = scrollDockItems.top[i];
        if (info.grouped) {
          scrollDockItem.renderElement.insertBefore(header.renderElement);
        } else {
          scrollDockItem.renderElement.insertBefore(item.renderElement);
        }
      }
    }
  }
  if (index === storeCount - 1) {
    item.isLast = true;
    itemCls.push(info.lastCls);
    headerCls.push(info.lastCls);
    if (!info.grouped) {
      itemCls.push(info.footerCls);
      headerCls.push(info.footerCls);
    }
    if (!infinite) {
      for (i = 0, ln = scrollDockItems.bottom.length; i < ln; i++) {
        scrollDockItem = scrollDockItems.bottom[i];
        scrollDockItem.renderElement.insertAfter(item.renderElement);
      }
    }
  }
  if (info.striped && index % 2 == 1) {
    itemCls.push(info.stripeCls);
  }
  if (currentItemCls) {
    for (i = 0; i < itemRemoveCls.length; i++) {
      Ext.Array.remove(currentItemCls, itemRemoveCls[i]);
    }
    itemCls = Ext.Array.merge(itemCls, currentItemCls);
  }
  if (currentHeaderCls) {
    for (i = 0; i < headerRemoveCls.length; i++) {
      Ext.Array.remove(currentHeaderCls, headerRemoveCls[i]);
    }
    headerCls = Ext.Array.merge(headerCls, currentHeaderCls);
  }
  classCache = itemCls.join(' ');
  if (item.classCache !== classCache) {
    item.renderElement.setCls(itemCls);
    item.classCache = classCache;
  }
  header.renderElement.setCls(headerCls);
}, updateAllListItems:function() {
  var me = this, store = me.getStore(), items = me.listItems, info = me.getListItemInfo(), topRenderedIndex = me.topRenderedIndex, i, ln;
  if (store) {
    for (i = 0, ln = items.length; i < ln; i++) {
      me.updateListItem(items[i], topRenderedIndex + i, info);
    }
  }
  if (me.isPainted()) {
    if (me.getInfinite() && store && store.getCount()) {
      me.handleItemHeights();
    }
    me.refreshScroller();
  }
}, doRefresh:function() {
  var me = this, infinite = me.getInfinite(), scroller = me.container.getScrollable().getScroller(), storeCount = me.getStore().getCount();
  if (infinite) {
    me.getItemMap().populate(storeCount, this.topRenderedIndex);
  }
  if (me.getGrouped()) {
    me.refreshHeaderIndices();
  }
  if (storeCount) {
    me.hideScrollDockItems();
    me.hideEmptyText();
    if (!infinite) {
      me.setItemsCount(storeCount);
      if (me.getScrollToTopOnRefresh()) {
        scroller.scrollTo(0, 0);
      }
    } else {
      if (me.getScrollToTopOnRefresh()) {
        me.topRenderedIndex = 0;
        me.topVisibleIndex = 0;
        scroller.position.y = 0;
      }
      me.updateAllListItems();
    }
  } else {
    me.onStoreClear();
  }
}, onContainerResize:function(container, size) {
  var me = this, currentVisibleCount = me.visibleCount;
  if (!me.headerHeight) {
    me.headerHeight = parseInt(me.pinnedHeader.renderElement.getHeight(), 10);
  }
  if (me.getInfinite()) {
    me.visibleCount = Math.ceil(size.height / me.getItemMap().getMinimumHeight());
    if (me.visibleCount != currentVisibleCount) {
      me.setItemsCount(me.visibleCount + me.getBufferSize());
      me.fireEvent('updatevisiblecount', this, me.visibleCount, currentVisibleCount);
    }
  } else {
    if (me.listItems.length && me.getGrouped() && me.getPinHeaders()) {
      me.updateHeaderMap();
    }
  }
}, refreshScroller:function() {
  var me = this;
  if (me.isPainted()) {
    if (!me.getInfinite() && me.getGrouped() && me.getPinHeaders()) {
      me.updateHeaderMap();
    }
    me.container.getScrollable().getScroller().refresh();
  }
}, updateHeaderMap:function() {
  var me = this, headerMap = me.headerMap, headerIndices = me.headerIndices, header, i;
  headerMap.length = 0;
  for (i in headerIndices) {
    if (headerIndices.hasOwnProperty(i)) {
      header = me.getItemAt(i).getHeader();
      headerMap.push(header.renderElement.dom.offsetTop);
    }
  }
}, applyVariableHeights:function(value) {
  if (!this.getInfinite()) {
    return true;
  }
  return value;
}, applyDefaultType:function(defaultType) {
  if (!defaultType) {
    defaultType = this.getUseSimpleItems() ? 'simplelistitem' : 'listitem';
  }
  return defaultType;
}, applyItemMap:function(itemMap) {
  return Ext.factory(itemMap, Ext.util.PositionMap, this.getItemMap());
}, updateItemHeight:function(itemHeight) {
  this.getItemMap().setMinimumHeight(itemHeight);
}, applyIndexBar:function(indexBar) {
  return Ext.factory(indexBar, Ext.dataview.IndexBar, this.getIndexBar());
}, updatePinHeaders:function(pinnedHeaders) {
  if (this.isPainted()) {
    this.pinnedHeader.translate(0, pinnedHeaders ? this.pinnedHeader.$position : -10000);
  }
}, updateItemTpl:function(newTpl) {
  var me = this, listItems = me.listItems, ln = listItems.length || 0, i, listItem;
  for (i = 0; i < ln; i++) {
    listItem = listItems[i];
    listItem.setTpl(newTpl);
  }
  me.updateAllListItems();
}, updateItemCls:function(newCls, oldCls) {
  var items = this.listItems, ln = items.length, i, item;
  for (i = 0; i < ln; i++) {
    item = items[i];
    item.removeCls(oldCls);
    item.addCls(newCls);
  }
}, updateIndexBar:function(indexBar, oldIndexBar) {
  var me = this, scrollViewElement = me.scrollViewElement;
  if (oldIndexBar) {
    oldIndexBar.un({index:'onIndex', scope:me});
    if (!indexBar) {
      me.element.removeCls(me.getBaseCls() + '-indexed');
    }
    if (scrollViewElement) {
      scrollViewElement.removeChild(oldIndexBar.renderElement);
    }
  }
  if (indexBar) {
    indexBar.on({index:'onIndex', scope:me});
    if (!oldIndexBar) {
      me.element.addCls(me.getBaseCls() + '-indexed');
    }
    if (scrollViewElement) {
      scrollViewElement.appendChild(indexBar.renderElement);
    }
  }
}, updateGrouped:function(grouped) {
  var me = this, baseCls = this.getBaseCls(), pinnedHeader = me.pinnedHeader, cls = baseCls + '-grouped', unCls = baseCls + '-ungrouped';
  if (pinnedHeader) {
    pinnedHeader.translate(0, -10000);
  }
  if (grouped) {
    me.addCls(cls);
    me.removeCls(unCls);
  } else {
    me.addCls(unCls);
    me.removeCls(cls);
  }
  if (me.getInfinite()) {
    me.refreshHeaderIndices();
    me.handleItemHeights();
  }
  me.updateAllListItems();
}, onStoreAdd:function() {
  this.doRefresh();
}, onStoreRemove:function() {
  this.doRefresh();
}, onStoreUpdate:function(store, record, newIndex, oldIndex) {
  var me = this, item;
  oldIndex = typeof oldIndex === 'undefined' ? newIndex : oldIndex;
  if (me.getInfinite() || oldIndex !== newIndex) {
    me.doRefresh();
  } else {
    item = me.listItems[newIndex];
    if (item) {
      me.updateListItem(item, newIndex, me.getListItemInfo());
    }
  }
}, onStoreClear:function() {
  var me = this, scroller = me.container.getScrollable().getScroller(), infinite = me.getInfinite();
  if (me.pinnedHeader) {
    me.pinnedHeader.translate(0, -10000);
  }
  if (!infinite) {
    me.setItemsCount(0);
    scroller.scrollTo(0, 0);
  } else {
    me.topRenderedIndex = 0;
    me.topVisibleIndex = 0;
    scroller.position.y = 0;
    me.updateAllListItems();
  }
}, showEmptyScrollDock:function() {
  var me = this, infinite = me.getInfinite(), scrollDockItems = me.scrollDockItems, offset = 0, i, ln, item;
  for (i = 0, ln = scrollDockItems.top.length; i < ln; i++) {
    item = scrollDockItems.top[i];
    if (infinite) {
      item.translate(0, offset);
      offset += item.$scrollDockHeight;
    } else {
      this.scrollElement.appendChild(item.renderElement);
    }
  }
  for (i = 0, ln = scrollDockItems.bottom.length; i < ln; i++) {
    item = scrollDockItems.bottom[i];
    if (infinite) {
      item.translate(0, offset);
      offset += item.$scrollDockHeight;
    } else {
      this.scrollElement.appendChild(item.renderElement);
    }
  }
}, hideScrollDockItems:function() {
  var me = this, infinite = me.getInfinite(), scrollDockItems = me.scrollDockItems, i, ln, item;
  if (!infinite) {
    return;
  }
  for (i = 0, ln = scrollDockItems.top.length; i < ln; i++) {
    item = scrollDockItems.top[i];
    item.translate(0, -10000);
  }
  for (i = 0, ln = scrollDockItems.bottom.length; i < ln; i++) {
    item = scrollDockItems.bottom[i];
    item.translate(0, -10000);
  }
}, getItemAt:function(index) {
  var listItems = this.listItems, ln = listItems.length, i, listItem;
  for (i = 0; i < ln; i++) {
    listItem = listItems[i];
    if (listItem.$dataIndex == index) {
      return listItem;
    }
  }
}, getItemIndex:function(item) {
  return item.$dataIndex;
}, getViewItems:function() {
  return this.listItems;
}, getListItemInfo:function() {
  var me = this, baseCls = me.getBaseCls();
  return {store:me.getStore(), grouped:me.getGrouped(), baseCls:baseCls, selectedCls:me.getSelectedCls(), headerCls:baseCls + '-header-wrap', footerCls:baseCls + '-footer-wrap', firstCls:baseCls + '-item-first', lastCls:baseCls + '-item-last', stripeCls:baseCls + '-item-odd', striped:me.getStriped(), itemMap:me.getItemMap(), defaultItemHeight:me.getItemHeight()};
}, getListItemConfig:function() {
  var me = this, minimumHeight = me.getItemMap().getMinimumHeight(), config = {xtype:me.getDefaultType(), itemConfig:me.getItemConfig(), tpl:me.getItemTpl(), minHeight:minimumHeight, cls:me.getItemCls()};
  if (me.getInfinite()) {
    config.translatable = {translationMethod:this.translationMethod};
  }
  if (!me.getVariableHeights()) {
    config.height = minimumHeight;
  }
  return config;
}, refreshHeaderIndices:function() {
  var me = this, store = me.getStore(), storeLn = store && store.getCount(), groups = store.getGrouper() ? store.getGroups() : null, grouped = me.getGrouped(), headerIndices = me.headerIndices = {}, footerIndices = me.footerIndices = {}, i, previousIndex, firstGroupedRecord, storeIndex, groupLn;
  if (!grouped || !groups) {
    return footerIndices;
  }
  groupLn = groups.length;
  me.groups = groups;
  for (i = 0; i < groupLn; i++) {
    firstGroupedRecord = groups[i].children[0];
    storeIndex = store.indexOf(firstGroupedRecord);
    headerIndices[storeIndex] = true;
    previousIndex = storeIndex - 1;
    if (previousIndex >= 0) {
      footerIndices[previousIndex] = true;
    }
  }
  footerIndices[storeLn - 1] = true;
  return headerIndices;
}, onIndex:function(indexBar, index) {
  var me = this, key = index.toLowerCase(), store = me.getStore(), groups = store.getGroups(), ln = groups.length, group, i, closest, id;
  for (i = 0; i < ln; i++) {
    group = groups[i];
    id = group.name.toLowerCase();
    if (id >= key) {
      closest = group;
      break;
    } else {
      closest = group;
    }
  }
  if (closest) {
    this.scrollToRecord(closest.children[0]);
  }
}, scrollToRecord:function(record, animate, overscroll) {
  var me = this, scroller = me.container.getScrollable().getScroller(), store = me.getStore(), index = store.indexOf(record);
  scroller.stopAnimation();
  var containerSize = scroller.getContainerSize().y, size = scroller.getSize().y, maxOffset = size - containerSize, offset, item;
  if (me.getInfinite()) {
    offset = me.getItemMap().map[index];
  } else {
    item = me.listItems[index];
    if (item.getHeader().isPainted()) {
      offset = item.getHeader().renderElement.dom.offsetTop;
    } else {
      offset = item.renderElement.dom.offsetTop;
    }
  }
  if (!overscroll) {
    offset = Math.min(offset, maxOffset);
  }
  scroller.scrollTo(0, offset, !!animate);
}, onItemAdd:function(item) {
  var me = this, config = item.config;
  if (config.scrollDock) {
    if (config.scrollDock == 'bottom') {
      me.scrollDockItems.bottom.push(item);
    } else {
      me.scrollDockItems.top.push(item);
    }
    if (me.getInfinite()) {
      item.on({resize:'onScrollDockItemResize', scope:this});
      item.addCls(me.getBaseCls() + '-scrolldockitem');
      item.setTranslatable({translationMethod:this.translationMethod});
      item.translate(0, -10000);
      item.$scrollDockHeight = 0;
    }
    me.container.doAdd(item);
  } else {
    Ext.dataview.DataView.prototype.onItemAdd.apply(this, arguments);
  }
}, getScrollDockedItems:function() {
  return this.scrollDockItems.bottom.slice().concat(this.scrollDockItems.top.slice());
}, onScrollDockItemResize:function(dockItem, size) {
  var me = this, items = me.listItems, ln = items.length, i, item;
  Ext.getCmp(dockItem.id).$scrollDockHeight = size.height;
  for (i = 0; i < ln; i++) {
    item = items[i];
    if (item.isLast) {
      this.updatedItems.push(item);
      this.refreshScroller();
      break;
    }
  }
}, onItemTouchStart:function(e) {
  this.container.innerElement.on({touchmove:'onItemTouchMove', delegate:'.x-list-item', single:true, scope:this});
  Ext.dataview.DataView.prototype.onItemTouchStart.apply(this, this.parseEvent(e));
}, onItemTouchMove:function(e) {
  Ext.dataview.DataView.prototype.onItemTouchMove.apply(this, this.parseEvent(e));
}, onItemTouchEnd:function(e) {
  this.container.innerElement.un({touchmove:'onItemTouchMove', delegate:'.x-list-item', scope:this});
  Ext.dataview.DataView.prototype.onItemTouchEnd.apply(this, this.parseEvent(e));
}, onItemTap:function(e) {
  Ext.dataview.DataView.prototype.onItemTap.apply(this, this.parseEvent(e));
}, onItemTapHold:function(e) {
  Ext.dataview.DataView.prototype.onItemTapHold.apply(this, this.parseEvent(e));
}, onItemSingleTap:function(e) {
  Ext.dataview.DataView.prototype.onItemSingleTap.apply(this, this.parseEvent(e));
}, onItemDoubleTap:function(e) {
  Ext.dataview.DataView.prototype.onItemDoubleTap.apply(this, this.parseEvent(e));
}, onItemSwipe:function(e) {
  Ext.dataview.DataView.prototype.onItemSwipe.apply(this, this.parseEvent(e));
}, parseEvent:function(e) {
  var me = this, target = Ext.fly(e.getTarget()).findParent('.x-list-item', 8), item = Ext.getCmp(target.id);
  return [me, item, item.$dataIndex, e];
}, doItemSelect:function(me, record) {
  Ext.dataview.DataView.prototype.doItemSelect.apply(this, arguments);
  var item = me.getItemAt(me.getStore().indexOf(record));
  if (me.container && !me.isDestroyed && item && item.isComponent) {
    item.classCache = item.renderElement.classList.slice();
  }
}, doItemDeselect:function(me, record) {
  Ext.dataview.DataView.prototype.doItemDeselect.apply(this, arguments);
  var item = me.getItemAt(me.getStore().indexOf(record));
  if (item && item.isComponent) {
    item.classCache = item.renderElement.classList.slice();
  }
}, applyOnItemDisclosure:function(config) {
  if (Ext.isFunction(config)) {
    return {scope:this, handler:config};
  }
  return config;
}, handleItemDisclosure:function(e) {
  var me = this, item = Ext.getCmp(Ext.get(e.getTarget()).up('.x-list-item').id), index = item.$dataIndex, record = me.getStore().getAt(index);
  me.fireAction('disclose', [me, record, item, index, e], 'doDisclose');
}, doDisclose:function(me, record, item, index, e) {
  var onItemDisclosure = me.getOnItemDisclosure();
  if (onItemDisclosure && onItemDisclosure.handler) {
    onItemDisclosure.handler.call(onItemDisclosure.scope || me, record, item, index, e);
  }
}, onItemTrigger:function(me, index, target, record, e) {
  if (!(this.getPreventSelectionOnDisclose() && Ext.fly(e.target).hasCls(this.getBaseCls() + '-disclosure'))) {
    Ext.dataview.DataView.prototype.onItemTrigger.apply(this, arguments);
  }
}, destroy:function() {
  var me = this, items = me.listItems, ln = items.length, i;
  Ext.dataview.DataView.prototype.destroy.apply(this, arguments);
  if (me.onIdleBound) {
    Ext.AnimationQueue.unIdle(me.onAnimationIdle, me);
  }
  for (i = 0; i < ln; i++) {
    items[i].destroy();
  }
  me.listItems = null;
}}, 1, ['list'], ['component', 'container', 'dataview', 'list'], {'component':true, 'container':true, 'dataview':true, 'list':true}, ['widget.list'], [[Ext.mixin.Bindable.prototype.mixinId || Ext.mixin.Bindable.$className, Ext.mixin.Bindable]], [Ext.dataview, 'List', Ext, 'List'], 0);
Ext.cmd.derive('Ext.util.DelayedTask', Ext.Base, {config:{interval:null, delay:null, fn:null, scope:null, args:null}, constructor:function(fn, scope, args) {
  var config = {fn:fn, scope:scope, args:args};
  this.initConfig(config);
}, delay:function(delay, newFn, newScope, newArgs) {
  var me = this;
  me.cancel();
  if (Ext.isNumber(delay)) {
    me.setDelay(delay);
  }
  if (Ext.isFunction(newFn)) {
    me.setFn(newFn);
  }
  if (newScope) {
    me.setScope(newScope);
  }
  if (newScope) {
    me.setArgs(newArgs);
  }
  var call = function() {
    me.getFn().apply(me.getScope(), me.getArgs() || []);
    me.cancel();
  };
  me.setInterval(setInterval(call, me.getDelay()));
}, cancel:function() {
  this.setInterval(null);
}, updateInterval:function(newInterval, oldInterval) {
  if (oldInterval) {
    clearInterval(oldInterval);
  }
}, applyArgs:function(config) {
  if (!Ext.isArray(config)) {
    config = [config];
  }
  return config;
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'DelayedTask'], 0);
Ext.cmd.derive('Ext.draw.Animator', Ext.Base, {singleton:true, frameCallbacks:{}, frameCallbackId:0, scheduled:0, frameStartTimeOffset:Date.now(), animations:[], running:false, animationTime:function() {
  return Ext.AnimationQueue.frameStartTime - this.frameStartTimeOffset;
}, add:function(animation) {
  if (!this.contains(animation)) {
    this.animations.push(animation);
    Ext.draw.Animator.ignite();
    if ('fireEvent' in animation) {
      animation.fireEvent('animationstart', animation);
    }
  }
}, remove:function(animation) {
  var me = this, animations = me.animations, i = 0, l = animations.length;
  for (; i < l; ++i) {
    if (animations[i] === animation) {
      animations.splice(i, 1);
      if ('fireEvent' in animation) {
        animation.fireEvent('animationend', animation);
      }
      return;
    }
  }
}, contains:function(animation) {
  return this.animations.indexOf(animation) > -1;
}, empty:function() {
  return this.animations.length === 0;
}, step:function(frameTime) {
  var me = this, animations = me.animations, animation, i = 0, ln = animations.length;
  for (; i < ln; i++) {
    animation = animations[i];
    animation.step(frameTime);
    if (!animation.animating) {
      animations.splice(i, 1);
      i--;
      ln--;
      if (animation.fireEvent) {
        animation.fireEvent('animationend');
      }
    }
  }
}, schedule:function(callback, scope) {
  scope = scope || this;
  var id = 'frameCallback' + this.frameCallbackId++;
  if (Ext.isString(callback)) {
    callback = scope[callback];
  }
  Ext.draw.Animator.frameCallbacks[id] = {fn:callback, scope:scope, once:true};
  this.scheduled++;
  Ext.draw.Animator.ignite();
  return id;
}, cancel:function(id) {
  if (Ext.draw.Animator.frameCallbacks[id] && Ext.draw.Animator.frameCallbacks[id].once) {
    this.scheduled--;
    delete Ext.draw.Animator.frameCallbacks[id];
  }
}, addFrameCallback:function(callback, scope) {
  scope = scope || this;
  if (Ext.isString(callback)) {
    callback = scope[callback];
  }
  var id = 'frameCallback' + this.frameCallbackId++;
  Ext.draw.Animator.frameCallbacks[id] = {fn:callback, scope:scope};
  return id;
}, removeFrameCallback:function(id) {
  delete Ext.draw.Animator.frameCallbacks[id];
}, fireFrameCallbacks:function() {
  var callbacks = this.frameCallbacks, id, fn, cb;
  for (id in callbacks) {
    cb = callbacks[id];
    fn = cb.fn;
    if (Ext.isString(fn)) {
      fn = cb.scope[fn];
    }
    fn.call(cb.scope);
    if (callbacks[id] && cb.once) {
      this.scheduled--;
      delete callbacks[id];
    }
  }
}, handleFrame:function() {
  this.step(this.animationTime());
  this.fireFrameCallbacks();
  if (!this.scheduled && this.empty()) {
    Ext.AnimationQueue.stop(this.handleFrame, this);
    this.running = false;
  }
}, ignite:function() {
  if (!this.running) {
    this.running = true;
    Ext.AnimationQueue.start(this.handleFrame, this);
    Ext.draw.Draw.updateIOS();
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.draw, 'Animator'], 0);
(function() {
  Ext.cmd.derive('Ext.draw.Color', Ext.Base, {statics:{colorToHexRe:/(.*?)rgb\((\d+),\s*(\d+),\s*(\d+)\)/, rgbToHexRe:/\s*rgb\((\d+),\s*(\d+),\s*(\d+)\)/, rgbaToHexRe:/\s*rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\.\d]+)\)/, hexRe:/\s*#([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)\s*/}, isColor:true, lightnessFactor:0.2, constructor:function(red, green, blue, alpha) {
    this.setRGB(red, green, blue, alpha);
  }, setRGB:function(red, green, blue, alpha) {
    var me = this;
    me.r = Math.min(255, Math.max(0, red));
    me.g = Math.min(255, Math.max(0, green));
    me.b = Math.min(255, Math.max(0, blue));
    if (alpha === undefined) {
      me.a = 1;
    } else {
      me.a = Math.min(1, Math.max(0, alpha));
    }
  }, getGrayscale:function() {
    return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
  }, getHSL:function(target) {
    var me = this, r = me.r / 255, g = me.g / 255, b = me.b / 255, max = Math.max(r, g, b), min = Math.min(r, g, b), delta = max - min, h, s = 0, l = 0.5 * (max + min);
    if (min !== max) {
      s = l < 0.5 ? delta / (max + min) : delta / (2 - max - min);
      if (r === max) {
        h = 60 * (g - b) / delta;
      } else {
        if (g === max) {
          h = 120 + 60 * (b - r) / delta;
        } else {
          h = 240 + 60 * (r - g) / delta;
        }
      }
      if (h < 0) {
        h += 360;
      }
      if (h >= 360) {
        h -= 360;
      }
    }
    if (target) {
      target[0] = h;
      target[1] = s;
      target[2] = l;
    } else {
      target = [h, s, l];
    }
    return target;
  }, setHSL:function(h, s, l) {
    var c, x, m, abs = Math.abs, floor = Math.floor;
    h = (h % 360 + 360) % 360;
    s = s > 1 ? 1 : s < 0 ? 0 : s;
    l = l > 1 ? 1 : l < 0 ? 0 : l;
    if (s === 0 || h === null) {
      l *= 255;
      this.setRGB(l, l, l);
    } else {
      h /= 60;
      c = s * (1 - abs(2 * l - 1));
      x = c * (1 - abs(h - 2 * floor(h / 2) - 1));
      m = l - c / 2;
      m *= 255;
      c *= 255;
      x *= 255;
      switch(floor(h)) {
        case 0:
          this.setRGB(c + m, x + m, m);
          break;
        case 1:
          this.setRGB(x + m, c + m, m);
          break;
        case 2:
          this.setRGB(m, c + m, x + m);
          break;
        case 3:
          this.setRGB(m, x + m, c + m);
          break;
        case 4:
          this.setRGB(x + m, m, c + m);
          break;
        case 5:
          this.setRGB(c + m, m, x + m);
          break;
      }
    }
    return this;
  }, createLighter:function(factor) {
    var hsl = this.getHSL();
    factor = factor || this.lightnessFactor;
    hsl[2] = hsl[2] + factor;
    if (hsl[2] > 1) {
      hsl[2] = 1;
    } else {
      if (hsl[2] < 0) {
        hsl[2] = 0;
      }
    }
    return Ext.draw.Color.fromHSL(hsl[0], hsl[1], hsl[2]);
  }, createDarker:function(factor) {
    factor = factor || this.lightnessFactor;
    return this.createLighter(-factor);
  }, toString:function() {
    if (this.a === 1) {
      var me = this, round = Math.round, r = round(me.r).toString(16), g = round(me.g).toString(16), b = round(me.b).toString(16);
      r = r.length === 1 ? '0' + r : r;
      g = g.length === 1 ? '0' + g : g;
      b = b.length === 1 ? '0' + b : b;
      return ['#', r, g, b].join('');
    } else {
      return 'rgba(' + [Math.round(this.r), Math.round(this.g), Math.round(this.b), this.a.toFixed(15)].join(',') + ')';
    }
  }, toHex:function(color) {
    if (Ext.isArray(color)) {
      color = color[0];
    }
    if (!Ext.isString(color)) {
      return '';
    }
    if (color.substr(0, 1) === '#') {
      return color;
    }
    var digits = Ext.draw.Color.colorToHexRe.exec(color);
    if (Ext.isArray(digits)) {
      var red = parseInt(digits[2], 10), green = parseInt(digits[3], 10), blue = parseInt(digits[4], 10), rgb = blue | green << 8 | red << 16;
      return digits[1] + '#' + ('000000' + rgb.toString(16)).slice(-6);
    } else {
      return '';
    }
  }, setFromString:function(str) {
    var values, r, g, b, a = 1, parse = parseInt;
    if (str === 'none') {
      this.r = this.g = this.b = this.a = 0;
      return this;
    }
    if ((str.length === 4 || str.length === 7) && str.substr(0, 1) === '#') {
      values = str.match(Ext.draw.Color.hexRe);
      if (values) {
        r = parse(values[1], 16) >> 0;
        g = parse(values[2], 16) >> 0;
        b = parse(values[3], 16) >> 0;
        if (str.length === 4) {
          r += r * 16;
          g += g * 16;
          b += b * 16;
        }
      }
    } else {
      if (values = str.match(Ext.draw.Color.rgbToHexRe)) {
        r = +values[1];
        g = +values[2];
        b = +values[3];
      } else {
        if (values = str.match(Ext.draw.Color.rgbaToHexRe)) {
          r = +values[1];
          g = +values[2];
          b = +values[3];
          a = +values[4];
        } else {
          if (Ext.draw.Color.ColorList.hasOwnProperty(str.toLowerCase())) {
            return this.setFromString(Ext.draw.Color.ColorList[str.toLowerCase()]);
          }
        }
      }
    }
    if (typeof r === 'undefined') {
      return this;
    }
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this;
  }}, 3, 0, 0, 0, 0, 0, [Ext.draw, 'Color'], function() {
    var flyColor = new this;
    this.addStatics({fly:function(r, g, b, a) {
      switch(arguments.length) {
        case 1:
          flyColor.setFromString(r);
          break;
        case 3:
        case 4:
          flyColor.setRGB(r, g, b, a);
          break;
        default:
          return null;
      }
      return flyColor;
    }, ColorList:{'aliceblue':'#f0f8ff', 'antiquewhite':'#faebd7', 'aqua':'#00ffff', 'aquamarine':'#7fffd4', 'azure':'#f0ffff', 'beige':'#f5f5dc', 'bisque':'#ffe4c4', 'black':'#000000', 'blanchedalmond':'#ffebcd', 'blue':'#0000ff', 'blueviolet':'#8a2be2', 'brown':'#a52a2a', 'burlywood':'#deb887', 'cadetblue':'#5f9ea0', 'chartreuse':'#7fff00', 'chocolate':'#d2691e', 'coral':'#ff7f50', 'cornflowerblue':'#6495ed', 'cornsilk':'#fff8dc', 'crimson':'#dc143c', 'cyan':'#00ffff', 'darkblue':'#00008b', 'darkcyan':'#008b8b', 
    'darkgoldenrod':'#b8860b', 'darkgray':'#a9a9a9', 'darkgreen':'#006400', 'darkkhaki':'#bdb76b', 'darkmagenta':'#8b008b', 'darkolivegreen':'#556b2f', 'darkorange':'#ff8c00', 'darkorchid':'#9932cc', 'darkred':'#8b0000', 'darksalmon':'#e9967a', 'darkseagreen':'#8fbc8f', 'darkslateblue':'#483d8b', 'darkslategray':'#2f4f4f', 'darkturquoise':'#00ced1', 'darkviolet':'#9400d3', 'deeppink':'#ff1493', 'deepskyblue':'#00bfff', 'dimgray':'#696969', 'dodgerblue':'#1e90ff', 'firebrick':'#b22222', 'floralwhite':'#fffaf0', 
    'forestgreen':'#228b22', 'fuchsia':'#ff00ff', 'gainsboro':'#dcdcdc', 'ghostwhite':'#f8f8ff', 'gold':'#ffd700', 'goldenrod':'#daa520', 'gray':'#808080', 'green':'#008000', 'greenyellow':'#adff2f', 'honeydew':'#f0fff0', 'hotpink':'#ff69b4', 'indianred ':'#cd5c5c', 'indigo ':'#4b0082', 'ivory':'#fffff0', 'khaki':'#f0e68c', 'lavender':'#e6e6fa', 'lavenderblush':'#fff0f5', 'lawngreen':'#7cfc00', 'lemonchiffon':'#fffacd', 'lightblue':'#add8e6', 'lightcoral':'#f08080', 'lightcyan':'#e0ffff', 'lightgoldenrodyellow':'#fafad2', 
    'lightgray':'#d3d3d3', 'lightgrey':'#d3d3d3', 'lightgreen':'#90ee90', 'lightpink':'#ffb6c1', 'lightsalmon':'#ffa07a', 'lightseagreen':'#20b2aa', 'lightskyblue':'#87cefa', 'lightslategray':'#778899', 'lightsteelblue':'#b0c4de', 'lightyellow':'#ffffe0', 'lime':'#00ff00', 'limegreen':'#32cd32', 'linen':'#faf0e6', 'magenta':'#ff00ff', 'maroon':'#800000', 'mediumaquamarine':'#66cdaa', 'mediumblue':'#0000cd', 'mediumorchid':'#ba55d3', 'mediumpurple':'#9370d8', 'mediumseagreen':'#3cb371', 'mediumslateblue':'#7b68ee', 
    'mediumspringgreen':'#00fa9a', 'mediumturquoise':'#48d1cc', 'mediumvioletred':'#c71585', 'midnightblue':'#191970', 'mintcream':'#f5fffa', 'mistyrose':'#ffe4e1', 'moccasin':'#ffe4b5', 'navajowhite':'#ffdead', 'navy':'#000080', 'oldlace':'#fdf5e6', 'olive':'#808000', 'olivedrab':'#6b8e23', 'orange':'#ffa500', 'orangered':'#ff4500', 'orchid':'#da70d6', 'palegoldenrod':'#eee8aa', 'palegreen':'#98fb98', 'paleturquoise':'#afeeee', 'palevioletred':'#d87093', 'papayawhip':'#ffefd5', 'peachpuff':'#ffdab9', 
    'peru':'#cd853f', 'pink':'#ffc0cb', 'plum':'#dda0dd', 'powderblue':'#b0e0e6', 'purple':'#800080', 'red':'#ff0000', 'rosybrown':'#bc8f8f', 'royalblue':'#4169e1', 'saddlebrown':'#8b4513', 'salmon':'#fa8072', 'sandybrown':'#f4a460', 'seagreen':'#2e8b57', 'seashell':'#fff5ee', 'sienna':'#a0522d', 'silver':'#c0c0c0', 'skyblue':'#87ceeb', 'slateblue':'#6a5acd', 'slategray':'#708090', 'snow':'#fffafa', 'springgreen':'#00ff7f', 'steelblue':'#4682b4', 'tan':'#d2b48c', 'teal':'#008080', 'thistle':'#d8bfd8', 
    'tomato':'#ff6347', 'turquoise':'#40e0d0', 'violet':'#ee82ee', 'wheat':'#f5deb3', 'white':'#ffffff', 'whitesmoke':'#f5f5f5', 'yellow':'#ffff00', 'yellowgreen':'#9acd32'}, fromHSL:function(h, s, l) {
      return (new this(0, 0, 0, 0)).setHSL(h, s, l);
    }, fromString:function(string) {
      return (new this(0, 0, 0, 0)).setFromString(string);
    }, create:function(arg) {
      if (arg instanceof this) {
        return arg;
      } else {
        if (Ext.isArray(arg)) {
          return new Ext.draw.Color(arg[0], arg[1], arg[2], arg[3]);
        } else {
          if (Ext.isString(arg)) {
            return Ext.draw.Color.fromString(arg);
          } else {
            if (arguments.length > 2) {
              return new Ext.draw.Color(arguments[0], arguments[1], arguments[2], arguments[3]);
            } else {
              return new Ext.draw.Color(0, 0, 0, 0);
            }
          }
        }
      }
    }});
  });
})();
(function() {
  function compute(from, to, delta) {
    return from + (to - from) * delta;
  }
  Ext.cmd.derive('Ext.draw.sprite.AnimationParser', Ext.Base, {singleton:true, attributeRe:/^url\(#([a-zA-Z\-]+)\)$/, color:{parseInitial:function(color1, color2) {
    if (Ext.isString(color1)) {
      color1 = Ext.draw.Color.create(color1);
    }
    if (Ext.isString(color2)) {
      color2 = Ext.draw.Color.create(color2);
    }
    if (color1 instanceof Ext.draw.Color && color2 instanceof Ext.draw.Color) {
      return [[color1.r, color1.g, color1.b, color1.a], [color2.r, color2.g, color2.b, color2.a]];
    } else {
      return [color1 || color2, color2 || color1];
    }
  }, compute:function(from, to, delta) {
    if (!Ext.isArray(from) || !Ext.isArray(to)) {
      return to || from;
    } else {
      return [compute(from[0], to[0], delta), compute(from[1], to[1], delta), compute(from[2], to[2], delta), compute(from[3], to[3], delta)];
    }
  }, serve:function(array) {
    var color = Ext.draw.Color.fly(array[0], array[1], array[2], array[3]);
    return color.toString();
  }}, number:{parse:function(n) {
    return n === null ? null : +n;
  }, compute:function(from, to, delta) {
    if (!Ext.isNumber(from) || !Ext.isNumber(to)) {
      return to || from;
    } else {
      return compute(from, to, delta);
    }
  }}, angle:{parseInitial:function(from, to) {
    if (to - from > Math.PI) {
      to -= Math.PI * 2;
    } else {
      if (to - from < -Math.PI) {
        to += Math.PI * 2;
      }
    }
    return [from, to];
  }, compute:function(from, to, delta) {
    if (!Ext.isNumber(from) || !Ext.isNumber(to)) {
      return to || from;
    } else {
      return compute(from, to, delta);
    }
  }}, path:{parseInitial:function(from, to) {
    var fromStripes = from.toStripes(), toStripes = to.toStripes(), i, j, fromLength = fromStripes.length, toLength = toStripes.length, fromStripe, toStripe, length, lastStripe = toStripes[toLength - 1], endPoint = [lastStripe[lastStripe.length - 2], lastStripe[lastStripe.length - 1]];
    for (i = fromLength; i < toLength; i++) {
      fromStripes.push(fromStripes[fromLength - 1].slice(0));
    }
    for (i = toLength; i < fromLength; i++) {
      toStripes.push(endPoint.slice(0));
    }
    length = fromStripes.length;
    toStripes.path = to;
    toStripes.temp = new Ext.draw.Path;
    for (i = 0; i < length; i++) {
      fromStripe = fromStripes[i];
      toStripe = toStripes[i];
      fromLength = fromStripe.length;
      toLength = toStripe.length;
      toStripes.temp.types.push('M');
      for (j = toLength; j < fromLength; j += 6) {
        toStripe.push(endPoint[0], endPoint[1], endPoint[0], endPoint[1], endPoint[0], endPoint[1]);
      }
      lastStripe = toStripes[toStripes.length - 1];
      endPoint = [lastStripe[lastStripe.length - 2], lastStripe[lastStripe.length - 1]];
      for (j = fromLength; j < toLength; j += 6) {
        fromStripe.push(endPoint[0], endPoint[1], endPoint[0], endPoint[1], endPoint[0], endPoint[1]);
      }
      for (i = 0; i < toStripe.length; i++) {
        toStripe[i] -= fromStripe[i];
      }
      for (i = 2; i < toStripe.length; i += 6) {
        toStripes.temp.types.push('C');
      }
    }
    return [fromStripes, toStripes];
  }, compute:function(fromStripes, toStripes, delta) {
    if (delta >= 1) {
      return toStripes.path;
    }
    var i = 0, ln = fromStripes.length, j = 0, ln2, from, to, temp = toStripes.temp.coords, pos = 0;
    for (; i < ln; i++) {
      from = fromStripes[i];
      to = toStripes[i];
      ln2 = from.length;
      for (j = 0; j < ln2; j++) {
        temp[pos++] = to[j] * delta + from[j];
      }
    }
    return toStripes.temp;
  }}, data:{compute:function(from, to, delta, target) {
    var lf = from.length - 1, lt = to.length - 1, len = Math.max(lf, lt), f, t, i;
    if (!target || target === from) {
      target = [];
    }
    target.length = len + 1;
    for (i = 0; i <= len; i++) {
      f = from[Math.min(i, lf)];
      t = to[Math.min(i, lt)];
      if (isNaN(f)) {
        target[i] = t;
      } else {
        target[i] = (t - f) * delta + f;
      }
    }
    return target;
  }}, text:{compute:function(from, to, delta) {
    return from.substr(0, Math.round(from.length * (1 - delta))) + to.substr(Math.round(to.length * (1 - delta)));
  }}, limited:'number', limited01:'number'}, 0, 0, 0, 0, 0, 0, [Ext.draw.sprite, 'AnimationParser'], 0);
})();
(function() {
  if (!Ext.global.Float32Array) {
    var Float32Array = function(array) {
      if (typeof array === 'number') {
        this.length = array;
      } else {
        if ('length' in array) {
          this.length = array.length;
          for (var i = 0, len = array.length; i < len; i++) {
            this[i] = +array[i];
          }
        }
      }
    };
    Float32Array.prototype = [];
    Ext.global.Float32Array = Float32Array;
  }
})();
Ext.cmd.derive('Ext.draw.Draw', Ext.Base, {singleton:true, radian:Math.PI / 180, pi2:Math.PI * 2, reflectFn:function(a) {
  return a;
}, rad:function(degrees) {
  return degrees % 360 * Math.PI / 180;
}, degrees:function(radian) {
  return radian * 180 / Math.PI % 360;
}, isBBoxIntersect:function(bbox1, bbox2, padding) {
  padding = padding || 0;
  return Math.max(bbox1.x, bbox2.x) - padding > Math.min(bbox1.x + bbox1.width, bbox2.x + bbox2.width) || Math.max(bbox1.y, bbox2.y) - padding > Math.min(bbox1.y + bbox1.height, bbox2.y + bbox2.height);
}, spline:function(points) {
  var i, j, ln = points.length, nd, d, y, ny, r = 0, zs = new Float32Array(points.length), result = new Float32Array(points.length * 3 - 2);
  zs[0] = 0;
  zs[ln - 1] = 0;
  for (i = 1; i < ln - 1; i++) {
    zs[i] = points[i + 1] + points[i - 1] - 2 * points[i] - zs[i - 1];
    r = 1 / (4 - r);
    zs[i] *= r;
  }
  for (i = ln - 2; i > 0; i--) {
    r = 3.732050807568877 + 48.248711305964385 / (-13.928203230275537 + Math.pow(0.07179676972449123, i));
    zs[i] -= zs[i + 1] * r;
  }
  ny = points[0];
  nd = ny - zs[0];
  for (i = 0, j = 0; i < ln - 1; j += 3) {
    y = ny;
    d = nd;
    i++;
    ny = points[i];
    nd = ny - zs[i];
    result[j] = y;
    result[j + 1] = (nd + 2 * d) / 3;
    result[j + 2] = (nd * 2 + d) / 3;
  }
  result[j] = ny;
  return result;
}, getAnchors:function(prevX, prevY, curX, curY, nextX, nextY, value) {
  value = value || 4;
  var PI = Math.PI, halfPI = PI / 2, abs = Math.abs, sin = Math.sin, cos = Math.cos, atan = Math.atan, control1Length, control2Length, control1Angle, control2Angle, control1X, control1Y, control2X, control2Y, alpha;
  control1Length = (curX - prevX) / value;
  control2Length = (nextX - curX) / value;
  if (curY >= prevY && curY >= nextY || curY <= prevY && curY <= nextY) {
    control1Angle = control2Angle = halfPI;
  } else {
    control1Angle = atan((curX - prevX) / abs(curY - prevY));
    if (prevY < curY) {
      control1Angle = PI - control1Angle;
    }
    control2Angle = atan((nextX - curX) / abs(curY - nextY));
    if (nextY < curY) {
      control2Angle = PI - control2Angle;
    }
  }
  alpha = halfPI - (control1Angle + control2Angle) % (PI * 2) / 2;
  if (alpha > halfPI) {
    alpha -= PI;
  }
  control1Angle += alpha;
  control2Angle += alpha;
  control1X = curX - control1Length * sin(control1Angle);
  control1Y = curY + control1Length * cos(control1Angle);
  control2X = curX + control2Length * sin(control2Angle);
  control2Y = curY + control2Length * cos(control2Angle);
  if (curY > prevY && control1Y < prevY || curY < prevY && control1Y > prevY) {
    control1X += abs(prevY - control1Y) * (control1X - curX) / (control1Y - curY);
    control1Y = prevY;
  }
  if (curY > nextY && control2Y < nextY || curY < nextY && control2Y > nextY) {
    control2X -= abs(nextY - control2Y) * (control2X - curX) / (control2Y - curY);
    control2Y = nextY;
  }
  return {x1:control1X, y1:control1Y, x2:control2X, y2:control2Y};
}, smooth:function(dataX, dataY, value) {
  var ln = dataX.length, prevX, prevY, curX, curY, nextX, nextY, x, y, smoothX = [], smoothY = [], i, anchors;
  for (i = 0; i < ln - 1; i++) {
    prevX = dataX[i];
    prevY = dataY[i];
    if (i === 0) {
      x = prevX;
      y = prevY;
      smoothX.push(x);
      smoothY.push(y);
      if (ln === 1) {
        break;
      }
    }
    curX = dataX[i + 1];
    curY = dataY[i + 1];
    nextX = dataX[i + 2];
    nextY = dataY[i + 2];
    if (isNaN(nextX) || isNaN(nextY)) {
      smoothX.push(x, curX, curX);
      smoothY.push(y, curY, curY);
      break;
    }
    anchors = this.getAnchors(prevX, prevY, curX, curY, nextX, nextY, value);
    smoothX.push(x, anchors.x1, curX);
    smoothY.push(y, anchors.y1, curY);
    x = anchors.x2;
    y = anchors.y2;
  }
  return {smoothX:smoothX, smoothY:smoothY};
}, updateIOS:Ext.os.is.iOS ? function() {
  Ext.getBody().createChild({id:'frame-workaround', style:'position: absolute; top: 0px; bottom: 0px; left: 0px; right: 0px; background: rgba(0,0,0,0.001); z-index: 100000'});
  Ext.draw.Animator.schedule(function() {
    Ext.get('frame-workaround').destroy();
  });
} : Ext.emptyFn}, 0, 0, 0, 0, 0, 0, [Ext.draw, 'Draw'], 0);
Ext.cmd.derive('Ext.draw.gradient.Gradient', Ext.Base, {isGradient:true, config:{stops:[]}, applyStops:function(newStops) {
  var stops = [], ln = newStops.length, i, stop, color;
  for (i = 0; i < ln; i++) {
    stop = newStops[i];
    color = Ext.draw.Color.fly(stop.color || 'none');
    stops.push({offset:Math.min(1, Math.max(0, 'offset' in stop ? stop.offset : stop.position || 0)), color:color.toString()});
  }
  stops.sort(function(a, b) {
    return a.offset - b.offset;
  });
  return stops;
}, onClassExtended:function(subClass, member) {
  if (!member.alias && member.type) {
    member.alias = 'gradient.' + member.type;
  }
}, constructor:function(config) {
  this.initConfig(config);
}, generateGradient:Ext.emptyFn}, 1, 0, 0, 0, 0, 0, [Ext.draw.gradient, 'Gradient'], 0);
Ext.cmd.derive('Ext.draw.gradient.GradientDefinition', Ext.Base, {singleton:true, urlStringRe:/^url\(#([\w\-]+)\)$/, gradients:{}, add:function(gradients) {
  var store = this.gradients, i, n, gradient;
  for (i = 0, n = gradients.length; i < n; i++) {
    gradient = gradients[i];
    if (Ext.isString(gradient.id)) {
      store[gradient.id] = gradient;
    }
  }
}, get:function(str) {
  var store = this.gradients, match = str.match(this.urlStringRe), gradient;
  if (match && match[1] && (gradient = store[match[1]])) {
    return gradient || str;
  }
  return str;
}}, 0, 0, 0, 0, 0, 0, [Ext.draw.gradient, 'GradientDefinition'], 0);
Ext.cmd.derive('Ext.draw.sprite.AttributeParser', Ext.Base, {singleton:true, attributeRe:/^url\(#([a-zA-Z\-]+)\)$/, 'default':function(n) {
  return n;
}, string:function(n) {
  return String(n);
}, number:function(n) {
  if (!isNaN(n)) {
    return n;
  }
}, angle:function(n) {
  if (!isNaN(n)) {
    n %= Math.PI * 2;
    if (n < -Math.PI) {
      n += Math.PI * 2;
    }
    if (n > Math.PI) {
      n -= Math.PI * 2;
    }
    return n;
  }
}, data:function(n) {
  if (Ext.isArray(n)) {
    return n.slice();
  } else {
    if (n instanceof Float32Array) {
      return new Float32Array(n);
    }
  }
}, bool:function(n) {
  return !!n;
}, color:function(n) {
  if (n instanceof Ext.draw.Color) {
    return n.toString();
  } else {
    if (n instanceof Ext.draw.gradient.Gradient) {
      return n;
    } else {
      if (!n) {
        return 'none';
      } else {
        if (Ext.isString(n)) {
          n = Ext.draw.gradient.GradientDefinition.get(n);
          if (Ext.isString(n)) {
            return n;
          }
        }
      }
    }
  }
  if (n.type === 'linear') {
    return Ext.create('Ext.draw.gradient.Linear', n);
  } else {
    if (n.type === 'radial') {
      return Ext.create('Ext.draw.gradient.Radial', n);
    } else {
      if (n.type === 'pattern') {
        return Ext.create('Ext.draw.gradient.Pattern', n);
      }
    }
  }
}, limited:function(low, hi) {
  return function(n) {
    return isNaN(n) ? undefined : Math.min(Math.max(+n, low), hi);
  };
}, limited01:function(n) {
  return isNaN(n) ? undefined : Math.min(Math.max(+n, 0), 1);
}, enums:function() {
  var enums = {}, args = Array.prototype.slice.call(arguments, 0), i, ln;
  for (i = 0, ln = args.length; i < ln; i++) {
    enums[args[i]] = true;
  }
  return function(n) {
    return n in enums ? n : undefined;
  };
}}, 0, 0, 0, 0, 0, 0, [Ext.draw.sprite, 'AttributeParser'], 0);
Ext.cmd.derive('Ext.draw.sprite.AttributeDefinition', Ext.Base, {config:{defaults:{}, aliases:{}, animationProcessors:{}, processors:{}, dirtyTriggers:{}, updaters:{}}, inheritableStatics:{processorRe:/^(\w+)\(([\w\-,]*)\)$/}, constructor:function(config) {
  var me = this;
  me.initConfig(config);
}, applyDefaults:function(defaults, oldDefaults) {
  oldDefaults = Ext.apply(oldDefaults || {}, this.normalize(defaults));
  return oldDefaults;
}, applyAliases:function(aliases, oldAliases) {
  return Ext.apply(oldAliases || {}, aliases);
}, applyProcessors:function(processors, oldProcessors) {
  this.getAnimationProcessors();
  var name, result = oldProcessors || {}, defaultProcessor = Ext.draw.sprite.AttributeParser, processorRe = this.self.processorRe, animationProcessors = {}, anyAnimationProcessors, match, fn;
  for (name in processors) {
    fn = processors[name];
    if (!Ext.isFunction(fn)) {
      if (Ext.isString(fn)) {
        match = fn.match(processorRe);
        if (match) {
          fn = defaultProcessor[match[1]].apply(defaultProcessor, match[2].split(','));
        } else {
          animationProcessors[name] = fn;
          anyAnimationProcessors = true;
          fn = defaultProcessor[fn];
        }
      } else {
        continue;
      }
    }
    result[name] = fn;
  }
  if (anyAnimationProcessors) {
    this.setAnimationProcessors(animationProcessors);
  }
  return result;
}, applyAnimationProcessors:function(animationProcessors, oldAnimationProcessors) {
  var parser = Ext.draw.sprite.AnimationParser, item;
  if (!oldAnimationProcessors) {
    oldAnimationProcessors = {};
  }
  for (var name in animationProcessors) {
    item = animationProcessors[name];
    if (item === 'none') {
      oldAnimationProcessors[name] = null;
    } else {
      if (Ext.isString(item) && !(name in oldAnimationProcessors)) {
        if (item in parser) {
          while (Ext.isString(parser[item])) {
            item = parser[item];
          }
          oldAnimationProcessors[name] = parser[item];
        }
      } else {
        if (Ext.isObject(item)) {
          oldAnimationProcessors[name] = item;
        }
      }
    }
  }
  return oldAnimationProcessors;
}, applyDirtyTriggers:function(dirtyTriggers, oldDirtyTrigger) {
  if (!oldDirtyTrigger) {
    oldDirtyTrigger = {};
  }
  for (var name in dirtyTriggers) {
    oldDirtyTrigger[name] = dirtyTriggers[name].split(',');
  }
  return oldDirtyTrigger;
}, applyUpdaters:function(updaters, oldUpdaters) {
  return Ext.apply(oldUpdaters || {}, updaters);
}, batchedNormalize:function(batchedChanges, reserveUnrecognized) {
  if (!batchedChanges) {
    return {};
  }
  var definition = this, processors = definition.getProcessors(), aliases = definition.getAliases(), normalized = {}, i, ln, name, val, translation, rotation, scaling, matrix, subVal, split;
  if ('rotation' in batchedChanges) {
    rotation = batchedChanges.rotation;
  } else {
    rotation = 'rotate' in batchedChanges ? batchedChanges.rotate : undefined;
  }
  if ('scaling' in batchedChanges) {
    scaling = batchedChanges.scaling;
  } else {
    scaling = 'scale' in batchedChanges ? batchedChanges.scale : undefined;
  }
  if ('translation' in batchedChanges) {
    translation = batchedChanges.translation;
  } else {
    translation = 'translate' in batchedChanges ? batchedChanges.translate : undefined;
  }
  if (typeof scaling !== 'undefined') {
    if (Ext.isNumber(scaling)) {
      normalized.scalingX = scaling;
      normalized.scalingY = scaling;
    } else {
      if ('x' in scaling) {
        normalized.scalingX = scaling.x;
      }
      if ('y' in scaling) {
        normalized.scalingY = scaling.y;
      }
      if ('centerX' in scaling) {
        normalized.scalingCenterX = scaling.centerX;
      }
      if ('centerY' in scaling) {
        normalized.scalingCenterY = scaling.centerY;
      }
    }
  }
  if (typeof rotation !== 'undefined') {
    if (Ext.isNumber(rotation)) {
      rotation = Ext.draw.Draw.rad(rotation);
      normalized.rotationRads = rotation;
    } else {
      if ('rads' in rotation) {
        normalized.rotationRads = rotation.rads;
      } else {
        if ('degrees' in rotation) {
          if (Ext.isArray(rotation.degrees)) {
            normalized.rotationRads = rotation.degrees.map(function(deg) {
              return Ext.draw.Draw.rad(deg);
            });
          } else {
            normalized.rotationRads = Ext.draw.Draw.rad(rotation.degrees);
          }
        }
      }
      if ('centerX' in rotation) {
        normalized.rotationCenterX = rotation.centerX;
      }
      if ('centerY' in rotation) {
        normalized.rotationCenterY = rotation.centerY;
      }
    }
  }
  if (typeof translation !== 'undefined') {
    if ('x' in translation) {
      normalized.translationX = translation.x;
    }
    if ('y' in translation) {
      normalized.translationY = translation.y;
    }
  }
  if ('matrix' in batchedChanges) {
    matrix = Ext.draw.Matrix.create(batchedChanges.matrix);
    split = matrix.split();
    normalized.matrix = matrix;
    normalized.rotationRads = split.rotation;
    normalized.rotationCenterX = 0;
    normalized.rotationCenterY = 0;
    normalized.scalingX = split.scaleX;
    normalized.scalingY = split.scaleY;
    normalized.scalingCenterX = 0;
    normalized.scalingCenterY = 0;
    normalized.translationX = split.translateX;
    normalized.translationY = split.translateY;
  }
  for (name in batchedChanges) {
    val = batchedChanges[name];
    if (typeof val === 'undefined') {
      continue;
    } else {
      if (Ext.isArray(val)) {
        if (name in aliases) {
          name = aliases[name];
        }
        if (name in processors) {
          normalized[name] = [];
          for (i = 0, ln = val.length; i < ln; i++) {
            subVal = processors[name].call(this, val[i]);
            if (typeof subVal !== 'undefined') {
              normalized[name][i] = subVal;
            }
          }
        } else {
          if (reserveUnrecognized) {
            normalized[name] = val;
          }
        }
      } else {
        if (name in aliases) {
          name = aliases[name];
        }
        if (name in processors) {
          val = processors[name].call(this, val);
          if (typeof val !== 'undefined') {
            normalized[name] = val;
          }
        } else {
          if (reserveUnrecognized) {
            normalized[name] = val;
          }
        }
      }
    }
  }
  return normalized;
}, normalize:function(changes, reserveUnrecognized) {
  if (!changes) {
    return {};
  }
  var definition = this, processors = definition.getProcessors(), aliases = definition.getAliases(), translation = changes.translation || changes.translate, normalized = {}, name, val, rotation, scaling, matrix, split;
  if ('rotation' in changes) {
    rotation = changes.rotation;
  } else {
    rotation = 'rotate' in changes ? changes.rotate : undefined;
  }
  if ('scaling' in changes) {
    scaling = changes.scaling;
  } else {
    scaling = 'scale' in changes ? changes.scale : undefined;
  }
  if (translation) {
    if ('x' in translation) {
      normalized.translationX = translation.x;
    }
    if ('y' in translation) {
      normalized.translationY = translation.y;
    }
  }
  if (typeof scaling !== 'undefined') {
    if (Ext.isNumber(scaling)) {
      normalized.scalingX = scaling;
      normalized.scalingY = scaling;
    } else {
      if ('x' in scaling) {
        normalized.scalingX = scaling.x;
      }
      if ('y' in scaling) {
        normalized.scalingY = scaling.y;
      }
      if ('centerX' in scaling) {
        normalized.scalingCenterX = scaling.centerX;
      }
      if ('centerY' in scaling) {
        normalized.scalingCenterY = scaling.centerY;
      }
    }
  }
  if (typeof rotation !== 'undefined') {
    if (Ext.isNumber(rotation)) {
      rotation = Ext.draw.Draw.rad(rotation);
      normalized.rotationRads = rotation;
    } else {
      if ('rads' in rotation) {
        normalized.rotationRads = rotation.rads;
      } else {
        if ('degrees' in rotation) {
          normalized.rotationRads = Ext.draw.Draw.rad(rotation.degrees);
        }
      }
      if ('centerX' in rotation) {
        normalized.rotationCenterX = rotation.centerX;
      }
      if ('centerY' in rotation) {
        normalized.rotationCenterY = rotation.centerY;
      }
    }
  }
  if ('matrix' in changes) {
    matrix = Ext.draw.Matrix.create(changes.matrix);
    split = matrix.split();
    normalized.matrix = matrix;
    normalized.rotationRads = split.rotation;
    normalized.rotationCenterX = 0;
    normalized.rotationCenterY = 0;
    normalized.scalingX = split.scaleX;
    normalized.scalingY = split.scaleY;
    normalized.scalingCenterX = 0;
    normalized.scalingCenterY = 0;
    normalized.translationX = split.translateX;
    normalized.translationY = split.translateY;
  }
  for (name in changes) {
    val = changes[name];
    if (typeof val === 'undefined') {
      continue;
    }
    if (name in aliases) {
      name = aliases[name];
    }
    if (name in processors) {
      val = processors[name].call(this, val);
      if (typeof val !== 'undefined') {
        normalized[name] = val;
      }
    } else {
      if (reserveUnrecognized) {
        normalized[name] = val;
      }
    }
  }
  return normalized;
}, setBypassingNormalization:function(attr, modifierStack, changes) {
  return modifierStack.pushDown(attr, changes);
}, set:function(attr, modifierStack, changes) {
  changes = this.normalize(changes);
  return this.setBypassingNormalization(attr, modifierStack, changes);
}}, 1, 0, 0, 0, 0, 0, [Ext.draw.sprite, 'AttributeDefinition'], 0);
Ext.cmd.derive('Ext.draw.modifier.Modifier', Ext.Base, {config:{previous:null, next:null, sprite:null}, constructor:function(config) {
  this.initConfig(config);
}, updateNext:function(next) {
  if (next) {
    next.setPrevious(this);
  }
}, updatePrev:function(prev) {
  if (prev) {
    prev.setNext(this);
  }
}, prepareAttributes:function(attr) {
  if (this._previous) {
    this._previous.prepareAttributes(attr);
  }
}, popUp:function(attributes, changes) {
  if (this._next) {
    this._next.popUp(attributes, changes);
  } else {
    Ext.apply(attributes, changes);
  }
}, pushDown:function(attr, changes) {
  if (this._previous) {
    return this._previous.pushDown(attr, changes);
  } else {
    for (var name in changes) {
      if (changes[name] === attr[name]) {
        delete changes[name];
      }
    }
    return changes;
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.draw.modifier, 'Modifier'], 0);
Ext.cmd.derive('Ext.draw.modifier.Target', Ext.draw.modifier.Modifier, {statics:{uniqueId:0}, prepareAttributes:function(attr) {
  if (this._previous) {
    this._previous.prepareAttributes(attr);
  }
  attr.attributeId = 'attribute-' + Ext.draw.modifier.Target.uniqueId++;
  if (!attr.hasOwnProperty('canvasAttributes')) {
    attr.bbox = {plain:{dirty:true}, transform:{dirty:true}};
    attr.dirty = true;
    attr.dirtyFlags = {};
    attr.canvasAttributes = {};
    attr.matrix = new Ext.draw.Matrix;
    attr.inverseMatrix = new Ext.draw.Matrix;
  }
}, setDirtyFlags:function(attr, changes) {
  Ext.apply(attr, changes);
  var sprite = this._sprite, dirtyTriggers = sprite.self.def._dirtyTriggers, name, dirtyFlags = attr.dirtyFlags, flags, any = false, triggers, trigger, i, ln, canvasNames;
  for (name in changes) {
    if (triggers = dirtyTriggers[name]) {
      i = 0;
      while (trigger = triggers[i++]) {
        if (!(flags = dirtyFlags[trigger])) {
          flags = dirtyFlags[trigger] = [];
        }
        flags.push(name);
      }
    }
  }
  for (name in changes) {
    any = true;
    break;
  }
  if (!any) {
    return;
  }
  if (dirtyFlags.canvas) {
    canvasNames = dirtyFlags.canvas;
    delete dirtyFlags.canvas;
    for (i = 0, ln = canvasNames.length; i < ln; i++) {
      name = canvasNames[i];
      attr.canvasAttributes[name] = attr[name];
    }
  }
  if (attr.hasOwnProperty('children')) {
    for (i = 0, ln = attr.children.length; i < ln; i++) {
      Ext.apply(attr.children[i].dirtyFlags, dirtyFlags);
      sprite.updateDirtyFlags(attr.children[i]);
    }
  }
  sprite.setDirty(true);
}, popUp:function(attributes, changes) {
  this.setDirtyFlags(attributes, changes);
  this._sprite.updateDirtyFlags(attributes);
}, pushDown:function(attr, changes) {
  if (this._previous) {
    changes = this._previous.pushDown(attr, changes);
  }
  this.setDirtyFlags(attr, changes);
  this._sprite.updateDirtyFlags(attr);
  return changes;
}}, 0, 0, 0, 0, ['modifier.target'], 0, [Ext.draw.modifier, 'Target'], 0);
(function() {
  var pow = Math.pow, sin = Math.sin, cos = Math.cos, sqrt = Math.sqrt, pi = Math.PI, easings, addEasing, poly, createPoly, easing, i, l;
  poly = ['quad', 'cubic', 'quart', 'quint'];
  easings = {pow:function(p, x) {
    return pow(p, x[0] || 6);
  }, expo:function(p) {
    return pow(2, 8 * (p - 1));
  }, circ:function(p) {
    return 1 - sqrt(1 - p * p);
  }, sine:function(p) {
    return 1 - sin((1 - p) * pi / 2);
  }, back:function(p, n) {
    n = n || 1.616;
    return p * p * ((n + 1) * p - n);
  }, bounce:function(p) {
    var value;
    for (var a = 0, b = 1; 1; a += b, b /= 2) {
      if (p >= (7 - 4 * a) / 11) {
        value = b * b - pow((11 - 6 * a - 11 * p) / 4, 2);
        break;
      }
    }
    return value;
  }, elastic:function(p, x) {
    return pow(2, 10 * --p) * cos(20 * p * pi * (x || 1) / 3);
  }};
  addEasing = function(easing, params) {
    params = params && params.length ? params : [params];
    return Ext.apply(easing, {easeIn:function(pos) {
      return easing(pos, params);
    }, easeOut:function(pos) {
      return 1 - easing(1 - pos, params);
    }, easeInOut:function(pos) {
      return pos <= 0.5 ? easing(2 * pos, params) / 2 : (2 - easing(2 * (1 - pos), params)) / 2;
    }});
  };
  createPoly = function(times) {
    return function(p) {
      return pow(p, times);
    };
  };
  for (i = 0, l = poly.length; i < l; ++i) {
    easings[poly[i]] = createPoly(i + 2);
  }
  easings.linear = function(x) {
    return x;
  };
  for (easing in easings) {
    if (easings.hasOwnProperty(easing)) {
      addEasing(easings[easing]);
    }
  }
  Ext.cmd.derive('Ext.draw.TimingFunctions', Ext.Base, {singleton:true, easingMap:{linear:easings.linear, easeIn:easings.quad.easeIn, easeOut:easings.quad.easeOut, easeInOut:easings.quad.easeInOut, backIn:easings.back, backOut:function(x, n) {
    return 1 - easings.back(1 - x, n);
  }, backInOut:function(x, n) {
    if (x < 0.5) {
      return easings.back(x * 2, n) * 0.5;
    } else {
      return 1 - easings.back((1 - x) * 2, n) * 0.5;
    }
  }, elasticIn:function(x, n) {
    return 1 - easings.elastic(1 - x, n);
  }, elasticOut:easings.elastic, bounceIn:easings.bounce, bounceOut:function(x) {
    return 1 - easings.bounce(1 - x);
  }}}, 0, 0, 0, 0, 0, 0, [Ext.draw, 'TimingFunctions'], function() {
    Ext.apply(this, easings);
  });
})();
Ext.cmd.derive('Ext.draw.modifier.Animation', Ext.draw.modifier.Modifier, {config:{easing:function(x) {
  return x;
}, duration:0, customEasings:{}, customDuration:{}}, constructor:function() {
  this.anyAnimation = false;
  this.anySpecialAnimations = false;
  this.animating = 0;
  this.animatingPool = [];
  Ext.draw.modifier.Modifier.prototype.constructor.apply(this, arguments);
}, prepareAttributes:function(attr) {
  if (!attr.hasOwnProperty('timers')) {
    attr.animating = false;
    attr.timers = {};
    attr.animationOriginal = Ext.Object.chain(attr);
    attr.animationOriginal.upperLevel = attr;
  }
  if (this._previous) {
    this._previous.prepareAttributes(attr.animationOriginal);
  }
}, updateSprite:function(sprite) {
  this.setConfig(sprite.config.fx);
}, updateDuration:function(duration) {
  this.anyAnimation = duration > 0;
}, applyEasing:function(easing) {
  if (typeof easing === 'string') {
    return Ext.draw.TimingFunctions.easingMap[easing];
  } else {
    return easing;
  }
}, applyCustomEasings:function(newCustomEasing, oldCustomEasing) {
  oldCustomEasing = oldCustomEasing || {};
  var attr, attrs, easing, i, ln;
  for (attr in newCustomEasing) {
    easing = newCustomEasing[attr];
    attrs = attr.split(',');
    if (typeof easing === 'string') {
      easing = Ext.draw.TimingFunctions.easingMap[easing];
    }
    for (i = 0, ln = attrs.length; i < ln; i++) {
      oldCustomEasing[attrs[i]] = easing;
    }
  }
  return oldCustomEasing;
}, setEasingOn:function(attrs, easing) {
  attrs = Ext.Array.from(attrs).slice();
  var customEasings = {}, i = 0, ln = attrs.length;
  for (; i < ln; i++) {
    customEasings[attrs[i]] = easing;
  }
  this.setCustomEasings(customEasings);
}, clearEasingOn:function(attrs) {
  attrs = Ext.Array.from(attrs, true);
  var i = 0, ln = attrs.length;
  for (; i < ln; i++) {
    delete this._customEasings[attrs[i]];
  }
}, applyCustomDuration:function(newCustomDuration, oldCustomDuration) {
  oldCustomDuration = oldCustomDuration || {};
  var attr, duration, attrs, i, ln, anySpecialAnimations = this.anySpecialAnimations;
  for (attr in newCustomDuration) {
    duration = newCustomDuration[attr];
    attrs = attr.split(',');
    anySpecialAnimations = true;
    for (i = 0, ln = attrs.length; i < ln; i++) {
      oldCustomDuration[attrs[i]] = duration;
    }
  }
  this.anySpecialAnimations = anySpecialAnimations;
  return oldCustomDuration;
}, setDurationOn:function(attrs, duration) {
  attrs = Ext.Array.from(attrs).slice();
  var customDurations = {}, i = 0, ln = attrs.length;
  for (; i < ln; i++) {
    customDurations[attrs[i]] = duration;
  }
  this.setCustomDuration(customDurations);
}, clearDurationOn:function(attrs) {
  attrs = Ext.Array.from(attrs, true);
  var i = 0, ln = attrs.length;
  for (; i < ln; i++) {
    delete this._customDuration[attrs[i]];
  }
}, setAnimating:function(attributes, animating) {
  var me = this, i, j;
  if (attributes.animating !== animating) {
    attributes.animating = animating;
    if (animating) {
      me.animatingPool.push(attributes);
      if (me.animating === 0) {
        Ext.draw.Animator.add(me);
      }
      me.animating++;
    } else {
      for (i = 0, j = 0; i < me.animatingPool.length; i++) {
        if (me.animatingPool[i] !== attributes) {
          me.animatingPool[j++] = me.animatingPool[i];
        }
      }
      me.animating = me.animatingPool.length = j;
    }
  }
}, setAttrs:function(attr, changes) {
  var timers = attr.timers, parsers = this._sprite.self.def._animationProcessors, defaultEasing = this._easing, defaultDuration = this._duration, customDuration = this._customDuration, customEasings = this._customEasings, anySpecial = this.anySpecialAnimations, any = this.anyAnimation || anySpecial, original = attr.animationOriginal, ignite = false, timer, name, newValue, startValue, parser, easing, duration;
  if (!any) {
    for (name in changes) {
      if (attr[name] === changes[name]) {
        delete changes[name];
      } else {
        attr[name] = changes[name];
      }
      delete original[name];
      delete timers[name];
    }
    return changes;
  } else {
    for (name in changes) {
      newValue = changes[name];
      startValue = attr[name];
      if (newValue !== startValue && any && startValue !== undefined && startValue !== null && (parser = parsers[name])) {
        easing = defaultEasing;
        duration = defaultDuration;
        if (anySpecial) {
          if (name in customEasings) {
            easing = customEasings[name];
          }
          if (name in customDuration) {
            duration = customDuration[name];
          }
        }
        if (duration) {
          if (!timers[name]) {
            timers[name] = {};
          }
          timer = timers[name];
          timer.start = 0;
          timer.easing = easing;
          timer.duration = duration;
          timer.compute = parser.compute;
          timer.serve = parser.serve || Ext.draw.Draw.reflectFn;
          if (parser.parseInitial) {
            var initial = parser.parseInitial(startValue, newValue);
            timer.source = initial[0];
            timer.target = initial[1];
          } else {
            if (parser.parse) {
              timer.source = parser.parse(startValue);
              timer.target = parser.parse(newValue);
            } else {
              timer.source = startValue;
              timer.target = newValue;
            }
          }
          timers[name] = timer;
          original[name] = newValue;
          delete changes[name];
          ignite = true;
          continue;
        } else {
          delete original[name];
        }
      } else {
        delete original[name];
      }
      delete timers[name];
    }
  }
  if (ignite && !attr.animating) {
    this.setAnimating(attr, true);
  }
  return changes;
}, updateAttributes:function(attr) {
  if (!attr.animating) {
    return {};
  }
  var changes = {}, any = false, original = attr.animationOriginal, timers = attr.timers, now = Ext.draw.Animator.animationTime(), name, timer, delta;
  if (attr.lastUpdate === now) {
    return {};
  }
  for (name in timers) {
    timer = timers[name];
    if (!timer.start) {
      timer.start = now;
      delta = 0;
    } else {
      delta = (now - timer.start) / timer.duration;
    }
    if (delta >= 1) {
      changes[name] = original[name];
      delete original[name];
      delete timers[name];
    } else {
      changes[name] = timer.serve(timer.compute(timer.source, timer.target, timer.easing(delta), attr[name]));
      any = true;
    }
  }
  attr.lastUpdate = now;
  this.setAnimating(attr, any);
  return changes;
}, pushDown:function(attr, changes) {
  changes = Ext.draw.modifier.Modifier.prototype.pushDown.call(this, attr.animationOriginal, changes);
  return this.setAttrs(attr, changes);
}, popUp:function(attr, changes) {
  attr = attr.upperLevel;
  changes = this.setAttrs(attr, changes);
  if (this._next) {
    return this._next.popUp(attr, changes);
  } else {
    return Ext.apply(attr, changes);
  }
}, step:function() {
  var me = this, pool = me.animatingPool.slice(), attributes, i, ln;
  for (i = 0, ln = pool.length; i < ln; i++) {
    attributes = pool[i];
    var changes = this.updateAttributes(attributes), name;
    for (name in changes) {
      if (this._next) {
        this._next.popUp(attributes, changes);
      }
      break;
    }
  }
}, stop:function() {
  this.step();
  var me = this, pool = me.animatingPool, i, ln;
  for (i = 0, ln = pool.length; i < ln; i++) {
    pool[i].animating = false;
  }
  me.animatingPool.length = 0;
  me.animating = 0;
  Ext.draw.Animator.remove(me);
}, destroy:function() {
  var me = this;
  me.animatingPool.length = 0;
  me.animating = 0;
}}, 1, 0, 0, 0, ['modifier.animation'], [['observable', Ext.mixin.Observable]], [Ext.draw.modifier, 'Animation'], 0);
Ext.cmd.derive('Ext.draw.modifier.Highlight', Ext.draw.modifier.Modifier, {config:{enabled:false, highlightStyle:null}, preFx:true, applyHighlightStyle:function(style, oldStyle) {
  oldStyle = oldStyle || {};
  if (this.getSprite()) {
    Ext.apply(oldStyle, this.getSprite().self.def.normalize(style));
  } else {
    Ext.apply(oldStyle, style);
  }
  return oldStyle;
}, prepareAttributes:function(attr) {
  if (!attr.hasOwnProperty('highlightOriginal')) {
    attr.highlighted = false;
    attr.highlightOriginal = Ext.Object.chain(attr);
  }
  if (this._previous) {
    this._previous.prepareAttributes(attr.highlightOriginal);
  }
}, updateSprite:function(sprite, oldSprite) {
  if (sprite) {
    if (this.getHighlightStyle()) {
      this._highlightStyle = sprite.self.def.normalize(this.getHighlightStyle());
    }
    this.setHighlightStyle(sprite.config.highlightCfg);
  }
  var def = sprite.self.def;
  this.setSprite(sprite);
  def.setConfig({defaults:{highlighted:false}, processors:{highlighted:'bool'}, aliases:{'highlight':'highlighted', 'highlighting':'highlighted'}, dirtyFlags:{}, updaters:{}});
}, filterChanges:function(attr, changes) {
  var me = this, name, original = attr.highlightOriginal, style = me.getHighlightStyle();
  if (attr.highlighted) {
    for (name in changes) {
      if (style.hasOwnProperty(name)) {
        original[name] = changes[name];
        delete changes[name];
      }
    }
  }
  for (name in changes) {
    if (name !== 'highlighted' && original[name] === changes[name]) {
      delete changes[name];
    }
  }
  return changes;
}, pushDown:function(attr, changes) {
  var style = this.getHighlightStyle(), original = attr.highlightOriginal, oldHighlighted, name;
  if (changes.hasOwnProperty('highlighted')) {
    oldHighlighted = changes.highlighted;
    delete changes.highlighted;
    if (this._previous) {
      changes = this._previous.pushDown(original, changes);
    }
    changes = this.filterChanges(attr, changes);
    if (oldHighlighted !== attr.highlighted) {
      if (oldHighlighted) {
        for (name in style) {
          if (name in changes) {
            original[name] = changes[name];
          } else {
            original[name] = attr[name];
          }
          if (original[name] !== style[name]) {
            changes[name] = style[name];
          }
        }
      } else {
        for (name in style) {
          if (!(name in changes)) {
            changes[name] = original[name];
          }
          delete original[name];
        }
      }
      changes.highlighted = oldHighlighted;
    }
  } else {
    if (this._previous) {
      changes = this._previous.pushDown(original, changes);
    }
    changes = this.filterChanges(attr, changes);
  }
  return changes;
}, popUp:function(attr, changes) {
  changes = this.filterChanges(attr, changes);
  Ext.draw.modifier.Modifier.prototype.popUp.call(this, attr, changes);
}}, 0, 0, 0, 0, ['modifier.highlight'], 0, [Ext.draw.modifier, 'Highlight'], 0);
Ext.cmd.derive('Ext.draw.sprite.Sprite', Ext.Base, {isSprite:true, inheritableStatics:{def:{processors:{strokeStyle:'color', fillStyle:'color', strokeOpacity:'limited01', fillOpacity:'limited01', lineWidth:'number', lineCap:'enums(butt,round,square)', lineJoin:'enums(round,bevel,miter)', lineDash:'data', lineDashOffset:'number', miterLimit:'number', shadowColor:'color', shadowOffsetX:'number', shadowOffsetY:'number', shadowBlur:'number', globalAlpha:'limited01', globalCompositeOperation:'enums(source-over,destination-over,source-in,destination-in,source-out,destination-out,source-atop,destination-atop,lighter,xor,copy)', 
hidden:'bool', transformFillStroke:'bool', zIndex:'number', translationX:'number', translationY:'number', rotationRads:'number', rotationCenterX:'number', rotationCenterY:'number', scalingX:'number', scalingY:'number', scalingCenterX:'number', scalingCenterY:'number', constrainGradients:'bool'}, aliases:{'stroke':'strokeStyle', 'fill':'fillStyle', 'color':'fillStyle', 'stroke-width':'lineWidth', 'stroke-linecap':'lineCap', 'stroke-linejoin':'lineJoin', 'stroke-miterlimit':'miterLimit', 'text-anchor':'textAlign', 
'opacity':'globalAlpha', translateX:'translationX', translateY:'translationY', rotateRads:'rotationRads', rotateCenterX:'rotationCenterX', rotateCenterY:'rotationCenterY', scaleX:'scalingX', scaleY:'scalingY', scaleCenterX:'scalingCenterX', scaleCenterY:'scalingCenterY'}, defaults:{hidden:false, zIndex:0, strokeStyle:'none', fillStyle:'none', lineWidth:1, lineDash:[], lineDashOffset:0, lineCap:'butt', lineJoin:'miter', miterLimit:1, shadowColor:'none', shadowOffsetX:0, shadowOffsetY:0, shadowBlur:0, 
globalAlpha:1, strokeOpacity:1, fillOpacity:1, transformFillStroke:false, translationX:0, translationY:0, rotationRads:0, rotationCenterX:null, rotationCenterY:null, scalingX:1, scalingY:1, scalingCenterX:null, scalingCenterY:null, constrainGradients:false}, dirtyTriggers:{hidden:'canvas', zIndex:'zIndex', globalAlpha:'canvas', globalCompositeOperation:'canvas', transformFillStroke:'canvas', strokeStyle:'canvas', fillStyle:'canvas', strokeOpacity:'canvas', fillOpacity:'canvas', lineWidth:'canvas', 
lineCap:'canvas', lineJoin:'canvas', lineDash:'canvas', lineDashOffset:'canvas', miterLimit:'canvas', shadowColor:'canvas', shadowOffsetX:'canvas', shadowOffsetY:'canvas', shadowBlur:'canvas', translationX:'transform', translationY:'transform', rotationRads:'transform', rotationCenterX:'transform', rotationCenterY:'transform', scalingX:'transform', scalingY:'transform', scalingCenterX:'transform', scalingCenterY:'transform', constrainGradients:'canvas'}, updaters:{'bbox':function(attrs) {
  attrs.bbox.plain.dirty = true;
  attrs.bbox.transform.dirty = true;
  if (attrs.rotationRads !== 0 && (attrs.rotationCenterX === null || attrs.rotationCenterY === null) || (attrs.scalingX !== 1 || attrs.scalingY !== 1) && (attrs.scalingCenterX === null || attrs.scalingCenterY === null)) {
    if (!attrs.dirtyFlags.transform) {
      attrs.dirtyFlags.transform = [];
    }
  }
}, 'zIndex':function(attrs) {
  attrs.dirtyZIndex = true;
}, 'transform':function(attrs) {
  attrs.dirtyTransform = true;
  attrs.bbox.transform.dirty = true;
}}}}, attr:{}, config:{parent:null}, onClassExtended:function(Class, member) {
  var initCfg = Class.superclass.self.def.initialConfig, cfg;
  if (member.inheritableStatics && member.inheritableStatics.def) {
    cfg = Ext.merge({}, initCfg, member.inheritableStatics.def);
    Class.def = Ext.create('Ext.draw.sprite.AttributeDefinition', cfg);
    delete member.inheritableStatics.def;
  } else {
    Class.def = Ext.create('Ext.draw.sprite.AttributeDefinition', initCfg);
  }
}, constructor:function(config) {
  if (this.$className === 'Ext.draw.sprite.Sprite') {
    throw 'Ext.draw.sprite.Sprite is an abstract class';
  }
  config = config || {};
  var me = this;
  me.id = config.id || Ext.id(null, 'ext-sprite-');
  me.attr = {};
  me.initConfig(config);
  var modifiers = Ext.Array.from(config.modifiers, true);
  me.prepareModifiers(modifiers);
  me.initializeAttributes();
  me.setAttributes(me.self.def.getDefaults(), true);
  me.setAttributes(config);
}, getDirty:function() {
  return this.attr.dirty;
}, setDirty:function(dirty) {
  if (this.attr.dirty = dirty) {
    if (this._parent) {
      this._parent.setDirty(true);
    }
  }
}, addModifier:function(modifier, reinitializeAttributes) {
  var me = this;
  if (!(modifier instanceof Ext.draw.modifier.Modifier)) {
    modifier = Ext.factory(modifier, null, null, 'modifier');
  }
  modifier.setSprite(this);
  if (modifier.preFx || modifier.config && modifier.config.preFx) {
    if (me.fx.getPrevious()) {
      me.fx.getPrevious().setNext(modifier);
    }
    modifier.setNext(me.fx);
  } else {
    me.topModifier.getPrevious().setNext(modifier);
    modifier.setNext(me.topModifier);
  }
  if (reinitializeAttributes) {
    me.initializeAttributes();
  }
  return modifier;
}, prepareModifiers:function(additionalModifiers) {
  var me = this, modifier, i, ln;
  me.topModifier = new Ext.draw.modifier.Target({sprite:me});
  me.fx = new Ext.draw.modifier.Animation({sprite:me});
  me.fx.setNext(me.topModifier);
  for (i = 0, ln = additionalModifiers.length; i < ln; i++) {
    me.addModifier(additionalModifiers[i], false);
  }
}, initializeAttributes:function() {
  var me = this;
  me.topModifier.prepareAttributes(me.attr);
}, updateDirtyFlags:function(attrs) {
  var me = this, dirtyFlags = attrs.dirtyFlags, flags, updaters = me.self.def._updaters, any = false, dirty = false, flag;
  do {
    any = false;
    for (flag in dirtyFlags) {
      me.updateDirtyFlags = Ext.emptyFn;
      flags = dirtyFlags[flag];
      delete dirtyFlags[flag];
      if (updaters[flag]) {
        updaters[flag].call(me, attrs, flags);
      }
      any = true;
      delete me.updateDirtyFlags;
    }
    dirty = dirty || any;
  } while (any);
  if (dirty) {
    me.setDirty(true);
  }
}, setAttributes:function(changes, bypassNormalization, avoidCopy) {
  var attributes = this.attr;
  if (bypassNormalization) {
    if (avoidCopy) {
      this.topModifier.pushDown(attributes, changes);
    } else {
      this.topModifier.pushDown(attributes, Ext.apply({}, changes));
    }
  } else {
    this.topModifier.pushDown(attributes, this.self.def.normalize(changes));
  }
}, setAttributesBypassingNormalization:function(changes, avoidCopy) {
  return this.setAttributes(changes, true, avoidCopy);
}, getBBox:function(isWithoutTransform) {
  var me = this, attr = me.attr, bbox = attr.bbox, plain = bbox.plain, transform = bbox.transform;
  if (plain.dirty) {
    me.updatePlainBBox(plain);
    plain.dirty = false;
  }
  if (isWithoutTransform) {
    return plain;
  } else {
    me.applyTransformations();
    if (transform.dirty) {
      me.updateTransformedBBox(transform, plain);
      transform.dirty = false;
    }
    return transform;
  }
}, updatePlainBBox:Ext.emptyFn, updateTransformedBBox:function(transform, plain) {
  this.attr.matrix.transformBBox(plain, 0, transform);
}, getBBoxCenter:function(isWithoutTransform) {
  var bbox = this.getBBox(isWithoutTransform);
  if (bbox) {
    return [bbox.x + bbox.width * 0.5, bbox.y + bbox.height * 0.5];
  } else {
    return [0, 0];
  }
}, hide:function() {
  this.attr.hidden = true;
  this.setDirty(true);
  return this;
}, show:function() {
  this.attr.hidden = false;
  this.setDirty(true);
  return this;
}, useAttributes:function(ctx, region) {
  this.applyTransformations();
  var attrs = this.attr, canvasAttributes = attrs.canvasAttributes, strokeStyle = canvasAttributes.strokeStyle, fillStyle = canvasAttributes.fillStyle, lineDash = canvasAttributes.lineDash, lineDashOffset = canvasAttributes.lineDashOffset, id;
  if (strokeStyle) {
    if (strokeStyle.isGradient) {
      ctx.strokeStyle = 'black';
      ctx.strokeGradient = strokeStyle;
    } else {
      ctx.strokeGradient = false;
    }
  }
  if (fillStyle) {
    if (fillStyle.isGradient) {
      ctx.fillStyle = 'black';
      ctx.fillGradient = fillStyle;
    } else {
      ctx.fillGradient = false;
    }
  }
  if (lineDash && ctx.setLineDash) {
    ctx.setLineDash(lineDash);
  }
  if (lineDashOffset && typeof ctx.lineDashOffset === 'number') {
    ctx.lineDashOffset = lineDashOffset;
  }
  for (id in canvasAttributes) {
    if (canvasAttributes[id] !== undefined && canvasAttributes[id] !== ctx[id]) {
      ctx[id] = canvasAttributes[id];
    }
  }
  if (attrs.constrainGradients) {
    ctx.setGradientBBox({x:region[0], y:region[1], width:region[2], height:region[3]});
  } else {
    ctx.setGradientBBox(this.getBBox(attrs.transformFillStroke));
  }
}, applyTransformations:function(force) {
  if (!force && !this.attr.dirtyTransform) {
    return;
  }
  var me = this, attr = me.attr, center = me.getBBoxCenter(true), centerX = center[0], centerY = center[1], x = attr.translationX, y = attr.translationY, sx = attr.scalingX, sy = attr.scalingY === null ? attr.scalingX : attr.scalingY, scx = attr.scalingCenterX === null ? centerX : attr.scalingCenterX, scy = attr.scalingCenterY === null ? centerY : attr.scalingCenterY, rad = attr.rotationRads, rcx = attr.rotationCenterX === null ? centerX : attr.rotationCenterX, rcy = attr.rotationCenterY === null ? 
  centerY : attr.rotationCenterY, cos = Math.cos(rad), sin = Math.sin(rad);
  if (sx === 1 && sy === 1) {
    scx = 0;
    scy = 0;
  }
  if (rad === 0) {
    rcx = 0;
    rcy = 0;
  }
  attr.matrix.elements = [cos * sx, sin * sy, -sin * sx, cos * sy, scx + (rcx - cos * rcx - scx + rcy * sin) * sx + x, scy + (rcy - cos * rcy - scy + rcx * -sin) * sy + y];
  attr.matrix.inverse(attr.inverseMatrix);
  attr.dirtyTransform = false;
  attr.bbox.transform.dirty = true;
}, preRender:Ext.emptyFn, render:Ext.emptyFn, repaint:function() {
  var parent = this.getParent();
  while (parent && !(parent instanceof Ext.draw.Surface)) {
    parent = parent.getParent();
  }
  if (parent) {
    parent.renderFrame();
  }
}, destroy:function() {
  var me = this, modifier = me.topModifier, curr;
  while (modifier) {
    curr = modifier;
    modifier = modifier.getPrevious();
    curr.destroy();
  }
  delete me.attr;
  me.destroy = Ext.emptyFn;
  if (me.fireEvent('beforedestroy', me) !== false) {
    me.fireEvent('destroy', me);
  }
  this.callSuper();
}}, 1, 0, 0, 0, ['sprite.sprite'], [['observable', Ext.mixin.Observable]], [Ext.draw.sprite, 'Sprite'], function() {
  this.def = Ext.create('Ext.draw.sprite.AttributeDefinition', this.def);
});
(function() {
  var PI2_3 = 2.0943951023931953, abs = Math.abs, sin = Math.cos, cos = Math.cos, acos = Math.acos, sqrt = Math.sqrt, exp = Math.exp, log = Math.log;
  Ext.cmd.derive('Ext.draw.Solver', Ext.Base, {singleton:true, cubicRoot:function(number) {
    if (number > 0) {
      return exp(log(number) / 3);
    } else {
      if (number < 0) {
        return -exp(log(-number) / 3);
      } else {
        return 0;
      }
    }
  }, linearFunction:function(a, b) {
    var result;
    if (a === 0) {
      result = function(t) {
        return b;
      };
      result.solve = function(y) {
        return [];
      };
    } else {
      result = function(t) {
        return a * t + b;
      };
      result.solve = function(y) {
        return [(y - b) / a];
      };
    }
    return result;
  }, quadraticFunction:function(a, b, c) {
    var result;
    if (a === 0) {
      return this.linearFunction(b, c);
    } else {
      result = function(t) {
        return (a * t + b) * t + c;
      };
      var delta0temp = b * b - 4 * a * c, delta = function(y) {
        return delta0temp + 4 * a * y;
      }, solveTemp0 = 1 / a * 0.5, solveTemp1 = -solveTemp0 * b;
      solveTemp0 = abs(solveTemp0);
      result.solve = function(y) {
        var deltaTemp = delta(y);
        if (deltaTemp < 0) {
          return [];
        }
        deltaTemp = sqrt(deltaTemp);
        return [solveTemp1 - deltaTemp * solveTemp0, solveTemp1 + deltaTemp * solveTemp0];
      };
    }
    return result;
  }, cubicFunction:function(a, b, c, d) {
    var result;
    if (a === 0) {
      return this.quadraticFunction(b, c, d);
    } else {
      result = function(t) {
        return ((a * t + b) * t + c) * t + d;
      };
      var b_a_3 = b / a / 3, c_a = c / a, d_a = d / a, b2 = b_a_3 * b_a_3, deltaTemp0 = (b_a_3 * c_a - d_a) * 0.5 - b_a_3 * b2, deltaTemp1 = b2 - c_a / 3, deltaTemp13 = deltaTemp1 * deltaTemp1 * deltaTemp1;
      if (deltaTemp1 === 0) {
        result.solve = function(y) {
          return [-b_a_3 + this.cubicRoot(deltaTemp0 * 2 + y / a)];
        };
      } else {
        if (deltaTemp1 > 0) {
          var deltaTemp1_2 = sqrt(deltaTemp1), deltaTemp13_2 = deltaTemp1_2 * deltaTemp1_2 * deltaTemp1_2;
          deltaTemp1_2 += deltaTemp1_2;
        }
        result.solve = function(y) {
          y /= a;
          var d0 = deltaTemp0 + y * 0.5, deltaTemp = d0 * d0 - deltaTemp13;
          if (deltaTemp > 0) {
            deltaTemp = sqrt(deltaTemp);
            return [-b_a_3 + this.cubicRoot(d0 + deltaTemp) + this.cubicRoot(d0 - deltaTemp)];
          } else {
            if (deltaTemp === 0) {
              var cr = this.cubicRoot(d0), root0 = -b_a_3 - cr;
              if (d0 >= 0) {
                return [root0, root0, -b_a_3 + 2 * cr];
              } else {
                return [-b_a_3 + 2 * cr, root0, root0];
              }
            } else {
              var theta = acos(d0 / deltaTemp13_2) / 3, ra = deltaTemp1_2 * cos(theta) - b_a_3, rb = deltaTemp1_2 * cos(theta + PI2_3) - b_a_3, rc = deltaTemp1_2 * cos(theta - PI2_3) - b_a_3;
              if (ra < rb) {
                if (rb < rc) {
                  return [ra, rb, rc];
                } else {
                  if (ra < rc) {
                    return [ra, rc, rb];
                  } else {
                    return [rc, ra, rb];
                  }
                }
              } else {
                if (ra < rc) {
                  return [rb, ra, rc];
                } else {
                  if (rb < rc) {
                    return [rb, rc, ra];
                  } else {
                    return [rc, rb, ra];
                  }
                }
              }
            }
          }
        };
      }
    }
    return result;
  }, createBezierSolver:function(a, b, c, d) {
    return this.cubicFunction(3 * (b - c) + d - a, 3 * (a - 2 * b + c), 3 * (b - a), a);
  }}, 0, 0, 0, 0, 0, 0, [Ext.draw, 'Solver'], 0);
})();
Ext.cmd.derive('Ext.draw.Path', Ext.Base, {statics:{pathRe:/,?([achlmqrstvxz]),?/gi, pathRe2:/-/gi, pathSplitRe:/\s|,/g}, svgString:'', constructor:function(pathString) {
  var me = this;
  me.coords = [];
  me.types = [];
  me.cursor = null;
  me.startX = 0;
  me.startY = 0;
  me.solvers = {};
  if (pathString) {
    me.fromSvgString(pathString);
  }
}, clear:function() {
  var me = this;
  me.coords.length = 0;
  me.types.length = 0;
  me.cursor = null;
  me.startX = 0;
  me.startY = 0;
  me.solvers = {};
  me.dirt();
}, dirt:function() {
  this.svgString = '';
}, moveTo:function(x, y) {
  var me = this;
  if (!me.cursor) {
    me.cursor = [x, y];
  }
  me.coords.push(x, y);
  me.types.push('M');
  me.startX = x;
  me.startY = y;
  me.cursor[0] = x;
  me.cursor[1] = y;
  me.dirt();
}, lineTo:function(x, y) {
  var me = this;
  if (!me.cursor) {
    me.cursor = [x, y];
    me.coords.push(x, y);
    me.types.push('M');
  } else {
    me.coords.push(x, y);
    me.types.push('L');
  }
  me.cursor[0] = x;
  me.cursor[1] = y;
  me.dirt();
}, bezierCurveTo:function(cx1, cy1, cx2, cy2, x, y) {
  var me = this;
  if (!me.cursor) {
    me.moveTo(cx1, cy1);
  }
  me.coords.push(cx1, cy1, cx2, cy2, x, y);
  me.types.push('C');
  me.cursor[0] = x;
  me.cursor[1] = y;
  me.dirt();
}, quadraticCurveTo:function(cx, cy, x, y) {
  var me = this;
  if (!me.cursor) {
    me.moveTo(cx, cy);
  }
  me.bezierCurveTo((me.cursor[0] * 2 + cx) / 3, (me.cursor[1] * 2 + cy) / 3, (x * 2 + cx) / 3, (y * 2 + cy) / 3, x, y);
}, closePath:function() {
  var me = this;
  if (me.cursor) {
    me.types.push('Z');
    me.dirt();
  }
}, arcTo:function(x1, y1, x2, y2, rx, ry, rotation) {
  var me = this;
  if (ry === undefined) {
    ry = rx;
  }
  if (rotation === undefined) {
    rotation = 0;
  }
  if (!me.cursor) {
    me.moveTo(x1, y1);
    return;
  }
  if (rx === 0 || ry === 0) {
    me.lineTo(x1, y1);
    return;
  }
  x2 -= x1;
  y2 -= y1;
  var x0 = me.cursor[0] - x1, y0 = me.cursor[1] - y1, area = x2 * y0 - y2 * x0, cos, sin, xx, yx, xy, yy, l0 = Math.sqrt(x0 * x0 + y0 * y0), l2 = Math.sqrt(x2 * x2 + y2 * y2), dist, cx, cy;
  if (area === 0) {
    me.lineTo(x1, y1);
    return;
  }
  if (ry !== rx) {
    cos = Math.cos(rotation);
    sin = Math.sin(rotation);
    xx = cos / rx;
    yx = sin / ry;
    xy = -sin / rx;
    yy = cos / ry;
    var temp = xx * x0 + yx * y0;
    y0 = xy * x0 + yy * y0;
    x0 = temp;
    temp = xx * x2 + yx * y2;
    y2 = xy * x2 + yy * y2;
    x2 = temp;
  } else {
    x0 /= rx;
    y0 /= ry;
    x2 /= rx;
    y2 /= ry;
  }
  cx = x0 * l2 + x2 * l0;
  cy = y0 * l2 + y2 * l0;
  dist = 1 / (Math.sin(Math.asin(Math.abs(area) / (l0 * l2)) * 0.5) * Math.sqrt(cx * cx + cy * cy));
  cx *= dist;
  cy *= dist;
  var k0 = (cx * x0 + cy * y0) / (x0 * x0 + y0 * y0), k2 = (cx * x2 + cy * y2) / (x2 * x2 + y2 * y2);
  var cosStart = x0 * k0 - cx, sinStart = y0 * k0 - cy, cosEnd = x2 * k2 - cx, sinEnd = y2 * k2 - cy, startAngle = Math.atan2(sinStart, cosStart), endAngle = Math.atan2(sinEnd, cosEnd);
  if (area > 0) {
    if (endAngle < startAngle) {
      endAngle += Math.PI * 2;
    }
  } else {
    if (startAngle < endAngle) {
      startAngle += Math.PI * 2;
    }
  }
  if (ry !== rx) {
    cx = cos * cx * rx - sin * cy * ry + x1;
    cy = sin * cy * ry + cos * cy * ry + y1;
    me.lineTo(cos * rx * cosStart - sin * ry * sinStart + cx, sin * rx * cosStart + cos * ry * sinStart + cy);
    me.ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, area < 0);
  } else {
    cx = cx * rx + x1;
    cy = cy * ry + y1;
    me.lineTo(rx * cosStart + cx, ry * sinStart + cy);
    me.ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, area < 0);
  }
}, ellipse:function(cx, cy, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
  var me = this, coords = me.coords, start = coords.length, count, i, j;
  if (endAngle - startAngle >= Math.PI * 2) {
    me.ellipse(cx, cy, radiusX, radiusY, rotation, startAngle, startAngle + Math.PI, anticlockwise);
    me.ellipse(cx, cy, radiusX, radiusY, rotation, startAngle + Math.PI, endAngle, anticlockwise);
    return;
  }
  if (!anticlockwise) {
    if (endAngle < startAngle) {
      endAngle += Math.PI * 2;
    }
    count = me.approximateArc(coords, cx, cy, radiusX, radiusY, rotation, startAngle, endAngle);
  } else {
    if (startAngle < endAngle) {
      startAngle += Math.PI * 2;
    }
    count = me.approximateArc(coords, cx, cy, radiusX, radiusY, rotation, endAngle, startAngle);
    for (i = start, j = coords.length - 2; i < j; i += 2, j -= 2) {
      var temp = coords[i];
      coords[i] = coords[j];
      coords[j] = temp;
      temp = coords[i + 1];
      coords[i + 1] = coords[j + 1];
      coords[j + 1] = temp;
    }
  }
  if (!me.cursor) {
    me.cursor = [coords[coords.length - 2], coords[coords.length - 1]];
    me.types.push('M');
  } else {
    me.cursor[0] = coords[coords.length - 2];
    me.cursor[1] = coords[coords.length - 1];
    me.types.push('L');
  }
  for (i = 2; i < count; i += 6) {
    me.types.push('C');
  }
  me.dirt();
}, arc:function(x, y, radius, startAngle, endAngle, anticlockwise) {
  this.ellipse(x, y, radius, radius, 0, startAngle, endAngle, anticlockwise);
}, rect:function(x, y, width, height) {
  if (width == 0 || height == 0) {
    return;
  }
  var me = this;
  me.moveTo(x, y);
  me.lineTo(x + width, y);
  me.lineTo(x + width, y + height);
  me.lineTo(x, y + height);
  me.closePath();
}, approximateArc:function(result, cx, cy, rx, ry, phi, theta1, theta2) {
  var cosPhi = Math.cos(phi), sinPhi = Math.sin(phi), cosTheta1 = Math.cos(theta1), sinTheta1 = Math.sin(theta1), xx = cosPhi * cosTheta1 * rx - sinPhi * sinTheta1 * ry, yx = -cosPhi * sinTheta1 * rx - sinPhi * cosTheta1 * ry, xy = sinPhi * cosTheta1 * rx + cosPhi * sinTheta1 * ry, yy = -sinPhi * sinTheta1 * rx + cosPhi * cosTheta1 * ry, rightAngle = Math.PI / 2, count = 2, exx = xx, eyx = yx, exy = xy, eyy = yy, rho = 0.547443256150549, temp, y1, x3, y3, x2, y2;
  theta2 -= theta1;
  if (theta2 < 0) {
    theta2 += Math.PI * 2;
  }
  result.push(xx + cx, xy + cy);
  while (theta2 >= rightAngle) {
    result.push(exx + eyx * rho + cx, exy + eyy * rho + cy, exx * rho + eyx + cx, exy * rho + eyy + cy, eyx + cx, eyy + cy);
    count += 6;
    theta2 -= rightAngle;
    temp = exx;
    exx = eyx;
    eyx = -temp;
    temp = exy;
    exy = eyy;
    eyy = -temp;
  }
  if (theta2) {
    y1 = (0.3294738052815987 + 0.012120855841304373 * theta2) * theta2;
    x3 = Math.cos(theta2);
    y3 = Math.sin(theta2);
    x2 = x3 + y1 * y3;
    y2 = y3 - y1 * x3;
    result.push(exx + eyx * y1 + cx, exy + eyy * y1 + cy, exx * x2 + eyx * y2 + cx, exy * x2 + eyy * y2 + cy, exx * x3 + eyx * y3 + cx, exy * x3 + eyy * y3 + cy);
    count += 6;
  }
  return count;
}, arcSvg:function(rx, ry, rotation, fA, fS, x2, y2) {
  if (rx < 0) {
    rx = -rx;
  }
  if (ry < 0) {
    ry = -ry;
  }
  var me = this, x1 = me.cursor[0], y1 = me.cursor[1], hdx = (x1 - x2) / 2, hdy = (y1 - y2) / 2, cosPhi = Math.cos(rotation), sinPhi = Math.sin(rotation), xp = hdx * cosPhi + hdy * sinPhi, yp = -hdx * sinPhi + hdy * cosPhi, ratX = xp / rx, ratY = yp / ry, lambda = ratX * ratX + ratY * ratY, cx = (x1 + x2) * 0.5, cy = (y1 + y2) * 0.5, cpx = 0, cpy = 0;
  if (lambda >= 1) {
    lambda = Math.sqrt(lambda);
    rx *= lambda;
    ry *= lambda;
  } else {
    lambda = Math.sqrt(1 / lambda - 1);
    if (fA === fS) {
      lambda = -lambda;
    }
    cpx = lambda * rx * ratY;
    cpy = -lambda * ry * ratX;
    cx += cosPhi * cpx - sinPhi * cpy;
    cy += sinPhi * cpx + cosPhi * cpy;
  }
  var theta1 = Math.atan2((yp - cpy) / ry, (xp - cpx) / rx), deltaTheta = Math.atan2((-yp - cpy) / ry, (-xp - cpx) / rx) - theta1;
  if (fS) {
    if (deltaTheta <= 0) {
      deltaTheta += Math.PI * 2;
    }
  } else {
    if (deltaTheta >= 0) {
      deltaTheta -= Math.PI * 2;
    }
  }
  me.ellipse(cx, cy, rx, ry, rotation, theta1, theta1 + deltaTheta, 1 - fS);
}, fromSvgString:function(pathString) {
  if (!pathString) {
    return;
  }
  var me = this, parts, paramCounts = {a:7, c:6, h:1, l:2, m:2, q:4, s:4, t:2, v:1, z:0, A:7, C:6, H:1, L:2, M:2, Q:4, S:4, T:2, V:1, Z:0}, lastCommand = '', lastControlX, lastControlY, lastX = 0, lastY = 0, part = false, i, partLength, relative;
  if (Ext.isString(pathString)) {
    parts = pathString.replace(Ext.draw.Path.pathRe, ' $1 ').replace(Ext.draw.Path.pathRe2, ' -').split(Ext.draw.Path.pathSplitRe);
  } else {
    if (Ext.isArray(pathString)) {
      parts = pathString.join(',').split(Ext.draw.Path.pathSplitRe);
    }
  }
  for (i = 0, partLength = 0; i < parts.length; i++) {
    if (parts[i] !== '') {
      parts[partLength++] = parts[i];
    }
  }
  parts.length = partLength;
  me.clear();
  for (i = 0; i < parts.length;) {
    lastCommand = part;
    part = parts[i];
    relative = part.toUpperCase() !== part;
    i++;
    switch(part) {
      case 'M':
        me.moveTo(lastX = +parts[i], lastY = +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX = +parts[i], lastY = +parts[i + 1]);
          i += 2;
        }
        break;
      case 'L':
        me.lineTo(lastX = +parts[i], lastY = +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX = +parts[i], lastY = +parts[i + 1]);
          i += 2;
        }
        break;
      case 'A':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.arcSvg(+parts[i], +parts[i + 1], +parts[i + 2] * Math.PI / 180, +parts[i + 3], +parts[i + 4], lastX = +parts[i + 5], lastY = +parts[i + 6]);
          i += 7;
        }
        break;
      case 'C':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(+parts[i], +parts[i + 1], lastControlX = +parts[i + 2], lastControlY = +parts[i + 3], lastX = +parts[i + 4], lastY = +parts[i + 5]);
          i += 6;
        }
        break;
      case 'Z':
        me.closePath();
        break;
      case 'm':
        me.moveTo(lastX += +parts[i], lastY += +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX += +parts[i], lastY += +parts[i + 1]);
          i += 2;
        }
        break;
      case 'l':
        me.lineTo(lastX += +parts[i], lastY += +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX += +parts[i], lastY += +parts[i + 1]);
          i += 2;
        }
        break;
      case 'a':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.arcSvg(+parts[i], +parts[i + 1], +parts[i + 2] * Math.PI / 180, +parts[i + 3], +parts[i + 4], lastX += +parts[i + 5], lastY += +parts[i + 6]);
          i += 7;
        }
        break;
      case 'c':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(lastX + +parts[i], lastY + +parts[i + 1], lastControlX = lastX + +parts[i + 2], lastControlY = lastY + +parts[i + 3], lastX += +parts[i + 4], lastY += +parts[i + 5]);
          i += 6;
        }
        break;
      case 'z':
        me.closePath();
        break;
      case 's':
        if (!(lastCommand === 'c' || lastCommand === 'C' || lastCommand === 's' || lastCommand === 'S')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(lastX + lastX - lastControlX, lastY + lastY - lastControlY, lastControlX = lastX + +parts[i], lastControlY = lastY + +parts[i + 1], lastX += +parts[i + 2], lastY += +parts[i + 3]);
          i += 4;
        }
        break;
      case 'S':
        if (!(lastCommand === 'c' || lastCommand === 'C' || lastCommand === 's' || lastCommand === 'S')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(lastX + lastX - lastControlX, lastY + lastY - lastControlY, lastControlX = +parts[i], lastControlY = +parts[i + 1], lastX = +parts[i + 2], lastY = +parts[i + 3]);
          i += 4;
        }
        break;
      case 'q':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = lastX + +parts[i], lastControlY = lastY + +parts[i + 1], lastX += +parts[i + 2], lastY += +parts[i + 3]);
          i += 4;
        }
        break;
      case 'Q':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = +parts[i], lastControlY = +parts[i + 1], lastX = +parts[i + 2], lastY = +parts[i + 3]);
          i += 4;
        }
        break;
      case 't':
        if (!(lastCommand === 'q' || lastCommand === 'Q' || lastCommand === 't' || lastCommand === 'T')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = lastX + lastX - lastControlX, lastControlY = lastY + lastY - lastControlY, lastX += +parts[i + 1], lastY += +parts[i + 2]);
          i += 2;
        }
        break;
      case 'T':
        if (!(lastCommand === 'q' || lastCommand === 'Q' || lastCommand === 't' || lastCommand === 'T')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = lastX + lastX - lastControlX, lastControlY = lastY + lastY - lastControlY, lastX = +parts[i + 1], lastY = +parts[i + 2]);
          i += 2;
        }
        break;
      case 'h':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX += +parts[i], lastY);
          i++;
        }
        break;
      case 'H':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX = +parts[i], lastY);
          i++;
        }
        break;
      case 'v':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX, lastY += +parts[i]);
          i++;
        }
        break;
      case 'V':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX, lastY = +parts[i]);
          i++;
        }
        break;
    }
  }
}, rayTestLine:function(x1, y1, x2, y2, x, y) {
  var cx;
  if (y1 === y2) {
    if (y === y1) {
      if (Math.min(x1, x2) <= x && x <= Math.max(x1, x2)) {
        return -1;
      }
    } else {
      return 0;
    }
  }
  if (y1 < y && y < y2 || y2 < y && y < y1) {
    cx = (y - y1) * (x2 - x1) / (y2 - y1) + x1;
    if (cx === x) {
      return -1;
    } else {
      if (cx < x) {
        return 0;
      } else {
        return 1;
      }
    }
  } else {
    return 0;
  }
}, rayTestCubicBezier:function(x1, y1, x2, y2, x3, y3, x4, y4, x, y, idx) {
  if (Math.min(x1, x2, x3, x4) <= x && x <= Math.max(x1, x2, x3, x4)) {
    if (Math.min(y1, y2, y3, y4) <= y && y <= Math.max(y1, y2, y3, y4)) {
      var me = this, solver = me.solvers[idx] || (me.solvers[idx] = Ext.draw.Solver.createBezierSolver(x1, x2, x3, x4)), result = solver.solve(y);
      return +(x <= result[0] && 0 <= result[0] && result[0] <= 1) + +(x <= result[1] && 0 <= result[1] && result[1] <= 1) + +(x <= result[2] && 0 <= result[2] && result[2] <= 1);
    }
  }
  return 0;
}, isPointInPath:function(x, y) {
  var me = this, i, j, count = 0, test = 0, types = me.types, coords = me.coords, ln = types.length, firstX = null, firstY = null, lastX = 0, lastY = 0;
  for (i = 0, j = 0; i < ln; i++) {
    switch(types[i]) {
      case 'M':
        if (firstX !== null) {
          test = me.rayTestLine(firstX, firstY, lastX, lastY, x, y);
          if (test < 0) {
            count += 1;
          } else {
            count += test;
          }
        }
        firstX = lastX = coords[j];
        firstY = lastY = coords[j + 1];
        j += 2;
        break;
      case 'L':
        test = me.rayTestLine(lastX, lastY, coords[j], coords[j + 1], x, y);
        if (test < 0) {
          return true;
        }
        count += test;
        lastX = coords[j];
        lastY = coords[j + 1];
        j += 2;
        break;
      case 'C':
        test = me.rayTestCubicBezier(lastX, lastY, coords[j], coords[j + 1], coords[j + 2], coords[j + 3], coords[j + 4], coords[j + 5], x, y, i);
        if (test < 0) {
          return true;
        }
        count += test;
        lastX = coords[j + 4];
        lastY = coords[j + 5];
        j += 6;
        break;
      case 'Z':
        break;
    }
  }
  return count % 2 === 1;
}, clone:function() {
  var me = this, path = new Ext.draw.Path;
  path.coords = me.coords.slice(0);
  path.types = me.types.slice(0);
  path.cursor = me.cursor ? me.cursor.slice(0) : null;
  path.startX = me.startX;
  path.startY = me.startY;
  path.svgString = me.svgString;
  return path;
}, transform:function(matrix) {
  if (matrix.isIdentity()) {
    return;
  }
  var xx = matrix.getXX(), yx = matrix.getYX(), dx = matrix.getDX(), xy = matrix.getXY(), yy = matrix.getYY(), dy = matrix.getDY(), coords = this.coords, i = 0, ln = coords.length, x, y;
  for (; i < ln; i += 2) {
    x = coords[i];
    y = coords[i + 1];
    coords[i] = x * xx + y * yx + dx;
    coords[i + 1] = x * xy + y * yy + dy;
  }
  this.dirt();
}, getDimension:function(target) {
  if (!target) {
    target = {};
  }
  if (!this.types || !this.types.length) {
    target.x = 0;
    target.y = 0;
    target.width = 0;
    target.height = 0;
    return target;
  }
  target.left = Infinity;
  target.top = Infinity;
  target.right = -Infinity;
  target.bottom = -Infinity;
  var i = 0, j = 0, types = this.types, coords = this.coords, ln = types.length, x, y;
  for (; i < ln; i++) {
    switch(types[i]) {
      case 'M':
      case 'L':
        x = coords[j];
        y = coords[j + 1];
        target.left = Math.min(x, target.left);
        target.top = Math.min(y, target.top);
        target.right = Math.max(x, target.right);
        target.bottom = Math.max(y, target.bottom);
        j += 2;
        break;
      case 'C':
        this.expandDimension(target, x, y, coords[j], coords[j + 1], coords[j + 2], coords[j + 3], x = coords[j + 4], y = coords[j + 5]);
        j += 6;
        break;
    }
  }
  target.x = target.left;
  target.y = target.top;
  target.width = target.right - target.left;
  target.height = target.bottom - target.top;
  return target;
}, getDimensionWithTransform:function(matrix, target) {
  if (!this.types || !this.types.length) {
    if (!target) {
      target = {};
    }
    target.x = 0;
    target.y = 0;
    target.width = 0;
    target.height = 0;
    return target;
  }
  target.left = Infinity;
  target.top = Infinity;
  target.right = -Infinity;
  target.bottom = -Infinity;
  var xx = matrix.getXX(), yx = matrix.getYX(), dx = matrix.getDX(), xy = matrix.getXY(), yy = matrix.getYY(), dy = matrix.getDY(), i = 0, j = 0, types = this.types, coords = this.coords, ln = types.length, x, y;
  for (; i < ln; i++) {
    switch(types[i]) {
      case 'M':
      case 'L':
        x = coords[j] * xx + coords[j + 1] * yx + dx;
        y = coords[j] * xy + coords[j + 1] * yy + dy;
        target.left = Math.min(x, target.left);
        target.top = Math.min(y, target.top);
        target.right = Math.max(x, target.right);
        target.bottom = Math.max(y, target.bottom);
        j += 2;
        break;
      case 'C':
        this.expandDimension(target, x, y, coords[j] * xx + coords[j + 1] * yx + dx, coords[j] * xy + coords[j + 1] * yy + dy, coords[j + 2] * xx + coords[j + 3] * yx + dx, coords[j + 2] * xy + coords[j + 3] * yy + dy, x = coords[j + 4] * xx + coords[j + 5] * yx + dx, y = coords[j + 4] * xy + coords[j + 5] * yy + dy);
        j += 6;
        break;
    }
  }
  if (!target) {
    target = {};
  }
  target.x = target.left;
  target.y = target.top;
  target.width = target.right - target.left;
  target.height = target.bottom - target.top;
  return target;
}, expandDimension:function(target, x1, y1, cx1, cy1, cx2, cy2, x2, y2) {
  var me = this, l = target.left, r = target.right, t = target.top, b = target.bottom, dim = me.dim || (me.dim = []);
  me.curveDimension(x1, cx1, cx2, x2, dim);
  l = Math.min(l, dim[0]);
  r = Math.max(r, dim[1]);
  me.curveDimension(y1, cy1, cy2, y2, dim);
  t = Math.min(t, dim[0]);
  b = Math.max(b, dim[1]);
  target.left = l;
  target.right = r;
  target.top = t;
  target.bottom = b;
}, curveDimension:function(a, b, c, d, dim) {
  var qa = 3 * (-a + 3 * (b - c) + d), qb = 6 * (a - 2 * b + c), qc = -3 * (a - b), x, y, min = Math.min(a, d), max = Math.max(a, d), delta;
  if (qa === 0) {
    if (qb === 0) {
      dim[0] = min;
      dim[1] = max;
      return;
    } else {
      x = -qc / qb;
      if (0 < x && x < 1) {
        y = this.interpolate(a, b, c, d, x);
        min = Math.min(min, y);
        max = Math.max(max, y);
      }
    }
  } else {
    delta = qb * qb - 4 * qa * qc;
    if (delta >= 0) {
      delta = Math.sqrt(delta);
      x = (delta - qb) / 2 / qa;
      if (0 < x && x < 1) {
        y = this.interpolate(a, b, c, d, x);
        min = Math.min(min, y);
        max = Math.max(max, y);
      }
      if (delta > 0) {
        x -= delta / qa;
        if (0 < x && x < 1) {
          y = this.interpolate(a, b, c, d, x);
          min = Math.min(min, y);
          max = Math.max(max, y);
        }
      }
    }
  }
  dim[0] = min;
  dim[1] = max;
}, interpolate:function(a, b, c, d, t) {
  if (t === 0) {
    return a;
  }
  if (t === 1) {
    return d;
  }
  var rate = (1 - t) / t;
  return t * t * t * (d + rate * (3 * c + rate * (3 * b + rate * a)));
}, fromStripes:function(stripes) {
  var me = this, i = 0, ln = stripes.length, j, ln2, stripe;
  me.clear();
  for (; i < ln; i++) {
    stripe = stripes[i];
    me.coords.push.apply(me.coords, stripe);
    me.types.push('M');
    for (j = 2, ln2 = stripe.length; j < ln2; j += 6) {
      me.types.push('C');
    }
  }
  if (!me.cursor) {
    me.cursor = [];
  }
  me.cursor[0] = me.coords[me.coords.length - 2];
  me.cursor[1] = me.coords[me.coords.length - 1];
  me.dirt();
}, toStripes:function(target) {
  var stripes = target || [], curr, x, y, lastX, lastY, startX, startY, i, j, types = this.types, coords = this.coords, ln = types.length;
  for (i = 0, j = 0; i < ln; i++) {
    switch(types[i]) {
      case 'M':
        curr = [startX = lastX = coords[j++], startY = lastY = coords[j++]];
        stripes.push(curr);
        break;
      case 'L':
        x = coords[j++];
        y = coords[j++];
        curr.push((lastX + lastX + x) / 3, (lastY + lastY + y) / 3, (lastX + x + x) / 3, (lastY + y + y) / 3, lastX = x, lastY = y);
        break;
      case 'C':
        curr.push(coords[j++], coords[j++], coords[j++], coords[j++], lastX = coords[j++], lastY = coords[j++]);
        break;
      case 'Z':
        x = startX;
        y = startY;
        curr.push((lastX + lastX + x) / 3, (lastY + lastY + y) / 3, (lastX + x + x) / 3, (lastY + y + y) / 3, lastX = x, lastY = y);
        break;
    }
  }
  return stripes;
}, updateSvgString:function() {
  var result = [], types = this.types, coords = this.coords, ln = types.length, i = 0, j = 0;
  for (; i < ln; i++) {
    switch(types[i]) {
      case 'M':
        result.push('M' + coords[j] + ',' + coords[j + 1]);
        j += 2;
        break;
      case 'L':
        result.push('L' + coords[j] + ',' + coords[j + 1]);
        j += 2;
        break;
      case 'C':
        result.push('C' + coords[j] + ',' + coords[j + 1] + ' ' + coords[j + 2] + ',' + coords[j + 3] + ' ' + coords[j + 4] + ',' + coords[j + 5]);
        j += 6;
        break;
      case 'Z':
        result.push('Z');
        break;
    }
  }
  this.svgString = result.join('');
}, toString:function() {
  if (!this.svgString) {
    this.updateSvgString();
  }
  return this.svgString;
}}, 3, 0, 0, 0, 0, 0, [Ext.draw, 'Path'], 0);
Ext.cmd.derive('Ext.draw.sprite.Path', Ext.draw.sprite.Sprite, {type:'path', inheritableStatics:{def:{processors:{path:function(n, o) {
  if (!(n instanceof Ext.draw.Path)) {
    n = new Ext.draw.Path(n);
  }
  return n;
}}, aliases:{d:'path'}, dirtyTriggers:{path:'bbox'}, updaters:{path:function(attr) {
  var path = attr.path;
  if (!path || path.bindAttr !== attr) {
    path = new Ext.draw.Path;
    path.bindAttr = attr;
    attr.path = path;
  }
  path.clear();
  this.updatePath(path, attr);
  attr.dirtyFlags.bbox = ['path'];
}}}}, updatePlainBBox:function(plain) {
  if (this.attr.path) {
    this.attr.path.getDimension(plain);
  }
}, updateTransformedBBox:function(transform) {
  if (this.attr.path) {
    this.attr.path.getDimensionWithTransform(this.attr.matrix, transform);
  }
}, render:function(surface, ctx) {
  var mat = this.attr.matrix, attr = this.attr;
  if (!attr.path || attr.path.coords.length === 0) {
    return;
  }
  mat.toContext(ctx);
  ctx.appendPath(attr.path);
  ctx.fillStroke(attr);
}, updatePath:function(path, attr) {
}}, 0, 0, 0, 0, ['sprite.path'], 0, [Ext.draw.sprite, 'Path'], 0);
Ext.cmd.derive('Ext.draw.sprite.Circle', Ext.draw.sprite.Path, {type:'circle', inheritableStatics:{def:{processors:{cx:'number', cy:'number', r:'number'}, aliases:{radius:'r', x:'cx', y:'cy', centerX:'cx', centerY:'cy'}, defaults:{cx:0, cy:0, r:0}, dirtyTriggers:{cx:'path', cy:'path', r:'path'}}}, updatePlainBBox:function(plain) {
  var attr = this.attr, cx = attr.cx, cy = attr.cy, r = attr.r;
  plain.x = cx - r;
  plain.y = cy - r;
  plain.width = r + r;
  plain.height = r + r;
}, updateTransformedBBox:function(transform) {
  var attr = this.attr, cx = attr.cx, cy = attr.cy, r = attr.r, matrix = attr.matrix, scalesX = matrix.getScaleX(), scalesY = matrix.getScaleY(), w, h;
  w = scalesX * r;
  h = scalesY * r;
  transform.x = matrix.x(cx, cy) - w;
  transform.y = matrix.y(cx, cy) - h;
  transform.width = w + w;
  transform.height = h + h;
}, updatePath:function(path, attr) {
  path.arc(attr.cx, attr.cy, attr.r, 0, Math.PI * 2, false);
}}, 0, 0, 0, 0, ['sprite.circle'], 0, [Ext.draw.sprite, 'Circle'], 0);
Ext.cmd.derive('Ext.draw.sprite.Arc', Ext.draw.sprite.Circle, {type:'arc', inheritableStatics:{def:{processors:{startAngle:'number', endAngle:'number', anticlockwise:'bool'}, aliases:{from:'startAngle', to:'endAngle', start:'startAngle', end:'endAngle'}, defaults:{startAngle:0, endAngle:Math.PI * 2, anticlockwise:false}, dirtyTriggers:{startAngle:'path', endAngle:'path', anticlockwise:'path'}}}, updatePath:function(path, attr) {
  path.arc(attr.cx, attr.cy, attr.r, attr.startAngle, attr.endAngle, attr.anticlockwise);
}}, 0, 0, 0, 0, ['sprite.arc'], 0, [Ext.draw.sprite, 'Arc'], 0);
Ext.cmd.derive('Ext.draw.sprite.Composite', Ext.draw.sprite.Sprite, {type:'composite', constructor:function() {
  Ext.draw.sprite.Sprite.prototype.constructor.apply(this, arguments);
  this.sprites = [];
  this.sprites.map = {};
}, add:function(sprite) {
  if (!(sprite instanceof Ext.draw.sprite.Sprite)) {
    sprite = Ext.create('sprite.' + sprite.type, sprite);
    sprite.setParent(this);
  }
  var oldTransformations = sprite.applyTransformations, me = this, attr = me.attr;
  sprite.applyTransformations = function() {
    if (sprite.attr.dirtyTransform) {
      attr.dirtyTransform = true;
      attr.bbox.plain.dirty = true;
      attr.bbox.transform.dirty = true;
    }
    oldTransformations.call(sprite);
  };
  this.sprites.push(sprite);
  this.sprites.map[sprite.id] = sprite.getId();
  attr.bbox.plain.dirty = true;
  attr.bbox.transform.dirty = true;
  return sprite;
}, addAll:function(sprites) {
  if (sprites.isSprite || sprites.type) {
    this.add(sprites);
  } else {
    if (Ext.isArray(sprites)) {
      var i = 0;
      while (i < sprites.length) {
        this.add(sprites[i++]);
      }
    }
  }
}, updatePlainBBox:function(plain) {
  var me = this, left = Infinity, right = -Infinity, top = Infinity, bottom = -Infinity, sprite, bbox, i, ln;
  for (i = 0, ln = me.sprites.length; i < ln; i++) {
    sprite = me.sprites[i];
    sprite.applyTransformations();
    bbox = sprite.getBBox();
    if (left > bbox.x) {
      left = bbox.x;
    }
    if (right < bbox.x + bbox.width) {
      right = bbox.x + bbox.width;
    }
    if (top > bbox.y) {
      top = bbox.y;
    }
    if (bottom < bbox.y + bbox.height) {
      bottom = bbox.y + bbox.height;
    }
  }
  plain.x = left;
  plain.y = top;
  plain.width = right - left;
  plain.height = bottom - top;
}, render:function(surface, ctx, region) {
  var mat = this.attr.matrix, i, ln;
  mat.toContext(ctx);
  for (i = 0, ln = this.sprites.length; i < ln; i++) {
    surface.renderSprite(this.sprites[i], region);
  }
}}, 1, 0, 0, 0, ['sprite.composite'], 0, [Ext.draw.sprite, 'Composite'], 0);
Ext.cmd.derive('Ext.draw.sprite.Ellipse', Ext.draw.sprite.Path, {type:'circle', inheritableStatics:{def:{processors:{cx:'number', cy:'number', rx:'number', ry:'number', axisRotation:'number'}, aliases:{radius:'r', x:'cx', y:'cy', centerX:'cx', centerY:'cy', radiusX:'rx', radiusY:'ry'}, defaults:{cx:0, cy:0, rx:1, ry:1, axisRotation:0}, dirtyTriggers:{cx:'path', cy:'path', rx:'path', ry:'path', axisRotation:'path'}}}, updatePlainBBox:function(plain) {
  var attr = this.attr, cx = attr.cx, cy = attr.cy, rx = attr.rx, ry = attr.ry;
  plain.x = cx - rx;
  plain.y = cy - ry;
  plain.width = rx + rx;
  plain.height = ry + ry;
}, updateTransformedBBox:function(transform) {
  var attr = this.attr, cx = attr.cx, cy = attr.cy, rx = attr.rx, ry = attr.ry, rxy = ry / rx, matrix = attr.matrix.clone(), xx, xy, yx, yy, dx, dy, w, h;
  matrix.append(1, 0, 0, rxy, 0, cy * (1 - rxy));
  xx = matrix.getXX();
  yx = matrix.getYX();
  dx = matrix.getDX();
  xy = matrix.getXY();
  yy = matrix.getYY();
  dy = matrix.getDY();
  w = Math.sqrt(xx * xx + yx * yx) * rx;
  h = Math.sqrt(xy * xy + yy * yy) * rx;
  transform.x = cx * xx + cy * yx + dx - w;
  transform.y = cx * xy + cy * yy + dy - h;
  transform.width = w + w;
  transform.height = h + h;
}, updatePath:function(path, attr) {
  path.ellipse(attr.cx, attr.cy, attr.rx, attr.ry, attr.axisRotation, 0, Math.PI * 2, false);
}}, 0, 0, 0, 0, ['sprite.ellipse'], 0, [Ext.draw.sprite, 'Ellipse'], 0);
Ext.cmd.derive('Ext.draw.sprite.EllipticalArc', Ext.draw.sprite.Ellipse, {type:'ellipticalArc', inheritableStatics:{def:{processors:{startAngle:'number', endAngle:'number', anticlockwise:'bool'}, aliases:{from:'startAngle', to:'endAngle', start:'startAngle', end:'endAngle'}, defaults:{startAngle:0, endAngle:Math.PI * 2, anticlockwise:false}, dirtyTriggers:{startAngle:'path', endAngle:'path', anticlockwise:'path'}}}, updatePath:function(path, attr) {
  path.ellipse(attr.cx, attr.cy, attr.rx, attr.ry, attr.axisRotation, attr.startAngle, attr.endAngle, attr.anticlockwise);
}}, 0, 0, 0, 0, ['sprite.ellipticalArc'], 0, [Ext.draw.sprite, 'EllipticalArc'], 0);
Ext.cmd.derive('Ext.draw.sprite.Rect', Ext.draw.sprite.Path, {type:'rect', inheritableStatics:{def:{processors:{x:'number', y:'number', width:'number', height:'number', radius:'number'}, aliases:{}, dirtyTriggers:{x:'path', y:'path', width:'path', height:'path', radius:'path'}, defaults:{x:0, y:0, width:1, height:1, radius:0}}}, updatePlainBBox:function(plain) {
  var attr = this.attr;
  plain.x = attr.x;
  plain.y = attr.y;
  plain.width = attr.width;
  plain.height = attr.height;
}, updateTransformedBBox:function(transform, plain) {
  this.attr.matrix.transformBBox(plain, this.attr.radius, transform);
}, updatePath:function(path, attr) {
  var x = attr.x, y = attr.y, width = attr.width, height = attr.height, radius = Math.min(attr.radius, Math.abs(attr.height) * 0.5, Math.abs(attr.width) * 0.5);
  if (radius === 0) {
    path.rect(x, y, width, height);
  } else {
    path.moveTo(x + radius, y);
    path.arcTo(x + width, y, x + width, y + height, radius);
    path.arcTo(x + width, y + height, x, y + height, radius);
    path.arcTo(x, y + height, x, y, radius);
    path.arcTo(x, y, x + radius, y, radius);
  }
}}, 0, 0, 0, 0, ['sprite.rect'], 0, [Ext.draw.sprite, 'Rect'], 0);
Ext.cmd.derive('Ext.draw.sprite.Image', Ext.draw.sprite.Rect, {type:'image', statics:{imageLoaders:{}}, inheritableStatics:{def:{processors:{src:'string'}, defaults:{src:'', width:null, height:null}}}, render:function(surface, ctx) {
  var me = this, attr = me.attr, mat = attr.matrix, src = attr.src, x = attr.x, y = attr.y, width = attr.width, height = attr.height, loadingStub = Ext.draw.sprite.Image.imageLoaders[src], imageLoader, i;
  if (loadingStub && loadingStub.done) {
    mat.toContext(ctx);
    ctx.drawImage(loadingStub.image, x, y, width || loadingStub.width, height || loadingStub.width);
  } else {
    if (!loadingStub) {
      imageLoader = new Image;
      loadingStub = Ext.draw.sprite.Image.imageLoaders[src] = {image:imageLoader, done:false, pendingSprites:[me], pendingSurfaces:[surface]};
      imageLoader.width = width;
      imageLoader.height = height;
      imageLoader.onload = function() {
        if (!loadingStub.done) {
          loadingStub.done = true;
          for (i = 0; i < loadingStub.pendingSprites.length; i++) {
            loadingStub.pendingSprites[i].setDirty(true);
          }
          for (i in loadingStub.pendingSurfaces) {
            loadingStub.pendingSurfaces[i].renderFrame();
          }
        }
      };
      imageLoader.src = src;
    } else {
      Ext.Array.include(loadingStub.pendingSprites, me);
      Ext.Array.include(loadingStub.pendingSurfaces, surface);
    }
  }
}}, 0, 0, 0, 0, ['sprite.image'], 0, [Ext.draw.sprite, 'Image'], 0);
Ext.cmd.derive('Ext.draw.sprite.Instancing', Ext.draw.sprite.Sprite, {type:'instancing', config:{template:null}, instances:null, constructor:function(config) {
  this.instances = [];
  Ext.draw.sprite.Sprite.prototype.constructor.call(this, config);
  if (config && config.template) {
    this.setTemplate(config.template);
  }
}, applyTemplate:function(template) {
  if (!(template instanceof Ext.draw.sprite.Sprite)) {
    template = Ext.create(template.xclass || 'sprite.' + template.type, template);
  }
  template.setParent(this);
  template.attr.children = [];
  this.instances = [];
  this.position = 0;
  return template;
}, createInstance:function(config, data, bypassNormalization, avoidCopy) {
  var template = this.getTemplate(), originalAttr = template.attr, attr = Ext.Object.chain(originalAttr);
  template.topModifier.prepareAttributes(attr);
  template.attr = attr;
  template.setAttributes(config, bypassNormalization, avoidCopy);
  attr.data = data;
  this.instances.push(attr);
  template.attr = originalAttr;
  this.position++;
  originalAttr.children.push(attr);
  return attr;
}, getBBox:function() {
  return null;
}, getBBoxFor:function(index, isWithoutTransform) {
  var template = this.getTemplate(), originalAttr = template.attr, bbox;
  template.attr = this.instances[index];
  bbox = template.getBBox(isWithoutTransform);
  template.attr = originalAttr;
  return bbox;
}, render:function(surface, ctx, clipRegion, region) {
  var me = this, mat = me.attr.matrix, template = me.getTemplate(), originalAttr = template.attr, instances = me.instances, i, ln = me.position;
  mat.toContext(ctx);
  template.preRender(surface, ctx, clipRegion, region);
  template.useAttributes(ctx, region);
  for (i = 0; i < ln; i++) {
    if (instances[i].dirtyZIndex) {
      break;
    }
  }
  for (i = 0; i < ln; i++) {
    if (instances[i].hidden) {
      continue;
    }
    ctx.save();
    template.attr = instances[i];
    template.applyTransformations();
    template.useAttributes(ctx, region);
    template.render(surface, ctx, clipRegion, region);
    ctx.restore();
  }
  template.attr = originalAttr;
}, setAttributesFor:function(index, changes, bypassNormalization) {
  var template = this.getTemplate(), originalAttr = template.attr, attr = this.instances[index];
  template.attr = attr;
  try {
    if (bypassNormalization) {
      changes = Ext.apply({}, changes);
    } else {
      changes = template.self.def.normalize(changes);
    }
    template.topModifier.pushDown(attr, changes);
    template.updateDirtyFlags(attr);
  } finally {
    template.attr = originalAttr;
  }
}, destroy:function() {
  Ext.draw.sprite.Sprite.prototype.destroy.call(this);
  this.instances.length = 0;
  this.instances = null;
  if (this.getTemplate()) {
    this.getTemplate().destroy();
  }
}}, 1, 0, 0, 0, ['sprite.instancing'], 0, [Ext.draw.sprite, 'Instancing'], 0);
Ext.cmd.derive('Ext.draw.sprite.Line', Ext.draw.sprite.Sprite, {type:'line', inheritableStatics:{def:{processors:{fromX:'number', fromY:'number', toX:'number', toY:'number'}, defaults:{fromX:0, fromY:0, toX:1, toY:1}}}, render:function(surface, ctx, clipRegion) {
  var attr = this.attr, matrix = this.attr.matrix;
  matrix.toContext(ctx);
  ctx.beginPath();
  ctx.moveTo(attr.fromX, attr.fromY);
  ctx.lineTo(attr.toX, attr.toY);
  ctx.stroke();
}}, 0, 0, 0, 0, ['sprite.line'], 0, [Ext.draw.sprite, 'Line'], 0);
Ext.cmd.derive('Ext.draw.sprite.Sector', Ext.draw.sprite.Path, {type:'sector', inheritableStatics:{def:{processors:{centerX:'number', centerY:'number', startAngle:'number', endAngle:'number', startRho:'number', endRho:'number', margin:'number'}, aliases:{rho:'endRho'}, dirtyTriggers:{centerX:'path,bbox', centerY:'path,bbox', startAngle:'path,bbox', endAngle:'path,bbox', startRho:'path,bbox', endRho:'path,bbox', margin:'path,bbox'}, defaults:{centerX:0, centerY:0, startAngle:0, endAngle:0, startRho:0, 
endRho:150, margin:0, path:'M 0,0'}}}, updatePath:function(path, attr) {
  var startAngle = Math.min(attr.startAngle, attr.endAngle), endAngle = Math.max(attr.startAngle, attr.endAngle), midAngle = (startAngle + endAngle) * 0.5, margin = attr.margin, centerX = attr.centerX, centerY = attr.centerY, startRho = Math.min(attr.startRho, attr.endRho), endRho = Math.max(attr.startRho, attr.endRho);
  if (margin) {
    centerX += margin * Math.cos(midAngle);
    centerY += margin * Math.sin(midAngle);
  }
  path.moveTo(centerX + startRho * Math.cos(startAngle), centerY + startRho * Math.sin(startAngle));
  path.lineTo(centerX + endRho * Math.cos(startAngle), centerY + endRho * Math.sin(startAngle));
  path.arc(centerX, centerY, endRho, startAngle, endAngle, false);
  path.lineTo(centerX + startRho * Math.cos(endAngle), centerY + startRho * Math.sin(endAngle));
  path.arc(centerX, centerY, startRho, endAngle, startAngle, true);
}}, 0, 0, 0, 0, ['sprite.sector'], 0, [Ext.draw.sprite, 'Sector'], 0);
Ext.cmd.derive('Ext.draw.TextMeasurer', Ext.Base, {singleton:true, measureDiv:null, measureCache:{}, actualMeasureText:function(text, font) {
  var me = Ext.draw.TextMeasurer, measureDiv = me.measureDiv, FARAWAY = 100000, size;
  if (!measureDiv) {
    var parent = Ext.Element.create({style:{'overflow':'hidden', 'position':'relative', 'float':'left', 'width':0, 'height':0}});
    me.measureDiv = measureDiv = Ext.Element.create({});
    measureDiv.setStyle({'position':'absolute', 'x':FARAWAY, 'y':FARAWAY, 'z-index':-FARAWAY, 'white-space':'nowrap', 'display':'block', 'padding':0, 'margin':0});
    Ext.getBody().appendChild(parent);
    parent.appendChild(measureDiv);
  }
  if (font) {
    measureDiv.setStyle({font:font, lineHeight:'normal'});
  }
  measureDiv.setText('(' + text + ')');
  size = measureDiv.getSize();
  measureDiv.setText('()');
  size.width -= measureDiv.getSize().width;
  return size;
}, measureTextSingleLine:function(text, font) {
  text = text.toString();
  var cache = this.measureCache, chars = text.split(''), width = 0, height = 0, cachedItem, charactor, i, ln, size;
  if (!cache[font]) {
    cache[font] = {};
  }
  cache = cache[font];
  if (cache[text]) {
    return cache[text];
  }
  for (i = 0, ln = chars.length; i < ln; i++) {
    charactor = chars[i];
    if (!(cachedItem = cache[charactor])) {
      size = this.actualMeasureText(charactor, font);
      cachedItem = cache[charactor] = size;
    }
    width += cachedItem.width;
    height = Math.max(height, cachedItem.height);
  }
  return cache[text] = {width:width, height:height};
}, measureText:function(text, font) {
  var lines = text.split('\n'), ln = lines.length, height = 0, width = 0, line, i, sizes;
  if (ln === 1) {
    return this.measureTextSingleLine(text, font);
  }
  sizes = [];
  for (i = 0; i < ln; i++) {
    line = this.measureTextSingleLine(lines[i], font);
    sizes.push(line);
    height += line.height;
    width = Math.max(width, line.width);
  }
  return {width:width, height:height, sizes:sizes};
}}, 0, 0, 0, 0, 0, 0, [Ext.draw, 'TextMeasurer'], 0);
Ext.cmd.derive('Ext.draw.sprite.Text', Ext.draw.sprite.Sprite, {type:'text', lineBreakRe:/\n/g, inheritableStatics:{shortHand1Re:/'(.*)'/g, shortHand2Re:/ /g, shortHand3Re:/\s*,\s*/g, shortHand4Re:/\$\$\$\$/g, def:{processors:{x:'number', y:'number', text:'string', fontSize:function(n) {
  if (!isNaN(n)) {
    return +n + 'px';
  } else {
    if (n.match(Ext.dom.Element.unitRe)) {
      return n;
    }
  }
}, fontStyle:'enums(,italic,oblique)', fontVariant:'enums(,small-caps)', fontWeight:function(fontWeights) {
  return function(n) {
    if (!n) {
      return '';
    } else {
      if (n === 'normal') {
        return '';
      } else {
        if (!isNaN(n)) {
          n = +n;
          if (100 <= n && n <= 900) {
            return n;
          }
        } else {
          if (n in fontWeights) {
            return n;
          }
        }
      }
    }
  };
}({'normal':true, 'bold':true, 'bolder':true, 'lighter':true}), fontFamily:'string', textAlign:function(textAligns) {
  return function(n) {
    if (n === 'middle') {
      return 'center';
    } else {
      if (!n) {
        return 'center';
      } else {
        if (!Ext.isString(n)) {
          return undefined;
        } else {
          if (n in textAligns) {
            return n;
          }
        }
      }
    }
  };
}({'left':true, 'right':true, 'center':true, 'start':true, 'end':true}), textBaseline:function(textBaselines) {
  return function(n) {
    if (n === false) {
      return 'alphabetic';
    } else {
      if (n in textBaselines) {
        return n;
      } else {
        if (n === 'center') {
          return 'middle';
        }
      }
    }
  };
}({'top':true, 'hanging':true, 'middle':true, 'alphabetic':true, 'ideographic':true, 'bottom':true}), font:'string'}, aliases:{'font-size':'fontSize', 'font-family':'fontFamily', 'font-weight':'fontWeight', 'font-variant':'fontVariant', 'text-anchor':'textAlign'}, defaults:{fontStyle:'', fontVariant:'', fontWeight:'', fontSize:'10px', fontFamily:'sans-serif', font:'10px sans-serif', textBaseline:'alphabetic', textAlign:'start', strokeStyle:'rgba(0, 0, 0, 0)', divBased:true, fillStyle:'#000', x:0, 
y:0, text:''}, dirtyTriggers:{fontStyle:'font,bbox', fontVariant:'font,bbox', fontWeight:'font,bbox', fontSize:'font,bbox', fontFamily:'font,bbox', font:'font-short-hand,bbox,canvas', textBaseline:'bbox', textAlign:'bbox', x:'bbox', y:'bbox', text:'bbox'}, updaters:{'font-short-hand':function(dispatcher) {
  return function(attrs) {
    var value = attrs.font, parts, part, i, ln, dispKey;
    value = value.replace(Ext.draw.sprite.Text.shortHand1Re, function(a, arg1) {
      return arg1.replace(Ext.draw.sprite.Text.shortHand2Re, '$$$$');
    });
    value = value.replace(Ext.draw.sprite.Text.shortHand3Re, ',');
    parts = value.split(' ');
    attrs = {};
    for (i = 0, ln = parts.length; i < ln; i++) {
      part = parts[i];
      dispKey = dispatcher[part];
      if (dispKey) {
        attrs[dispKey] = part;
      } else {
        if (part.match(Ext.dom.Element.unitRe)) {
          attrs.fontSize = part;
        } else {
          attrs.fontFamily = part.replace(Ext.draw.sprite.Text.shortHand4Re, ' ');
        }
      }
    }
    this.setAttributes(attrs, true);
  };
}({'italic':'fontStyles', 'oblique':'fontStyles', 'bold':'fontWeights', 'bolder':'fontWeights', 'lighter':'fontWeights', 100:'fontWeights', 200:'fontWeights', 300:'fontWeights', 400:'fontWeights', 500:'fontWeights', 600:'fontWeights', 700:'fontWeights', 800:'fontWeights', 900:'fontWeights', 'small-caps':'fontVariant'}), 'font':function(attrs) {
  var font = '';
  if (attrs.fontWeight) {
    font += attrs.fontWeight + ' ';
  }
  if (attrs.fontVariant) {
    font += attrs.fontVariant + ' ';
  }
  if (attrs.fontSize) {
    font += attrs.fontSize + ' ';
  }
  if (attrs.fontFamily) {
    font += attrs.fontFamily + ' ';
  }
  this.setAttributes({font:font.substr(0, font.length - 1)}, true);
}}}}, constructor:function(config) {
  Ext.draw.sprite.Sprite.prototype.constructor.call(this, config);
}, updatePlainBBox:function(plain) {
  var me = this, attr = me.attr, x = attr.x, y = attr.y, dx = [], font = attr.font, text = attr.text, baseline = attr.textBaseline, alignment = attr.textAlign, size = Ext.draw.TextMeasurer.measureText(text, font), sizes = size.sizes, height = size.height, width = size.width, ln = sizes ? sizes.length : 0, i = 0;
  switch(baseline) {
    case 'hanging':
    case 'top':
      break;
    case 'ideographic':
    case 'bottom':
      y -= height;
      break;
    case 'alphabetic':
      y -= height * 0.8;
      break;
    case 'middle':
    case 'center':
      y -= height * 0.5;
      break;
  }
  switch(alignment) {
    case 'end':
    case 'right':
      x -= width;
      for (; i < ln; i++) {
        dx.push(width - sizes[i].width);
      }
      break;
    case 'middle':
    case 'center':
      x -= width * 0.5;
      for (; i < ln; i++) {
        dx.push((width - sizes[i].width) * 0.5);
      }
      break;
  }
  attr.textAlignOffsets = dx;
  plain.x = x;
  plain.y = y;
  plain.width = width;
  plain.height = height;
}, setText:function(text) {
  this.setAttributes({text:text}, true);
}, setElementStyles:function(element, styles) {
  var stylesCache = element.stylesCache || (element.stylesCache = {}), style = element.dom.style, name;
  for (name in styles) {
    if (stylesCache[name] !== styles[name]) {
      stylesCache[name] = style[name] = styles[name];
    }
  }
}, render:function(surface, ctx) {
  var attr = this.attr, mat = Ext.draw.Matrix.fly(attr.matrix.elements.slice(0)), bbox = this.getBBox(true), dx = attr.textAlignOffsets, x, y, i, lines;
  if (attr.text.length === 0) {
    return;
  }
  lines = attr.text.split('\n');
  x = attr.bbox.plain.x;
  y = attr.bbox.plain.y;
  mat.toContext(ctx);
  for (i = 0; i < lines.length; i++) {
    if (ctx.fillStyle !== 'rgba(0, 0, 0, 0)') {
      ctx.fillText(lines[i], x + (dx[i] || 0), y + bbox.height / lines.length * i);
    }
    if (ctx.strokeStyle !== 'rgba(0, 0, 0, 0)') {
      ctx.strokeText(lines[i], x + (dx[i] || 0), y + bbox.height / lines.length * i);
    }
  }
}}, 1, 0, 0, 0, ['sprite.text'], 0, [Ext.draw.sprite, 'Text'], 0);
Ext.cmd.derive('Ext.draw.gradient.Linear', Ext.draw.gradient.Gradient, {type:'linear', config:{degrees:0}, setAngle:function(angle) {
  this.setDegrees(angle);
}, generateGradient:function(ctx, bbox) {
  var angle = Ext.draw.Draw.rad(this.getDegrees()), cos = Math.cos(angle), sin = Math.sin(angle), w = bbox.width, h = bbox.height, cx = bbox.x + w * 0.5, cy = bbox.y + h * 0.5, stops = this.getStops(), ln = stops.length, gradient, l, i;
  if (!isNaN(cx) && !isNaN(cy) && h > 0 && w > 0) {
    l = Math.sqrt(h * h + w * w) * Math.abs(Math.cos(angle - Math.atan(h / w))) / 2;
    gradient = ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);
    for (i = 0; i < ln; i++) {
      gradient.addColorStop(stops[i].offset, stops[i].color);
    }
    return gradient;
  }
  return 'none';
}}, 0, 0, 0, 0, 0, 0, [Ext.draw.gradient, 'Linear'], 0);
Ext.cmd.derive('Ext.draw.gradient.Radial', Ext.draw.gradient.Gradient, {type:'radial', config:{start:{x:0, y:0, r:0}, end:{x:0, y:0, r:1}}, applyStart:function(newStart, oldStart) {
  if (!oldStart) {
    return newStart;
  }
  var circle = {x:oldStart.x, y:oldStart.y, r:oldStart.r};
  if ('x' in newStart) {
    circle.x = newStart.x;
  } else {
    if ('centerX' in newStart) {
      circle.x = newStart.centerX;
    }
  }
  if ('y' in newStart) {
    circle.y = newStart.y;
  } else {
    if ('centerY' in newStart) {
      circle.y = newStart.centerY;
    }
  }
  if ('r' in newStart) {
    circle.r = newStart.r;
  } else {
    if ('radius' in newStart) {
      circle.r = newStart.radius;
    }
  }
  return circle;
}, applyEnd:function(newEnd, oldEnd) {
  if (!oldEnd) {
    return newEnd;
  }
  var circle = {x:oldEnd.x, y:oldEnd.y, r:oldEnd.r};
  if ('x' in newEnd) {
    circle.x = newEnd.x;
  } else {
    if ('centerX' in newEnd) {
      circle.x = newEnd.centerX;
    }
  }
  if ('y' in newEnd) {
    circle.y = newEnd.y;
  } else {
    if ('centerY' in newEnd) {
      circle.y = newEnd.centerY;
    }
  }
  if ('r' in newEnd) {
    circle.r = newEnd.r;
  } else {
    if ('radius' in newEnd) {
      circle.r = newEnd.radius;
    }
  }
  return circle;
}, generateGradient:function(ctx, bbox) {
  var start = this.getStart(), end = this.getEnd(), w = bbox.width * 0.5, h = bbox.height * 0.5, x = bbox.x + w, y = bbox.y + h, gradient = ctx.createRadialGradient(x + start.x * w, y + start.y * h, start.r * Math.max(w, h), x + end.x * w, y + end.y * h, end.r * Math.max(w, h)), stops = this.getStops(), ln = stops.length, i;
  for (i = 0; i < ln; i++) {
    gradient.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient;
}}, 0, 0, 0, 0, 0, 0, [Ext.draw.gradient, 'Radial'], 0);
Ext.cmd.derive('Ext.draw.Matrix', Ext.Base, {statics:{createAffineMatrixFromTwoPair:function(x0, y0, x1, y1, x0p, y0p, x1p, y1p) {
  var dx = x1 - x0, dy = y1 - y0, dxp = x1p - x0p, dyp = y1p - y0p, r = 1 / (dx * dx + dy * dy), a = dx * dxp + dy * dyp, b = dxp * dy - dx * dyp, c = -a * x0 - b * y0, f = b * x0 - a * y0;
  return new this(a * r, -b * r, b * r, a * r, c * r + x0p, f * r + y0p);
}, createPanZoomFromTwoPair:function(x0, y0, x1, y1, x0p, y0p, x1p, y1p) {
  if (arguments.length === 2) {
    return this.createPanZoomFromTwoPair.apply(this, x0.concat(y0));
  }
  var dx = x1 - x0, dy = y1 - y0, cx = (x0 + x1) * 0.5, cy = (y0 + y1) * 0.5, dxp = x1p - x0p, dyp = y1p - y0p, cxp = (x0p + x1p) * 0.5, cyp = (y0p + y1p) * 0.5, r = dx * dx + dy * dy, rp = dxp * dxp + dyp * dyp, scale = Math.sqrt(rp / r);
  return new this(scale, 0, 0, scale, cxp - scale * cx, cyp - scale * cy);
}, fly:function() {
  var flyMatrix = null, simplefly = function(elements) {
    flyMatrix.elements = elements;
    return flyMatrix;
  };
  return function(elements) {
    if (!flyMatrix) {
      flyMatrix = new Ext.draw.Matrix;
    }
    flyMatrix.elements = elements;
    Ext.draw.Matrix.fly = simplefly;
    return flyMatrix;
  };
}(), create:function(mat) {
  if (mat instanceof this) {
    return mat;
  }
  return new this(mat);
}}, constructor:function(xx, xy, yx, yy, dx, dy) {
  if (xx && xx.length === 6) {
    this.elements = xx.slice();
  } else {
    if (xx !== undefined) {
      this.elements = [xx, xy, yx, yy, dx, dy];
    } else {
      this.elements = [1, 0, 0, 1, 0, 0];
    }
  }
}, prepend:function(xx, xy, yx, yy, dx, dy) {
  var elements = this.elements, xx0 = elements[0], xy0 = elements[1], yx0 = elements[2], yy0 = elements[3], dx0 = elements[4], dy0 = elements[5];
  elements[0] = xx * xx0 + yx * xy0;
  elements[1] = xy * xx0 + yy * xy0;
  elements[2] = xx * yx0 + yx * yy0;
  elements[3] = xy * yx0 + yy * yy0;
  elements[4] = xx * dx0 + yx * dy0 + dx;
  elements[5] = xy * dx0 + yy * dy0 + dy;
  return this;
}, prependMatrix:function(matrix) {
  return this.prepend.apply(this, matrix.elements);
}, append:function(xx, xy, yx, yy, dx, dy) {
  var elements = this.elements, xx0 = elements[0], xy0 = elements[1], yx0 = elements[2], yy0 = elements[3], dx0 = elements[4], dy0 = elements[5];
  elements[0] = xx * xx0 + xy * yx0;
  elements[1] = xx * xy0 + xy * yy0;
  elements[2] = yx * xx0 + yy * yx0;
  elements[3] = yx * xy0 + yy * yy0;
  elements[4] = dx * xx0 + dy * yx0 + dx0;
  elements[5] = dx * xy0 + dy * yy0 + dy0;
  return this;
}, appendMatrix:function(matrix) {
  return this.append.apply(this, matrix.elements);
}, set:function(xx, xy, yx, yy, dx, dy) {
  var elements = this.elements;
  elements[0] = xx;
  elements[1] = xy;
  elements[2] = yx;
  elements[3] = yy;
  elements[4] = dx;
  elements[5] = dy;
  return this;
}, inverse:function(target) {
  var elements = this.elements, a = elements[0], b = elements[1], c = elements[2], d = elements[3], e = elements[4], f = elements[5], rDim = 1 / (a * d - b * c);
  a *= rDim;
  b *= rDim;
  c *= rDim;
  d *= rDim;
  if (target) {
    target.set(d, -b, -c, a, c * f - d * e, b * e - a * f);
    return target;
  } else {
    return new Ext.draw.Matrix(d, -b, -c, a, c * f - d * e, b * e - a * f);
  }
}, translate:function(x, y, prepend) {
  if (prepend) {
    return this.prepend(1, 0, 0, 1, x, y);
  } else {
    return this.append(1, 0, 0, 1, x, y);
  }
}, scale:function(sx, sy, scx, scy, prepend) {
  var me = this;
  if (sy == null) {
    sy = sx;
  }
  if (scx === undefined) {
    scx = 0;
  }
  if (scy === undefined) {
    scy = 0;
  }
  if (prepend) {
    return me.prepend(sx, 0, 0, sy, scx - scx * sx, scy - scy * sy);
  } else {
    return me.append(sx, 0, 0, sy, scx - scx * sx, scy - scy * sy);
  }
}, rotate:function(angle, rcx, rcy, prepend) {
  var me = this, cos = Math.cos(angle), sin = Math.sin(angle);
  rcx = rcx || 0;
  rcy = rcy || 0;
  if (prepend) {
    return me.prepend(cos, sin, -sin, cos, rcx - cos * rcx + rcy * sin, rcy - cos * rcy - rcx * sin);
  } else {
    return me.append(cos, sin, -sin, cos, rcx - cos * rcx + rcy * sin, rcy - cos * rcy - rcx * sin);
  }
}, rotateFromVector:function(x, y, prepend) {
  var me = this, d = Math.sqrt(x * x + y * y), cos = x / d, sin = y / d;
  if (prepend) {
    return me.prepend(cos, sin, -sin, cos, 0, 0);
  } else {
    return me.append(cos, sin, -sin, cos, 0, 0);
  }
}, clone:function() {
  return new Ext.draw.Matrix(this.elements);
}, flipX:function() {
  return this.append(-1, 0, 0, 1, 0, 0);
}, flipY:function() {
  return this.append(1, 0, 0, -1, 0, 0);
}, skewX:function(angle) {
  return this.append(1, Math.tan(angle), 0, -1, 0, 0);
}, skewY:function(angle) {
  return this.append(1, 0, Math.tan(angle), -1, 0, 0);
}, reset:function() {
  return this.set(1, 0, 0, 1, 0, 0);
}, precisionCompensate:function(devicePixelRatio, comp) {
  var elements = this.elements, x2x = elements[0], x2y = elements[1], y2x = elements[2], y2y = elements[3], newDx = elements[4], newDy = elements[5], r = x2y * y2x - x2x * y2y;
  comp.b = devicePixelRatio * x2y / x2x;
  comp.c = devicePixelRatio * y2x / y2y;
  comp.d = devicePixelRatio;
  comp.xx = x2x / devicePixelRatio;
  comp.yy = y2y / devicePixelRatio;
  comp.dx = (newDy * x2x * y2x - newDx * x2x * y2y) / r / devicePixelRatio;
  comp.dy = (newDx * x2y * y2y - newDy * x2x * y2y) / r / devicePixelRatio;
}, precisionCompensateRect:function(devicePixelRatio, comp) {
  var elements = this.elements, x2x = elements[0], x2y = elements[1], y2x = elements[2], y2y = elements[3], newDx = elements[4], newDy = elements[5], yxOnXx = y2x / x2x;
  comp.b = devicePixelRatio * x2y / x2x;
  comp.c = devicePixelRatio * yxOnXx;
  comp.d = devicePixelRatio * y2y / x2x;
  comp.xx = x2x / devicePixelRatio;
  comp.yy = x2x / devicePixelRatio;
  comp.dx = (newDy * y2x - newDx * y2y) / (x2y * yxOnXx - y2y) / devicePixelRatio;
  comp.dy = -(newDy * x2x - newDx * x2y) / (x2y * yxOnXx - y2y) / devicePixelRatio;
}, x:function(x, y) {
  var elements = this.elements;
  return x * elements[0] + y * elements[2] + elements[4];
}, y:function(x, y) {
  var elements = this.elements;
  return x * elements[1] + y * elements[3] + elements[5];
}, get:function(i, j) {
  return +this.elements[i + j * 2].toFixed(4);
}, transformPoint:function(point) {
  var elements = this.elements;
  return [point[0] * elements[0] + point[1] * elements[2] + elements[4], point[0] * elements[1] + point[1] * elements[3] + elements[5]];
}, transformBBox:function(bbox, radius, target) {
  var elements = this.elements, l = bbox.x, t = bbox.y, w0 = bbox.width * 0.5, h0 = bbox.height * 0.5, xx = elements[0], xy = elements[1], yx = elements[2], yy = elements[3], cx = l + w0, cy = t + h0, w, h, scales;
  if (radius) {
    w0 -= radius;
    h0 -= radius;
    scales = [Math.sqrt(elements[0] * elements[0] + elements[2] * elements[2]), Math.sqrt(elements[1] * elements[1] + elements[3] * elements[3])];
    w = Math.abs(w0 * xx) + Math.abs(h0 * yx) + Math.abs(scales[0] * radius);
    h = Math.abs(w0 * xy) + Math.abs(h0 * yy) + Math.abs(scales[1] * radius);
  } else {
    w = Math.abs(w0 * xx) + Math.abs(h0 * yx);
    h = Math.abs(w0 * xy) + Math.abs(h0 * yy);
  }
  if (!target) {
    target = {};
  }
  target.x = cx * xx + cy * yx + elements[4] - w;
  target.y = cx * xy + cy * yy + elements[5] - h;
  target.width = w + w;
  target.height = h + h;
  return target;
}, transformList:function(list) {
  var elements = this.elements, xx = elements[0], yx = elements[2], dx = elements[4], xy = elements[1], yy = elements[3], dy = elements[5], ln = list.length, p, i;
  for (i = 0; i < ln; i++) {
    p = list[i];
    list[i] = [p[0] * xx + p[1] * yx + dx, p[0] * xy + p[1] * yy + dy];
  }
  return list;
}, isIdentity:function() {
  var elements = this.elements;
  return elements[0] === 1 && elements[1] === 0 && elements[2] === 0 && elements[3] === 1 && elements[4] === 0 && elements[5] === 0;
}, equals:function(matrix) {
  var elements = this.elements, elements2 = matrix.elements;
  return elements[0] === elements2[0] && elements[1] === elements2[1] && elements[2] === elements2[2] && elements[3] === elements2[3] && elements[4] === elements2[4] && elements[5] === elements2[5];
}, toArray:function() {
  var elements = this.elements;
  return [elements[0], elements[2], elements[4], elements[1], elements[3], elements[5]];
}, toVerticalArray:function() {
  return this.elements.slice();
}, toString:function() {
  var me = this;
  return [me.get(0, 0), me.get(0, 1), me.get(1, 0), me.get(1, 1), me.get(2, 0), me.get(2, 1)].join(',');
}, toContext:function(ctx) {
  ctx.transform.apply(ctx, this.elements);
  return this;
}, toSvg:function() {
  var elements = this.elements;
  return 'matrix(' + elements[0].toFixed(9) + ',' + elements[1].toFixed(9) + ',' + elements[2].toFixed(9) + ',' + elements[3].toFixed(9) + ',' + elements[4].toFixed(9) + ',' + elements[5].toFixed(9) + ')';
}, getScaleX:function() {
  var elements = this.elements;
  return Math.sqrt(elements[0] * elements[0] + elements[2] * elements[2]);
}, getScaleY:function() {
  var elements = this.elements;
  return Math.sqrt(elements[1] * elements[1] + elements[3] * elements[3]);
}, getXX:function() {
  return this.elements[0];
}, getXY:function() {
  return this.elements[1];
}, getYX:function() {
  return this.elements[2];
}, getYY:function() {
  return this.elements[3];
}, getDX:function() {
  return this.elements[4];
}, getDY:function() {
  return this.elements[5];
}, split:function() {
  var el = this.elements, xx = el[0], xy = el[1], yx = el[2], yy = el[3], out = {translateX:el[4], translateY:el[5]};
  out.scaleX = Math.sqrt(xx * xx + yx * yx);
  out.shear = (xx * xy + yx * yy) / out.scaleX;
  xy -= out.shear * xx;
  yy -= out.shear * yx;
  out.scaleY = Math.sqrt(xy * xy + yy * yy);
  out.shear /= out.scaleY;
  out.rotation = -Math.atan2(yx / out.scaleX, xy / out.scaleY);
  out.isSimple = Math.abs(out.shear) < 1.0E-9 && (!out.rotation || Math.abs(out.scaleX - out.scaleY) < 1.0E-9);
  return out;
}}, 3, 0, 0, 0, 0, 0, [Ext.draw, 'Matrix'], function() {
  function registerName(properties, name, i) {
    properties[name] = {get:function() {
      return this.elements[i];
    }, set:function(val) {
      this.elements[i] = val;
    }};
  }
  if (Object.defineProperties) {
    var properties = {};
    registerName(properties, 'a', 0);
    registerName(properties, 'b', 1);
    registerName(properties, 'c', 2);
    registerName(properties, 'd', 3);
    registerName(properties, 'e', 4);
    registerName(properties, 'f', 5);
    Object.defineProperties(this.prototype, properties);
  }
  this.prototype.multiply = this.prototype.appendMatrix;
});
Ext.cmd.derive('Ext.draw.Surface', Ext.Component, {defaultIdPrefix:'ext-surface-', devicePixelRatio:window.devicePixelRatio || 1, statics:{stableSort:function(list) {
  if (list.length < 2) {
    return;
  }
  var keys = {}, sortedKeys, result = [], i, ln, zIndex;
  for (i = 0, ln = list.length; i < ln; i++) {
    zIndex = list[i].attr.zIndex;
    if (!keys[zIndex]) {
      keys[zIndex] = [list[i]];
    } else {
      keys[zIndex].push(list[i]);
    }
  }
  sortedKeys = Ext.Object.getKeys(keys).sort(function(a, b) {
    return a - b;
  });
  for (i = 0, ln = sortedKeys.length; i < ln; i++) {
    result.push.apply(result, keys[sortedKeys[i]]);
  }
  for (i = 0, ln = list.length; i < ln; i++) {
    list[i] = result[i];
  }
}}, config:{region:null, background:null, items:[], dirty:false}, dirtyPredecessor:0, constructor:function(config) {
  var me = this;
  me.predecessors = [];
  me.successors = [];
  me.pendingRenderFrame = false;
  me.map = {};
  Ext.Component.prototype.constructor.call(this, config);
  me.matrix = new Ext.draw.Matrix;
  me.inverseMatrix = me.matrix.inverse(me.inverseMatrix);
  me.resetTransform();
}, roundPixel:function(num) {
  return Math.round(this.devicePixelRatio * num) / this.devicePixelRatio;
}, waitFor:function(surface) {
  var me = this, predecessors = me.predecessors;
  if (!Ext.Array.contains(predecessors, surface)) {
    predecessors.push(surface);
    surface.successors.push(me);
    if (surface._dirty) {
      me.dirtyPredecessor++;
    }
  }
}, setDirty:function(dirty) {
  if (this._dirty !== dirty) {
    var successors = this.successors, successor, i, ln = successors.length;
    for (i = 0; i < ln; i++) {
      successor = successors[i];
      if (dirty) {
        successor.dirtyPredecessor++;
        successor.setDirty(true);
      } else {
        successor.dirtyPredecessor--;
        if (successor.dirtyPredecessor === 0 && successor.pendingRenderFrame) {
          successor.renderFrame();
        }
      }
    }
    this._dirty = dirty;
  }
}, applyElement:function(newElement, oldElement) {
  if (oldElement) {
    oldElement.set(newElement);
  } else {
    oldElement = Ext.Element.create(newElement);
  }
  this.setDirty(true);
  return oldElement;
}, applyBackground:function(background, oldBackground) {
  this.setDirty(true);
  if (Ext.isString(background)) {
    background = {fillStyle:background};
  }
  return Ext.factory(background, Ext.draw.sprite.Rect, oldBackground);
}, applyRegion:function(region, oldRegion) {
  if (oldRegion && region[0] === oldRegion[0] && region[1] === oldRegion[1] && region[2] === oldRegion[2] && region[3] === oldRegion[3]) {
    return;
  }
  if (Ext.isArray(region)) {
    return [region[0], region[1], region[2], region[3]];
  } else {
    if (Ext.isObject(region)) {
      return [region.x || region.left, region.y || region.top, region.width || region.right - region.left, region.height || region.bottom - region.top];
    }
  }
}, updateRegion:function(region) {
  var me = this, l = region[0], t = region[1], r = l + region[2], b = t + region[3], background = this.getBackground(), element = me.element;
  element.setBox({top:Math.floor(t), left:Math.floor(l), width:Math.ceil(r - Math.floor(l)), height:Math.ceil(b - Math.floor(t))});
  if (background) {
    background.setAttributes({x:0, y:0, width:Math.ceil(r - Math.floor(l)), height:Math.ceil(b - Math.floor(t))});
  }
  me.setDirty(true);
}, resetTransform:function() {
  this.matrix.set(1, 0, 0, 1, 0, 0);
  this.inverseMatrix.set(1, 0, 0, 1, 0, 0);
  this.setDirty(true);
}, updateComponent:function(component, oldComponent) {
  if (component) {
    component.element.dom.appendChild(this.element.dom);
  }
}, get:function(id) {
  return this.map[id] || this.items[id];
}, add:function() {
  var me = this, args = Array.prototype.slice.call(arguments), argIsArray = Ext.isArray(args[0]), results = [], sprite, sprites, items, i, ln;
  items = Ext.Array.clean(argIsArray ? args[0] : args);
  if (!items.length) {
    return results;
  }
  sprites = me.prepareItems(items);
  for (i = 0, ln = sprites.length; i < ln; i++) {
    sprite = sprites[i];
    me.map[sprite.getId()] = sprite;
    results.push(sprite);
    sprite.setParent(this);
    me.onAdd(sprite);
  }
  items = me.getItems();
  if (items) {
    items.push.apply(items, results);
  }
  me.dirtyZIndex = true;
  me.setDirty(true);
  if (!argIsArray && results.length === 1) {
    return results[0];
  } else {
    return results;
  }
}, onAdd:Ext.emptyFn, remove:function(sprite, destroySprite) {
  if (sprite) {
    delete this.map[sprite.getId()];
    if (destroySprite) {
      sprite.destroy();
    } else {
      sprite.setParent(null);
      Ext.Array.remove(this.getItems(), sprite);
    }
    this.dirtyZIndex = true;
    this.setDirty(true);
  }
}, removeAll:function(destroySprites) {
  var items = this.getItems(), i = items.length;
  if (destroySprites) {
    while (i > 0) {
      items[--i].destroy();
    }
  } else {
    while (i > 0) {
      items[--i].setParent(null);
    }
  }
  items.length = 0;
  this.map = {};
  this.dirtyZIndex = true;
}, applyItems:function(items) {
  if (this.getItems()) {
    this.removeAll(true);
  }
  return Ext.Array.from(this.add(items));
}, prepareItems:function(items) {
  items = [].concat(items);
  var me = this, item, i, ln, j, removeSprite = function(sprite) {
    this.remove(sprite, false);
  };
  for (i = 0, ln = items.length; i < ln; i++) {
    item = items[i];
    if (!(item instanceof Ext.draw.sprite.Sprite)) {
      item = items[i] = me.createItem(item);
    }
    item.on('beforedestroy', removeSprite, me);
  }
  return items;
}, createItem:function(config) {
  var sprite = Ext.create(config.xclass || 'sprite.' + config.type, config);
  return sprite;
}, getBBox:function(sprites, isWithoutTransform) {
  var sprites = Ext.Array.from(sprites), left = Infinity, right = -Infinity, top = Infinity, bottom = -Infinity, sprite, bbox, i, ln;
  for (i = 0, ln = sprites.length; i < ln; i++) {
    sprite = sprites[i];
    bbox = sprite.getBBox(isWithoutTransform);
    if (left > bbox.x) {
      left = bbox.x;
    }
    if (right < bbox.x + bbox.width) {
      right = bbox.x + bbox.width;
    }
    if (top > bbox.y) {
      top = bbox.y;
    }
    if (bottom < bbox.y + bbox.height) {
      bottom = bbox.y + bbox.height;
    }
  }
  return {x:left, y:top, width:right - left, height:bottom - top};
}, clear:Ext.emptyFn, orderByZIndex:function() {
  var me = this, items = me.getItems(), dirtyZIndex = false, i, ln;
  if (me.getDirty()) {
    for (i = 0, ln = items.length; i < ln; i++) {
      if (items[i].attr.dirtyZIndex) {
        dirtyZIndex = true;
        break;
      }
    }
    if (dirtyZIndex) {
      Ext.draw.Surface.stableSort(items);
      this.setDirty(true);
    }
    for (i = 0, ln = items.length; i < ln; i++) {
      items[i].attr.dirtyZIndex = false;
    }
  }
}, repaint:function() {
  var me = this;
  me.repaint = Ext.emptyFn;
  setTimeout(function() {
    delete me.repaint;
    me.element.repaint();
  }, 1);
}, renderFrame:function() {
  if (!this.element) {
    return;
  }
  if (this.dirtyPredecessor > 0) {
    this.pendingRenderFrame = true;
    return;
  }
  var me = this, region = this.getRegion(), background = me.getBackground(), items = me.getItems(), item, i, ln;
  if (!region) {
    return;
  }
  me.orderByZIndex();
  if (me.getDirty()) {
    me.clear();
    me.clearTransform();
    if (background) {
      me.renderSprite(background);
    }
    for (i = 0, ln = items.length; i < ln; i++) {
      item = items[i];
      if (false === me.renderSprite(item)) {
        return;
      }
      item.attr.textPositionCount = me.textPosition;
    }
    me.setDirty(false);
  }
}, renderSprite:Ext.emptyFn, clearTransform:Ext.emptyFn, getDirty:function() {
  return this._dirty;
}, destroy:function() {
  var me = this;
  me.removeAll();
  me.setBackground(null);
  me.predecessors = null;
  me.successors = null;
  Ext.Component.prototype.destroy.call(this);
}}, 1, ['surface'], ['component', 'surface'], {'component':true, 'surface':true}, ['widget.surface'], 0, [Ext.draw, 'Surface'], 0);
Ext.cmd.derive('Ext.draw.engine.SvgContext', Ext.Base, {toSave:['strokeOpacity', 'strokeStyle', 'fillOpacity', 'fillStyle', 'globalAlpha', 'lineWidth', 'lineCap', 'lineJoin', 'lineDash', 'lineDashOffset', 'miterLimit', 'shadowOffsetX', 'shadowOffsetY', 'shadowBlur', 'shadowColor', 'globalCompositeOperation', 'position'], 'strokeOpacity':1, 'strokeStyle':'none', 'fillOpacity':1, 'fillStyle':'none', 'lineDash':[], 'lineDashOffset':0, 'globalAlpha':1, 'lineWidth':1, 'lineCap':'butt', 'lineJoin':'miter', 
'miterLimit':10, 'shadowOffsetX':0, 'shadowOffsetY':0, 'shadowBlur':0, 'shadowColor':'none', 'globalCompositeOperation':'src', urlStringRe:/^url\(#([\w\-]+)\)$/, constructor:function(SvgSurface) {
  this.surface = SvgSurface;
  this.status = [];
  this.matrix = new Ext.draw.Matrix;
  this.path = null;
  this.clear();
}, clear:function() {
  this.group = this.surface.mainGroup;
  this.position = 0;
  this.path = null;
}, getElement:function(tag) {
  return this.surface.getSvgElement(this.group, tag, this.position++);
}, removeElement:function(element) {
  var element = Ext.fly(element), fill, stroke, fillMatch, strokeMatch, gradients, gradient, key;
  if (!element) {
    return;
  }
  if (element.dom.tagName === 'g') {
    gradients = element.dom.gradients;
    for (key in gradients) {
      gradients[key].destroy();
    }
  } else {
    fill = element.getAttribute('fill');
    stroke = element.getAttribute('stroke');
    fillMatch = fill && fill.match(this.urlStringRe);
    strokeMatch = stroke && stroke.match(this.urlStringRe);
    if (fillMatch && fillMatch[1]) {
      gradient = Ext.fly(fillMatch[1]);
      if (gradient) {
        gradient.destroy();
      }
    }
    if (strokeMatch && strokeMatch[1]) {
      gradient = Ext.fly(strokeMatch[1]);
      if (gradient) {
        gradient.destroy();
      }
    }
  }
  element.destroy();
}, save:function() {
  var toSave = this.toSave, obj = {}, group = this.getElement('g'), key, i;
  for (i = 0; i < toSave.length; i++) {
    key = toSave[i];
    if (key in this) {
      obj[key] = this[key];
    }
  }
  this.position = 0;
  obj.matrix = this.matrix.clone();
  this.status.push(obj);
  this.group = group;
  return group;
}, restore:function() {
  var toSave = this.toSave, obj = this.status.pop(), children = this.group.dom.childNodes, key, i;
  while (children.length > this.position) {
    this.removeElement(children[children.length - 1]);
  }
  for (i = 0; i < toSave.length; i++) {
    key = toSave[i];
    if (key in obj) {
      this[key] = obj[key];
    } else {
      delete this[key];
    }
  }
  this.setTransform.apply(this, obj.matrix.elements);
  this.group = this.group.getParent();
}, transform:function(xx, yx, xy, yy, dx, dy) {
  if (this.path) {
    var inv = Ext.draw.Matrix.fly([xx, yx, xy, yy, dx, dy]).inverse();
    this.path.transform(inv);
  }
  this.matrix.append(xx, yx, xy, yy, dx, dy);
}, setTransform:function(xx, yx, xy, yy, dx, dy) {
  if (this.path) {
    this.path.transform(this.matrix);
  }
  this.matrix.reset();
  this.transform(xx, yx, xy, yy, dx, dy);
}, scale:function(x, y) {
  this.transform(x, 0, 0, y, 0, 0);
}, rotate:function(angle) {
  var xx = Math.cos(angle), yx = Math.sin(angle), xy = -Math.sin(angle), yy = Math.cos(angle);
  this.transform(xx, yx, xy, yy, 0, 0);
}, translate:function(x, y) {
  this.transform(1, 0, 0, 1, x, y);
}, setGradientBBox:function(bbox) {
  this.bbox = bbox;
}, beginPath:function() {
  this.path = new Ext.draw.Path;
}, moveTo:function(x, y) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.moveTo(x, y);
  this.path.element = null;
}, lineTo:function(x, y) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.lineTo(x, y);
  this.path.element = null;
}, rect:function(x, y, width, height) {
  this.moveTo(x, y);
  this.lineTo(x + width, y);
  this.lineTo(x + width, y + height);
  this.lineTo(x, y + height);
  this.closePath();
}, strokeRect:function(x, y, width, height) {
  this.beginPath();
  this.rect(x, y, width, height);
  this.stroke();
}, fillRect:function(x, y, width, height) {
  this.beginPath();
  this.rect(x, y, width, height);
  this.fill();
}, closePath:function() {
  if (!this.path) {
    this.beginPath();
  }
  this.path.closePath();
  this.path.element = null;
}, arcSvg:function(r1, r2, rotation, large, swipe, x2, y2) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.arcSvg(r1, r2, rotation, large, swipe, x2, y2);
  this.path.element = null;
}, arc:function(x, y, radius, startAngle, endAngle, anticlockwise) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);
  this.path.element = null;
}, ellipse:function(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
  this.path.element = null;
}, arcTo:function(x1, y1, x2, y2, radiusX, radiusY, rotation) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.arcTo(x1, y1, x2, y2, radiusX, radiusY, rotation);
  this.path.element = null;
}, bezierCurveTo:function(x1, y1, x2, y2, x3, y3) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.bezierCurveTo(x1, y1, x2, y2, x3, y3);
  this.path.element = null;
}, strokeText:function(text, x, y) {
  text = String(text);
  if (this.strokeStyle) {
    var element = this.getElement('text'), tspan = this.surface.getSvgElement(element, 'tspan', 0);
    this.surface.setElementAttributes(element, {'x':x, 'y':y, 'transform':this.matrix.toSvg(), 'stroke':this.strokeStyle, 'fill':'none', 'opacity':this.globalAlpha, 'stroke-opacity':this.strokeOpacity, 'style':'font: ' + this.font});
    if (this.lineDash.length) {
      this.surface.setElementAttributes(element, {'stroke-dasharray':this.lineDash.join(','), 'stroke-dashoffset':this.lineDashOffset});
    }
    if (tspan.dom.firstChild) {
      tspan.dom.removeChild(tspan.dom.firstChild);
    }
    this.surface.setElementAttributes(tspan, {'alignment-baseline':'middle', 'baseline-shift':'-50%'});
    tspan.appendChild(document.createTextNode(Ext.String.htmlDecode(text)));
  }
}, fillText:function(text, x, y) {
  text = String(text);
  if (this.fillStyle) {
    var element = this.getElement('text'), tspan = this.surface.getSvgElement(element, 'tspan', 0);
    this.surface.setElementAttributes(element, {'x':x, 'y':y, 'transform':this.matrix.toSvg(), 'fill':this.fillStyle, 'opacity':this.globalAlpha, 'fill-opacity':this.fillOpacity, 'style':'font: ' + this.font});
    if (tspan.dom.firstChild) {
      tspan.dom.removeChild(tspan.dom.firstChild);
    }
    this.surface.setElementAttributes(tspan, {'alignment-baseline':'middle', 'baseline-shift':'-50%'});
    tspan.appendChild(document.createTextNode(Ext.String.htmlDecode(text)));
  }
}, drawImage:function(image, sx, sy, sw, sh, dx, dy, dw, dh) {
  var me = this, element = me.getElement('image'), x = sx, y = sy, width = typeof sw === 'undefined' ? image.width : sw, height = typeof sh === 'undefined' ? image.height : sh, viewBox = null;
  if (typeof dh !== 'undefined') {
    viewBox = sx + ' ' + sy + ' ' + sw + ' ' + sh;
    x = dx;
    y = dy;
    width = dw;
    height = dh;
  }
  element.dom.setAttributeNS('http://www.w3.org/1999/xlink', 'href', image.src);
  me.surface.setElementAttributes(element, {viewBox:viewBox, x:x, y:y, width:width, height:height, opacity:me.globalAlpha, transform:me.matrix.toSvg()});
}, fill:function() {
  if (!this.path) {
    return;
  }
  if (this.fillStyle) {
    var path, fillGradient = this.fillGradient, bbox = this.bbox, element = this.path.element;
    if (!element) {
      path = this.path.toString();
      element = this.path.element = this.getElement('path');
      this.surface.setElementAttributes(element, {'d':path, 'transform':this.matrix.toSvg()});
    }
    this.surface.setElementAttributes(element, {'fill':fillGradient && bbox ? fillGradient.generateGradient(this, bbox) : this.fillStyle, 'fill-opacity':this.fillOpacity * this.globalAlpha});
  }
}, stroke:function() {
  if (!this.path) {
    return;
  }
  if (this.strokeStyle) {
    var path, strokeGradient = this.strokeGradient, bbox = this.bbox, element = this.path.element;
    if (!element || !this.path.svgString) {
      path = this.path.toString();
      element = this.path.element = this.getElement('path');
      this.surface.setElementAttributes(element, {'fill':'none', 'd':path, 'transform':this.matrix.toSvg()});
    }
    this.surface.setElementAttributes(element, {'stroke':strokeGradient && bbox ? strokeGradient.generateGradient(this, bbox) : this.strokeStyle, 'stroke-linecap':this.lineCap, 'stroke-linejoin':this.lineJoin, 'stroke-width':this.lineWidth, 'stroke-opacity':this.strokeOpacity * this.globalAlpha});
    if (this.lineDash.length) {
      this.surface.setElementAttributes(element, {'stroke-dasharray':this.lineDash.join(','), 'stroke-dashoffset':this.lineDashOffset});
    }
  }
}, fillStroke:function(attr, transformFillStroke) {
  var ctx = this, fillStyle = ctx.fillStyle, strokeStyle = ctx.strokeStyle, fillOpacity = ctx.fillOpacity, strokeOpacity = ctx.strokeOpacity;
  if (transformFillStroke === undefined) {
    transformFillStroke = attr.transformFillStroke;
  }
  if (!transformFillStroke) {
    attr.inverseMatrix.toContext(ctx);
  }
  if (fillStyle && fillOpacity !== 0) {
    ctx.fill();
  }
  if (strokeStyle && strokeOpacity !== 0) {
    ctx.stroke();
  }
}, appendPath:function(path) {
  this.path = path.clone();
}, createLinearGradient:function(x0, y0, x1, y1) {
  var me = this, element = me.surface.getNextDef('linearGradient'), gradients = me.group.dom.gradients || (me.group.dom.gradients = {}), gradient;
  me.surface.setElementAttributes(element, {'x1':x0, 'y1':y0, 'x2':x1, 'y2':y1, 'gradientUnits':'userSpaceOnUse'});
  gradient = new Ext.draw.engine.SvgContext.Gradient(me, me.surface, element);
  gradients[element.dom.id] = gradient;
  return gradient;
}, createRadialGradient:function(x0, y0, r0, x1, y1, r1) {
  var me = this, element = me.surface.getNextDef('radialGradient'), gradients = me.group.dom.gradients || (me.group.dom.gradients = {}), gradient;
  me.surface.setElementAttributes(element, {'fx':x0, 'fy':y0, 'cx':x1, 'cy':y1, 'r':r1, 'gradientUnits':'userSpaceOnUse'});
  gradient = new Ext.draw.engine.SvgContext.Gradient(me, me.surface, element, r0 / r1);
  gradients[element.dom.id] = gradient;
  return gradient;
}}, 1, 0, 0, 0, 0, 0, [Ext.draw.engine, 'SvgContext'], 0);
Ext.cmd.derive('Ext.draw.engine.SvgContext.Gradient', Ext.Base, {statics:{map:{}}, constructor:function(ctx, surface, element, compression) {
  var map = this.statics().map, oldInstance;
  oldInstance = map[element.dom.id];
  if (oldInstance) {
    oldInstance.element = null;
  }
  map[element.dom.id] = this;
  this.ctx = ctx;
  this.surface = surface;
  this.element = element;
  this.position = 0;
  this.compression = compression || 0;
}, addColorStop:function(offset, color) {
  var stop = this.surface.getSvgElement(this.element, 'stop', this.position++), compression = this.compression;
  this.surface.setElementAttributes(stop, {'offset':(((1 - compression) * offset + compression) * 100).toFixed(2) + '%', 'stop-color':color, 'stop-opacity':Ext.draw.Color.fly(color).a.toFixed(15)});
}, toString:function() {
  var children = this.element.dom.childNodes;
  while (children.length > this.position) {
    Ext.fly(children[children.length - 1]).destroy();
  }
  return 'url(#' + this.element.getId() + ')';
}, destroy:function() {
  var map = this.statics().map, element = this.element;
  if (element) {
    delete map[element.dom.id];
    element.destroy();
  }
  this.callSuper();
}}, 3, 0, 0, 0, 0, 0, [Ext.draw.engine.SvgContext, 'Gradient'], 0);
Ext.cmd.derive('Ext.draw.engine.Svg', Ext.draw.Surface, {statics:{BBoxTextCache:{}}, config:{highPrecision:false}, getElementConfig:function() {
  return {reference:'element', style:{position:'absolute'}, children:[{reference:'innerElement', style:{width:'100%', height:'100%', position:'relative'}, children:[{tag:'svg', reference:'svgElement', namespace:'http://www.w3.org/2000/svg', version:1.1, cls:'x-surface'}]}]};
}, constructor:function(config) {
  var me = this;
  Ext.draw.Surface.prototype.constructor.call(this, config);
  me.mainGroup = me.createSvgNode('g');
  me.defElement = me.createSvgNode('defs');
  me.svgElement.appendChild(me.mainGroup);
  me.svgElement.appendChild(me.defElement);
  me.ctx = new Ext.draw.engine.SvgContext(me);
}, createSvgNode:function(type) {
  var node = document.createElementNS('http://www.w3.org/2000/svg', type);
  return Ext.get(node);
}, getSvgElement:function(group, tag, position) {
  var element;
  if (group.dom.childNodes.length > position) {
    element = group.dom.childNodes[position];
    if (element.tagName === tag) {
      return Ext.get(element);
    } else {
      Ext.destroy(element);
    }
  }
  element = Ext.get(this.createSvgNode(tag));
  if (position === 0) {
    group.insertFirst(element);
  } else {
    element.insertAfter(Ext.fly(group.dom.childNodes[position - 1]));
  }
  element.cache = {};
  return element;
}, setElementAttributes:function(element, attributes) {
  var dom = element.dom, cache = element.cache, name, value;
  for (name in attributes) {
    value = attributes[name];
    if (cache[name] !== value) {
      cache[name] = value;
      dom.setAttribute(name, value);
    }
  }
}, getNextDef:function(tagName) {
  return this.getSvgElement(this.defElement, tagName, this.defPosition++);
}, clearTransform:function() {
  var me = this;
  me.mainGroup.set({transform:me.matrix.toSvg()});
}, clear:function() {
  this.ctx.clear();
  this.defPosition = 0;
}, renderSprite:function(sprite) {
  var me = this, region = me.getRegion(), ctx = me.ctx;
  if (sprite.attr.hidden || sprite.attr.opacity === 0) {
    ctx.save();
    ctx.restore();
    return;
  }
  try {
    sprite.element = ctx.save();
    sprite.preRender(this);
    sprite.useAttributes(ctx, region);
    if (false === sprite.render(this, ctx, [0, 0, region[2], region[3]])) {
      return false;
    }
    sprite.setDirty(false);
  } finally {
    ctx.restore();
  }
}, destroy:function(path, matrix, band) {
  var me = this;
  me.ctx.destroy();
  me.mainGroup.destroy();
  delete me.mainGroup;
  delete me.ctx;
  Ext.draw.Surface.prototype.destroy.apply(this, arguments);
}, remove:function(sprite, destroySprite) {
  if (sprite && sprite.element) {
    if (this.ctx) {
      this.ctx.removeElement(sprite.element);
    } else {
      sprite.element.destroy();
    }
    sprite.element = null;
  }
  Ext.draw.Surface.prototype.remove.apply(this, arguments);
}}, 1, 0, ['component', 'surface'], {'component':true, 'surface':true}, 0, 0, [Ext.draw.engine, 'Svg'], 0);
Ext.cmd.derive('Ext.draw.engine.Canvas', Ext.draw.Surface, {config:{highPrecision:false}, statics:{contextOverrides:{setGradientBBox:function(bbox) {
  this.bbox = bbox;
}, fill:function() {
  var fillStyle = this.fillStyle, fillGradient = this.fillGradient, fillOpacity = this.fillOpacity, rgba = 'rgba(0, 0, 0, 0)', rgba0 = 'rgba(0, 0, 0, 0.0)', bbox = this.bbox, alpha = this.globalAlpha;
  if (fillStyle !== rgba && fillStyle !== rgba0 && fillOpacity !== 0) {
    if (fillGradient && bbox) {
      this.fillStyle = fillGradient.generateGradient(this, bbox);
    }
    if (fillOpacity !== 1) {
      this.globalAlpha = alpha * fillOpacity;
    }
    this.$fill();
    if (fillOpacity !== 1) {
      this.globalAlpha = alpha;
    }
    if (fillGradient && bbox) {
      this.fillStyle = fillStyle;
    }
  }
}, stroke:function() {
  var strokeStyle = this.strokeStyle, strokeGradient = this.strokeGradient, strokeOpacity = this.strokeOpacity, rgba = 'rgba(0, 0, 0, 0)', rgba0 = 'rgba(0, 0, 0, 0.0)', bbox = this.bbox, alpha = this.globalAlpha;
  if (strokeStyle !== rgba && strokeStyle !== rgba0 && strokeOpacity !== 0) {
    if (strokeGradient && bbox) {
      this.strokeStyle = strokeGradient.generateGradient(this, bbox);
    }
    if (strokeOpacity !== 1) {
      this.globalAlpha = alpha * strokeOpacity;
    }
    this.$stroke();
    if (strokeOpacity !== 1) {
      this.globalAlpha = alpha;
    }
    if (strokeGradient && bbox) {
      this.strokeStyle = strokeStyle;
    }
  }
}, fillStroke:function(attr, transformFillStroke) {
  var ctx = this, fillStyle = this.fillStyle, fillOpacity = this.fillOpacity, strokeStyle = this.strokeStyle, strokeOpacity = this.strokeOpacity, shadowColor = ctx.shadowColor, shadowBlur = ctx.shadowBlur, rgba = 'rgba(0, 0, 0, 0)', rgba0 = 'rgba(0, 0, 0, 0.0)';
  if (transformFillStroke === undefined) {
    transformFillStroke = attr.transformFillStroke;
  }
  if (!transformFillStroke) {
    attr.inverseMatrix.toContext(ctx);
  }
  if (fillStyle !== rgba && fillStyle !== rgba0 && fillOpacity !== 0) {
    ctx.fill();
    ctx.shadowColor = 'rgba(0,0,0,0)';
    ctx.shadowBlur = 0;
  }
  if (strokeStyle !== rgba && strokeStyle !== rgba0 && strokeOpacity !== 0) {
    ctx.stroke();
  }
  ctx.shadowColor = shadowColor;
  ctx.shadowBlur = shadowBlur;
}, ellipse:function(cx, cy, rx, ry, rotation, start, end, anticlockwise) {
  var cos = Math.cos(rotation), sin = Math.sin(rotation);
  this.transform(cos * rx, sin * rx, -sin * ry, cos * ry, cx, cy);
  this.arc(0, 0, 1, start, end, anticlockwise);
  this.transform(cos / rx, -sin / ry, sin / rx, cos / ry, -(cos * cx + sin * cy) / rx, (sin * cx - cos * cy) / ry);
}, appendPath:function(path) {
  var me = this, i = 0, j = 0, types = path.types, coords = path.coords, ln = path.types.length;
  me.beginPath();
  for (; i < ln; i++) {
    switch(types[i]) {
      case 'M':
        me.moveTo(coords[j], coords[j + 1]);
        j += 2;
        break;
      case 'L':
        me.lineTo(coords[j], coords[j + 1]);
        j += 2;
        break;
      case 'C':
        me.bezierCurveTo(coords[j], coords[j + 1], coords[j + 2], coords[j + 3], coords[j + 4], coords[j + 5]);
        j += 6;
        break;
      case 'Z':
        me.closePath();
        break;
    }
  }
}}}, splitThreshold:1800, getElementConfig:function() {
  return {reference:'element', style:{position:'absolute'}, children:[{reference:'innerElement', style:{width:'100%', height:'100%', position:'relative'}}]};
}, createCanvas:function() {
  var canvas = Ext.Element.create({tag:'canvas', cls:'x-surface'}), overrides = Ext.draw.engine.Canvas.contextOverrides, ctx = canvas.dom.getContext('2d'), backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1, name;
  this.devicePixelRatio /= Ext.os.is.WindowsPhone ? window.innerWidth / window.screen.width : backingStoreRatio;
  if (ctx.ellipse) {
    delete overrides.ellipse;
  }
  for (name in overrides) {
    ctx['$' + name] = ctx[name];
  }
  Ext.apply(ctx, overrides);
  if (this.getHighPrecision()) {
    this.enablePrecisionCompensation(ctx);
  } else {
    this.disablePrecisionCompensation(ctx);
  }
  this.innerElement.appendChild(canvas);
  this.canvases.push(canvas);
  this.contexts.push(ctx);
}, initElement:function() {
  Ext.draw.Surface.prototype.initElement.call(this);
  this.canvases = [];
  this.contexts = [];
  this.createCanvas();
  this.activeCanvases = 0;
}, updateHighPrecision:function(pc) {
  var contexts = this.contexts, ln = contexts.length, i, context;
  for (i = 0; i < ln; i++) {
    context = contexts[i];
    if (pc) {
      this.enablePrecisionCompensation(context);
    } else {
      this.disablePrecisionCompensation(context);
    }
  }
}, precisionMethods:{rect:false, fillRect:false, strokeRect:false, clearRect:false, moveTo:false, lineTo:false, arc:false, arcTo:false, save:false, restore:false, updatePrecisionCompensate:false, setTransform:false, transform:false, scale:false, translate:false, rotate:false, quadraticCurveTo:false, bezierCurveTo:false, createLinearGradient:false, createRadialGradient:false, fillText:false, strokeText:false, drawImage:false}, disablePrecisionCompensation:function(ctx) {
  var precisionMethods = this.precisionMethods, name;
  for (name in precisionMethods) {
    delete ctx[name];
  }
  this.setDirty(true);
}, enablePrecisionCompensation:function(ctx) {
  var surface = this, xx = 1, yy = 1, dx = 0, dy = 0, matrix = new Ext.draw.Matrix, transStack = [], comp = {}, originalCtx = ctx.constructor.prototype;
  var override = {rect:function(x, y, w, h) {
    return originalCtx.rect.call(this, x * xx + dx, y * yy + dy, w * xx, h * yy);
  }, fillRect:function(x, y, w, h) {
    this.updatePrecisionCompensateRect();
    originalCtx.fillRect.call(this, x * xx + dx, y * yy + dy, w * xx, h * yy);
    this.updatePrecisionCompensate();
  }, strokeRect:function(x, y, w, h) {
    this.updatePrecisionCompensateRect();
    originalCtx.strokeRect.call(this, x * xx + dx, y * yy + dy, w * xx, h * yy);
    this.updatePrecisionCompensate();
  }, clearRect:function(x, y, w, h) {
    return originalCtx.clearRect.call(this, x * xx + dx, y * yy + dy, w * xx, h * yy);
  }, moveTo:function(x, y) {
    return originalCtx.moveTo.call(this, x * xx + dx, y * yy + dy);
  }, lineTo:function(x, y) {
    return originalCtx.lineTo.call(this, x * xx + dx, y * yy + dy);
  }, arc:function(x, y, radius, startAngle, endAngle, anticlockwise) {
    this.updatePrecisionCompensateRect();
    originalCtx.arc.call(this, x * xx + dx, y * xx + dy, radius * xx, startAngle, endAngle, anticlockwise);
    this.updatePrecisionCompensate();
  }, arcTo:function(x1, y1, x2, y2, radius) {
    this.updatePrecisionCompensateRect();
    originalCtx.arcTo.call(this, x1 * xx + dx, y1 * yy + dy, x2 * xx + dx, y2 * yy + dy, radius * xx);
    this.updatePrecisionCompensate();
  }, save:function() {
    transStack.push(matrix);
    matrix = matrix.clone();
    return originalCtx.save.call(this);
  }, restore:function() {
    matrix = transStack.pop();
    originalCtx.restore.call(this);
    this.updatePrecisionCompensate();
  }, updatePrecisionCompensate:function() {
    matrix.precisionCompensate(surface.devicePixelRatio, comp);
    xx = comp.xx;
    yy = comp.yy;
    dx = comp.dx;
    dy = comp.dy;
    return originalCtx.setTransform.call(this, surface.devicePixelRatio, comp.b, comp.c, comp.d, 0, 0);
  }, updatePrecisionCompensateRect:function() {
    matrix.precisionCompensateRect(surface.devicePixelRatio, comp);
    xx = comp.xx;
    yy = comp.yy;
    dx = comp.dx;
    dy = comp.dy;
    return originalCtx.setTransform.call(this, surface.devicePixelRatio, comp.b, comp.c, comp.d, 0, 0);
  }, setTransform:function(x2x, x2y, y2x, y2y, newDx, newDy) {
    matrix.set(x2x, x2y, y2x, y2y, newDx, newDy);
    this.updatePrecisionCompensate();
  }, transform:function(x2x, x2y, y2x, y2y, newDx, newDy) {
    matrix.append(x2x, x2y, y2x, y2y, newDx, newDy);
    this.updatePrecisionCompensate();
  }, scale:function(sx, sy) {
    return this.transform(sx, 0, 0, sy, 0, 0);
  }, translate:function(dx, dy) {
    return this.transform(1, 0, 0, 1, dx, dy);
  }, rotate:function(radians) {
    var cos = Math.cos(radians), sin = Math.sin(radians);
    return this.transform(cos, sin, -sin, cos, 0, 0);
  }, quadraticCurveTo:function(cx, cy, x, y) {
    return originalCtx.quadraticCurveTo.call(this, cx * xx + dx, cy * yy + dy, x * xx + dx, y * yy + dy);
  }, bezierCurveTo:function(c1x, c1y, c2x, c2y, x, y) {
    return originalCtx.bezierCurveTo.call(this, c1x * xx + dx, c1y * yy + dy, c2x * xx + dx, c2y * yy + dy, x * xx + dx, y * yy + dy);
  }, createLinearGradient:function(x0, y0, x1, y1) {
    this.updatePrecisionCompensateRect();
    var grad = originalCtx.createLinearGradient.call(this, x0 * xx + dx, y0 * yy + dy, x1 * xx + dx, y1 * yy + dy);
    this.updatePrecisionCompensate();
    return grad;
  }, createRadialGradient:function(x0, y0, r0, x1, y1, r1) {
    this.updatePrecisionCompensateRect();
    var grad = originalCtx.createLinearGradient.call(this, x0 * xx + dx, y0 * xx + dy, r0 * xx, x1 * xx + dx, y1 * xx + dy, r1 * xx);
    this.updatePrecisionCompensate();
    return grad;
  }, fillText:function(text, x, y, maxWidth) {
    originalCtx.setTransform.apply(this, matrix.elements);
    if (typeof maxWidth === 'undefined') {
      originalCtx.fillText.call(this, text, x, y);
    } else {
      originalCtx.fillText.call(this, text, x, y, maxWidth);
    }
    this.updatePrecisionCompensate();
  }, strokeText:function(text, x, y, maxWidth) {
    originalCtx.setTransform.apply(this, matrix.elements);
    if (typeof maxWidth === 'undefined') {
      originalCtx.strokeText.call(this, text, x, y);
    } else {
      originalCtx.strokeText.call(this, text, x, y, maxWidth);
    }
    this.updatePrecisionCompensate();
  }, fill:function() {
    this.updatePrecisionCompensateRect();
    originalCtx.fill.call(this);
    this.updatePrecisionCompensate();
  }, stroke:function() {
    this.updatePrecisionCompensateRect();
    originalCtx.stroke.call(this);
    this.updatePrecisionCompensate();
  }, drawImage:function(img_elem, arg1, arg2, arg3, arg4, dst_x, dst_y, dw, dh) {
    switch(arguments.length) {
      case 3:
        return originalCtx.drawImage.call(this, img_elem, arg1 * xx + dx, arg2 * yy + dy);
      case 5:
        return originalCtx.drawImage.call(this, img_elem, arg1 * xx + dx, arg2 * yy + dy, arg3 * xx, arg4 * yy);
      case 9:
        return originalCtx.drawImage.call(this, img_elem, arg1, arg2, arg3, arg4, dst_x * xx + dx, dst_y * yy * dy, dw * xx, dh * yy);
    }
  }};
  Ext.apply(ctx, override);
  this.setDirty(true);
}, updateRegion:function(region) {
  Ext.draw.Surface.prototype.updateRegion.call(this, region);
  var me = this, l = Math.floor(region[0]), t = Math.floor(region[1]), r = Math.ceil(region[0] + region[2]), b = Math.ceil(region[1] + region[3]), devicePixelRatio = me.devicePixelRatio, w = r - l, h = b - t, splitThreshold = Math.round(me.splitThreshold / devicePixelRatio), splits = Math.ceil(w / splitThreshold), activeCanvases = me.activeCanvases, i, offsetX, dom, leftWidth;
  for (i = 0, offsetX = 0; i < splits; i++, offsetX += splitThreshold) {
    if (i >= me.canvases.length) {
      me.createCanvas();
    }
    dom = me.canvases[i].dom;
    dom.style.left = offsetX + 'px';
    if (h * devicePixelRatio !== dom.height) {
      dom.height = h * devicePixelRatio;
      dom.style.height = h + 'px';
    }
    leftWidth = Math.min(splitThreshold, w - offsetX);
    if (leftWidth * devicePixelRatio !== dom.width) {
      dom.width = leftWidth * devicePixelRatio;
      dom.style.width = leftWidth + 'px';
    }
    me.applyDefaults(me.contexts[i]);
  }
  for (; i < activeCanvases; i++) {
    dom = me.canvases[i].dom;
    dom.width = 0;
    dom.height = 0;
  }
  me.activeCanvases = splits;
  me.clear();
}, clearTransform:function() {
  var me = this, activeCanvases = me.activeCanvases, i, ctx;
  for (i = 0; i < activeCanvases; i++) {
    ctx = me.contexts[i];
    ctx.translate(-me.splitThreshold * i, 0);
    ctx.scale(me.devicePixelRatio, me.devicePixelRatio);
    me.matrix.toContext(ctx);
  }
}, renderSprite:function(sprite) {
  var me = this, region = me._region, surfaceMatrix = me.matrix, parent = sprite._parent, matrix = Ext.draw.Matrix.fly([1, 0, 0, 1, 0, 0]), bbox, i, offsetX, ctx, width, left = 0, top, right = region[2], bottom;
  while (parent && parent !== me) {
    matrix.prependMatrix(parent.matrix || parent.attr && parent.attr.matrix);
    parent = parent.getParent();
  }
  matrix.prependMatrix(surfaceMatrix);
  bbox = sprite.getBBox();
  if (bbox) {
    bbox = matrix.transformBBox(bbox);
  }
  sprite.preRender(me);
  if (sprite.attr.hidden || sprite.attr.globalAlpha === 0) {
    sprite.setDirty(false);
    return;
  }
  top = 0;
  bottom = top + region[3];
  for (i = 0, offsetX = 0; i < me.activeCanvases; i++, offsetX += me.splitThreshold / me.devicePixelRatio) {
    ctx = me.contexts[i];
    width = Math.min(region[2] - offsetX, me.splitThreshold / me.devicePixelRatio);
    left = offsetX;
    right = left + width;
    if (bbox) {
      if (bbox.x > right || bbox.x + bbox.width < left || bbox.y > bottom || bbox.y + bbox.height < top) {
        continue;
      }
    }
    try {
      ctx.save();
      sprite.useAttributes(ctx, region);
      if (false === sprite.render(me, ctx, [left, top, width, bottom - top], region)) {
        return false;
      }
    } finally {
      ctx.restore();
    }
  }
  sprite.setDirty(false);
}, applyDefaults:function(ctx) {
  ctx.strokeStyle = 'rgba(0,0,0,0)';
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.textAlign = 'start';
  ctx.textBaseline = 'top';
  ctx.miterLimit = 1;
}, clear:function() {
  var me = this, activeCanvases = this.activeCanvases, i, canvas, ctx;
  for (i = 0; i < activeCanvases; i++) {
    canvas = me.canvases[i].dom;
    ctx = me.contexts[i];
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
  me.setDirty(true);
}, destroy:function() {
  var me = this, i, ln = me.canvases.length;
  for (i = 0; i < ln; i++) {
    me.contexts[i] = null;
    me.canvases[i].destroy();
    me.canvases[i] = null;
  }
  delete me.contexts;
  delete me.canvases;
  Ext.draw.Surface.prototype.destroy.apply(this, arguments);
}}, 0, 0, ['component', 'surface'], {'component':true, 'surface':true}, 0, 0, [Ext.draw.engine, 'Canvas'], function() {
  if (Ext.os.is.Android4 && Ext.browser.is.Chrome) {
    this.prototype.splitThreshold = 3000;
  } else {
    if (Ext.os.is.Android) {
      this.prototype.splitThreshold = 1.0E10;
    }
  }
});
Ext.cmd.derive('Ext.draw.Component', Ext.Container, {defaultType:'surface', engine:'Ext.draw.engine.Canvas', statics:{WATERMARK:'Powered by \x3cspan style\x3d"color:#22E962; font-weight: 900"\x3eSencha Touch\x3c/span\x3e \x3cspan style\x3d"color:#75cdff; font-weight: 900"\x3eGPLv3\x3c/span\x3e'}, config:{cls:'x-draw-component', autoSize:false, viewBox:false, fitSurface:true, resizeHandler:null, background:null, sprites:null, gradients:[]}, constructor:function(config) {
  config = config || {};
  Ext.Container.prototype.constructor.apply(this, arguments);
  this.frameCallbackId = Ext.draw.Animator.addFrameCallback('renderFrame', this);
}, applyGradients:function(gradients) {
  var result = [], i, n, gradient, offset;
  if (!Ext.isArray(gradients)) {
    return result;
  }
  for (i = 0, n = gradients.length; i < n; i++) {
    gradient = gradients[i];
    if (!Ext.isObject(gradient)) {
      continue;
    }
    if (typeof gradient.type !== 'string') {
      gradient.type = 'linear';
    }
    if (gradient.angle) {
      gradient.degrees = gradient.angle;
      delete gradient.angle;
    }
    if (Ext.isObject(gradient.stops)) {
      gradient.stops = function(stops) {
        var result = [], stop;
        for (offset in stops) {
          stop = stops[offset];
          stop.offset = offset / 100;
          result.push(stop);
        }
        return result;
      }(gradient.stops);
    }
    result.push(gradient);
  }
  Ext.draw.gradient.GradientDefinition.add(result);
  return result;
}, initialize:function() {
  var me = this;
  Ext.Container.prototype.initialize.call(this);
  me.element.on('resize', 'onResize', this);
}, applySprites:function(sprites) {
  if (!sprites) {
    return;
  }
  sprites = Ext.Array.from(sprites);
  var ln = sprites.length, i, surface;
  for (i = 0; i < ln; i++) {
    if (sprites[i].surface instanceof Ext.draw.Surface) {
      surface = sprites[i].surface;
    } else {
      if (Ext.isString(sprites[i].surface)) {
        surface = this.getSurface(sprites[i].surface);
      } else {
        surface = this.getSurface('main');
      }
    }
    surface.add(sprites[i]);
  }
}, getElementConfig:function() {
  return {reference:'element', className:'x-container', children:[{reference:'innerElement', className:'x-inner', children:[{reference:'watermarkElement', cls:'x-chart-watermark', html:Ext.draw.Component.WATERMARK, style:Ext.draw.Component.WATERMARK ? '' : 'display: none'}]}]};
}, updateBackground:function(background) {
  this.element.setStyle({background:background});
}, onPlaceWatermark:function() {
}, onResize:function() {
  var me = this, size = me.element.getSize(), resizeHandler = me.getResizeHandler() || me.resizeHandler, result;
  me.fireEvent('resize', me, size);
  result = resizeHandler.call(me, size);
  if (result !== false) {
    me.renderFrame();
    me.onPlaceWatermark();
  }
}, resizeHandler:function(size) {
  var me = this;
  me.getItems().each(function(surface) {
    surface.setRegion([0, 0, size.width, size.height]);
  });
}, getSurface:function(id) {
  id = this.getId() + '-' + (id || 'main');
  var me = this, surfaces = me.getItems(), surface = surfaces.get(id), size;
  if (!surface) {
    surface = me.add({xclass:me.engine, id:id});
    if (me.getFitSurface()) {
      size = me.element.getSize();
      surface.setRegion([0, 0, size.width, size.height]);
    }
    surface.renderFrame();
  }
  return surface;
}, renderFrame:function() {
  var me = this, i, ln, bbox, surfaces = me.getItems();
  for (i = 0, ln = surfaces.length; i < ln; i++) {
    surfaces.items[i].renderFrame();
  }
}, destroy:function() {
  Ext.draw.Animator.removeFrameCallback(this.frameCallbackId);
  Ext.Container.prototype.destroy.call(this);
}}, 1, ['draw'], ['component', 'container', 'draw'], {'component':true, 'container':true, 'draw':true}, ['widget.draw'], 0, [Ext.draw, 'Component'], function() {
  if (location.search.match('svg')) {
    Ext.draw.Component.prototype.engine = 'Ext.draw.engine.Svg';
  } else {
    if (Ext.os.is.BlackBerry && Ext.os.version.getMajor() === 10 || Ext.browser.is.AndroidStock4 && (Ext.os.version.getMinor() === 1 || Ext.os.version.getMinor() === 2 || Ext.os.version.getMinor() === 3)) {
      Ext.draw.Component.prototype.engine = 'Ext.draw.engine.Svg';
    }
  }
});
Ext.cmd.derive('Ext.event.Event', Ext.Base, {alternateClassName:'Ext.EventObject', isStopped:false, set:function(name, value) {
  if (arguments.length === 1 && typeof name != 'string') {
    var info = name;
    for (name in info) {
      if (info.hasOwnProperty(name)) {
        this[name] = info[name];
      }
    }
  } else {
    this[name] = info[name];
  }
}, stopEvent:function() {
  return this.stopPropagation();
}, stopPropagation:function() {
  this.isStopped = true;
  return this;
}}, 0, 0, 0, 0, 0, 0, [Ext.event, 'Event', Ext, 'EventObject'], 0);
Ext.cmd.derive('Ext.event.Dom', Ext.event.Event, {constructor:function(event) {
  var target = event.target, touches;
  if (target && target.nodeType !== 1) {
    target = target.parentNode;
  }
  touches = event.changedTouches;
  if (touches) {
    touches = touches[0];
    this.pageX = touches.pageX;
    this.pageY = touches.pageY;
  } else {
    this.pageX = event.pageX;
    this.pageY = event.pageY;
  }
  this.browserEvent = this.event = event;
  this.target = this.delegatedTarget = target;
  this.type = event.type;
  this.timeStamp = this.time = +event.timeStamp;
  return this;
}, stopEvent:function() {
  this.preventDefault();
  return Ext.event.Event.prototype.stopEvent.call(this);
}, preventDefault:function() {
  this.browserEvent.preventDefault();
}, getPageX:function() {
  return this.pageX || this.browserEvent.pageX;
}, getPageY:function() {
  return this.pageY || this.browserEvent.pageY;
}, getXY:function() {
  if (!this.xy) {
    this.xy = [this.getPageX(), this.getPageY()];
  }
  return this.xy;
}, getTarget:function(selector, maxDepth, returnEl) {
  if (arguments.length === 0) {
    return this.delegatedTarget;
  }
  return selector ? Ext.fly(this.target).findParent(selector, maxDepth, returnEl) : returnEl ? Ext.get(this.target) : this.target;
}, getTime:function() {
  return this.time;
}, setDelegatedTarget:function(target) {
  this.delegatedTarget = target;
}, makeUnpreventable:function() {
  this.browserEvent.preventDefault = Ext.emptyFn;
}}, 1, 0, 0, 0, 0, 0, [Ext.event, 'Dom'], 0);
Ext.cmd.derive('Ext.event.Touch', Ext.event.Dom, {constructor:function(event, info, map, list) {
  var touches = [], touch, i, ln, identifier;
  if (info) {
    this.set(info);
  }
  this.changedTouches = this.cloneTouches(event.changedTouches, map);
  for (i = 0, ln = list.length; i < ln; i++) {
    identifier = list[i];
    touches.push(map[identifier]);
  }
  this.touches = touches;
  this.targetTouches = touches.slice();
  touch = this.changedTouches[0];
  Ext.event.Dom.prototype.constructor.call(this, event);
  this.target = this.delegatedTarget = touch.target;
  this.pageX = touch.pageX;
  this.pageY = touch.pageY;
}, cloneTouches:function(touches, map) {
  var clonedTouches = [], i, ln, touch, identifier;
  for (i = 0, ln = touches.length; i < ln; i++) {
    touch = touches[i];
    identifier = touch.identifier;
    clonedTouches[i] = map[identifier];
  }
  return clonedTouches;
}}, 1, 0, 0, 0, 0, 0, [Ext.event, 'Touch'], 0);
Ext.cmd.derive('Ext.event.publisher.Publisher', Ext.Base, {targetType:'', idSelectorRegex:/^#([\w\-]+)$/i, constructor:function() {
  var handledEvents = this.handledEvents, handledEventsMap, i, ln, event;
  handledEventsMap = this.handledEventsMap = {};
  for (i = 0, ln = handledEvents.length; i < ln; i++) {
    event = handledEvents[i];
    handledEventsMap[event] = true;
  }
  this.subscribers = {};
  return this;
}, handles:function(eventName) {
  var map = this.handledEventsMap;
  return !!map[eventName] || !!map['*'] || eventName === '*';
}, getHandledEvents:function() {
  return this.handledEvents;
}, setDispatcher:function(dispatcher) {
  this.dispatcher = dispatcher;
}, subscribe:function() {
  return false;
}, unsubscribe:function() {
  return false;
}, unsubscribeAll:function() {
  delete this.subscribers;
  this.subscribers = {};
  return this;
}, notify:function() {
  return false;
}, getTargetType:function() {
  return this.targetType;
}, dispatch:function(target, eventName, args) {
  this.dispatcher.doDispatchEvent(this.targetType, target, eventName, args);
}}, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, 'Publisher'], 0);
Ext.cmd.derive('Ext.event.publisher.ComponentDelegation', Ext.event.publisher.Publisher, {targetType:'component', optimizedSelectorRegex:/^#([\w\-]+)((?:[\s]*)>(?:[\s]*)|(?:\s*))([\w\-]+)$/i, handledEvents:['*'], getSubscribers:function(eventName, createIfNotExist) {
  var subscribers = this.subscribers, eventSubscribers = subscribers[eventName];
  if (!eventSubscribers && createIfNotExist) {
    eventSubscribers = subscribers[eventName] = {type:{$length:0}, selector:[], $length:0};
  }
  return eventSubscribers;
}, subscribe:function(target, eventName) {
  if (this.idSelectorRegex.test(target)) {
    return false;
  }
  var optimizedSelector = target.match(this.optimizedSelectorRegex), subscribers = this.getSubscribers(eventName, true), typeSubscribers = subscribers.type, selectorSubscribers = subscribers.selector, id, isDescendant, type, map, subMap;
  if (optimizedSelector !== null) {
    id = optimizedSelector[1];
    isDescendant = optimizedSelector[2].indexOf('\x3e') === -1;
    type = optimizedSelector[3];
    map = typeSubscribers[type];
    if (!map) {
      typeSubscribers[type] = map = {descendents:{$length:0}, children:{$length:0}, $length:0};
    }
    subMap = isDescendant ? map.descendents : map.children;
    if (subMap.hasOwnProperty(id)) {
      subMap[id]++;
      return true;
    }
    subMap[id] = 1;
    subMap.$length++;
    map.$length++;
    typeSubscribers.$length++;
  } else {
    if (selectorSubscribers.hasOwnProperty(target)) {
      selectorSubscribers[target]++;
      return true;
    }
    selectorSubscribers[target] = 1;
    selectorSubscribers.push(target);
  }
  subscribers.$length++;
  return true;
}, unsubscribe:function(target, eventName, all) {
  var subscribers = this.getSubscribers(eventName);
  if (!subscribers) {
    return false;
  }
  var match = target.match(this.optimizedSelectorRegex), typeSubscribers = subscribers.type, selectorSubscribers = subscribers.selector, id, isDescendant, type, map, subMap;
  all = Boolean(all);
  if (match !== null) {
    id = match[1];
    isDescendant = match[2].indexOf('\x3e') === -1;
    type = match[3];
    map = typeSubscribers[type];
    if (!map) {
      return true;
    }
    subMap = isDescendant ? map.descendents : map.children;
    if (!subMap.hasOwnProperty(id) || !all && --subMap[id] > 0) {
      return true;
    }
    delete subMap[id];
    subMap.$length--;
    map.$length--;
    typeSubscribers.$length--;
  } else {
    if (!selectorSubscribers.hasOwnProperty(target) || !all && --selectorSubscribers[target] > 0) {
      return true;
    }
    delete selectorSubscribers[target];
    Ext.Array.remove(selectorSubscribers, target);
  }
  if (--subscribers.$length === 0) {
    delete this.subscribers[eventName];
  }
  return true;
}, notify:function(target, eventName) {
  var subscribers = this.getSubscribers(eventName), id, component;
  if (!subscribers || subscribers.$length === 0) {
    return false;
  }
  id = target.substr(1);
  component = Ext.ComponentManager.get(id);
  if (component) {
    this.dispatcher.doAddListener(this.targetType, target, eventName, 'publish', this, {args:[eventName, component]}, 'before');
  }
}, matchesSelector:function(component, selector) {
  return Ext.ComponentQuery.is(component, selector);
}, dispatch:function(target, eventName, args, connectedController) {
  this.dispatcher.doDispatchEvent(this.targetType, target, eventName, args, null, connectedController);
}, publish:function(eventName, component) {
  var subscribers = this.getSubscribers(eventName);
  if (!subscribers) {
    return;
  }
  var eventController = arguments[arguments.length - 1], typeSubscribers = subscribers.type, selectorSubscribers = subscribers.selector, args = Array.prototype.slice.call(arguments, 2, -2), types = component.xtypesChain, descendentsSubscribers, childrenSubscribers, parentId, ancestorIds, ancestorId, parentComponent, selector, i, ln, type, j, subLn;
  for (i = 0, ln = types.length; i < ln; i++) {
    type = types[i];
    subscribers = typeSubscribers[type];
    if (subscribers && subscribers.$length > 0) {
      descendentsSubscribers = subscribers.descendents;
      if (descendentsSubscribers.$length > 0) {
        if (!ancestorIds) {
          ancestorIds = component.getAncestorIds();
        }
        for (j = 0, subLn = ancestorIds.length; j < subLn; j++) {
          ancestorId = ancestorIds[j];
          if (descendentsSubscribers.hasOwnProperty(ancestorId)) {
            this.dispatch('#' + ancestorId + ' ' + type, eventName, args, eventController);
          }
        }
      }
      childrenSubscribers = subscribers.children;
      if (childrenSubscribers.$length > 0) {
        if (!parentId) {
          if (ancestorIds) {
            parentId = ancestorIds[0];
          } else {
            parentComponent = component.getParent();
            if (parentComponent) {
              parentId = parentComponent.getId();
            }
          }
        }
        if (parentId) {
          if (childrenSubscribers.hasOwnProperty(parentId)) {
            this.dispatch('#' + parentId + ' \x3e ' + type, eventName, args, eventController);
          }
        }
      }
    }
  }
  ln = selectorSubscribers.length;
  if (ln > 0) {
    for (i = 0; i < ln; i++) {
      selector = selectorSubscribers[i];
      if (this.matchesSelector(component, selector)) {
        this.dispatch(selector, eventName, args, eventController);
      }
    }
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.event.publisher, 'ComponentDelegation'], 0);
Ext.cmd.derive('Ext.event.publisher.ComponentPaint', Ext.event.publisher.Publisher, {targetType:'component', handledEvents:['erased'], eventNames:{painted:'painted', erased:'erased'}, constructor:function() {
  Ext.event.publisher.Publisher.prototype.constructor.apply(this, arguments);
  this.hiddenQueue = {};
  this.renderedQueue = {};
}, getSubscribers:function(eventName, createIfNotExist) {
  var subscribers = this.subscribers;
  if (!subscribers.hasOwnProperty(eventName)) {
    if (!createIfNotExist) {
      return null;
    }
    subscribers[eventName] = {$length:0};
  }
  return subscribers[eventName];
}, setDispatcher:function(dispatcher) {
  var targetType = this.targetType;
  dispatcher.doAddListener(targetType, '*', 'renderedchange', 'onBeforeComponentRenderedChange', this, null, 'before');
  dispatcher.doAddListener(targetType, '*', 'hiddenchange', 'onBeforeComponentHiddenChange', this, null, 'before');
  dispatcher.doAddListener(targetType, '*', 'renderedchange', 'onComponentRenderedChange', this, null, 'after');
  dispatcher.doAddListener(targetType, '*', 'hiddenchange', 'onComponentHiddenChange', this, null, 'after');
  return Ext.event.publisher.Publisher.prototype.setDispatcher.apply(this, arguments);
}, subscribe:function(target, eventName) {
  var match = target.match(this.idSelectorRegex), subscribers, id;
  if (!match) {
    return false;
  }
  id = match[1];
  subscribers = this.getSubscribers(eventName, true);
  if (subscribers.hasOwnProperty(id)) {
    subscribers[id]++;
    return true;
  }
  subscribers[id] = 1;
  subscribers.$length++;
  return true;
}, unsubscribe:function(target, eventName, all) {
  var match = target.match(this.idSelectorRegex), subscribers, id;
  if (!match || !(subscribers = this.getSubscribers(eventName))) {
    return false;
  }
  id = match[1];
  if (!subscribers.hasOwnProperty(id) || !all && --subscribers[id] > 0) {
    return true;
  }
  delete subscribers[id];
  if (--subscribers.$length === 0) {
    delete this.subscribers[eventName];
  }
  return true;
}, onBeforeComponentRenderedChange:function(container, component, rendered) {
  var eventNames = this.eventNames, eventName = rendered ? eventNames.painted : eventNames.erased, subscribers = this.getSubscribers(eventName), queue;
  if (subscribers && subscribers.$length > 0) {
    this.renderedQueue[component.getId()] = queue = [];
    this.publish(subscribers, component, eventName, queue);
  }
}, onBeforeComponentHiddenChange:function(component, hidden) {
  var eventNames = this.eventNames, eventName = hidden ? eventNames.erased : eventNames.painted, subscribers = this.getSubscribers(eventName), queue;
  if (subscribers && subscribers.$length > 0) {
    this.hiddenQueue[component.getId()] = queue = [];
    this.publish(subscribers, component, eventName, queue);
  }
}, onComponentRenderedChange:function(container, component) {
  var renderedQueue = this.renderedQueue, id = component.getId(), queue;
  if (!renderedQueue.hasOwnProperty(id)) {
    return;
  }
  queue = renderedQueue[id];
  delete renderedQueue[id];
  if (queue.length > 0) {
    this.dispatchQueue(queue);
  }
}, onComponentHiddenChange:function(component) {
  var hiddenQueue = this.hiddenQueue, id = component.getId(), queue;
  if (!hiddenQueue.hasOwnProperty(id)) {
    return;
  }
  queue = hiddenQueue[id];
  delete hiddenQueue[id];
  if (queue.length > 0) {
    this.dispatchQueue(queue);
  }
}, dispatchQueue:function(dispatchingQueue) {
  var dispatcher = this.dispatcher, targetType = this.targetType, eventNames = this.eventNames, queue = dispatchingQueue.slice(), ln = queue.length, i, item, component, eventName, isPainted;
  dispatchingQueue.length = 0;
  if (ln > 0) {
    for (i = 0; i < ln; i++) {
      item = queue[i];
      component = item.component;
      eventName = item.eventName;
      isPainted = component.isPainted();
      if (eventName === eventNames.painted && isPainted || eventName === eventNames.erased && !isPainted) {
        dispatcher.doDispatchEvent(targetType, '#' + item.id, eventName, [component]);
      }
    }
    queue.length = 0;
  }
}, publish:function(subscribers, component, eventName, dispatchingQueue) {
  var id = component.getId(), needsDispatching = false, eventNames, items, i, ln, isPainted;
  if (subscribers[id]) {
    eventNames = this.eventNames;
    isPainted = component.isPainted();
    if (eventName === eventNames.painted && !isPainted || eventName === eventNames.erased && isPainted) {
      needsDispatching = true;
    } else {
      return this;
    }
  }
  if (component.isContainer) {
    items = component.getItems().items;
    for (i = 0, ln = items.length; i < ln; i++) {
      this.publish(subscribers, items[i], eventName, dispatchingQueue);
    }
  } else {
    if (component.isDecorator) {
      this.publish(subscribers, component.getComponent(), eventName, dispatchingQueue);
    }
  }
  if (needsDispatching) {
    dispatchingQueue.push({id:id, eventName:eventName, component:component});
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, 'ComponentPaint'], 0);
Ext.cmd.derive('Ext.event.publisher.Dom', Ext.event.publisher.Publisher, {targetType:'element', idOrClassSelectorRegex:/^([#|\.])([\w\-]+)$/, handledEvents:['focus', 'blur', 'paste', 'input', 'change', 'keyup', 'keydown', 'keypress', 'submit', 'transitionend', 'animationstart', 'animationend'], classNameSplitRegex:/\s+/, SELECTOR_ALL:'*', constructor:function() {
  var eventNames = this.getHandledEvents(), eventNameMap = {}, i, ln, eventName, vendorEventName;
  this.doBubbleEventsMap = {'click':true, 'submit':true, 'mousedown':true, 'mousemove':true, 'mouseup':true, 'mouseover':true, 'mouseout':true, 'transitionend':true};
  this.onEvent = Ext.Function.bind(this.onEvent, this);
  for (i = 0, ln = eventNames.length; i < ln; i++) {
    eventName = eventNames[i];
    vendorEventName = this.getVendorEventName(eventName);
    eventNameMap[vendorEventName] = eventName;
    this.attachListener(vendorEventName);
  }
  this.eventNameMap = eventNameMap;
  return Ext.event.publisher.Publisher.prototype.constructor.call(this);
}, getSubscribers:function(eventName) {
  var subscribers = this.subscribers, eventSubscribers = subscribers[eventName];
  if (!eventSubscribers) {
    eventSubscribers = subscribers[eventName] = {id:{$length:0}, className:{$length:0}, selector:[], all:0, $length:0};
  }
  return eventSubscribers;
}, getVendorEventName:function(eventName) {
  if (Ext.browser.is.WebKit) {
    if (eventName === 'transitionend') {
      eventName = Ext.browser.getVendorProperyName('transitionEnd');
    } else {
      if (eventName === 'animationstart') {
        eventName = Ext.browser.getVendorProperyName('animationStart');
      } else {
        if (eventName === 'animationend') {
          eventName = Ext.browser.getVendorProperyName('animationEnd');
        }
      }
    }
  }
  return eventName;
}, bindListeners:function(doc, bind) {
  var handlesEvents = this.getHandledEvents(), handlesEventsLength = handlesEvents.length, i;
  for (i = 0; i < handlesEventsLength; i++) {
    this.bindListener(doc, this.getVendorEventName(handlesEvents[i]), bind);
  }
}, bindListener:function(doc, eventName, bind) {
  if (bind) {
    this.attachListener(eventName, doc);
  } else {
    this.removeListener(eventName, doc);
  }
  return this;
}, attachListener:function(eventName, doc) {
  if (!doc) {
    doc = document;
  }
  var defaultView = doc.defaultView;
  if (Ext.os.is.iOS && Ext.os.version.getMajor() < 5 || Ext.browser.is.AndroidStock) {
    document.addEventListener(eventName, this.onEvent, !this.doesEventBubble(eventName));
  } else {
    if (defaultView && defaultView.addEventListener) {
      doc.defaultView.addEventListener(eventName, this.onEvent, !this.doesEventBubble(eventName));
    } else {
      doc.addEventListener(eventName, this.onEvent, !this.doesEventBubble(eventName));
    }
  }
  return this;
}, removeListener:function(eventName, doc) {
  if (!doc) {
    doc = document;
  }
  var defaultView = doc.defaultView;
  if (Ext.os.is.iOS && Ext.os.version.getMajor() < 5 && Ext.browser.is.AndroidStock) {
    document.removeEventListener(eventName, this.onEvent, !this.doesEventBubble(eventName));
  } else {
    if (defaultView && defaultView.addEventListener) {
      doc.defaultView.removeEventListener(eventName, this.onEvent, !this.doesEventBubble(eventName));
    } else {
      doc.removeEventListener(eventName, this.onEvent, !this.doesEventBubble(eventName));
    }
  }
  return this;
}, doesEventBubble:function(eventName) {
  return !!this.doBubbleEventsMap[eventName];
}, subscribe:function(target, eventName) {
  if (!this.handles(eventName)) {
    return false;
  }
  var idOrClassSelectorMatch = target.match(this.idOrClassSelectorRegex), subscribers = this.getSubscribers(eventName), idSubscribers = subscribers.id, classNameSubscribers = subscribers.className, selectorSubscribers = subscribers.selector, type, value;
  if (idOrClassSelectorMatch !== null) {
    type = idOrClassSelectorMatch[1];
    value = idOrClassSelectorMatch[2];
    if (type === '#') {
      if (idSubscribers.hasOwnProperty(value)) {
        idSubscribers[value]++;
        return true;
      }
      idSubscribers[value] = 1;
      idSubscribers.$length++;
    } else {
      if (classNameSubscribers.hasOwnProperty(value)) {
        classNameSubscribers[value]++;
        return true;
      }
      classNameSubscribers[value] = 1;
      classNameSubscribers.$length++;
    }
  } else {
    if (target === this.SELECTOR_ALL) {
      subscribers.all++;
    } else {
      if (selectorSubscribers.hasOwnProperty(target)) {
        selectorSubscribers[target]++;
        return true;
      }
      selectorSubscribers[target] = 1;
      selectorSubscribers.push(target);
    }
  }
  subscribers.$length++;
  return true;
}, unsubscribe:function(target, eventName, all) {
  if (!this.handles(eventName)) {
    return false;
  }
  var idOrClassSelectorMatch = target.match(this.idOrClassSelectorRegex), subscribers = this.getSubscribers(eventName), idSubscribers = subscribers.id, classNameSubscribers = subscribers.className, selectorSubscribers = subscribers.selector, type, value;
  all = Boolean(all);
  if (idOrClassSelectorMatch !== null) {
    type = idOrClassSelectorMatch[1];
    value = idOrClassSelectorMatch[2];
    if (type === '#') {
      if (!idSubscribers.hasOwnProperty(value) || !all && --idSubscribers[value] > 0) {
        return true;
      }
      delete idSubscribers[value];
      idSubscribers.$length--;
    } else {
      if (!classNameSubscribers.hasOwnProperty(value) || !all && --classNameSubscribers[value] > 0) {
        return true;
      }
      delete classNameSubscribers[value];
      classNameSubscribers.$length--;
    }
  } else {
    if (target === this.SELECTOR_ALL) {
      if (all) {
        subscribers.all = 0;
      } else {
        subscribers.all--;
      }
    } else {
      if (!selectorSubscribers.hasOwnProperty(target) || !all && --selectorSubscribers[target] > 0) {
        return true;
      }
      delete selectorSubscribers[target];
      Ext.Array.remove(selectorSubscribers, target);
    }
  }
  subscribers.$length--;
  return true;
}, getElementTarget:function(target) {
  if (target.nodeType !== 1) {
    target = target.parentNode;
    if (!target || target.nodeType !== 1) {
      return null;
    }
  }
  return target;
}, getBubblingTargets:function(target) {
  var targets = [];
  if (!target) {
    return targets;
  }
  do {
    targets[targets.length] = target;
    target = target.parentNode;
  } while (target && target.nodeType === 1);
  return targets;
}, dispatch:function(target, eventName, args) {
  args.push(args[0].target);
  Ext.event.publisher.Publisher.prototype.dispatch.apply(this, arguments);
}, publish:function(eventName, targets, event) {
  var subscribers = this.getSubscribers(eventName), wildcardSubscribers;
  if (subscribers.$length === 0 || !this.doPublish(subscribers, eventName, targets, event)) {
    wildcardSubscribers = this.getSubscribers('*');
    if (wildcardSubscribers.$length > 0) {
      this.doPublish(wildcardSubscribers, eventName, targets, event);
    }
  }
  return this;
}, doPublish:function(subscribers, eventName, targets, event) {
  var idSubscribers = subscribers.id, classNameSubscribers = subscribers.className, selectorSubscribers = subscribers.selector, hasIdSubscribers = idSubscribers.$length > 0, hasClassNameSubscribers = classNameSubscribers.$length > 0, hasSelectorSubscribers = selectorSubscribers.length > 0, hasAllSubscribers = subscribers.all > 0, isClassNameHandled = {}, args = [event], hasDispatched = false, classNameSplitRegex = this.classNameSplitRegex, i, ln, j, subLn, target, id, className, classNames, selector;
  for (i = 0, ln = targets.length; i < ln; i++) {
    target = targets[i];
    event.setDelegatedTarget(target);
    if (hasIdSubscribers) {
      id = target.getAttribute('id');
      if (id) {
        if (idSubscribers.hasOwnProperty(id)) {
          hasDispatched = true;
          this.dispatch('#' + id, eventName, args);
        }
      }
    }
    if (hasClassNameSubscribers) {
      className = target.className;
      if (className) {
        classNames = className.split(classNameSplitRegex);
        for (j = 0, subLn = classNames.length; j < subLn; j++) {
          className = classNames[j];
          if (!isClassNameHandled[className]) {
            isClassNameHandled[className] = true;
            if (classNameSubscribers.hasOwnProperty(className)) {
              hasDispatched = true;
              this.dispatch('.' + className, eventName, args);
            }
          }
        }
      }
    }
    if (event.isStopped) {
      return hasDispatched;
    }
  }
  if (hasAllSubscribers && !hasDispatched) {
    event.setDelegatedTarget(event.browserEvent.target);
    hasDispatched = true;
    this.dispatch(this.SELECTOR_ALL, eventName, args);
    if (event.isStopped) {
      return hasDispatched;
    }
  }
  if (hasSelectorSubscribers) {
    for (j = 0, subLn = targets.length; j < subLn; j++) {
      target = targets[j];
      for (i = 0, ln = selectorSubscribers.length; i < ln; i++) {
        selector = selectorSubscribers[i];
        if (this.matchesSelector(target, selector)) {
          event.setDelegatedTarget(target);
          hasDispatched = true;
          this.dispatch(selector, eventName, args);
        }
        if (event.isStopped) {
          return hasDispatched;
        }
      }
    }
  }
  return hasDispatched;
}, matchesSelector:function() {
  var test = Element.prototype, matchesSelector = 'webkitMatchesSelector' in test ? 'webkitMatchesSelector' : 'msMatchesSelector' in test ? 'msMatchesSelector' : 'mozMatchesSelector' in test ? 'mozMatchesSelector' : null;
  if (matchesSelector) {
    return function(element, selector) {
      return element[matchesSelector](selector);
    };
  }
  return function(element, selector) {
    Ext.DomQuery.is(element, selector);
  };
}(), onEvent:function(e) {
  var eventName = this.eventNameMap[e.type];
  Ext.frameStartTime = e.timeStamp;
  if (!eventName || this.getSubscribersCount(eventName) === 0) {
    return;
  }
  var target = this.getElementTarget(e.target), targets;
  if (!target) {
    return;
  }
  if (this.doesEventBubble(eventName)) {
    targets = this.getBubblingTargets(target);
  } else {
    targets = [target];
  }
  this.publish(eventName, targets, new Ext.event.Dom(e));
}, getSubscribersCount:function(eventName) {
  if (!this.handles(eventName)) {
    return 0;
  }
  return this.getSubscribers(eventName).$length + this.getSubscribers('*').$length;
}}, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, 'Dom'], 0);
Ext.cmd.derive('Ext.util.paintmonitor.Abstract', Ext.Base, {config:{element:null, callback:Ext.emptyFn, scope:null, args:[]}, eventName:'', monitorClass:'', constructor:function(config) {
  this.onElementPainted = Ext.Function.bind(this.onElementPainted, this);
  this.initConfig(config);
}, bindListeners:function(bind) {
  this.monitorElement[bind ? 'addEventListener' : 'removeEventListener'](this.eventName, this.onElementPainted, true);
}, applyElement:function(element) {
  if (element) {
    return Ext.get(element);
  }
}, updateElement:function(element) {
  this.monitorElement = Ext.Element.create({classList:['x-paint-monitor', this.monitorClass]}, true);
  element.appendChild(this.monitorElement);
  element.addCls('x-paint-monitored');
  this.bindListeners(true);
}, onElementPainted:function() {
}, destroy:function() {
  var monitorElement = this.monitorElement, parentNode = monitorElement.parentNode, element = this.getElement();
  this.bindListeners(false);
  delete this.monitorElement;
  if (element && !element.isDestroyed) {
    element.removeCls('x-paint-monitored');
    delete this._element;
  }
  if (parentNode) {
    parentNode.removeChild(monitorElement);
  }
  this.callSuper();
}}, 1, 0, 0, 0, 0, 0, [Ext.util.paintmonitor, 'Abstract'], 0);
Ext.cmd.derive('Ext.util.paintmonitor.CssAnimation', Ext.util.paintmonitor.Abstract, {eventName:Ext.browser.is.WebKit ? 'webkitAnimationEnd' : 'animationend', monitorClass:'cssanimation', onElementPainted:function(e) {
  if (e.animationName === 'x-paint-monitor-helper') {
    this.getCallback().apply(this.getScope(), this.getArgs());
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.util.paintmonitor, 'CssAnimation'], 0);
Ext.cmd.derive('Ext.util.PaintMonitor', Ext.Base, {constructor:function(config) {
  return new Ext.util.paintmonitor.CssAnimation(config);
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'PaintMonitor'], 0);
Ext.define('Xedu.override.PaintMonitor', {override:'Ext.util.PaintMonitor', constructor:function(config) {
  if (Ext.browser.is.Firefox || Ext.browser.is.WebKit && Ext.browser.engineVersion.gtEq('536') && !Ext.browser.engineVersion.ltEq('537.36') && !Ext.os.is.Blackberry) {
    return new Ext.util.paintmonitor.OverflowChange(config);
  } else {
    return new Ext.util.paintmonitor.CssAnimation(config);
  }
}});
Ext.cmd.derive('Ext.event.publisher.ElementPaint', Ext.event.publisher.Publisher, {targetType:'element', handledEvents:['painted'], constructor:function() {
  this.monitors = {};
  Ext.event.publisher.Publisher.prototype.constructor.apply(this, arguments);
}, subscribe:function(target) {
  var match = target.match(this.idSelectorRegex), subscribers = this.subscribers, id, element;
  if (!match) {
    return false;
  }
  id = match[1];
  if (subscribers.hasOwnProperty(id)) {
    subscribers[id]++;
    return true;
  }
  subscribers[id] = 1;
  element = Ext.get(id);
  this.monitors[id] = new Ext.util.PaintMonitor({element:element, callback:this.onElementPainted, scope:this, args:[target, element]});
  return true;
}, unsubscribe:function(target, eventName, all) {
  var match = target.match(this.idSelectorRegex), subscribers = this.subscribers, id;
  if (!match) {
    return false;
  }
  id = match[1];
  if (!subscribers.hasOwnProperty(id) || !all && --subscribers[id] > 0) {
    return true;
  }
  delete subscribers[id];
  this.monitors[id].destroy();
  delete this.monitors[id];
  return true;
}, onElementPainted:function(target, element) {
  Ext.TaskQueue.requestRead('dispatch', this, [target, 'painted', [element]]);
}}, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, 'ElementPaint'], 0);
Ext.cmd.derive('Ext.mixin.Templatable', Ext.mixin.Mixin, {mixinConfig:{id:'templatable'}, referenceAttributeName:'reference', referenceSelector:'[reference]', getElementConfig:function() {
  return {reference:'element'};
}, getElementTemplate:function() {
  var elementTemplate = document.createDocumentFragment();
  elementTemplate.appendChild(Ext.Element.create(this.getElementConfig(), true));
  return elementTemplate;
}, initElement:function() {
  var prototype = this.self.prototype;
  prototype.elementTemplate = this.getElementTemplate();
  prototype.initElement = prototype.doInitElement;
  this.initElement.apply(this, arguments);
}, linkElement:function(reference, node) {
  this.link(reference, node);
}, doInitElement:function() {
  var referenceAttributeName = this.referenceAttributeName, renderElement, referenceNodes, i, ln, referenceNode, reference;
  renderElement = this.elementTemplate.cloneNode(true);
  referenceNodes = renderElement.querySelectorAll(this.referenceSelector);
  for (i = 0, ln = referenceNodes.length; i < ln; i++) {
    referenceNode = referenceNodes[i];
    reference = referenceNode.getAttribute(referenceAttributeName);
    referenceNode.removeAttribute(referenceAttributeName);
    this.linkElement(reference, referenceNode);
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.mixin, 'Templatable'], 0);
Ext.cmd.derive('Ext.util.sizemonitor.Abstract', Ext.Base, {config:{element:null, callback:Ext.emptyFn, scope:null, args:[]}, width:0, height:0, contentWidth:0, contentHeight:0, constructor:function(config) {
  this.refresh = Ext.Function.bind(this.refresh, this);
  this.info = {width:0, height:0, contentWidth:0, contentHeight:0, flag:0};
  this.initElement();
  this.initConfig(config);
  this.bindListeners(true);
}, bindListeners:Ext.emptyFn, applyElement:function(element) {
  if (element) {
    return Ext.get(element);
  }
}, updateElement:function(element) {
  element.append(this.detectorsContainer);
  element.addCls('x-size-monitored');
}, applyArgs:function(args) {
  return args.concat([this.info]);
}, refreshMonitors:Ext.emptyFn, forceRefresh:function() {
  Ext.TaskQueue.requestRead('refresh', this);
}, getContentBounds:function() {
  return this.detectorsContainer.getBoundingClientRect();
}, getContentWidth:function() {
  return this.detectorsContainer.offsetWidth;
}, getContentHeight:function() {
  return this.detectorsContainer.offsetHeight;
}, refreshSize:function() {
  var element = this.getElement();
  if (!element || element.isDestroyed) {
    return false;
  }
  var width = element.getWidth(), height = element.getHeight(), contentWidth = this.getContentWidth(), contentHeight = this.getContentHeight(), currentContentWidth = this.contentWidth, currentContentHeight = this.contentHeight, info = this.info, resized = false, flag;
  this.width = width;
  this.height = height;
  this.contentWidth = contentWidth;
  this.contentHeight = contentHeight;
  flag = (currentContentWidth !== contentWidth ? 1 : 0) + (currentContentHeight !== contentHeight ? 2 : 0);
  if (flag > 0) {
    info.width = width;
    info.height = height;
    info.contentWidth = contentWidth;
    info.contentHeight = contentHeight;
    info.flag = flag;
    resized = true;
    this.getCallback().apply(this.getScope(), this.getArgs());
  }
  return resized;
}, refresh:function(force) {
  if (this.refreshSize() || force) {
    Ext.TaskQueue.requestWrite('refreshMonitors', this);
  }
}, destroy:function() {
  var element = this.getElement();
  this.bindListeners(false);
  if (element && !element.isDestroyed) {
    element.removeCls('x-size-monitored');
  }
  delete this._element;
  this.callSuper();
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Templatable.prototype.mixinId || Ext.mixin.Templatable.$className, Ext.mixin.Templatable]], [Ext.util.sizemonitor, 'Abstract'], 0);
Ext.cmd.derive('Ext.util.sizemonitor.Default', Ext.util.sizemonitor.Abstract, {updateElement:function(element) {
}, bindListeners:function(bind) {
  var element = this.getElement().dom;
  if (!element) {
    return;
  }
  if (bind) {
    element.onresize = this.refresh;
  } else {
    delete element.onresize;
  }
}, getContentBounds:function() {
  return this.getElement().dom.getBoundingClientRect();
}, getContentWidth:function() {
  return this.getElement().getWidth();
}, getContentHeight:function() {
  return this.getElement().getHeight();
}}, 0, 0, 0, 0, 0, 0, [Ext.util.sizemonitor, 'Default'], 0);
Ext.cmd.derive('Ext.util.sizemonitor.Scroll', Ext.util.sizemonitor.Abstract, {getElementConfig:function() {
  return {reference:'detectorsContainer', classList:['x-size-monitors', 'scroll'], children:[{reference:'expandMonitor', className:'expand'}, {reference:'shrinkMonitor', className:'shrink'}]};
}, constructor:function(config) {
  this.onScroll = Ext.Function.bind(this.onScroll, this);
  Ext.util.sizemonitor.Abstract.prototype.constructor.apply(this, arguments);
}, bindListeners:function(bind) {
  var method = bind ? 'addEventListener' : 'removeEventListener';
  this.expandMonitor[method]('scroll', this.onScroll, true);
  this.shrinkMonitor[method]('scroll', this.onScroll, true);
}, forceRefresh:function() {
  Ext.TaskQueue.requestRead('refresh', this, [true]);
}, onScroll:function() {
  Ext.TaskQueue.requestRead('refresh', this);
}, refreshMonitors:function() {
  var expandMonitor = this.expandMonitor, shrinkMonitor = this.shrinkMonitor, end = 1000000;
  if (expandMonitor && !expandMonitor.isDestroyed) {
    expandMonitor.scrollLeft = end;
    expandMonitor.scrollTop = end;
  }
  if (shrinkMonitor && !shrinkMonitor.isDestroyed) {
    shrinkMonitor.scrollLeft = end;
    shrinkMonitor.scrollTop = end;
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.util.sizemonitor, 'Scroll'], 0);
Ext.cmd.derive('Ext.util.sizemonitor.OverflowChange', Ext.util.sizemonitor.Abstract, {constructor:function(config) {
  this.onExpand = Ext.Function.bind(this.onExpand, this);
  this.onShrink = Ext.Function.bind(this.onShrink, this);
  Ext.util.sizemonitor.Abstract.prototype.constructor.apply(this, arguments);
}, getElementConfig:function() {
  return {reference:'detectorsContainer', classList:['x-size-monitors', 'overflowchanged'], children:[{reference:'expandMonitor', className:'expand', children:[{reference:'expandHelper'}]}, {reference:'shrinkMonitor', className:'shrink', children:[{reference:'shrinkHelper'}]}]};
}, bindListeners:function(bind) {
  var method = bind ? 'addEventListener' : 'removeEventListener';
  this.expandMonitor[method](Ext.browser.is.Firefox ? 'underflow' : 'overflowchanged', this.onExpand, true);
  this.shrinkMonitor[method](Ext.browser.is.Firefox ? 'overflow' : 'overflowchanged', this.onShrink, true);
}, onExpand:function(e) {
  if (Ext.browser.is.Webkit && e.horizontalOverflow && e.verticalOverflow) {
    return;
  }
  Ext.TaskQueue.requestRead('refresh', this);
}, onShrink:function(e) {
  if (Ext.browser.is.Webkit && !e.horizontalOverflow && !e.verticalOverflow) {
    return;
  }
  Ext.TaskQueue.requestRead('refresh', this);
}, refreshMonitors:function() {
  if (this.isDestroyed) {
    return;
  }
  var expandHelper = this.expandHelper, shrinkHelper = this.shrinkHelper, contentBounds = this.getContentBounds(), width = contentBounds.width, height = contentBounds.height, style;
  if (expandHelper && !expandHelper.isDestroyed) {
    style = expandHelper.style;
    style.width = width + 1 + 'px';
    style.height = height + 1 + 'px';
  }
  if (shrinkHelper && !shrinkHelper.isDestroyed) {
    style = shrinkHelper.style;
    style.width = width + 'px';
    style.height = height + 'px';
  }
  Ext.TaskQueue.requestRead('refresh', this);
}}, 1, 0, 0, 0, 0, 0, [Ext.util.sizemonitor, 'OverflowChange'], 0);
Ext.cmd.derive('Ext.util.SizeMonitor', Ext.Base, {constructor:function(config) {
  var namespace = Ext.util.sizemonitor;
  if (Ext.browser.is.Firefox) {
    return new namespace.OverflowChange(config);
  } else {
    if (Ext.browser.is.WebKit || Ext.browser.is.IE11) {
      return new namespace.Scroll(config);
    } else {
      return new namespace.Default(config);
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.util, 'SizeMonitor'], 0);
Ext.define('Xedu.override.SizeMonitor', {override:'Ext.util.SizeMonitor', constructor:function(config) {
  var namespace = Ext.util.sizemonitor;
  if (Ext.browser.is.Firefox) {
    return new namespace.OverflowChange(config);
  } else {
    if (Ext.browser.is.WebKit) {
      if (!Ext.browser.is.Silk && Ext.browser.engineVersion.gtEq('535') && !Ext.browser.engineVersion.ltEq('537.36')) {
        return new namespace.OverflowChange(config);
      } else {
        return new namespace.Scroll(config);
      }
    } else {
      if (Ext.browser.is.IE11) {
        return new namespace.Scroll(config);
      } else {
        return new namespace.Scroll(config);
      }
    }
  }
}});
Ext.cmd.derive('Ext.event.publisher.ElementSize', Ext.event.publisher.Publisher, {targetType:'element', handledEvents:['resize'], constructor:function() {
  this.monitors = {};
  Ext.event.publisher.Publisher.prototype.constructor.apply(this, arguments);
}, subscribe:function(target) {
  var match = target.match(this.idSelectorRegex), subscribers = this.subscribers, id, element, sizeMonitor;
  if (!match) {
    return false;
  }
  id = match[1];
  if (subscribers.hasOwnProperty(id)) {
    subscribers[id]++;
    return true;
  }
  subscribers[id] = 1;
  element = Ext.get(id);
  this.monitors[id] = sizeMonitor = new Ext.util.SizeMonitor({element:element, callback:this.onElementResize, scope:this, args:[target, element]});
  this.dispatcher.addListener('element', target, 'painted', 'forceRefresh', sizeMonitor);
  return true;
}, unsubscribe:function(target, eventName, all) {
  var match = target.match(this.idSelectorRegex), subscribers = this.subscribers, monitors = this.monitors, id, sizeMonitor;
  if (!match) {
    return false;
  }
  id = match[1];
  if (!subscribers.hasOwnProperty(id) || !all && --subscribers[id] > 0) {
    return true;
  }
  delete subscribers[id];
  sizeMonitor = monitors[id];
  this.dispatcher.removeListener('element', target, 'painted', 'forceRefresh', sizeMonitor);
  sizeMonitor.destroy();
  delete monitors[id];
  return true;
}, onElementResize:function(target, element, info) {
  Ext.TaskQueue.requestRead('dispatch', this, [target, 'resize', [element, info]]);
}}, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, 'ElementSize'], 0);
Ext.cmd.derive('Ext.event.publisher.TouchGesture', Ext.event.publisher.Dom, {isNotPreventable:/^(select|a)$/i, handledEvents:['touchstart', 'touchmove', 'touchend', 'touchcancel'], mouseToTouchMap:{mousedown:'touchstart', mousemove:'touchmove', mouseup:'touchend'}, lastEventType:null, config:{moveThrottle:0, recognizers:{}}, constructor:function(config) {
  var me = this;
  this.eventProcessors = {touchstart:this.onTouchStart, touchmove:this.onTouchMove, touchend:this.onTouchEnd, touchcancel:this.onTouchEnd};
  this.eventToRecognizerMap = {};
  this.activeRecognizers = [];
  this.touchesMap = {};
  this.currentIdentifiers = [];
  if (Ext.browser.is.Chrome && Ext.os.is.Android) {
    this.screenPositionRatio = Ext.browser.version.gt('18') ? 1 : 1 / window.devicePixelRatio;
  } else {
    if (Ext.browser.is.AndroidStock4) {
      this.screenPositionRatio = 1;
    } else {
      if (Ext.os.is.BlackBerry) {
        this.screenPositionRatio = 1 / window.devicePixelRatio;
      } else {
        if (Ext.browser.engineName == 'WebKit' && Ext.os.is.Desktop) {
          this.screenPositionRatio = 1;
        } else {
          this.screenPositionRatio = window.innerWidth / window.screen.width;
        }
      }
    }
  }
  this.initConfig(config);
  if (Ext.feature.has.Touch) {
    me.onTargetTouchMove = me.onTargetTouchMove.bind(me);
    me.onTargetTouchEnd = me.onTargetTouchEnd.bind(me);
  }
  return Ext.event.publisher.Dom.prototype.constructor.call(this);
}, applyRecognizers:function(recognizers) {
  var i, recognizer;
  for (i in recognizers) {
    if (recognizers.hasOwnProperty(i)) {
      recognizer = recognizers[i];
      if (recognizer) {
        this.registerRecognizer(recognizer);
      }
    }
  }
  return recognizers;
}, handles:function(eventName) {
  return Ext.event.publisher.Dom.prototype.handles.apply(this, arguments) || this.eventToRecognizerMap.hasOwnProperty(eventName);
}, doesEventBubble:function() {
  return true;
}, onEvent:function(e) {
  var type = e.type, lastEventType = this.lastEventType, touchList = [e];
  if (this.eventProcessors[type]) {
    this.eventProcessors[type].call(this, e);
    return;
  }
  if ('button' in e && e.button > 0) {
    return;
  } else {
    if (type === 'mousedown' && lastEventType && lastEventType !== 'mouseup') {
      var fixedEvent = document.createEvent('MouseEvent');
      fixedEvent.initMouseEvent('mouseup', e.bubbles, e.cancelable, document.defaultView, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.metaKey, e.button, e.relatedTarget);
      this.onEvent(fixedEvent);
    }
    if (type !== 'mousemove') {
      this.lastEventType = type;
    }
    e.identifier = 1;
    e.touches = type !== 'mouseup' ? touchList : [];
    e.targetTouches = type !== 'mouseup' ? touchList : [];
    e.changedTouches = touchList;
    this.eventProcessors[this.mouseToTouchMap[type]].call(this, e);
  }
}, registerRecognizer:function(recognizer) {
  var map = this.eventToRecognizerMap, activeRecognizers = this.activeRecognizers, handledEvents = recognizer.getHandledEvents(), i, ln, eventName;
  recognizer.setOnRecognized(this.onRecognized);
  recognizer.setCallbackScope(this);
  for (i = 0, ln = handledEvents.length; i < ln; i++) {
    eventName = handledEvents[i];
    map[eventName] = recognizer;
  }
  activeRecognizers.push(recognizer);
  return this;
}, onRecognized:function(eventName, e, touches, info) {
  var targetGroups = [], ln = touches.length, targets, i, touch;
  if (ln === 1) {
    return this.publish(eventName, touches[0].targets, e, info);
  }
  for (i = 0; i < ln; i++) {
    touch = touches[i];
    targetGroups.push(touch.targets);
  }
  targets = this.getCommonTargets(targetGroups);
  this.publish(eventName, targets, e, info);
}, publish:function(eventName, targets, event, info) {
  event.set(info);
  return Ext.event.publisher.Dom.prototype.publish.call(this, eventName, targets, event);
}, getCommonTargets:function(targetGroups) {
  var firstTargetGroup = targetGroups[0], ln = targetGroups.length;
  if (ln === 1) {
    return firstTargetGroup;
  }
  var commonTargets = [], i = 1, target, targets, j;
  while (true) {
    target = firstTargetGroup[firstTargetGroup.length - i];
    if (!target) {
      return commonTargets;
    }
    for (j = 1; j < ln; j++) {
      targets = targetGroups[j];
      if (targets[targets.length - i] !== target) {
        return commonTargets;
      }
    }
    commonTargets.unshift(target);
    i++;
  }
  return commonTargets;
}, invokeRecognizers:function(methodName, e) {
  var recognizers = this.activeRecognizers, ln = recognizers.length, i, recognizer;
  if (methodName === 'onStart') {
    for (i = 0; i < ln; i++) {
      recognizers[i].isActive = true;
    }
  }
  for (i = 0; i < ln; i++) {
    recognizer = recognizers[i];
    if (recognizer.isActive && recognizer[methodName].call(recognizer, e) === false) {
      recognizer.isActive = false;
    }
  }
}, getActiveRecognizers:function() {
  return this.activeRecognizers;
}, updateTouch:function(touch) {
  var identifier = touch.identifier, currentTouch = this.touchesMap[identifier], target, x, y;
  if (!currentTouch) {
    target = this.getElementTarget(touch.target);
    this.touchesMap[identifier] = currentTouch = {identifier:identifier, target:target, targets:this.getBubblingTargets(target)};
    this.currentIdentifiers.push(identifier);
  }
  x = touch.pageX;
  y = touch.pageY;
  if (x === currentTouch.pageX && y === currentTouch.pageY) {
    return false;
  }
  currentTouch.pageX = x;
  currentTouch.pageY = y;
  currentTouch.timeStamp = touch.timeStamp;
  currentTouch.point = new Ext.util.Point(x, y);
  return currentTouch;
}, updateTouches:function(touches) {
  var i, ln, touch, changedTouches = [];
  for (i = 0, ln = touches.length; i < ln; i++) {
    touch = this.updateTouch(touches[i]);
    if (touch) {
      changedTouches.push(touch);
    }
  }
  return changedTouches;
}, syncTouches:function(touches) {
  var touchIDs = [], len = touches.length, i, id, touch, ghostTouches;
  for (i = 0; i < len; i++) {
    touch = touches[i];
    touchIDs.push(touch.identifier);
  }
  ghostTouches = Ext.Array.difference(this.currentIdentifiers, touchIDs);
  len = ghostTouches.length;
  for (i = 0; i < len; i++) {
    id = ghostTouches[i];
    Ext.Array.remove(this.currentIdentifiers, id);
    delete this.touchesMap[id];
  }
}, factoryEvent:function(e) {
  return new Ext.event.Touch(e, null, this.touchesMap, this.currentIdentifiers);
}, onTouchStart:function(e) {
  var changedTouches = e.changedTouches, target = e.target, touches = e.touches, ln = changedTouches.length, isNotPreventable = this.isNotPreventable, isTouch = e.type === 'touchstart', me = this, i, touch, parent;
  if (touches && touches.length < this.currentIdentifiers.length + 1) {
    this.syncTouches(touches);
  }
  this.updateTouches(changedTouches);
  e = this.factoryEvent(e);
  changedTouches = e.changedTouches;
  if (Ext.browser.is.AndroidStock && this.currentIdentifiers.length >= 2) {
    e.preventDefault();
  }
  if (isTouch) {
    target.addEventListener('touchmove', me.onTargetTouchMove);
    target.addEventListener('touchend', me.onTargetTouchEnd);
    target.addEventListener('touchcancel', me.onTargetTouchEnd);
  }
  for (i = 0; i < ln; i++) {
    touch = changedTouches[i];
    this.publish('touchstart', touch.targets, e, {touch:touch});
  }
  if (!this.isStarted) {
    this.isStarted = true;
    this.invokeRecognizers('onStart', e);
  }
  this.invokeRecognizers('onTouchStart', e);
  parent = target.parentNode || {};
}, onTouchMove:function(e) {
  if (!this.isStarted) {
    return;
  }
  if (!this.animationQueued) {
    this.animationQueued = true;
    Ext.AnimationQueue.start('onAnimationFrame', this);
  }
  this.lastMoveEvent = e;
}, onAnimationFrame:function() {
  var event = this.lastMoveEvent;
  if (event) {
    this.lastMoveEvent = null;
    this.doTouchMove(event);
  }
}, doTouchMove:function(e) {
  var changedTouches, i, ln, touch;
  changedTouches = this.updateTouches(e.changedTouches);
  ln = changedTouches.length;
  e = this.factoryEvent(e);
  for (i = 0; i < ln; i++) {
    touch = changedTouches[i];
    this.publish('touchmove', touch.targets, e, {touch:touch});
  }
  if (ln > 0) {
    this.invokeRecognizers('onTouchMove', e);
  }
}, onTouchEnd:function(e) {
  if (!this.isStarted) {
    return;
  }
  if (this.lastMoveEvent) {
    this.onAnimationFrame();
  }
  var touchesMap = this.touchesMap, currentIdentifiers = this.currentIdentifiers, changedTouches = e.changedTouches, ln = changedTouches.length, identifier, i, touch;
  this.updateTouches(changedTouches);
  changedTouches = e.changedTouches;
  for (i = 0; i < ln; i++) {
    Ext.Array.remove(currentIdentifiers, changedTouches[i].identifier);
  }
  e = this.factoryEvent(e);
  for (i = 0; i < ln; i++) {
    identifier = changedTouches[i].identifier;
    touch = touchesMap[identifier];
    delete touchesMap[identifier];
    this.publish('touchend', touch.targets, e, {touch:touch});
  }
  this.invokeRecognizers('onTouchEnd', e);
  if (e.touches && e.touches.length === 0 && currentIdentifiers.length) {
    currentIdentifiers.length = 0;
    this.touchesMap = {};
  }
  if (currentIdentifiers.length === 0) {
    this.isStarted = false;
    this.invokeRecognizers('onEnd', e);
    if (this.animationQueued) {
      this.animationQueued = false;
      Ext.AnimationQueue.stop('onAnimationFrame', this);
    }
  }
}, onTargetTouchMove:function(e) {
  if (!Ext.getBody().contains(e.target)) {
    this.onTouchMove(e);
  }
}, onTargetTouchEnd:function(e) {
  var me = this, target = e.target, touchCount = 0, touchTarget;
  for (identifier in this.touchesMap) {
    touchTarget = this.touchesMap[identifier].target;
    if (touchTarget === target) {
      touchCount++;
    }
  }
  if (touchCount <= 1) {
    target.removeEventListener('touchmove', me.onTargetTouchMove);
    target.removeEventListener('touchend', me.onTargetTouchEnd);
    target.removeEventListener('touchcancel', me.onTargetTouchEnd);
  }
  if (!Ext.getBody().contains(target)) {
    me.onTouchEnd(e);
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.event.publisher, 'TouchGesture'], function() {
  if (Ext.feature.has.Pointer) {
    this.override({pointerToTouchMap:{MSPointerDown:'touchstart', MSPointerMove:'touchmove', MSPointerUp:'touchend', MSPointerCancel:'touchcancel', pointerdown:'touchstart', pointermove:'touchmove', pointerup:'touchend', pointercancel:'touchcancel'}, touchToPointerMap:{touchstart:'MSPointerDown', touchmove:'MSPointerMove', touchend:'MSPointerUp', touchcancel:'MSPointerCancel'}, attachListener:function(eventName, doc) {
      eventName = this.touchToPointerMap[eventName];
      if (!eventName) {
        return;
      }
      return this.callOverridden([eventName, doc]);
    }, onEvent:function(e) {
      var type = e.type;
      if (this.currentIdentifiers.length === 0 && (e.pointerType === e.MSPOINTER_TYPE_TOUCH || e.pointerType === 'touch') && (type === 'MSPointerMove' || type === 'pointermove')) {
        type = 'MSPointerDown';
      }
      if ('button' in e && e.button > 0) {
        return;
      }
      type = this.pointerToTouchMap[type];
      e.identifier = e.pointerId;
      e.changedTouches = [e];
      this.eventProcessors[type].call(this, e);
    }});
  } else {
    if (!Ext.browser.is.Ripple && (Ext.os.is.ChromeOS || !Ext.feature.has.Touch)) {
      this.override({handledEvents:['touchstart', 'touchmove', 'touchend', 'touchcancel', 'mousedown', 'mousemove', 'mouseup']});
    }
  }
});
Ext.cmd.derive('Ext.event.recognizer.Recognizer', Ext.Base, {handledEvents:[], config:{onRecognized:Ext.emptyFn, onFailed:Ext.emptyFn, callbackScope:null}, constructor:function(config) {
  this.initConfig(config);
  return this;
}, getHandledEvents:function() {
  return this.handledEvents;
}, onStart:Ext.emptyFn, onEnd:Ext.emptyFn, fail:function() {
  this.getOnFailed().apply(this.getCallbackScope(), arguments);
  return false;
}, fire:function() {
  this.getOnRecognized().apply(this.getCallbackScope(), arguments);
}}, 1, 0, 0, 0, 0, [[Ext.mixin.Identifiable.prototype.mixinId || Ext.mixin.Identifiable.$className, Ext.mixin.Identifiable]], [Ext.event.recognizer, 'Recognizer'], 0);
Ext.cmd.derive('Ext.event.recognizer.Touch', Ext.event.recognizer.Recognizer, {onTouchStart:Ext.emptyFn, onTouchMove:Ext.emptyFn, onTouchEnd:Ext.emptyFn}, 0, 0, 0, 0, 0, 0, [Ext.event.recognizer, 'Touch'], 0);
Ext.cmd.derive('Ext.event.recognizer.SingleTouch', Ext.event.recognizer.Touch, {inheritableStatics:{NOT_SINGLE_TOUCH:1, TOUCH_MOVED:2}, onTouchStart:function(e) {
  if (e.touches.length > 1) {
    return this.fail(this.self.NOT_SINGLE_TOUCH);
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.event.recognizer, 'SingleTouch'], 0);
Ext.cmd.derive('Ext.event.recognizer.DoubleTap', Ext.event.recognizer.SingleTouch, {inheritableStatics:{DIFFERENT_TARGET:3}, config:{maxDuration:300}, handledEvents:['singletap', 'doubletap'], singleTapTimer:null, startTime:0, lastTapTime:0, onTouchStart:function(e) {
  if (Ext.event.recognizer.SingleTouch.prototype.onTouchStart.apply(this, arguments) === false) {
    return false;
  }
  this.startTime = e.time;
  clearTimeout(this.singleTapTimer);
}, onTouchMove:function() {
  return this.fail(this.self.TOUCH_MOVED);
}, onEnd:function(e) {
  var me = this, maxDuration = this.getMaxDuration(), touch = e.changedTouches[0], time = e.time, target = e.target, lastTapTime = this.lastTapTime, lastTarget = this.lastTarget, duration;
  this.lastTapTime = time;
  this.lastTarget = target;
  if (lastTapTime) {
    duration = time - lastTapTime;
    if (duration <= maxDuration) {
      if (target !== lastTarget) {
        return this.fail(this.self.DIFFERENT_TARGET);
      }
      this.lastTarget = null;
      this.lastTapTime = 0;
      this.fire('doubletap', e, [touch], {touch:touch, duration:duration});
      return;
    }
  }
  if (time - this.startTime > maxDuration) {
    this.fireSingleTap(e, touch);
  } else {
    this.singleTapTimer = setTimeout(function() {
      me.fireSingleTap(e, touch);
    }, maxDuration);
  }
}, fireSingleTap:function(e, touch) {
  this.fire('singletap', e, [touch], {touch:touch});
}}, 0, 0, 0, 0, 0, 0, [Ext.event.recognizer, 'DoubleTap'], 0);
Ext.cmd.derive('Ext.event.recognizer.Drag', Ext.event.recognizer.SingleTouch, {isStarted:false, startPoint:null, previousPoint:null, lastPoint:null, handledEvents:['dragstart', 'drag', 'dragend'], config:{minDistance:8}, constructor:function() {
  Ext.event.recognizer.SingleTouch.prototype.constructor.apply(this, arguments);
  this.info = {touch:null, previous:{x:0, y:0}, x:0, y:0, delta:{x:0, y:0}, absDelta:{x:0, y:0}, flick:{velocity:{x:0, y:0}}, direction:{x:0, y:0}, time:0, previousTime:{x:0, y:0}};
}, onTouchStart:function(e) {
  if (Ext.event.recognizer.SingleTouch.prototype.onTouchStart.apply(this, arguments) === false) {
    if (this.isStarted && this.lastMoveEvent !== null) {
      this.lastMoveEvent.isStopped = false;
      this.onTouchEnd(this.lastMoveEvent);
    }
    return false;
  }
  this.startTime = e.time;
  this.startPoint = e.changedTouches[0].point;
}, tryDragStart:function(e) {
  var startPoint = this.startPoint, touches = e.changedTouches, touch = touches[0], point = touch.point, minDistance = this.getMinDistance(), info = this.info;
  if (Math.abs(point.getDistanceTo(startPoint)) >= minDistance) {
    this.isStarted = true;
    this.previousPoint = this.lastPoint = point;
    this.resetInfo('x', e, touch);
    this.resetInfo('y', e, touch);
    info.time = e.time;
    this.fire('dragstart', e, touches, info);
  }
}, onTouchMove:function(e) {
  if (!this.isStarted) {
    this.tryDragStart(e);
  }
  if (!this.isStarted) {
    return;
  }
  var touches = e.changedTouches, touch = touches[0], point = touch.point;
  if (this.lastPoint) {
    this.previousPoint = this.lastPoint;
  }
  this.lastPoint = point;
  this.lastMoveEvent = e;
  this.updateInfo('x', e, touch, true);
  this.updateInfo('y', e, touch, true);
  this.info.time = e.time;
  this.fire('drag', e, touches, this.info);
}, onAxisDragEnd:function(axis, info) {
  var duration = info.time - info.previousTime[axis];
  if (duration > 0) {
    info.flick.velocity[axis] = (info[axis] - info.previous[axis]) / duration;
  }
}, resetInfo:function(axis, e, touch) {
  var value = this.lastPoint[axis], startValue = this.startPoint[axis], delta = value - startValue, capAxis = axis.toUpperCase(), info = this.info;
  info.touch = touch;
  info.delta[axis] = delta;
  info.absDelta[axis] = Math.abs(delta);
  info.previousTime[axis] = this.startTime;
  info.previous[axis] = startValue;
  info[axis] = value;
  info.direction[axis] = 0;
  info['start' + capAxis] = this.startPoint[axis];
  info['previous' + capAxis] = info.previous[axis];
  info['page' + capAxis] = info[axis];
  info['delta' + capAxis] = info.delta[axis];
  info['absDelta' + capAxis] = info.absDelta[axis];
  info['previousDelta' + capAxis] = 0;
  info.startTime = this.startTime;
}, updateInfo:function(axis, e, touch, updatePrevious) {
  var time = e.time, value = this.lastPoint[axis], previousValue = this.previousPoint[axis], startValue = this.startPoint[axis], delta = value - startValue, info = this.info, direction = info.direction, capAxis = axis.toUpperCase(), previousFlick = info.previous[axis], previousDelta;
  info.touch = touch;
  previousDelta = info.delta[axis];
  info.delta[axis] = delta;
  info.absDelta[axis] = Math.abs(delta);
  if (updatePrevious && value !== previousFlick && value !== info[axis] && time - info.previousTime[axis] >= 50) {
    info.previous[axis] = info[axis];
    info.previousTime[axis] = info.time;
  }
  info[axis] = value;
  if (value > previousValue) {
    direction[axis] = 1;
  } else {
    if (value < previousValue) {
      direction[axis] = -1;
    }
  }
  info['start' + capAxis] = this.startPoint[axis];
  info['previous' + capAxis] = info.previous[axis];
  info['page' + capAxis] = info[axis];
  info['delta' + capAxis] = info.delta[axis];
  info['absDelta' + capAxis] = info.absDelta[axis];
  info['previousDelta' + capAxis] = previousDelta;
  info.startTime = this.startTime;
}, onTouchEnd:function(e) {
  if (!this.isStarted) {
    this.tryDragStart(e);
  }
  if (this.isStarted) {
    var touches = e.changedTouches, touch = touches[0], point = touch.point, info = this.info;
    this.isStarted = false;
    this.lastPoint = point;
    this.updateInfo('x', e, touch);
    this.updateInfo('y', e, touch);
    info.time = e.time;
    this.onAxisDragEnd('x', info);
    this.onAxisDragEnd('y', info);
    this.fire('dragend', e, touches, info);
    this.startPoint = null;
    this.previousPoint = null;
    this.lastPoint = null;
    this.lastMoveEvent = null;
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.event.recognizer, 'Drag'], 0);
Ext.cmd.derive('Ext.event.recognizer.Swipe', Ext.event.recognizer.SingleTouch, {handledEvents:['swipestart', 'swipe'], inheritableStatics:{MAX_OFFSET_EXCEEDED:16, MAX_DURATION_EXCEEDED:17, DISTANCE_NOT_ENOUGH:18}, config:{minDistance:80, maxOffset:35, maxDuration:1000}, onTouchStart:function(e) {
  if (Ext.event.recognizer.SingleTouch.prototype.onTouchStart.apply(this, arguments) === false) {
    return false;
  }
  var touch = e.changedTouches[0];
  this.startTime = e.time;
  this.isHorizontal = true;
  this.isVertical = true;
  this.startX = touch.pageX;
  this.startY = touch.pageY;
}, onTouchMove:function(e) {
  var touch = e.changedTouches[0], x = touch.pageX, y = touch.pageY, deltaX = x - this.startX, deltaY = y - this.startY, absDeltaX = Math.abs(x - this.startX), absDeltaY = Math.abs(y - this.startY), duration = e.time - this.startTime, minDistance = this.getMinDistance(), time = e.time, direction, distance;
  if (time - this.startTime > this.getMaxDuration()) {
    return this.fail(this.self.MAX_DURATION_EXCEEDED);
  }
  if (this.isHorizontal && absDeltaY > this.getMaxOffset()) {
    this.isHorizontal = false;
  }
  if (this.isVertical && absDeltaX > this.getMaxOffset()) {
    this.isVertical = false;
  }
  if (!this.isVertical || !this.isHorizontal) {
    if (this.isHorizontal && absDeltaX < minDistance) {
      direction = deltaX < 0 ? 'left' : 'right';
      distance = absDeltaX;
    } else {
      if (this.isVertical && absDeltaY < minDistance) {
        direction = deltaY < 0 ? 'up' : 'down';
        distance = absDeltaY;
      }
    }
  }
  if (direction && !this.started) {
    this.started = true;
    this.fire('swipestart', e, [touch], {touch:touch, direction:direction, distance:distance, duration:duration});
  }
  if (!this.isHorizontal && !this.isVertical) {
    return this.fail(this.self.MAX_OFFSET_EXCEEDED);
  }
}, onTouchEnd:function(e) {
  if (this.onTouchMove(e) === false) {
    return false;
  }
  var touch = e.changedTouches[0], x = touch.pageX, y = touch.pageY, deltaX = x - this.startX, deltaY = y - this.startY, absDeltaX = Math.abs(deltaX), absDeltaY = Math.abs(deltaY), minDistance = this.getMinDistance(), duration = e.time - this.startTime, direction, distance;
  if (this.isVertical && absDeltaY < minDistance) {
    this.isVertical = false;
  }
  if (this.isHorizontal && absDeltaX < minDistance) {
    this.isHorizontal = false;
  }
  if (this.isHorizontal) {
    direction = deltaX < 0 ? 'left' : 'right';
    distance = absDeltaX;
  } else {
    if (this.isVertical) {
      direction = deltaY < 0 ? 'up' : 'down';
      distance = absDeltaY;
    } else {
      return this.fail(this.self.DISTANCE_NOT_ENOUGH);
    }
  }
  this.started = false;
  this.fire('swipe', e, [touch], {touch:touch, direction:direction, distance:distance, duration:duration});
}}, 0, 0, 0, 0, 0, 0, [Ext.event.recognizer, 'Swipe'], 0);
Ext.cmd.derive('Ext.event.recognizer.EdgeSwipe', Ext.event.recognizer.Swipe, {handledEvents:['edgeswipe', 'edgeswipestart', 'edgeswipeend'], inheritableStatics:{NOT_NEAR_EDGE:19}, config:{minDistance:60}, onTouchStart:function(e) {
  if (Ext.event.recognizer.Swipe.prototype.onTouchStart.apply(this, arguments) === false) {
    return false;
  }
  var touch = e.changedTouches[0];
  this.started = false;
  this.direction = null;
  this.isHorizontal = true;
  this.isVertical = true;
  this.startX = touch.pageX;
  this.startY = touch.pageY;
}, onTouchMove:function(e) {
  var touch = e.changedTouches[0], x = touch.pageX, y = touch.pageY, deltaX = x - this.startX, deltaY = y - this.startY, absDeltaY = Math.abs(y - this.startY), absDeltaX = Math.abs(x - this.startX), minDistance = this.getMinDistance(), maxOffset = this.getMaxOffset(), duration = e.time - this.startTime, elementWidth = Ext.Viewport && Ext.Viewport.element.getWidth(), elementHeight = Ext.Viewport && Ext.Viewport.element.getHeight(), direction, distance;
  if (this.isVertical && absDeltaX > maxOffset) {
    this.isVertical = false;
  }
  if (this.isHorizontal && absDeltaY > maxOffset) {
    this.isHorizontal = false;
  }
  if (this.isVertical && this.isHorizontal) {
    if (absDeltaY > absDeltaX) {
      this.isHorizontal = false;
    } else {
      this.isVertical = false;
    }
  }
  if (this.isHorizontal) {
    direction = deltaX < 0 ? 'left' : 'right';
    distance = deltaX;
  } else {
    if (this.isVertical) {
      direction = deltaY < 0 ? 'up' : 'down';
      distance = deltaY;
    }
  }
  this.direction = this.direction || direction;
  if (this.direction == 'up') {
    distance = deltaY * -1;
  } else {
    if (this.direction == 'left') {
      distance = deltaX * -1;
    }
  }
  this.distance = distance;
  if (distance == 0) {
    return this.fail(this.self.DISTANCE_NOT_ENOUGH);
  }
  if (!this.started) {
    if (this.direction == 'right' && this.startX > minDistance) {
      return this.fail(this.self.NOT_NEAR_EDGE);
    } else {
      if (this.direction == 'down' && this.startY > minDistance) {
        return this.fail(this.self.NOT_NEAR_EDGE);
      } else {
        if (this.direction == 'left' && elementWidth - this.startX > minDistance) {
          return this.fail(this.self.NOT_NEAR_EDGE);
        } else {
          if (this.direction == 'up' && elementHeight - this.startY > minDistance) {
            return this.fail(this.self.NOT_NEAR_EDGE);
          }
        }
      }
    }
    this.started = true;
    this.startTime = e.time;
    this.fire('edgeswipestart', e, [touch], {touch:touch, direction:this.direction, distance:this.distance, duration:duration});
  } else {
    this.fire('edgeswipe', e, [touch], {touch:touch, direction:this.direction, distance:this.distance, duration:duration});
  }
}, onTouchEnd:function(e) {
  if (this.onTouchMove(e) !== false) {
    var touch = e.changedTouches[0], duration = e.time - this.startTime;
    this.fire('edgeswipeend', e, [touch], {touch:touch, direction:this.direction, distance:this.distance, duration:duration});
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.event.recognizer, 'EdgeSwipe'], 0);
Ext.cmd.derive('Ext.event.recognizer.LongPress', Ext.event.recognizer.SingleTouch, {inheritableStatics:{DURATION_NOT_ENOUGH:32}, config:{minDuration:1000}, handledEvents:['longpress'], fireLongPress:function(e) {
  var touch = e.changedTouches[0];
  this.fire('longpress', e, [touch], {touch:touch, duration:this.getMinDuration()});
  this.isLongPress = true;
}, onTouchStart:function(e) {
  var me = this;
  if (Ext.event.recognizer.SingleTouch.prototype.onTouchStart.apply(this, arguments) === false) {
    return false;
  }
  this.isLongPress = false;
  this.timer = setTimeout(function() {
    me.fireLongPress(e);
  }, this.getMinDuration());
}, onTouchMove:function() {
  return this.fail(this.self.TOUCH_MOVED);
}, onTouchEnd:function() {
  if (!this.isLongPress) {
    return this.fail(this.self.DURATION_NOT_ENOUGH);
  }
}, fail:function() {
  clearTimeout(this.timer);
  return Ext.event.recognizer.SingleTouch.prototype.fail.apply(this, arguments);
}}, 0, 0, 0, 0, 0, 0, [Ext.event.recognizer, 'LongPress'], function() {
  this.override({handledEvents:['longpress', 'taphold'], fire:function(eventName) {
    if (eventName === 'longpress') {
      var args = Array.prototype.slice.call(arguments);
      args[0] = 'taphold';
      this.fire.apply(this, args);
    }
    return this.callOverridden(arguments);
  }});
});
Ext.cmd.derive('Ext.event.recognizer.MultiTouch', Ext.event.recognizer.Touch, {requiredTouchesCount:2, isTracking:false, isStarted:false, onTouchStart:function(e) {
  var requiredTouchesCount = this.requiredTouchesCount, touches = e.touches, touchesCount = touches.length;
  if (touchesCount === requiredTouchesCount) {
    this.start(e);
  } else {
    if (touchesCount > requiredTouchesCount) {
      this.end(e);
    }
  }
}, onTouchEnd:function(e) {
  this.end(e);
}, start:function() {
  if (!this.isTracking) {
    this.isTracking = true;
    this.isStarted = false;
  }
}, end:function(e) {
  if (this.isTracking) {
    this.isTracking = false;
    if (this.isStarted) {
      this.isStarted = false;
      this.fireEnd(e);
    }
  }
}}, 0, 0, 0, 0, 0, 0, [Ext.event.recognizer, 'MultiTouch'], 0);
Ext.cmd.derive('Ext.event.recognizer.Pinch', Ext.event.recognizer.MultiTouch, {requiredTouchesCount:2, handledEvents:['pinchstart', 'pinch', 'pinchend'], startDistance:0, lastTouches:null, onTouchMove:function(e) {
  if (!this.isTracking) {
    return;
  }
  var touches = Array.prototype.slice.call(e.touches), firstPoint, secondPoint, distance;
  firstPoint = touches[0].point;
  secondPoint = touches[1].point;
  distance = firstPoint.getDistanceTo(secondPoint);
  if (distance === 0) {
    return;
  }
  if (!this.isStarted) {
    this.isStarted = true;
    this.startDistance = distance;
    this.fire('pinchstart', e, touches, {touches:touches, distance:distance, scale:1});
  } else {
    this.fire('pinch', e, touches, {touches:touches, distance:distance, scale:distance / this.startDistance});
  }
  this.lastTouches = touches;
}, fireEnd:function(e) {
  this.fire('pinchend', e, this.lastTouches);
}, fail:function() {
  return Ext.event.recognizer.MultiTouch.prototype.fail.apply(this, arguments);
}}, 0, 0, 0, 0, 0, 0, [Ext.event.recognizer, 'Pinch'], 0);
Ext.cmd.derive('Ext.event.recognizer.Rotate', Ext.event.recognizer.MultiTouch, {requiredTouchesCount:2, handledEvents:['rotatestart', 'rotate', 'rotateend'], startAngle:0, lastTouches:null, lastAngle:null, onTouchMove:function(e) {
  if (!this.isTracking) {
    return;
  }
  var touches = Array.prototype.slice.call(e.touches), lastAngle = this.lastAngle, firstPoint, secondPoint, angle, nextAngle, previousAngle, diff;
  firstPoint = touches[0].point;
  secondPoint = touches[1].point;
  angle = firstPoint.getAngleTo(secondPoint);
  if (lastAngle !== null) {
    diff = Math.abs(lastAngle - angle);
    nextAngle = angle + 360;
    previousAngle = angle - 360;
    if (Math.abs(nextAngle - lastAngle) < diff) {
      angle = nextAngle;
    } else {
      if (Math.abs(previousAngle - lastAngle) < diff) {
        angle = previousAngle;
      }
    }
  }
  this.lastAngle = angle;
  if (!this.isStarted) {
    this.isStarted = true;
    this.startAngle = angle;
    this.fire('rotatestart', e, touches, {touches:touches, angle:angle, rotation:0});
  } else {
    this.fire('rotate', e, touches, {touches:touches, angle:angle, rotation:angle - this.startAngle});
  }
  this.lastTouches = touches;
}, fireEnd:function(e) {
  this.lastAngle = null;
  this.fire('rotateend', e, this.lastTouches);
}}, 0, 0, 0, 0, 0, 0, [Ext.event.recognizer, 'Rotate'], 0);
Ext.cmd.derive('Ext.event.recognizer.Tap', Ext.event.recognizer.SingleTouch, {handledEvents:['tap', 'tapcancel'], config:{moveDistance:8}, onTouchStart:function(e) {
  if (Ext.event.recognizer.SingleTouch.prototype.onTouchStart.apply(this, arguments) === false) {
    return false;
  }
  this.startPoint = e.changedTouches[0].point;
}, onTouchMove:function(e) {
  var touch = e.changedTouches[0], point = touch.point;
  if (Math.abs(point.getDistanceTo(this.startPoint)) >= this.getMoveDistance()) {
    this.fire('tapcancel', e, [touch], {touch:touch});
    return this.fail(this.self.TOUCH_MOVED);
  }
}, onTouchEnd:function(e) {
  var touch = e.changedTouches[0];
  this.fire('tap', e, [touch], {touch:touch});
}}, 0, 0, 0, 0, 0, 0, [Ext.event.recognizer, 'Tap'], 0);
Ext.cmd.derive('Ext.field.Checkbox', Ext.field.Field, {alternateClassName:'Ext.form.Checkbox', qsaLeftRe:/[\[]/g, qsaRightRe:/[\]]/g, isCheckbox:true, config:{ui:'checkbox', value:'', checked:false, tabIndex:-1, component:{xtype:'input', type:'checkbox', useMask:true, cls:'x-input-checkbox'}}, platformConfig:[{theme:['Windows', 'Blackberry', 'Blackberry103', 'Tizen'], labelAlign:'left'}], initialize:function() {
  var me = this, component = me.getComponent();
  Ext.field.Field.prototype.initialize.call(this);
  component.on({scope:me, order:'before', masktap:'onMaskTap'});
  component.doMaskTap = Ext.emptyFn;
  me.label.on({scope:me, tap:'onMaskTap'});
}, doInitValue:function() {
  var me = this, initialConfig = me.getInitialConfig();
  if (initialConfig.hasOwnProperty('value')) {
    me.originalState = initialConfig.value;
  }
  if (initialConfig.hasOwnProperty('checked')) {
    me.originalState = initialConfig.checked;
  }
  Ext.field.Field.prototype.doInitValue.apply(this, arguments);
}, updateInputType:function(newInputType) {
  var component = this.getComponent();
  if (component) {
    component.setType(newInputType);
  }
}, updateName:function(newName) {
  var component = this.getComponent();
  if (component) {
    component.setName(newName);
  }
}, getChecked:function() {
  this._checked = this.getComponent().getChecked();
  return this._checked;
}, getSubmitValue:function() {
  return this.getChecked() ? Ext.isEmpty(this._value) ? true : this._value : null;
}, setChecked:function(newChecked) {
  this.updateChecked(newChecked);
  this._checked = newChecked;
}, updateChecked:function(newChecked) {
  this.getComponent().setChecked(newChecked);
  if (this.initialized) {
    this.onChange();
  }
}, onMaskTap:function(component, e) {
  var me = this, dom = me.getComponent().input.dom;
  if (me.getDisabled()) {
    return false;
  }
  dom.checked = !dom.checked;
  me.onChange(e);
  return false;
}, onChange:function(e) {
  var me = this, oldChecked = me._checked, newChecked = me.getChecked();
  if (oldChecked != newChecked) {
    if (newChecked) {
      me.fireEvent('check', me, e);
    } else {
      me.fireEvent('uncheck', me, e);
    }
    me.fireEvent('change', me, newChecked, oldChecked);
  }
}, doChecked:Ext.emptyFn, doUnChecked:Ext.emptyFn, isChecked:function() {
  return this.getChecked();
}, check:function() {
  return this.setChecked(true);
}, uncheck:function() {
  return this.setChecked(false);
}, getSameGroupFields:function() {
  var me = this, component = me.up('formpanel') || me.up('fieldset'), name = me.getName(), replaceLeft = me.qsaLeftRe, replaceRight = me.qsaRightRe, baseCls = me.getBaseCls().split(' ').join('.'), components = [], elements, element, i, ln;
  if (!component) {
    component = Ext.Viewport;
  }
  name = name.replace(replaceLeft, '\\[');
  name = name.replace(replaceRight, '\\]');
  elements = Ext.query('[name\x3d' + name + ']', component.element.dom);
  ln = elements.length;
  for (i = 0; i < ln; i++) {
    element = elements[i];
    element = Ext.fly(element).up('.' + baseCls);
    if (element && element.id) {
      components.push(Ext.getCmp(element.id));
    }
  }
  return components;
}, getGroupValues:function() {
  var values = [];
  this.getSameGroupFields().forEach(function(field) {
    if (field.getChecked()) {
      values.push(field.getValue());
    }
  });
  return values;
}, setGroupValues:function(values) {
  this.getSameGroupFields().forEach(function(field) {
    field.setChecked(values.indexOf(field.getValue()) !== -1);
  });
  return this;
}, resetGroupValues:function() {
  this.getSameGroupFields().forEach(function(field) {
    field.setChecked(field.originalState);
  });
  return this;
}, reset:function() {
  this.setChecked(this.originalState);
  return this;
}}, 0, ['checkboxfield'], ['component', 'field', 'checkboxfield'], {'component':true, 'field':true, 'checkboxfield':true}, ['widget.checkboxfield'], 0, [Ext.field, 'Checkbox', Ext.form, 'Checkbox'], 0);
Ext.define('Ext.picker.Slot', {extend:Ext.dataview.DataView, xtype:'pickerslot', alternateClassName:'Ext.Picker.Slot', isSlot:true, config:{title:null, showTitle:true, cls:'x-picker-slot', name:null, value:null, flex:1, align:'left', displayField:'text', valueField:'value', itemTpl:null, scrollable:{direction:'vertical', indicators:false, momentumEasing:{minVelocity:2}, slotSnapEasing:{duration:100}}, verticallyCenterItems:true}, platformConfig:[{theme:['Windows'], title:'choose an item'}], constructor:function() {
  this.selectedIndex = 0;
  Ext.dataview.DataView.prototype.constructor.apply(this, arguments);
}, applyTitle:function(title) {
  if (title) {
    title = Ext.create('Ext.Component', {cls:'x-picker-slot-title', docked:'top', html:title});
  }
  return title;
}, updateTitle:function(newTitle, oldTitle) {
  if (newTitle) {
    this.add(newTitle);
    this.setupBar();
  }
  if (oldTitle) {
    this.remove(oldTitle);
  }
}, updateShowTitle:function(showTitle) {
  var title = this.getTitle(), mode = showTitle ? 'show' : 'hide';
  if (title) {
    title.on(mode, this.setupBar, this, {single:true, delay:50});
    title[showTitle ? 'show' : 'hide']();
  }
}, updateDisplayField:function(newDisplayField) {
  if (!this.config.itemTpl) {
    this.setItemTpl('\x3cdiv class\x3d"x-picker-item {cls} \x3ctpl if\x3d"extra"\x3ex-picker-invalid\x3c/tpl\x3e"\x3e{' + newDisplayField + '}\x3c/div\x3e');
  }
}, updateAlign:function(newAlign, oldAlign) {
  var element = this.element;
  element.addCls('x-picker-' + newAlign);
  element.removeCls('x-picker-' + oldAlign);
}, applyData:function(data) {
  var parsedData = [], ln = data && data.length, i, item, obj;
  if (data && Ext.isArray(data) && ln) {
    for (i = 0; i < ln; i++) {
      item = data[i];
      obj = {};
      if (Ext.isArray(item)) {
        obj[this.valueField] = item[0];
        obj[this.displayField] = item[1];
      } else {
        if (Ext.isString(item)) {
          obj[this.valueField] = item;
          obj[this.displayField] = item;
        } else {
          if (Ext.isObject(item)) {
            obj = item;
          }
        }
      }
      parsedData.push(obj);
    }
  }
  return data;
}, initialize:function() {
  Ext.dataview.DataView.prototype.initialize.call(this);
  var scroller = this.getScrollable().getScroller();
  this.on({scope:this, painted:'onPainted', itemtap:'doItemTap'});
  this.element.on({scope:this, touchstart:'onTouchStart', touchend:'onTouchEnd'});
  scroller.on({scope:this, scrollend:'onScrollEnd'});
}, onPainted:function() {
  this.setupBar();
}, getPicker:function() {
  if (!this.picker) {
    this.picker = this.getParent();
  }
  return this.picker;
}, setupBar:function() {
  if (!this.rendered) {
    return;
  }
  var element = this.element, innerElement = this.innerElement, picker = this.getPicker(), bar = picker.bar, value = this.getValue(), showTitle = this.getShowTitle(), title = this.getTitle(), scrollable = this.getScrollable(), scroller = scrollable.getScroller(), titleHeight = 0, barHeight, padding;
  barHeight = bar.dom.getBoundingClientRect().height;
  if (showTitle && title) {
    titleHeight = title.element.getHeight();
  }
  padding = Math.ceil((element.getHeight() - titleHeight - barHeight) / 2);
  if (this.getVerticallyCenterItems()) {
    innerElement.setStyle({padding:padding + 'px 0 ' + padding + 'px'});
  }
  scroller.refresh();
  scroller.setSlotSnapSize(barHeight);
  this.setValue(value);
}, doItemTap:function(list, index, item, e) {
  var me = this;
  me.selectedIndex = index;
  me.selectedNode = item;
  me.scrollToItem(item, true);
}, scrollToItem:function(item, animated) {
  var y = item.getY(), parentEl = item.parent(), parentY = parentEl.getY(), scrollView = this.getScrollable(), scroller = scrollView.getScroller(), difference;
  difference = y - parentY;
  scroller.scrollTo(0, difference, animated);
}, onTouchStart:function() {
  this.element.addCls('x-scrolling');
}, onTouchEnd:function() {
  this.element.removeCls('x-scrolling');
}, onScrollEnd:function(scroller, x, y) {
  var me = this, index = Math.round(y / me.picker.bar.dom.getBoundingClientRect().height), viewItems = me.getViewItems(), item = viewItems[index];
  if (item) {
    me.selectedIndex = index;
    me.selectedNode = item;
    me.fireEvent('slotpick', me, me.getValue(), me.selectedNode);
  }
}, getValue:function(useDom) {
  var store = this.getStore(), record, value;
  if (!store) {
    return;
  }
  if (!this.rendered || !useDom) {
    return this._value;
  }
  if (this._value === false) {
    return null;
  }
  record = store.getAt(this.selectedIndex);
  value = record ? record.get(this.getValueField()) : null;
  return value;
}, setValue:function(value) {
  return this.doSetValue(value);
}, setValueAnimated:function(value) {
  return this.doSetValue(value, true);
}, doSetValue:function(value, animated) {
  if (!this.rendered) {
    this._value = value;
    return;
  }
  var store = this.getStore(), viewItems = this.getViewItems(), valueField = this.getValueField(), index, item;
  index = store.findExact(valueField, value);
  if (index == -1) {
    index = 0;
  }
  item = Ext.get(viewItems[index]);
  this.selectedIndex = index;
  if (item) {
    this.scrollToItem(item, animated ? {duration:100} : false);
    this.select(this.selectedIndex);
  }
  this._value = value;
}});
Ext.define('Ext.picker.Picker', {extend:Ext.Sheet, alias:'widget.picker', alternateClassName:'Ext.Picker', isPicker:true, config:{baseCls:'x-picker', doneButton:true, cancelButton:true, useTitles:false, slots:null, value:null, height:220, layout:{type:'hbox', align:'stretch'}, centered:false, left:0, right:0, bottom:0, defaultType:'pickerslot', toolbarPosition:'top', toolbar:{xtype:'titlebar'}}, platformConfig:[{theme:['Windows'], height:'100%', toolbarPosition:'bottom', toolbar:{xtype:'toolbar', 
layout:{type:'hbox', pack:'center'}}, doneButton:{iconCls:'check2', ui:'round', text:''}, cancelButton:{iconCls:'delete', ui:'round', text:''}}, {theme:['CupertinoClassic'], toolbar:{ui:'black'}}, {theme:['MountainView'], toolbarPosition:'bottom', toolbar:{defaults:{flex:1}}}], initialize:function() {
  var me = this, clsPrefix = 'x-', innerElement = this.innerElement;
  this.mask = innerElement.createChild({cls:clsPrefix + 'picker-mask'});
  this.bar = this.mask.createChild({cls:clsPrefix + 'picker-bar'});
  me.on({scope:this, delegate:'pickerslot', slotpick:'onSlotPick'});
}, applyToolbar:function(config) {
  if (config === true) {
    config = {};
  }
  Ext.applyIf(config, {docked:this.getToolbarPosition()});
  return Ext.factory(config, 'Ext.TitleBar', this.getToolbar());
}, updateToolbar:function(newToolbar, oldToolbar) {
  if (newToolbar) {
    this.add(newToolbar);
  }
  if (oldToolbar) {
    this.remove(oldToolbar);
  }
}, applyDoneButton:function(config) {
  if (config) {
    if (Ext.isBoolean(config)) {
      config = {};
    }
    if (typeof config == 'string') {
      config = {text:config};
    }
    Ext.applyIf(config, {ui:'action', align:'right', text:'Done'});
  }
  return Ext.factory(config, 'Ext.Button', this.getDoneButton());
}, updateDoneButton:function(newDoneButton, oldDoneButton) {
  var toolbar = this.getToolbar();
  if (newDoneButton) {
    toolbar.add(newDoneButton);
    newDoneButton.on('tap', this.onDoneButtonTap, this);
  } else {
    if (oldDoneButton) {
      toolbar.remove(oldDoneButton);
    }
  }
}, applyCancelButton:function(config) {
  if (config) {
    if (Ext.isBoolean(config)) {
      config = {};
    }
    if (typeof config == 'string') {
      config = {text:config};
    }
    Ext.applyIf(config, {align:'left', text:'Cancel'});
  }
  return Ext.factory(config, 'Ext.Button', this.getCancelButton());
}, updateCancelButton:function(newCancelButton, oldCancelButton) {
  var toolbar = this.getToolbar();
  if (newCancelButton) {
    toolbar.add(newCancelButton);
    newCancelButton.on('tap', this.onCancelButtonTap, this);
  } else {
    if (oldCancelButton) {
      toolbar.remove(oldCancelButton);
    }
  }
}, updateUseTitles:function(useTitles) {
  var innerItems = this.getInnerItems(), ln = innerItems.length, cls = 'x-use-titles', i, innerItem;
  if (useTitles) {
    this.addCls(cls);
  } else {
    this.removeCls(cls);
  }
  for (i = 0; i < ln; i++) {
    innerItem = innerItems[i];
    if (innerItem.isSlot) {
      innerItem.setShowTitle(useTitles);
    }
  }
}, applySlots:function(slots) {
  if (slots) {
    var ln = slots.length, i;
    for (i = 0; i < ln; i++) {
      slots[i].picker = this;
    }
  }
  return slots;
}, updateSlots:function(newSlots) {
  var bcss = 'x-', innerItems;
  this.removeAll();
  if (newSlots) {
    this.add(newSlots);
  }
  innerItems = this.getInnerItems();
  if (innerItems.length > 0) {
    innerItems[0].addCls(bcss + 'first');
    innerItems[innerItems.length - 1].addCls(bcss + 'last');
  }
  this.updateUseTitles(this.getUseTitles());
}, onDoneButtonTap:function() {
  var oldValue = this._value, newValue = this.getValue(true);
  if (newValue != oldValue) {
    this.fireEvent('change', this, newValue);
  }
  this.hide();
  Ext.util.InputBlocker.unblockInputs();
}, onCancelButtonTap:function() {
  this.fireEvent('cancel', this);
  this.hide();
  Ext.util.InputBlocker.unblockInputs();
}, onSlotPick:function(slot) {
  this.fireEvent('pick', this, this.getValue(true), slot);
}, show:function() {
  if (this.getParent() === undefined) {
    Ext.Viewport.add(this);
  }
  Ext.Sheet.prototype.show.apply(this, arguments);
  if (!this.isHidden()) {
    this.setValue(this._value);
  }
  Ext.util.InputBlocker.blockInputs();
}, setValue:function(values, animated) {
  var me = this, slots = me.getInnerItems(), ln = slots.length, key, slot, loopSlot, i, value;
  if (!values) {
    values = {};
    for (i = 0; i < ln; i++) {
      values[slots[i].config.name] = null;
    }
  }
  for (key in values) {
    slot = null;
    value = values[key];
    for (i = 0; i < slots.length; i++) {
      loopSlot = slots[i];
      if (loopSlot.config.name == key) {
        slot = loopSlot;
        break;
      }
    }
    if (slot) {
      if (animated) {
        slot.setValueAnimated(value);
      } else {
        slot.setValue(value);
      }
    }
  }
  me._values = me._value = values;
  return me;
}, setValueAnimated:function(values) {
  this.setValue(values, true);
}, getValue:function(useDom) {
  var values = {}, items = this.getItems().items, ln = items.length, item, i;
  if (useDom) {
    for (i = 0; i < ln; i++) {
      item = items[i];
      if (item && item.isSlot) {
        values[item.getName()] = item.getValue(useDom);
      }
    }
    this._values = values;
  }
  return this._values;
}, getValues:function() {
  return this.getValue();
}, destroy:function() {
  Ext.Sheet.prototype.destroy.call(this);
  Ext.destroy(this.mask, this.bar);
}}, function() {
});
Ext.cmd.derive('Ext.field.Select', Ext.field.Text, {alternateClassName:'Ext.form.Select', config:{ui:'select', valueField:'value', displayField:'text', store:null, options:null, hiddenName:null, component:{useMask:true}, clearIcon:false, usePicker:'auto', autoSelect:true, defaultPhonePickerConfig:null, defaultTabletPickerConfig:null, name:'picker', pickerSlotAlign:'center'}, platformConfig:[{theme:['Windows'], pickerSlotAlign:'left'}, {theme:['Tizen'], usePicker:false}], initialize:function() {
  var me = this, component = me.getComponent();
  Ext.field.Text.prototype.initialize.call(this);
  component.on({scope:me, masktap:'onMaskTap'});
  component.doMaskTap = Ext.emptyFn;
  if (Ext.browser.is.AndroidStock2) {
    component.input.dom.disabled = true;
  }
  if (Ext.theme.is.Blackberry || Ext.theme.is.Blackberry103) {
    this.label.on({scope:me, tap:'onFocus'});
  }
}, getElementConfig:function() {
  if (Ext.theme.is.Blackberry || Ext.theme.is.Blackberry103) {
    var prefix = 'x-';
    return {reference:'element', className:'x-container', children:[{reference:'innerElement', cls:prefix + 'component-outer', children:[{reference:'label', cls:prefix + 'form-label', children:[{reference:'labelspan', tag:'span'}]}]}]};
  } else {
    return Ext.field.Text.prototype.getElementConfig.apply(this, arguments);
  }
}, updateDefaultPhonePickerConfig:function(newConfig) {
  var picker = this.picker;
  if (picker) {
    picker.setConfig(newConfig);
  }
}, updateDefaultTabletPickerConfig:function(newConfig) {
  var listPanel = this.listPanel;
  if (listPanel) {
    listPanel.setConfig(newConfig);
  }
}, applyUsePicker:function(usePicker) {
  if (usePicker == 'auto') {
    usePicker = Ext.os.deviceType == 'Phone';
  }
  return Boolean(usePicker);
}, syncEmptyCls:Ext.emptyFn, applyValue:function(value) {
  var record = value, index, store;
  this.getOptions();
  store = this.getStore();
  if (value != undefined && !value.isModel && store) {
    index = store.find(this.getValueField(), value, null, null, null, true);
    if (index == -1) {
      index = store.find(this.getDisplayField(), value, null, null, null, true);
    }
    record = store.getAt(index);
  }
  return record;
}, updateValue:function(newValue, oldValue) {
  this.record = newValue;
  Ext.field.Text.prototype.updateValue.call(this, newValue && newValue.isModel ? newValue.get(this.getDisplayField()) : '');
}, getValue:function() {
  var record = this.record;
  return record && record.isModel ? record.get(this.getValueField()) : null;
}, getRecord:function() {
  return this.record;
}, getPhonePicker:function() {
  var config = this.getDefaultPhonePickerConfig();
  if (!this.picker) {
    this.picker = Ext.create('Ext.picker.Picker', Ext.apply({slots:[{align:this.getPickerSlotAlign(), name:this.getName(), valueField:this.getValueField(), displayField:this.getDisplayField(), value:this.getValue(), store:this.getStore()}], listeners:{change:this.onPickerChange, scope:this}}, config));
  }
  return this.picker;
}, getTabletPicker:function() {
  var config = this.getDefaultTabletPickerConfig();
  if (!this.listPanel) {
    this.listPanel = Ext.create('Ext.Panel', Ext.apply({left:0, top:0, modal:true, cls:'x-select-overlay', layout:'fit', hideOnMaskTap:true, width:Ext.os.is.Phone ? '14em' : '18em', height:Ext.os.is.BlackBerry && Ext.os.version.getMajor() === 10 ? '12em' : Ext.os.is.Phone ? '12.5em' : '22em', items:{xtype:'list', store:this.getStore(), itemTpl:'\x3cspan class\x3d"x-list-label"\x3e{' + this.getDisplayField() + ':htmlEncode}\x3c/span\x3e', listeners:{select:this.onListSelect, itemtap:this.onListTap, 
    scope:this}}}, config));
  }
  return this.listPanel;
}, onMaskTap:function() {
  this.onFocus();
  return false;
}, showPicker:function() {
  var me = this, store = me.getStore(), value = me.getValue();
  if (!store || store.getCount() === 0) {
    return;
  }
  if (me.getReadOnly()) {
    return;
  }
  me.isFocused = true;
  if (me.getUsePicker()) {
    var picker = me.getPhonePicker(), name = me.getName(), pickerValue = {};
    pickerValue[name] = value;
    picker.setValue(pickerValue);
    if (!picker.getParent()) {
      Ext.Viewport.add(picker);
    }
    picker.show();
  } else {
    var listPanel = me.getTabletPicker(), list = listPanel.down('list'), index, record;
    if (!listPanel.getParent()) {
      Ext.Viewport.add(listPanel);
    }
    listPanel.showBy(me.getComponent(), null);
    if (value || me.getAutoSelect()) {
      store = list.getStore();
      index = store.find(me.getValueField(), value, null, null, null, true);
      record = store.getAt(index);
      if (record) {
        list.select(record, null, true);
      }
    }
  }
}, onListSelect:function(item, record) {
  var me = this;
  if (record) {
    me.setValue(record);
  }
}, onListTap:function() {
  this.listPanel.hide({type:'fade', out:true, scope:this});
}, onPickerChange:function(picker, value) {
  var me = this, newValue = value[me.getName()], store = me.getStore(), index = store.find(me.getValueField(), newValue, null, null, null, true), record = store.getAt(index);
  me.setValue(record);
}, onChange:function(component, newValue, oldValue) {
  var me = this, store = me.getStore(), index = store ? store.find(me.getDisplayField(), oldValue, null, null, null, true) : -1, valueField = me.getValueField(), record = store ? store.getAt(index) : null;
  oldValue = record ? record.get(valueField) : null;
  me.fireEvent('change', me, me.getValue(), oldValue);
}, updateOptions:function(newOptions) {
  var store = this.getStore();
  if (!store) {
    this.setStore(true);
    store = this._store;
  }
  if (!newOptions) {
    store.clearData();
  } else {
    store.setData(newOptions);
    this.onStoreDataChanged(store);
  }
  return this;
}, applyStore:function(store) {
  if (store === true) {
    store = Ext.create('Ext.data.Store', {fields:[this.getValueField(), this.getDisplayField()], autoDestroy:true});
  }
  if (store) {
    store = Ext.data.StoreManager.lookup(store);
    store.on({scope:this, addrecords:'onStoreDataChanged', removerecords:'onStoreDataChanged', updaterecord:'onStoreDataChanged', refresh:'onStoreDataChanged'});
  }
  return store;
}, updateStore:function(newStore) {
  if (newStore) {
    this.onStoreDataChanged(newStore);
  }
  if (this.getUsePicker() && this.picker) {
    this.picker.down('pickerslot').setStore(newStore);
  } else {
    if (this.listPanel) {
      this.listPanel.down('dataview').setStore(newStore);
    }
  }
}, onStoreDataChanged:function(store) {
  var initialConfig = this.getInitialConfig(), value = this.getValue();
  if (value || value == 0) {
    this.updateValue(this.applyValue(value));
  }
  if (this.getValue() === null) {
    if (initialConfig.hasOwnProperty('value')) {
      this.setValue(initialConfig.value);
    }
    if (this.getValue() === null && this.getAutoSelect()) {
      if (store.getCount() > 0) {
        this.setValue(store.getAt(0));
      }
    }
  }
}, doSetDisabled:function(disabled) {
  var component = this.getComponent();
  if (component) {
    component.setDisabled(disabled);
  }
  Ext.Component.prototype.doSetDisabled.apply(this, arguments);
}, setDisabled:function() {
  Ext.Component.prototype.setDisabled.apply(this, arguments);
}, updateLabelWidth:function() {
  if (Ext.theme.is.Blackberry || Ext.theme.is.Blackberry103) {
    return;
  } else {
    Ext.field.Text.prototype.updateLabelWidth.apply(this, arguments);
  }
}, updateLabelAlign:function() {
  if (Ext.theme.is.Blackberry || Ext.theme.is.Blackberry103) {
    return;
  } else {
    Ext.field.Text.prototype.updateLabelAlign.apply(this, arguments);
  }
}, reset:function() {
  var me = this, record;
  if (me.getAutoSelect()) {
    var store = me.getStore();
    record = me.originalValue ? me.originalValue : store.getAt(0);
  } else {
    var usePicker = me.getUsePicker(), picker = usePicker ? me.picker : me.listPanel;
    if (picker) {
      picker = picker.child(usePicker ? 'pickerslot' : 'dataview');
      picker.deselectAll();
    }
    record = null;
  }
  me.setValue(record);
  return me;
}, onFocus:function(e) {
  if (this.getDisabled()) {
    return false;
  }
  var component = this.getComponent();
  this.fireEvent('focus', this, e);
  if (Ext.os.is.Android4) {
    component.input.dom.focus();
  }
  component.input.dom.blur();
  this.isFocused = true;
  this.showPicker();
}, destroy:function() {
  Ext.field.Text.prototype.destroy.apply(this, arguments);
  var store = this.getStore();
  if (store && store.getAutoDestroy()) {
    Ext.destroy(store);
  }
  Ext.destroy(this.listPanel, this.picker);
}}, 0, ['selectfield'], ['component', 'field', 'textfield', 'selectfield'], {'component':true, 'field':true, 'textfield':true, 'selectfield':true}, ['widget.selectfield'], 0, [Ext.field, 'Select', Ext.form, 'Select'], 0);
Ext.cmd.derive('Ext.picker.Date', Ext.picker.Picker, {alternateClassName:'Ext.DatePicker', config:{yearFrom:1980, yearTo:(new Date).getFullYear(), monthText:'Month', dayText:'Day', yearText:'Year', slotOrder:['month', 'day', 'year'], doneButton:true}, platformConfig:[{theme:['Windows'], doneButton:{iconCls:'check2', ui:'round', text:''}}], initialize:function() {
  Ext.picker.Picker.prototype.initialize.call(this);
  this.on({scope:this, delegate:'\x3e slot', slotpick:this.onSlotPick});
  this.on({scope:this, show:this.onSlotPick});
}, setValue:function(value, animated) {
  if (Ext.isDate(value)) {
    value = {day:value.getDate(), month:value.getMonth() + 1, year:value.getFullYear()};
  }
  (arguments.callee.$previous || Ext.picker.Picker.prototype.setValue).call(this, value, animated);
  this.onSlotPick();
}, getValue:function(useDom) {
  var values = {}, items = this.getItems().items, ln = items.length, daysInMonth, day, month, year, item, i;
  for (i = 0; i < ln; i++) {
    item = items[i];
    if (item instanceof Ext.picker.Slot) {
      values[item.getName()] = item.getValue(useDom);
    }
  }
  if (values.year === null && values.month === null && values.day === null) {
    return null;
  }
  year = Ext.isNumber(values.year) ? values.year : 1;
  month = Ext.isNumber(values.month) ? values.month : 1;
  day = Ext.isNumber(values.day) ? values.day : 1;
  if (month && year && month && day) {
    daysInMonth = this.getDaysInMonth(month, year);
  }
  day = daysInMonth ? Math.min(day, daysInMonth) : day;
  return new Date(year, month - 1, day);
}, updateYearFrom:function() {
  if (this.initialized) {
    this.createSlots();
  }
}, updateYearTo:function() {
  if (this.initialized) {
    this.createSlots();
  }
}, updateMonthText:function(newMonthText, oldMonthText) {
  var innerItems = this.getInnerItems, ln = innerItems.length, item, i;
  if (this.initialized) {
    for (i = 0; i < ln; i++) {
      item = innerItems[i];
      if (typeof item.title == 'string' && item.title == oldMonthText || item.title.html == oldMonthText) {
        item.setTitle(newMonthText);
      }
    }
  }
}, updateDayText:function(newDayText, oldDayText) {
  var innerItems = this.getInnerItems, ln = innerItems.length, item, i;
  if (this.initialized) {
    for (i = 0; i < ln; i++) {
      item = innerItems[i];
      if (typeof item.title == 'string' && item.title == oldDayText || item.title.html == oldDayText) {
        item.setTitle(newDayText);
      }
    }
  }
}, updateYearText:function(yearText) {
  var innerItems = this.getInnerItems, ln = innerItems.length, item, i;
  if (this.initialized) {
    for (i = 0; i < ln; i++) {
      item = innerItems[i];
      if (item.title == this.yearText) {
        item.setTitle(yearText);
      }
    }
  }
}, constructor:function() {
  Ext.picker.Picker.prototype.constructor.apply(this, arguments);
  this.createSlots();
}, createSlots:function() {
  var me = this, slotOrder = me.getSlotOrder(), yearsFrom = me.getYearFrom(), yearsTo = me.getYearTo(), years = [], days = [], months = [], reverse = yearsFrom > yearsTo, ln, i, daysInMonth;
  while (yearsFrom) {
    years.push({text:yearsFrom, value:yearsFrom});
    if (yearsFrom === yearsTo) {
      break;
    }
    if (reverse) {
      yearsFrom--;
    } else {
      yearsFrom++;
    }
  }
  daysInMonth = me.getDaysInMonth(1, (new Date).getFullYear());
  for (i = 0; i < daysInMonth; i++) {
    days.push({text:i + 1, value:i + 1});
  }
  for (i = 0, ln = Ext.Date.monthNames.length; i < ln; i++) {
    months.push({text:Ext.Date.monthNames[i], value:i + 1});
  }
  var slots = [];
  slotOrder.forEach(function(item) {
    slots.push(me.createSlot(item, days, months, years));
  });
  me.setSlots(slots);
}, createSlot:function(name, days, months, years) {
  switch(name) {
    case 'year':
      return {name:'year', align:'center', data:years, title:this.getYearText(), flex:3};
    case 'month':
      return {name:name, align:'right', data:months, title:this.getMonthText(), flex:4};
    case 'day':
      return {name:'day', align:'center', data:days, title:this.getDayText(), flex:2};
  }
}, onSlotPick:function() {
  var value = this.getValue(true), slot = this.getDaySlot(), year = value.getFullYear(), month = value.getMonth(), days = [], daysInMonth, i;
  if (!value || !Ext.isDate(value) || !slot) {
    return;
  }
  Ext.picker.Picker.prototype.onSlotPick.apply(this, arguments);
  daysInMonth = this.getDaysInMonth(month + 1, year);
  for (i = 0; i < daysInMonth; i++) {
    days.push({text:i + 1, value:i + 1});
  }
  if (slot.getStore().getCount() == days.length) {
    return;
  }
  slot.getStore().setData(days);
  var store = slot.getStore(), viewItems = slot.getViewItems(), valueField = slot.getValueField(), index, item;
  index = store.find(valueField, value.getDate());
  if (index == -1) {
    return;
  }
  item = Ext.get(viewItems[index]);
  slot.selectedIndex = index;
  slot.scrollToItem(item);
  slot.setValue(slot.getValue(true));
}, getDaySlot:function() {
  var innerItems = this.getInnerItems(), ln = innerItems.length, i, slot;
  if (this.daySlot) {
    return this.daySlot;
  }
  for (i = 0; i < ln; i++) {
    slot = innerItems[i];
    if (slot.isSlot && slot.getName() == 'day') {
      this.daySlot = slot;
      return slot;
    }
  }
  return null;
}, getDaysInMonth:function(month, year) {
  var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  return month == 2 && this.isLeapYear(year) ? 29 : daysInMonth[month - 1];
}, isLeapYear:function(year) {
  return !!((year & 3) === 0 && (year % 100 || year % 400 === 0 && year));
}, onDoneButtonTap:function() {
  var oldValue = this._value, newValue = this.getValue(true), testValue = newValue;
  if (Ext.isDate(newValue)) {
    testValue = newValue.toDateString();
  }
  if (Ext.isDate(oldValue)) {
    oldValue = oldValue.toDateString();
  }
  if (testValue != oldValue) {
    this.fireEvent('change', this, newValue);
  }
  this.hide();
  Ext.util.InputBlocker.unblockInputs();
}}, 1, ['datepicker'], ['component', 'container', 'panel', 'sheet', 'picker', 'datepicker'], {'component':true, 'container':true, 'panel':true, 'sheet':true, 'picker':true, 'datepicker':true}, ['widget.datepicker'], 0, [Ext.picker, 'Date', Ext, 'DatePicker'], 0);
Ext.cmd.derive('Ext.field.DatePicker', Ext.field.Select, {alternateClassName:'Ext.form.DatePicker', config:{ui:'select', picker:true, clearIcon:false, destroyPickerOnHide:false, dateFormat:null, component:{useMask:true}}, initialize:function() {
  var me = this, component = me.getComponent();
  Ext.field.Select.prototype.initialize.call(this);
  component.on({scope:me, masktap:'onMaskTap'});
  component.doMaskTap = Ext.emptyFn;
  if (Ext.browser.is.AndroidStock2) {
    component.input.dom.disabled = true;
  }
}, syncEmptyCls:Ext.emptyFn, applyValue:function(value) {
  if (!Ext.isDate(value) && !Ext.isObject(value)) {
    return null;
  }
  if (Ext.isObject(value)) {
    return new Date(value.year, value.month - 1, value.day);
  }
  return value;
}, updateValue:function(newValue, oldValue) {
  var me = this, picker = me._picker;
  if (picker && picker.isPicker) {
    picker.setValue(newValue);
  }
  if (newValue !== null) {
    me.getComponent().setValue(Ext.Date.format(newValue, me.getDateFormat() || Ext.util.Format.defaultDateFormat));
  } else {
    me.getComponent().setValue('');
  }
  if (newValue !== oldValue) {
    me.fireEvent('change', me, newValue, oldValue);
  }
}, updateDateFormat:function(newDateFormat, oldDateFormat) {
  var value = this.getValue();
  if (newDateFormat != oldDateFormat && Ext.isDate(value)) {
    this.getComponent().setValue(Ext.Date.format(value, newDateFormat || Ext.util.Format.defaultDateFormat));
  }
}, getValue:function() {
  if (this._picker && this._picker instanceof Ext.picker.Date) {
    return this._picker.getValue();
  }
  return this._value;
}, getFormattedValue:function(format) {
  var value = this.getValue();
  return Ext.isDate(value) ? Ext.Date.format(value, format || this.getDateFormat() || Ext.util.Format.defaultDateFormat) : value;
}, applyPicker:function(picker, pickerInstance) {
  if (pickerInstance && pickerInstance.isPicker) {
    picker = pickerInstance.setConfig(picker);
  }
  return picker;
}, getPicker:function() {
  var picker = this._picker, value = this.getValue();
  if (picker && !picker.isPicker) {
    picker = Ext.factory(picker, Ext.picker.Date);
    if (value != null) {
      picker.setValue(value);
    }
  }
  picker.on({scope:this, change:'onPickerChange', hide:'onPickerHide'});
  this._picker = picker;
  return picker;
}, onMaskTap:function() {
  if (this.getDisabled()) {
    return false;
  }
  this.onFocus();
  return false;
}, onPickerChange:function(picker, value) {
  var me = this, oldValue = me.getValue();
  me.setValue(value);
  me.fireEvent('select', me, value);
  me.onChange(me, value, oldValue);
}, onChange:Ext.emptyFn, onPickerHide:function() {
  var me = this, picker = me.getPicker();
  if (me.getDestroyPickerOnHide() && picker) {
    picker.destroy();
    me._picker = me.getInitialConfig().picker || true;
  }
}, reset:function() {
  this.setValue(this.originalValue);
}, onFocus:function(e) {
  var component = this.getComponent();
  this.fireEvent('focus', this, e);
  if (Ext.os.is.Android4) {
    component.input.dom.focus();
  }
  component.input.dom.blur();
  if (this.getReadOnly()) {
    return false;
  }
  this.isFocused = true;
  this.getPicker().show();
}, destroy:function() {
  var picker = this._picker;
  if (picker && picker.isPicker) {
    picker.destroy();
  }
  Ext.field.Select.prototype.destroy.apply(this, arguments);
}}, 0, ['datepickerfield'], ['component', 'field', 'textfield', 'selectfield', 'datepickerfield'], {'component':true, 'field':true, 'textfield':true, 'selectfield':true, 'datepickerfield':true}, ['widget.datepickerfield'], 0, [Ext.field, 'DatePicker', Ext.form, 'DatePicker'], 0);
Ext.cmd.derive('Ext.field.FileInput', Ext.field.Input, {config:{type:'file', accept:null, capture:null, name:null, multiple:false}, captureLookup:{video:'camcorder', image:'camera', audio:'microphone'}, initialize:function() {
  var me = this;
  Ext.field.Input.prototype.initialize.call(this);
  me.input.on({scope:me, change:'onInputChange'});
}, getValue:function() {
  var input = this.input;
  if (input) {
    this._value = input.dom.value;
  }
  return this._value;
}, setValue:function(newValue) {
  var oldValue = this._value;
  this._value = newValue;
  if (String(this._value) != String(oldValue) && this.initialized) {
    this.onChange(this, this._value, oldValue);
  }
  return this;
}, getFiles:function() {
  var input = this.input;
  if (input) {
    this.$files = input.dom.files;
  }
  return this.$files;
}, onInputChange:function(e) {
  this.setValue(e.target.value);
}, onChange:function(me, value, startValue) {
  this.fireEvent('change', me, value, startValue);
}, applyName:function(value) {
  if (this.getMultiple() && value.substr(-2, 2) !== '[]') {
    value += '[]';
  } else {
    if (!this.getMultiple() && value.substr(-2, 2) === '[]') {
      value = value.substr(0, value.length - 2);
    }
  }
  return value;
}, applyMultiple:function(value) {
  this.updateFieldAttribute('multiple', value ? '' : null);
  return value;
}, updateMultiple:function() {
  var name = this.getName();
  if (!Ext.isEmpty(name)) {
    this.setName(name);
  }
}, applyAccept:function(value) {
  switch(value) {
    case 'video':
    case 'audio':
    case 'image':
      value = value + '/*';
      break;
  }
  this.updateFieldAttribute('accept', value);
}, applyCapture:function(value) {
  this.updateFieldAttribute('capture', value);
  return value;
}}, 0, ['fileinput'], ['component', 'input', 'fileinput'], {'component':true, 'input':true, 'fileinput':true}, ['widget.fileinput'], 0, [Ext.field, 'FileInput'], 0);
Ext.cmd.derive('Ext.field.File', Ext.field.Field, {config:{component:{xtype:'fileinput', fastFocus:false}}, proxyConfig:{name:null, value:null, files:null, multiple:false, accept:null, capture:null}, isFile:true, initialize:function() {
  var me = this;
  Ext.field.Field.prototype.initialize.call(this);
  me.getComponent().on({scope:this, change:'onChange'});
}, onChange:function(me, value, startValue) {
  me.fireEvent('change', this, value, startValue);
}}, 0, ['filefield'], ['component', 'field', 'filefield'], {'component':true, 'field':true, 'filefield':true}, ['widget.filefield'], 0, [Ext.field, 'File'], 0);
Ext.cmd.derive('Ext.field.Password', Ext.field.Text, {alternateClassName:'Ext.form.Password', config:{autoCapitalize:false, revealable:false, revealed:false, component:{type:'password'}}, platformConfig:[{theme:['Blackberry', 'Blackberry103'], revealable:true}], isPassword:true, initialize:function() {
  Ext.field.Text.prototype.initialize.apply(this, arguments);
  this.addCls('x-field-password');
}, updateRevealable:function(newValue, oldValue) {
  if (newValue === oldValue) {
    return;
  }
  if (this.$revealIcon) {
    this.getComponent().element.removeChild(this.$revealIcon);
    this.$revealIcon = null;
  }
  if (newValue === true) {
    this.$revealIcon = new Ext.Element(Ext.Element.create({cls:'x-reveal-icon'}, true));
    this.$revealIcon.on({tap:'onRevealIconTap', touchstart:'onRevealIconPress', touchend:'onRevealIconRelease', scope:this});
    this.getComponent().element.appendChild(this.$revealIcon);
  }
}, updateRevealed:function(newValue, oldValue) {
  var component = this.getComponent();
  if (newValue) {
    this.element.addCls('x-revealed');
    component.setType('text');
  } else {
    this.element.removeCls('x-revealed');
    component.setType('password');
  }
}, updateValue:function(newValue) {
  var component = this.getComponent(), valueValid = newValue !== undefined && newValue !== null && newValue !== '';
  if (component) {
    component.setValue(newValue);
  }
  this[valueValid && this.isDirty() ? 'showClearIcon' : 'hideClearIcon']();
  this.syncEmptyCls();
  this[valueValid ? 'showRevealIcon' : 'hideRevealIcon']();
}, doKeyUp:function(me, e) {
  var value = me.getValue(), valueValid = value !== undefined && value !== null && value !== '';
  this[valueValid ? 'showClearIcon' : 'hideClearIcon']();
  if (e.browserEvent.keyCode === 13) {
    me.fireAction('action', [me, e], 'doAction');
  }
  this[valueValid ? 'showRevealIcon' : 'hideRevealIcon']();
}, showRevealIcon:function() {
  var me = this, value = me.getValue(), valueValid = value !== undefined && value !== null && value !== '';
  if (me.getRevealable() && !me.getDisabled() && valueValid) {
    me.element.addCls('x-field-revealable');
  }
  return me;
}, hideRevealIcon:function() {
  if (this.getRevealable()) {
    this.element.removeCls('x-field-revealable');
  }
}, onRevealIconTap:function(e) {
  this.fireAction('revealicontap', [this, e], 'doRevealIconTap');
}, doRevealIconTap:function(me, e) {
  if (this.getRevealed()) {
    this.setRevealed(false);
  } else {
    this.setRevealed(true);
  }
}, onRevealIconPress:function() {
  this.$revealIcon.addCls('x-pressing');
}, onRevealIconRelease:function() {
  this.$revealIcon.removeCls('x-pressing');
}}, 0, ['passwordfield'], ['component', 'field', 'textfield', 'passwordfield'], {'component':true, 'field':true, 'textfield':true, 'passwordfield':true}, ['widget.passwordfield'], 0, [Ext.field, 'Password', Ext.form, 'Password'], 0);
Ext.cmd.derive('Ext.field.Search', Ext.field.Text, {alternateClassName:'Ext.form.Search', config:{component:{type:'search'}, ui:'search'}, platformConfig:[{platform:'blackberry', component:{type:'text'}}]}, 0, ['searchfield'], ['component', 'field', 'textfield', 'searchfield'], {'component':true, 'field':true, 'textfield':true, 'searchfield':true}, ['widget.searchfield'], 0, [Ext.field, 'Search', Ext.form, 'Search'], 0);
Ext.cmd.derive('Ext.slider.Thumb', Ext.Component, {config:{baseCls:'x-thumb', pressedCls:'x-thumb-pressing', draggable:{direction:'horizontal'}}, platformConfig:[{platform:['ie10'], draggable:{translatable:{translationMethod:'csstransform'}}}], elementWidth:0, initialize:function() {
  Ext.Component.prototype.initialize.call(this);
  this.getDraggable().onBefore({dragstart:'onDragStart', drag:'onDrag', dragend:'onDragEnd', scope:this});
  this.getDraggable().on({touchstart:'onPress', touchend:'onRelease', scope:this});
  this.element.on('resize', 'onElementResize', this);
}, getTemplate:function() {
  if (Ext.theme.is.Blackberry || Ext.theme.is.Blackberry103) {
    return [{tag:'div', className:'x-thumb-inner', reference:'innerElement'}];
  } else {
    return this.template;
  }
}, updatePressedCls:function(pressedCls, oldPressedCls) {
  var element = this.element;
  if (element.hasCls(oldPressedCls)) {
    element.replaceCls(oldPressedCls, pressedCls);
  }
}, onPress:function() {
  var me = this, element = me.element, pressedCls = me.getPressedCls();
  if (!me.getDisabled()) {
    element.addCls(pressedCls);
  }
}, onRelease:function(e) {
  this.fireAction('release', [this, e], 'doRelease');
}, doRelease:function(me, e) {
  if (!me.getDisabled()) {
    me.element.removeCls(me.getPressedCls());
  }
}, onDragStart:function() {
  if (this.isDisabled()) {
    return false;
  }
  this.relayEvent(arguments);
}, onDrag:function() {
  if (this.isDisabled()) {
    return false;
  }
  this.relayEvent(arguments);
}, onDragEnd:function() {
  if (this.isDisabled()) {
    return false;
  }
  this.relayEvent(arguments);
}, onElementResize:function(element, info) {
  this.elementWidth = info.width;
}, getElementWidth:function() {
  return this.elementWidth;
}}, 0, ['thumb'], ['component', 'thumb'], {'component':true, 'thumb':true}, ['widget.thumb'], 0, [Ext.slider, 'Thumb'], 0);
Ext.cmd.derive('Ext.slider.Slider', Ext.Container, {config:{baseCls:'x-slider', thumbConfig:{draggable:{translatable:{easingX:{duration:300, type:'ease-out'}}}}, increment:1, value:0, minValue:0, maxValue:100, allowThumbsOverlapping:false, animation:true, readOnly:false}, elementWidth:0, offsetValueRatio:0, activeThumb:null, constructor:function(config) {
  config = config || {};
  if (config.hasOwnProperty('values')) {
    config.value = config.values;
  }
  Ext.Container.prototype.constructor.call(this, config);
}, initialize:function() {
  var element = this.element;
  Ext.Container.prototype.initialize.call(this);
  element.on({scope:this, tap:'onTap', resize:'onResize'});
  this.on({scope:this, delegate:'\x3e thumb', tap:'onTap', dragstart:'onThumbDragStart', drag:'onThumbDrag', dragend:'onThumbDragEnd'});
  var thumb = this.getThumb(0);
  if (thumb) {
    thumb.on('resize', 'onThumbResize', this);
  }
}, factoryThumb:function() {
  return Ext.factory(this.getThumbConfig(), Ext.slider.Thumb);
}, getThumbs:function() {
  return this.innerItems;
}, getThumb:function(index) {
  if (typeof index != 'number') {
    index = 0;
  }
  return this.innerItems[index];
}, refreshOffsetValueRatio:function() {
  var valueRange = this.getMaxValue() - this.getMinValue(), trackWidth = this.elementWidth - this.thumbWidth;
  this.offsetValueRatio = trackWidth / valueRange;
}, onThumbResize:function() {
  var thumb = this.getThumb(0);
  if (thumb) {
    this.thumbWidth = thumb.getElementWidth();
  }
  this.refresh();
}, onResize:function(element, info) {
  this.elementWidth = info.width;
  this.refresh();
}, refresh:function() {
  this.refreshValue();
}, setActiveThumb:function(thumb) {
  var oldActiveThumb = this.activeThumb;
  if (oldActiveThumb && oldActiveThumb !== thumb) {
    oldActiveThumb.setZIndex(null);
  }
  this.activeThumb = thumb;
  thumb.setZIndex(2);
  return this;
}, onThumbDragStart:function(thumb, e) {
  if (e.absDeltaX <= e.absDeltaY || this.getReadOnly()) {
    return false;
  } else {
    e.stopPropagation();
  }
  if (this.getAllowThumbsOverlapping()) {
    this.setActiveThumb(thumb);
  }
  this.dragStartValue = this.getValue()[this.getThumbIndex(thumb)];
  this.fireEvent('dragstart', this, thumb, this.dragStartValue, e);
}, onThumbDrag:function(thumb, e, offsetX) {
  var index = this.getThumbIndex(thumb), offsetValueRatio = this.offsetValueRatio, constrainedValue = this.constrainValue(this.getMinValue() + offsetX / offsetValueRatio);
  e.stopPropagation();
  this.setIndexValue(index, constrainedValue);
  this.fireEvent('drag', this, thumb, this.getValue(), e);
  return false;
}, setIndexValue:function(index, value, animation) {
  var thumb = this.getThumb(index), values = this.getValue(), minValue = this.getMinValue(), offsetValueRatio = this.offsetValueRatio, increment = this.getIncrement(), draggable = thumb.getDraggable();
  draggable.setOffset((value - minValue) * offsetValueRatio, null, animation);
  values[index] = minValue + Math.round(draggable.offset.x / offsetValueRatio / increment) * increment;
}, onThumbDragEnd:function(thumb, e) {
  this.refreshThumbConstraints(thumb);
  var index = this.getThumbIndex(thumb), newValue = this.getValue()[index], oldValue = this.dragStartValue;
  this.fireEvent('dragend', this, thumb, this.getValue(), e);
  if (oldValue !== newValue) {
    this.fireEvent('change', this, thumb, newValue, oldValue);
  }
}, getThumbIndex:function(thumb) {
  return this.getThumbs().indexOf(thumb);
}, refreshThumbConstraints:function(thumb) {
  var allowThumbsOverlapping = this.getAllowThumbsOverlapping(), offsetX = thumb.getDraggable().getOffset().x, thumbs = this.getThumbs(), index = this.getThumbIndex(thumb), previousThumb = thumbs[index - 1], nextThumb = thumbs[index + 1], thumbWidth = this.thumbWidth;
  if (previousThumb) {
    previousThumb.getDraggable().addExtraConstraint({max:{x:offsetX - (allowThumbsOverlapping ? 0 : thumbWidth)}});
  }
  if (nextThumb) {
    nextThumb.getDraggable().addExtraConstraint({min:{x:offsetX + (allowThumbsOverlapping ? 0 : thumbWidth)}});
  }
}, onTap:function(e) {
  if (this.isDisabled() || this.getReadOnly()) {
    return;
  }
  var targetElement = Ext.get(e.target);
  if (!targetElement || Ext.browser.engineName == 'WebKit' && targetElement.hasCls('x-thumb')) {
    return;
  }
  var touchPointX = e.touch.point.x, element = this.element, elementX = element.getX(), offset = touchPointX - elementX - this.thumbWidth / 2, value = this.constrainValue(this.getMinValue() + offset / this.offsetValueRatio), values = this.getValue(), minDistance = Infinity, ln = values.length, i, absDistance, testValue, closestIndex, oldValue, thumb;
  if (ln === 1) {
    closestIndex = 0;
  } else {
    for (i = 0; i < ln; i++) {
      testValue = values[i];
      absDistance = Math.abs(testValue - value);
      if (absDistance < minDistance) {
        minDistance = absDistance;
        closestIndex = i;
      }
    }
  }
  oldValue = values[closestIndex];
  thumb = this.getThumb(closestIndex);
  this.setIndexValue(closestIndex, value, this.getAnimation());
  this.refreshThumbConstraints(thumb);
  if (oldValue !== value) {
    this.fireEvent('change', this, thumb, value, oldValue);
  }
}, updateThumbs:function(newThumbs) {
  this.add(newThumbs);
}, applyValue:function(value) {
  var values = Ext.Array.from(value || 0), filteredValues = [], previousFilteredValue = this.getMinValue(), filteredValue, i, ln;
  for (i = 0, ln = values.length; i < ln; i++) {
    filteredValue = this.constrainValue(values[i]);
    if (filteredValue < previousFilteredValue) {
      filteredValue = previousFilteredValue;
    }
    filteredValues.push(filteredValue);
    previousFilteredValue = filteredValue;
  }
  return filteredValues;
}, updateValue:function(newValue, oldValue) {
  var thumbs = this.getThumbs(), ln = newValue.length, minValue = this.getMinValue(), offset = this.offsetValueRatio, i;
  this.setThumbsCount(ln);
  for (i = 0; i < ln; i++) {
    thumbs[i].getDraggable().setExtraConstraint(null).setOffset((newValue[i] - minValue) * offset);
  }
  for (i = 0; i < ln; i++) {
    this.refreshThumbConstraints(thumbs[i]);
  }
}, refreshValue:function() {
  this.refreshOffsetValueRatio();
  this.setValue(this.getValue());
}, constrainValue:function(value) {
  var me = this, minValue = me.getMinValue(), maxValue = me.getMaxValue(), increment = me.getIncrement(), remainder;
  value = parseFloat(value);
  if (isNaN(value)) {
    value = minValue;
  }
  remainder = (value - minValue) % increment;
  value -= remainder;
  if (Math.abs(remainder) >= increment / 2) {
    value += remainder > 0 ? increment : -increment;
  }
  value = Math.max(minValue, value);
  value = Math.min(maxValue, value);
  return value;
}, setThumbsCount:function(count) {
  var thumbs = this.getThumbs(), thumbsCount = thumbs.length, i, ln, thumb;
  if (thumbsCount > count) {
    for (i = 0, ln = thumbsCount - count; i < ln; i++) {
      thumb = thumbs[thumbs.length - 1];
      thumb.destroy();
    }
  } else {
    if (thumbsCount < count) {
      for (i = 0, ln = count - thumbsCount; i < ln; i++) {
        this.add(this.factoryThumb());
      }
    }
  }
  return this;
}, setValues:function(value) {
  this.setValue(value);
}, getValues:function() {
  return this.getValue();
}, applyIncrement:function(increment) {
  if (increment === 0) {
    increment = 1;
  }
  return Math.abs(increment);
}, updateAllowThumbsOverlapping:function(newValue, oldValue) {
  if (typeof oldValue != 'undefined') {
    this.refreshValue();
  }
}, updateMinValue:function(newValue, oldValue) {
  if (typeof oldValue != 'undefined') {
    this.refreshValue();
  }
}, updateMaxValue:function(newValue, oldValue) {
  if (typeof oldValue != 'undefined') {
    this.refreshValue();
  }
}, updateIncrement:function(newValue, oldValue) {
  if (typeof oldValue != 'undefined') {
    this.refreshValue();
  }
}, doSetDisabled:function(disabled) {
  Ext.Container.prototype.doSetDisabled.apply(this, arguments);
  var items = this.getItems().items, ln = items.length, i;
  for (i = 0; i < ln; i++) {
    items[i].setDisabled(disabled);
  }
}}, 1, ['slider'], ['component', 'container', 'slider'], {'component':true, 'container':true, 'slider':true}, ['widget.slider'], 0, [Ext.slider, 'Slider'], function() {
});
Ext.cmd.derive('Ext.field.Slider', Ext.field.Field, {alternateClassName:'Ext.form.Slider', config:{cls:'x-slider-field', tabIndex:-1, readOnly:false}, proxyConfig:{increment:1, value:0, minValue:0, maxValue:100}, constructor:function(config) {
  config = config || {};
  if (config.hasOwnProperty('values')) {
    config.value = config.values;
  }
  Ext.field.Field.prototype.constructor.call(this, config);
  this.updateMultipleState();
}, initialize:function() {
  Ext.field.Field.prototype.initialize.call(this);
  this.getComponent().on({scope:this, change:'onSliderChange', dragstart:'onSliderDragStart', drag:'onSliderDrag', dragend:'onSliderDragEnd'});
}, applyComponent:function(config) {
  return Ext.factory(config, Ext.slider.Slider);
}, updateComponent:function(component) {
  Ext.field.Field.prototype.updateComponent.apply(this, arguments);
  component.setMinValue(this.getMinValue());
  component.setMaxValue(this.getMaxValue());
}, onSliderChange:function() {
  this.fireEvent.apply(this, [].concat('change', this, Array.prototype.slice.call(arguments)));
}, onSliderDragStart:function() {
  this.fireEvent.apply(this, [].concat('dragstart', this, Array.prototype.slice.call(arguments)));
}, onSliderDrag:function() {
  this.fireEvent.apply(this, [].concat('drag', this, Array.prototype.slice.call(arguments)));
}, onSliderDragEnd:function() {
  this.fireEvent.apply(this, [].concat('dragend', this, Array.prototype.slice.call(arguments)));
}, setValues:function(value) {
  this.setValue(value);
  this.updateMultipleState();
}, getValues:function() {
  return this.getValue();
}, reset:function() {
  var config = this.config, initialValue = this.config.hasOwnProperty('values') ? config.values : config.value;
  this.setValue(initialValue);
}, doSetDisabled:function(disabled) {
  Ext.field.Field.prototype.doSetDisabled.apply(this, arguments);
  this.getComponent().setDisabled(disabled);
}, updateReadOnly:function(newValue) {
  this.getComponent().setReadOnly(newValue);
}, isDirty:function() {
  if (this.getDisabled()) {
    return false;
  }
  return this.getValue() !== this.originalValue;
}, updateMultipleState:function() {
  var value = this.getValue();
  if (value && value.length > 1) {
    this.addCls('x-slider-multiple');
  }
}}, 1, ['sliderfield'], ['component', 'field', 'sliderfield'], {'component':true, 'field':true, 'sliderfield':true}, ['widget.sliderfield'], 0, [Ext.field, 'Slider', Ext.form, 'Slider'], 0);
Ext.cmd.derive('Ext.slider.Toggle', Ext.slider.Slider, {config:{baseCls:'x-toggle', minValueCls:'x-toggle-off', maxValueCls:'x-toggle-on'}, initialize:function() {
  Ext.slider.Slider.prototype.initialize.call(this);
  this.on({change:'onChange'});
}, applyMinValue:function() {
  return 0;
}, applyMaxValue:function() {
  return 1;
}, applyIncrement:function() {
  return 1;
}, updateMinValueCls:function(newCls, oldCls) {
  var element = this.element;
  if (oldCls && element.hasCls(oldCls)) {
    element.replaceCls(oldCls, newCls);
  }
}, updateMaxValueCls:function(newCls, oldCls) {
  var element = this.element;
  if (oldCls && element.hasCls(oldCls)) {
    element.replaceCls(oldCls, newCls);
  }
}, setValue:function(newValue, oldValue) {
  (arguments.callee.$previous || Ext.slider.Slider.prototype.setValue).apply(this, arguments);
  this.onChange(this, this.getThumbs()[0], newValue, oldValue);
}, setIndexValue:function(index, value, animation) {
  var oldValue = this.getValue()[index];
  Ext.slider.Slider.prototype.setIndexValue.apply(this, arguments);
  var thumb = this.getThumb(index), newValue = this.getValue()[index];
  if (oldValue !== newValue) {
    this.fireEvent('change', this, thumb, newValue, oldValue);
  }
}, onChange:function(me, thumb, newValue, oldValue) {
  var isOn = newValue > 0, onCls = me.getMaxValueCls(), offCls = me.getMinValueCls(), element = this.element;
  element.addCls(isOn ? onCls : offCls);
  element.removeCls(isOn ? offCls : onCls);
}, toggle:function() {
  var value = this.getValue();
  this.setValue(value == 1 ? 0 : 1);
  return this;
}, onTap:function() {
  if (this.isDisabled() || this.getReadOnly()) {
    return;
  }
  var oldValue = this.getValue(), newValue = oldValue == 1 ? 0 : 1, thumb = this.getThumb(0);
  this.setIndexValue(0, newValue, this.getAnimation());
  this.refreshThumbConstraints(thumb);
}}, 0, 0, ['component', 'container', 'slider'], {'component':true, 'container':true, 'slider':true}, 0, 0, [Ext.slider, 'Toggle'], 0);
Ext.cmd.derive('Ext.field.Toggle', Ext.field.Slider, {alternateClassName:'Ext.form.Toggle', config:{cls:'x-toggle-field', labelAlign:'left', activeLabel:null, inactiveLabel:null}, platformConfig:[{theme:['Windows'], labelAlign:'left'}, {theme:['Blackberry', 'Blackberry103', 'MountainView'], activeLabel:'On', inactiveLabel:'Off'}], proxyConfig:{minValueCls:'x-toggle-off', maxValueCls:'x-toggle-on'}, applyComponent:function(config) {
  return Ext.factory(config, Ext.slider.Toggle);
}, updateActiveLabel:function(newActiveLabel, oldActiveLabel) {
  if (newActiveLabel != oldActiveLabel) {
    this.getComponent().element.dom.setAttribute('data-activelabel', newActiveLabel);
  }
}, updateInactiveLabel:function(newInactiveLabel, oldInactiveLabel) {
  if (newInactiveLabel != oldInactiveLabel) {
    this.getComponent().element.dom.setAttribute('data-inactivelabel', newInactiveLabel);
  }
}, setValue:function(newValue) {
  if (newValue === true) {
    newValue = 1;
  }
  var oldValue = this.getValue();
  if (oldValue != newValue) {
    this.getComponent().setValue(newValue);
    this.fireEvent('change', this, newValue, oldValue);
  }
  return this;
}, getValue:function() {
  return this.getComponent().getValue() == 1 ? 1 : 0;
}, onSliderChange:function(component, thumb, newValue, oldValue) {
  this.fireEvent.call(this, 'change', this, newValue, oldValue);
}, toggle:function() {
  var value = this.getValue();
  this.setValue(value == 1 ? 0 : 1);
  return this;
}, onChange:function() {
  this.setLabel(this.getValue() == 1 ? this.toggleOnLabel : this.toggleOffLabel);
}}, 0, ['togglefield'], ['component', 'field', 'sliderfield', 'togglefield'], {'component':true, 'field':true, 'sliderfield':true, 'togglefield':true}, ['widget.togglefield'], 0, [Ext.field, 'Toggle', Ext.form, 'Toggle'], 0);
Ext.cmd.derive('Ext.form.FieldSet', Ext.Container, {config:{baseCls:'x-form-fieldset', title:null, instructions:null}, applyTitle:function(title) {
  if (typeof title == 'string') {
    title = {title:title};
  }
  Ext.applyIf(title, {docked:'top', baseCls:this.getBaseCls() + '-title'});
  return Ext.factory(title, Ext.Title, this._title);
}, updateTitle:function(newTitle, oldTitle) {
  if (newTitle) {
    this.add(newTitle);
  }
  if (oldTitle) {
    this.remove(oldTitle);
  }
}, getTitle:function() {
  var title = this._title;
  if (title && title instanceof Ext.Title) {
    return title.getTitle();
  }
  return title;
}, applyInstructions:function(instructions) {
  if (typeof instructions == 'string') {
    instructions = {title:instructions};
  }
  Ext.applyIf(instructions, {docked:'bottom', baseCls:this.getBaseCls() + '-instructions'});
  return Ext.factory(instructions, Ext.Title, this._instructions);
}, updateInstructions:function(newInstructions, oldInstructions) {
  if (newInstructions) {
    this.add(newInstructions);
  }
  if (oldInstructions) {
    this.remove(oldInstructions);
  }
}, getInstructions:function() {
  var instructions = this._instructions;
  if (instructions && instructions instanceof Ext.Title) {
    return instructions.getTitle();
  }
  return instructions;
}, doSetDisabled:function(newDisabled) {
  this.getFieldsAsArray().forEach(function(field) {
    field.setDisabled(newDisabled);
  });
  return this;
}, getFieldsAsArray:function() {
  var fields = [], getFieldsFrom = function(item) {
    if (item.isField) {
      fields.push(item);
    }
    if (item.isContainer) {
      item.getItems().each(getFieldsFrom);
    }
  };
  this.getItems().each(getFieldsFrom);
  return fields;
}}, 0, ['fieldset'], ['component', 'container', 'fieldset'], {'component':true, 'container':true, 'fieldset':true}, ['widget.fieldset'], 0, [Ext.form, 'FieldSet'], 0);
Ext.cmd.derive('Ext.form.Panel', Ext.Panel, {alternateClassName:'Ext.form.FormPanel', config:{baseCls:'x-form', standardSubmit:false, url:null, enctype:null, baseParams:null, submitOnAction:false, record:null, method:'post', scrollable:{translatable:{translationMethod:'scrollposition'}}, trackResetOnLoad:false, api:null, paramOrder:null, paramsAsHash:null, timeout:30, multipartDetection:true, enableSubmissionForm:true}, getElementConfig:function() {
  var config = Ext.Panel.prototype.getElementConfig.call(this);
  config.tag = 'form';
  config.children.push({tag:'input', type:'submit', style:'visibility: hidden; width: 0; height: 0; position: absolute; right: 0; bottom: 0;'});
  return config;
}, initialize:function() {
  var me = this;
  Ext.Panel.prototype.initialize.call(this);
  me.element.on({submit:'onSubmit', scope:me});
}, applyEnctype:function(newValue) {
  var form = this.element.dom || null;
  if (form) {
    if (newValue) {
      form.setAttribute('enctype', newValue);
    } else {
      form.setAttribute('enctype');
    }
  }
}, updateRecord:function(newRecord) {
  var fields, values, name;
  if (newRecord && (fields = newRecord.fields)) {
    values = this.getValues();
    for (name in values) {
      if (values.hasOwnProperty(name) && fields.containsKey(name)) {
        newRecord.set(name, values[name]);
      }
    }
  }
  return this;
}, setRecord:function(record) {
  var me = this;
  if (record && record.data) {
    me.setValues(record.data);
  }
  me._record = record;
  return this;
}, onSubmit:function(e) {
  var me = this;
  if (e && !me.getStandardSubmit()) {
    e.stopEvent();
  } else {
    if (me.getEnableSubmissionForm()) {
      e.stopEvent();
    }
    this.submit(null, e);
  }
}, updateSubmitOnAction:function(newSubmitOnAction) {
  if (newSubmitOnAction) {
    this.on({action:'onFieldAction', scope:this});
  } else {
    this.un({action:'onFieldAction', scope:this});
  }
}, onFieldAction:function(field) {
  if (this.getSubmitOnAction()) {
    field.blur();
    this.submit();
  }
}, submit:function(options, e) {
  options = options || {};
  var me = this, formValues = me.getValues(me.getStandardSubmit() || !options.submitDisabled), form = me.element.dom || {};
  if (this.getEnableSubmissionForm()) {
    form = this.createSubmissionForm(form, formValues);
  }
  options = Ext.apply({url:me.getUrl() || form.action, submit:false, form:form, method:me.getMethod() || form.method || 'post', autoAbort:false, params:null, waitMsg:null, headers:null, success:null, failure:null}, options || {});
  return me.fireAction('beforesubmit', [me, formValues, options, e], 'doBeforeSubmit');
}, createSubmissionForm:function(form, values) {
  var fields = this.getFields(), name, input, field, fileinputElement, inputComponent;
  if (form.nodeType === 1) {
    form = form.cloneNode(false);
    for (name in values) {
      input = document.createElement('input');
      input.setAttribute('type', 'text');
      input.setAttribute('name', name);
      input.setAttribute('value', values[name]);
      form.appendChild(input);
    }
  }
  for (name in fields) {
    if (fields.hasOwnProperty(name)) {
      field = fields[name];
      if (field.isFile) {
        if (!form.$fileswap) {
          form.$fileswap = [];
        }
        inputComponent = field.getComponent().input;
        fileinputElement = inputComponent.dom;
        input = fileinputElement.cloneNode(true);
        fileinputElement.parentNode.insertBefore(input, fileinputElement.nextSibling);
        form.appendChild(fileinputElement);
        form.$fileswap.push({original:fileinputElement, placeholder:input});
      } else {
        if (field.isPassword) {
          if (field.getComponent().getType !== 'password') {
            field.setRevealed(false);
          }
        }
      }
    }
  }
  return form;
}, doBeforeSubmit:function(me, formValues, options) {
  var form = options.form || {}, multipartDetected = false;
  if (this.getMultipartDetection() === true) {
    this.getFieldsAsArray().forEach(function(field) {
      if (field.isFile === true) {
        multipartDetected = true;
        return false;
      }
    });
    if (multipartDetected) {
      form.setAttribute('enctype', 'multipart/form-data');
    }
  }
  if (options.enctype) {
    form.setAttribute('enctype', options.enctype);
  }
  if (me.getStandardSubmit()) {
    if (options.url && Ext.isEmpty(form.action)) {
      form.action = options.url;
    }
    var fields = this.query('spinnerfield'), ln = fields.length, i, field;
    for (i = 0; i < ln; i++) {
      field = fields[i];
      if (!field.getDisabled()) {
        field.getComponent().setDisabled(false);
      }
    }
    form.method = (options.method || form.method).toLowerCase();
    form.submit();
  } else {
    var api = me.getApi(), url = options.url || me.getUrl(), scope = options.scope || me, waitMsg = options.waitMsg, failureFn = function(response, responseText) {
      if (Ext.isFunction(options.failure)) {
        options.failure.call(scope, me, response, responseText);
      }
      me.fireEvent('exception', me, response);
    }, successFn = function(response, responseText) {
      if (Ext.isFunction(options.success)) {
        options.success.call(options.scope || me, me, response, responseText);
      }
      me.fireEvent('submit', me, response);
    }, submit;
    if (options.waitMsg) {
      if (typeof waitMsg === 'string') {
        waitMsg = {xtype:'loadmask', message:waitMsg};
      }
      me.setMasked(waitMsg);
    }
    if (api) {
      submit = api.submit;
      if (typeof submit === 'string') {
        submit = Ext.direct.Manager.parseMethod(submit);
        if (submit) {
          api.submit = submit;
        }
      }
      if (submit) {
        return submit(this.element, function(data, response, success) {
          me.setMasked(false);
          if (success) {
            if (data.success) {
              successFn(response, data);
            } else {
              failureFn(response, data);
            }
          } else {
            failureFn(response, data);
          }
        }, this);
      }
    } else {
      var request = Ext.merge({}, {url:url, timeout:this.getTimeout() * 1000, form:form, scope:me}, options);
      delete request.success;
      delete request.failure;
      request.params = Ext.merge(me.getBaseParams() || {}, options.params);
      request.header = Ext.apply({'Content-Type':'application/x-www-form-urlencoded; charset\x3dUTF-8'}, options.headers || {});
      request.callback = function(callbackOptions, success, response) {
        var responseText = response.responseText, responseXML = response.responseXML, statusResult = Ext.Ajax.parseStatus(response.status, response);
        if (form.$fileswap) {
          var original, placeholder;
          Ext.each(form.$fileswap, function(item) {
            original = item.original;
            placeholder = item.placeholder;
            placeholder.parentNode.insertBefore(original, placeholder.nextSibling);
            placeholder.parentNode.removeChild(placeholder);
          });
          form.$fileswap = null;
          delete form.$fileswap;
        }
        me.setMasked(false);
        if (response.success === false) {
          success = false;
        }
        if (success) {
          if (statusResult && responseText && responseText.length == 0) {
            success = true;
          } else {
            if (!Ext.isEmpty(response.responseBytes)) {
              success = statusResult.success;
            } else {
              if (Ext.isString(responseText) && response.request.options.responseType === 'text') {
                response.success = true;
              } else {
                if (Ext.isString(responseText)) {
                  try {
                    response = Ext.decode(responseText);
                  } catch (e$12) {
                    response.success = false;
                    response.error = e$12;
                    response.message = e$12.message;
                  }
                } else {
                  if (Ext.isSimpleObject(responseText)) {
                    response = responseText;
                    Ext.applyIf(response, {success:true});
                  }
                }
              }
              if (!Ext.isEmpty(responseXML)) {
                response.success = true;
              }
              success = !!response.success;
            }
          }
          if (success) {
            successFn(response, responseText);
          } else {
            failureFn(response, responseText);
          }
        } else {
          failureFn(response, responseText);
        }
      };
      if (Ext.feature.has.XHR2 && request.xhr2) {
        delete request.form;
        var formData = new FormData(form);
        if (request.params) {
          Ext.iterate(request.params, function(name, value) {
            if (Ext.isArray(value)) {
              Ext.each(value, function(v) {
                formData.append(name, v);
              });
            } else {
              formData.append(name, value);
            }
          });
          delete request.params;
        }
        request.data = formData;
      }
      return Ext.Ajax.request(request);
    }
  }
}, load:function(options) {
  options = options || {};
  var me = this, api = me.getApi(), url = me.getUrl() || options.url, waitMsg = options.waitMsg, successFn = function(response, data) {
    me.setValues(data.data);
    if (Ext.isFunction(options.success)) {
      options.success.call(options.scope || me, me, response, data);
    }
    me.fireEvent('load', me, response);
  }, failureFn = function(response, data) {
    if (Ext.isFunction(options.failure)) {
      options.failure.call(scope, me, response, data);
    }
    me.fireEvent('exception', me, response);
  }, load, method, args;
  if (options.waitMsg) {
    if (typeof waitMsg === 'string') {
      waitMsg = {xtype:'loadmask', message:waitMsg};
    }
    me.setMasked(waitMsg);
  }
  if (api) {
    load = api.load;
    if (typeof load === 'string') {
      load = Ext.direct.Manager.parseMethod(load);
      if (load) {
        api.load = load;
      }
    }
    if (load) {
      method = load.directCfg.method;
      args = method.getArgs(me.getParams(options.params), me.getParamOrder(), me.getParamsAsHash());
      args.push(function(data, response, success) {
        me.setMasked(false);
        if (success) {
          successFn(response, data);
        } else {
          failureFn(response, data);
        }
      }, me);
      return load.apply(window, args);
    }
  } else {
    if (url) {
      return Ext.Ajax.request({url:url, timeout:(options.timeout || this.getTimeout()) * 1000, method:options.method || 'GET', autoAbort:options.autoAbort, headers:Ext.apply({'Content-Type':'application/x-www-form-urlencoded; charset\x3dUTF-8'}, options.headers || {}), callback:function(callbackOptions, success, response) {
        var responseText = response.responseText, statusResult = Ext.Ajax.parseStatus(response.status, response);
        me.setMasked(false);
        if (success) {
          if (statusResult && responseText.length == 0) {
            success = true;
          } else {
            response = Ext.decode(responseText);
            success = !!response.success;
          }
          if (success) {
            successFn(response, responseText);
          } else {
            failureFn(response, responseText);
          }
        } else {
          failureFn(response, responseText);
        }
      }});
    }
  }
}, getParams:function(params) {
  return Ext.apply({}, params, this.getBaseParams());
}, setValues:function(values) {
  var fields = this.getFields(), me = this, name, field, value, ln, i, f;
  values = values || {};
  for (name in values) {
    if (values.hasOwnProperty(name)) {
      field = fields[name];
      value = values[name];
      if (field) {
        if (Ext.isArray(field)) {
          ln = field.length;
          for (i = 0; i < ln; i++) {
            f = field[i];
            if (f.isRadio) {
              f.setGroupValue(value);
              break;
            } else {
              if (f.isCheckbox) {
                if (Ext.isArray(value)) {
                  f.setChecked(value.indexOf(f._value) != -1);
                } else {
                  f.setChecked(value == f._value);
                }
              } else {
                if (Ext.isArray(value)) {
                  f.setValue(value[i]);
                }
              }
            }
          }
        } else {
          if (field.isRadio || field.isCheckbox) {
            field.setChecked(value);
          } else {
            field.setValue(value);
          }
        }
        if (me.getTrackResetOnLoad()) {
          field.resetOriginalValue();
        }
      }
    }
  }
  return this;
}, getValues:function(enabled, all) {
  var fields = this.getFields(), values = {}, isArray = Ext.isArray, field, value, addValue, bucket, name, ln, i;
  addValue = function(field, name) {
    if (!all && (!name || name === 'null') || field.isFile) {
      return;
    }
    if (field.isCheckbox) {
      value = field.getSubmitValue();
    } else {
      value = field.getValue();
    }
    if (!(enabled && field.getDisabled())) {
      if (field.isRadio) {
        if (field.isChecked()) {
          values[name] = value;
        }
      } else {
        bucket = values[name];
        if (!Ext.isEmpty(bucket)) {
          if (!isArray(bucket)) {
            bucket = values[name] = [bucket];
          }
          if (isArray(value)) {
            bucket = values[name] = bucket.concat(value);
          } else {
            bucket.push(value);
          }
        } else {
          values[name] = value;
        }
      }
    }
  };
  for (name in fields) {
    if (fields.hasOwnProperty(name)) {
      field = fields[name];
      if (isArray(field)) {
        ln = field.length;
        for (i = 0; i < ln; i++) {
          addValue(field[i], name);
        }
      } else {
        addValue(field, name);
      }
    }
  }
  return values;
}, reset:function() {
  this.getFieldsAsArray().forEach(function(field) {
    field.reset();
  });
  return this;
}, doSetDisabled:function(newDisabled) {
  this.getFieldsAsArray().forEach(function(field) {
    field.setDisabled(newDisabled);
  });
  return this;
}, getFieldsAsArray:function() {
  var fields = [], getFieldsFrom = function(item) {
    if (item.isField) {
      fields.push(item);
    }
    if (item.isContainer) {
      item.getItems().each(getFieldsFrom);
    }
  };
  this.getItems().each(getFieldsFrom);
  return fields;
}, getFields:function(byName) {
  var fields = {}, itemName;
  var getFieldsFrom = function(item) {
    if (item.isField) {
      itemName = item.getName();
      if (byName && itemName == byName || typeof byName == 'undefined') {
        if (fields.hasOwnProperty(itemName)) {
          if (!Ext.isArray(fields[itemName])) {
            fields[itemName] = [fields[itemName]];
          }
          fields[itemName].push(item);
        } else {
          fields[itemName] = item;
        }
      }
    }
    if (item.isContainer) {
      item.items.each(getFieldsFrom);
    }
  };
  this.getItems().each(getFieldsFrom);
  return byName ? fields[byName] || [] : fields;
}, getFieldsArray:function() {
  var fields = [];
  var getFieldsFrom = function(item) {
    if (item.isField) {
      fields.push(item);
    }
    if (item.isContainer) {
      item.items.each(getFieldsFrom);
    }
  };
  this.items.each(getFieldsFrom);
  return fields;
}, getFieldsFromItem:Ext.emptyFn, showMask:function(cfg, target) {
  cfg = Ext.isObject(cfg) ? cfg.message : cfg;
  if (cfg) {
    this.setMasked({xtype:'loadmask', message:cfg});
  } else {
    this.setMasked(true);
  }
  return this;
}, hideMask:function() {
  this.setMasked(false);
  return this;
}, getFocusedField:function() {
  var fields = this.getFieldsArray(), ln = fields.length, field, i;
  for (i = 0; i < ln; i++) {
    field = fields[i];
    if (field.isFocused) {
      return field;
    }
  }
  return null;
}, getNextField:function() {
  var fields = this.getFieldsArray(), focusedField = this.getFocusedField(), index;
  if (focusedField) {
    index = fields.indexOf(focusedField);
    if (index !== fields.length - 1) {
      index++;
      return fields[index];
    }
  }
  return false;
}, focusNextField:function() {
  var field = this.getNextField();
  if (field) {
    field.focus();
    return field;
  }
  return false;
}, getPreviousField:function() {
  var fields = this.getFieldsArray(), focusedField = this.getFocusedField(), index;
  if (focusedField) {
    index = fields.indexOf(focusedField);
    if (index !== 0) {
      index--;
      return fields[index];
    }
  }
  return false;
}, focusPreviousField:function() {
  var field = this.getPreviousField();
  if (field) {
    field.focus();
    return field;
  }
  return false;
}}, 0, ['formpanel'], ['component', 'container', 'panel', 'formpanel'], {'component':true, 'container':true, 'panel':true, 'formpanel':true}, ['widget.formpanel'], 0, [Ext.form, 'Panel', Ext.form, 'FormPanel'], function() {
});
Ext.cmd.derive('Ext.fx.runner.Css', Ext.Evented, {prefixedProperties:{'transform':true, 'transform-origin':true, 'perspective':true, 'transform-style':true, 'transition':true, 'transition-property':true, 'transition-duration':true, 'transition-timing-function':true, 'transition-delay':true, 'animation':true, 'animation-name':true, 'animation-duration':true, 'animation-iteration-count':true, 'animation-direction':true, 'animation-timing-function':true, 'animation-delay':true}, lengthProperties:{'top':true, 
'right':true, 'bottom':true, 'left':true, 'width':true, 'height':true, 'max-height':true, 'max-width':true, 'min-height':true, 'min-width':true, 'margin-bottom':true, 'margin-left':true, 'margin-right':true, 'margin-top':true, 'padding-bottom':true, 'padding-left':true, 'padding-right':true, 'padding-top':true, 'border-bottom-width':true, 'border-left-width':true, 'border-right-width':true, 'border-spacing':true, 'border-top-width':true, 'border-width':true, 'outline-width':true, 'letter-spacing':true, 
'line-height':true, 'text-indent':true, 'word-spacing':true, 'font-size':true, 'translate':true, 'translateX':true, 'translateY':true, 'translateZ':true, 'translate3d':true}, durationProperties:{'transition-duration':true, 'transition-delay':true, 'animation-duration':true, 'animation-delay':true}, angleProperties:{rotate:true, rotateX:true, rotateY:true, rotateZ:true, skew:true, skewX:true, skewY:true}, lengthUnitRegex:/([a-z%]*)$/, DEFAULT_UNIT_LENGTH:'px', DEFAULT_UNIT_ANGLE:'deg', DEFAULT_UNIT_DURATION:'ms', 
formattedNameCache:{}, constructor:function() {
  var supports3dTransform = Ext.feature.has.Css3dTransforms;
  if (supports3dTransform) {
    this.transformMethods = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY', 'scaleX', 'scaleY', 'scaleZ'];
  } else {
    this.transformMethods = ['translateX', 'translateY', 'rotate', 'skewX', 'skewY', 'scaleX', 'scaleY'];
  }
  this.vendorPrefix = Ext.browser.getStyleDashPrefix();
  this.ruleStylesCache = {};
  return this;
}, getStyleSheet:function() {
  var styleSheet = this.styleSheet, styleElement, styleSheets;
  if (!styleSheet) {
    styleElement = document.createElement('style');
    styleElement.type = 'text/css';
    (document.head || document.getElementsByTagName('head')[0]).appendChild(styleElement);
    styleSheets = document.styleSheets;
    this.styleSheet = styleSheet = styleSheets[styleSheets.length - 1];
  }
  return styleSheet;
}, applyRules:function(selectors) {
  var styleSheet = this.getStyleSheet(), ruleStylesCache = this.ruleStylesCache, rules = styleSheet.cssRules, selector, properties, ruleStyle, ruleStyleCache, rulesLength, name, value;
  for (selector in selectors) {
    properties = selectors[selector];
    ruleStyle = ruleStylesCache[selector];
    if (ruleStyle === undefined) {
      rulesLength = rules.length;
      styleSheet.insertRule(selector + '{}', rulesLength);
      ruleStyle = ruleStylesCache[selector] = rules.item(rulesLength).style;
    }
    ruleStyleCache = ruleStyle.$cache;
    if (!ruleStyleCache) {
      ruleStyleCache = ruleStyle.$cache = {};
    }
    for (name in properties) {
      value = this.formatValue(properties[name], name);
      name = this.formatName(name);
      if (ruleStyleCache[name] !== value) {
        ruleStyleCache[name] = value;
        if (value === null) {
          ruleStyle.removeProperty(name);
        } else {
          ruleStyle.setProperty(name, value, 'important');
        }
      }
    }
  }
  return this;
}, applyStyles:function(styles) {
  var id, element, elementStyle, properties, name, value;
  for (id in styles) {
    if (styles.hasOwnProperty(id)) {
      element = document.getElementById(id);
      if (!element) {
        return this;
      }
      elementStyle = element.style;
      properties = styles[id];
      for (name in properties) {
        if (properties.hasOwnProperty(name)) {
          value = this.formatValue(properties[name], name);
          name = this.formatName(name);
          if (value === null) {
            elementStyle.removeProperty(name);
          } else {
            elementStyle.setProperty(name, value, 'important');
          }
        }
      }
    }
  }
  return this;
}, formatName:function(name) {
  var cache = this.formattedNameCache, formattedName = cache[name];
  if (!formattedName) {
    if ((Ext.os.is.Tizen || !Ext.feature.has.CssTransformNoPrefix) && this.prefixedProperties[name]) {
      formattedName = this.vendorPrefix + name;
    } else {
      formattedName = name;
    }
    cache[name] = formattedName;
  }
  return formattedName;
}, formatValue:function(value, name) {
  var type = typeof value, lengthUnit = this.DEFAULT_UNIT_LENGTH, transformMethods, method, i, ln, transformValues, values, unit;
  if (value === null) {
    return '';
  }
  if (type == 'string') {
    if (this.lengthProperties[name]) {
      unit = value.match(this.lengthUnitRegex)[1];
      if (unit.length > 0) {
      } else {
        return value + lengthUnit;
      }
    }
    return value;
  } else {
    if (type == 'number') {
      if (value == 0) {
        return '0';
      }
      if (this.lengthProperties[name]) {
        return value + lengthUnit;
      }
      if (this.angleProperties[name]) {
        return value + this.DEFAULT_UNIT_ANGLE;
      }
      if (this.durationProperties[name]) {
        return value + this.DEFAULT_UNIT_DURATION;
      }
    } else {
      if (name === 'transform') {
        transformMethods = this.transformMethods;
        transformValues = [];
        for (i = 0, ln = transformMethods.length; i < ln; i++) {
          method = transformMethods[i];
          transformValues.push(method + '(' + this.formatValue(value[method], method) + ')');
        }
        return transformValues.join(' ');
      } else {
        if (Ext.isArray(value)) {
          values = [];
          for (i = 0, ln = value.length; i < ln; i++) {
            values.push(this.formatValue(value[i], name));
          }
          return values.length > 0 ? values.join(', ') : 'none';
        }
      }
    }
  }
  return value;
}}, 1, 0, 0, 0, 0, 0, [Ext.fx.runner, 'Css'], 0);
Ext.cmd.derive('Ext.fx.runner.CssTransition', Ext.fx.runner.Css, {listenersAttached:false, constructor:function() {
  this.runningAnimationsData = {};
  return Ext.fx.runner.Css.prototype.constructor.apply(this, arguments);
}, attachListeners:function() {
  this.listenersAttached = true;
  this.getEventDispatcher().addListener('element', '*', 'transitionend', 'onTransitionEnd', this);
}, onTransitionEnd:function(e) {
  var target = e.target, id = target.id;
  if (id && this.runningAnimationsData.hasOwnProperty(id)) {
    this.refreshRunningAnimationsData(Ext.get(target), [e.browserEvent.propertyName]);
  }
}, onAnimationEnd:function(element, data, animation, isInterrupted, isReplaced) {
  var id = element.getId(), runningData = this.runningAnimationsData[id], endRules = {}, endData = {}, runningNameMap, toPropertyNames, i, ln, name;
  animation.un('stop', 'onAnimationStop', this);
  if (runningData) {
    runningNameMap = runningData.nameMap;
  }
  endRules[id] = endData;
  if (data.onBeforeEnd) {
    data.onBeforeEnd.call(data.scope || this, element, isInterrupted);
  }
  animation.fireEvent('animationbeforeend', animation, element, isInterrupted);
  this.fireEvent('animationbeforeend', this, animation, element, isInterrupted);
  if (isReplaced || !isInterrupted && !data.preserveEndState) {
    toPropertyNames = data.toPropertyNames;
    for (i = 0, ln = toPropertyNames.length; i < ln; i++) {
      name = toPropertyNames[i];
      if (runningNameMap && !runningNameMap.hasOwnProperty(name)) {
        endData[name] = null;
      }
    }
  }
  if (data.after) {
    Ext.merge(endData, data.after);
  }
  this.applyStyles(endRules);
  if (data.onEnd) {
    data.onEnd.call(data.scope || this, element, isInterrupted);
  }
  animation.fireEvent('animationend', animation, element, isInterrupted);
  this.fireEvent('animationend', this, animation, element, isInterrupted);
  Ext.AnimationQueue.stop(Ext.emptyFn, animation);
}, onAllAnimationsEnd:function(element) {
  var id = element.getId(), endRules = {};
  delete this.runningAnimationsData[id];
  endRules[id] = {'transition-property':null, 'transition-duration':null, 'transition-timing-function':null, 'transition-delay':null};
  this.applyStyles(endRules);
  this.fireEvent('animationallend', this, element);
}, hasRunningAnimations:function(element) {
  var id = element.getId(), runningAnimationsData = this.runningAnimationsData;
  return runningAnimationsData.hasOwnProperty(id) && runningAnimationsData[id].sessions.length > 0;
}, refreshRunningAnimationsData:function(element, propertyNames, interrupt, replace) {
  var id = element.getId(), runningAnimationsData = this.runningAnimationsData, runningData = runningAnimationsData[id];
  if (!runningData) {
    return;
  }
  var nameMap = runningData.nameMap, nameList = runningData.nameList, sessions = runningData.sessions, ln, j, subLn, name, i, session, map, list, hasCompletedSession = false;
  interrupt = Boolean(interrupt);
  replace = Boolean(replace);
  if (!sessions) {
    return this;
  }
  ln = sessions.length;
  if (ln === 0) {
    return this;
  }
  if (replace) {
    runningData.nameMap = {};
    nameList.length = 0;
    for (i = 0; i < ln; i++) {
      session = sessions[i];
      this.onAnimationEnd(element, session.data, session.animation, interrupt, replace);
    }
    sessions.length = 0;
  } else {
    for (i = 0; i < ln; i++) {
      session = sessions[i];
      map = session.map;
      list = session.list;
      for (j = 0, subLn = propertyNames.length; j < subLn; j++) {
        name = propertyNames[j];
        if (map[name]) {
          delete map[name];
          Ext.Array.remove(list, name);
          session.length--;
          if (--nameMap[name] == 0) {
            delete nameMap[name];
            Ext.Array.remove(nameList, name);
          }
        }
      }
      if (session.length == 0) {
        sessions.splice(i, 1);
        i--;
        ln--;
        hasCompletedSession = true;
        this.onAnimationEnd(element, session.data, session.animation, interrupt);
      }
    }
  }
  if (!replace && !interrupt && sessions.length == 0 && hasCompletedSession) {
    this.onAllAnimationsEnd(element);
  }
}, getRunningData:function(id) {
  var runningAnimationsData = this.runningAnimationsData;
  if (!runningAnimationsData.hasOwnProperty(id)) {
    runningAnimationsData[id] = {nameMap:{}, nameList:[], sessions:[]};
  }
  return runningAnimationsData[id];
}, getTestElement:function() {
  var testElement = this.testElement, iframe, iframeDocument, iframeStyle;
  if (!testElement) {
    iframe = document.createElement('iframe');
    iframeStyle = iframe.style;
    iframeStyle.setProperty('visibility', 'hidden', 'important');
    iframeStyle.setProperty('width', '0px', 'important');
    iframeStyle.setProperty('height', '0px', 'important');
    iframeStyle.setProperty('position', 'absolute', 'important');
    iframeStyle.setProperty('border', '0px', 'important');
    iframeStyle.setProperty('zIndex', '-1000', 'important');
    document.body.appendChild(iframe);
    iframeDocument = iframe.contentDocument;
    iframeDocument.open();
    iframeDocument.writeln('\x3c/body\x3e');
    iframeDocument.close();
    this.testElement = testElement = iframeDocument.createElement('div');
    testElement.style.setProperty('position', 'absolute', 'important');
    iframeDocument.body.appendChild(testElement);
    this.testElementComputedStyle = window.getComputedStyle(testElement);
  }
  return testElement;
}, getCssStyleValue:function(name, value) {
  var testElement = this.getTestElement(), computedStyle = this.testElementComputedStyle, style = testElement.style;
  style.setProperty(name, value);
  if (Ext.browser.is.Firefox) {
    testElement.offsetHeight;
  }
  value = computedStyle.getPropertyValue(name);
  style.removeProperty(name);
  return value;
}, run:function(animations) {
  var me = this, isLengthPropertyMap = this.lengthProperties, fromData = {}, toData = {}, data = {}, element, elementId, from, to, before, fromPropertyNames, toPropertyNames, doApplyTo, message, runningData, elementData, i, j, ln, animation, propertiesLength, sessionNameMap, computedStyle, formattedName, name, toFormattedValue, computedValue, fromFormattedValue, isLengthProperty, runningNameMap, runningNameList, runningSessions, runningSession;
  if (!this.listenersAttached) {
    this.attachListeners();
  }
  animations = Ext.Array.from(animations);
  for (i = 0, ln = animations.length; i < ln; i++) {
    animation = animations[i];
    animation = Ext.factory(animation, Ext.fx.Animation);
    element = animation.getElement();
    Ext.AnimationQueue.start(Ext.emptyFn, animation);
    computedStyle = window.getComputedStyle(element.dom);
    elementId = element.getId();
    data = Ext.merge({}, animation.getData());
    if (animation.onBeforeStart) {
      animation.onBeforeStart.call(animation.scope || this, element);
    }
    animation.fireEvent('animationstart', animation);
    this.fireEvent('animationstart', this, animation);
    data[elementId] = data;
    before = data.before;
    from = data.from;
    to = data.to;
    data.fromPropertyNames = fromPropertyNames = [];
    data.toPropertyNames = toPropertyNames = [];
    for (name in to) {
      if (to.hasOwnProperty(name)) {
        to[name] = toFormattedValue = this.formatValue(to[name], name);
        formattedName = this.formatName(name);
        isLengthProperty = isLengthPropertyMap.hasOwnProperty(name);
        if (!isLengthProperty) {
          toFormattedValue = this.getCssStyleValue(formattedName, toFormattedValue);
        }
        if (from.hasOwnProperty(name)) {
          from[name] = fromFormattedValue = this.formatValue(from[name], name);
          if (!isLengthProperty) {
            fromFormattedValue = this.getCssStyleValue(formattedName, fromFormattedValue);
          }
          if (toFormattedValue !== fromFormattedValue) {
            fromPropertyNames.push(formattedName);
            toPropertyNames.push(formattedName);
          }
        } else {
          computedValue = computedStyle.getPropertyValue(formattedName);
          if (toFormattedValue !== computedValue) {
            toPropertyNames.push(formattedName);
          }
        }
      }
    }
    propertiesLength = toPropertyNames.length;
    if (propertiesLength === 0) {
      this.onAnimationEnd(element, data, animation);
      continue;
    }
    runningData = this.getRunningData(elementId);
    runningSessions = runningData.sessions;
    if (runningSessions.length > 0) {
      this.refreshRunningAnimationsData(element, Ext.Array.merge(fromPropertyNames, toPropertyNames), true, data.replacePrevious);
    }
    runningNameMap = runningData.nameMap;
    runningNameList = runningData.nameList;
    sessionNameMap = {};
    for (j = 0; j < propertiesLength; j++) {
      name = toPropertyNames[j];
      sessionNameMap[name] = true;
      if (!runningNameMap.hasOwnProperty(name)) {
        runningNameMap[name] = 1;
        runningNameList.push(name);
      } else {
        runningNameMap[name]++;
      }
    }
    runningSession = {element:element, map:sessionNameMap, list:toPropertyNames.slice(), length:propertiesLength, data:data, animation:animation};
    runningSessions.push(runningSession);
    animation.on('stop', 'onAnimationStop', this);
    elementData = Ext.apply({}, before);
    Ext.apply(elementData, from);
    if (runningNameList.length > 0) {
      fromPropertyNames = Ext.Array.difference(runningNameList, fromPropertyNames);
      toPropertyNames = Ext.Array.merge(fromPropertyNames, toPropertyNames);
      elementData['transition-property'] = fromPropertyNames;
    }
    fromData[elementId] = elementData;
    toData[elementId] = Ext.apply({}, to);
    toData[elementId]['transition-property'] = toPropertyNames;
    toData[elementId]['transition-duration'] = data.duration;
    toData[elementId]['transition-timing-function'] = data.easing;
    toData[elementId]['transition-delay'] = data.delay;
    animation.startTime = Date.now();
  }
  message = this.$className;
  this.applyStyles(fromData);
  doApplyTo = function(e) {
    if (e.data === message && e.source === window) {
      window.removeEventListener('message', doApplyTo, false);
      me.applyStyles(toData);
    }
  };
  if (Ext.browser.is.IE) {
    window.requestAnimationFrame(function() {
      window.addEventListener('message', doApplyTo, false);
      window.postMessage(message, '*');
    });
  } else {
    window.addEventListener('message', doApplyTo, false);
    window.postMessage(message, '*');
  }
}, onAnimationStop:function(animation) {
  var runningAnimationsData = this.runningAnimationsData, id, runningData, sessions, i, ln, session;
  for (id in runningAnimationsData) {
    if (runningAnimationsData.hasOwnProperty(id)) {
      runningData = runningAnimationsData[id];
      sessions = runningData.sessions;
      for (i = 0, ln = sessions.length; i < ln; i++) {
        session = sessions[i];
        if (session.animation === animation) {
          this.refreshRunningAnimationsData(session.element, session.list.slice(), false);
        }
      }
    }
  }
}}, 1, 0, 0, 0, 0, 0, [Ext.fx.runner, 'CssTransition'], 0);
Ext.cmd.derive('Ext.fx.Runner', Ext.Base, {constructor:function() {
  return new Ext.fx.runner.CssTransition;
}}, 1, 0, 0, 0, 0, 0, [Ext.fx, 'Runner'], 0);
Ext.cmd.derive('Ext.navigation.Bar', Ext.TitleBar, {isToolbar:true, config:{baseCls:'x-toolbar', cls:'x-navigation-bar', ui:'dark', title:null, defaultType:'button', layout:{type:'hbox'}, defaultBackButtonText:'Back', animation:{duration:300}, useTitleForBackButtonText:null, view:null, android2Transforms:false, backButton:{align:'left', ui:'back', hidden:true}}, platformConfig:[{theme:['Blackberry', 'Blackberry103'], animation:false}], constructor:function(config) {
  config = config || {};
  if (!config.items) {
    config.items = [];
  }
  this.backButtonStack = [];
  this.activeAnimations = [];
  Ext.TitleBar.prototype.constructor.call(this, config);
}, applyBackButton:function(config) {
  return Ext.factory(config, Ext.Button, this.getBackButton());
}, updateBackButton:function(newBackButton, oldBackButton) {
  if (oldBackButton) {
    this.remove(oldBackButton);
  }
  if (newBackButton) {
    this.add(newBackButton);
    newBackButton.on({scope:this, tap:this.onBackButtonTap});
  }
}, onBackButtonTap:function() {
  this.fireEvent('back', this);
}, updateView:function(newView) {
  var me = this, backButton = me.getBackButton(), innerItems, i, backButtonText, item, title, titleText;
  me.getItems();
  if (newView) {
    innerItems = newView.getInnerItems();
    for (i = 0; i < innerItems.length; i++) {
      item = innerItems[i];
      title = item.getTitle ? item.getTitle() : item.config.title;
      me.backButtonStack.push(title || '\x26nbsp;');
    }
    titleText = me.getTitleText();
    if (titleText === undefined) {
      titleText = '';
    }
    me.setTitle(titleText);
    backButtonText = me.getBackButtonText();
    if (backButtonText) {
      backButton.setText(backButtonText);
      backButton.show();
    }
  }
}, onViewAdd:function(view, item) {
  var me = this, backButtonStack = me.backButtonStack, hasPrevious, title;
  me.endAnimation();
  title = item.getTitle ? item.getTitle() : item.config.title;
  backButtonStack.push(title || '\x26nbsp;');
  hasPrevious = backButtonStack.length > 1;
  me.doChangeView(view, hasPrevious, false);
}, onViewRemove:function(view) {
  var me = this, backButtonStack = me.backButtonStack, hasPrevious;
  me.endAnimation();
  backButtonStack.pop();
  hasPrevious = backButtonStack.length > 1;
  me.doChangeView(view, hasPrevious, true);
}, doChangeView:function(view, hasPrevious, reverse) {
  var me = this, leftBox = me.leftBox, leftBoxElement = leftBox.element, titleComponent = me.titleComponent, titleElement = titleComponent.element, backButton = me.getBackButton(), titleText = me.getTitleText(), backButtonText = me.getBackButtonText(), animation = me.getAnimation() && view.getLayout().getAnimation(), animated = animation && animation.isAnimation && view.isPainted(), properties, leftGhost, titleGhost, leftProps, titleProps;
  if (animated) {
    leftGhost = me.createProxy(leftBox.element);
    leftBoxElement.setStyle('opacity', '0');
    backButton.setText(backButtonText);
    backButton[hasPrevious ? 'show' : 'hide']();
    titleGhost = me.createProxy(titleComponent.element.getParent());
    titleElement.setStyle('opacity', '0');
    me.setTitle(titleText);
    properties = me.measureView(leftGhost, titleGhost, reverse);
    leftProps = properties.left;
    titleProps = properties.title;
    me.isAnimating = true;
    me.animate(leftBoxElement, leftProps.element);
    me.animate(titleElement, titleProps.element, function() {
      titleElement.setLeft(properties.titleLeft);
      me.isAnimating = false;
      me.refreshTitlePosition();
    });
    if (Ext.browser.is.AndroidStock2 && !this.getAndroid2Transforms()) {
      leftGhost.ghost.destroy();
      titleGhost.ghost.destroy();
    } else {
      me.animate(leftGhost.ghost, leftProps.ghost);
      me.animate(titleGhost.ghost, titleProps.ghost, function() {
        leftGhost.ghost.destroy();
        titleGhost.ghost.destroy();
      });
    }
  } else {
    if (hasPrevious) {
      backButton.setText(backButtonText);
      backButton.show();
    } else {
      backButton.hide();
    }
    me.setTitle(titleText);
  }
}, measureView:function(oldLeft, oldTitle, reverse) {
  var me = this, barElement = me.element, newLeftElement = me.leftBox.element, titleElement = me.titleComponent.element, minOffset = Math.min(barElement.getWidth() / 3, 200), newLeftWidth = newLeftElement.getWidth(), barX = barElement.getX(), barWidth = barElement.getWidth(), titleX = titleElement.getX(), titleLeft = titleElement.getLeft(), titleWidth = titleElement.getWidth(), oldLeftX = oldLeft.x, oldLeftWidth = oldLeft.width, oldLeftLeft = oldLeft.left, useLeft = Ext.browser.is.AndroidStock2 && 
  !this.getAndroid2Transforms(), newOffset, oldOffset, leftAnims, titleAnims, omega, theta;
  theta = barX - oldLeftX - oldLeftWidth;
  if (reverse) {
    newOffset = theta;
    oldOffset = Math.min(titleX - oldLeftWidth, minOffset);
  } else {
    oldOffset = theta;
    newOffset = Math.min(titleX - barX, minOffset);
  }
  if (useLeft) {
    leftAnims = {element:{from:{left:newOffset, opacity:1}, to:{left:0, opacity:1}}};
  } else {
    leftAnims = {element:{from:{transform:{translateX:newOffset}, opacity:0}, to:{transform:{translateX:0}, opacity:1}}, ghost:{to:{transform:{translateX:oldOffset}, opacity:0}}};
  }
  theta = barX - titleX + newLeftWidth;
  if (oldLeftLeft + titleWidth > titleX) {
    omega = barX - titleX - titleWidth;
  }
  if (reverse) {
    titleElement.setLeft(0);
    oldOffset = barX + barWidth - titleX - titleWidth;
    if (omega !== undefined) {
      newOffset = omega;
    } else {
      newOffset = theta;
    }
  } else {
    newOffset = barX + barWidth - titleX - titleWidth;
    if (omega !== undefined) {
      oldOffset = omega;
    } else {
      oldOffset = theta;
    }
    newOffset = Math.max(titleLeft, newOffset);
  }
  if (useLeft) {
    titleAnims = {element:{from:{left:newOffset, opacity:1}, to:{left:titleLeft, opacity:1}}};
  } else {
    titleAnims = {element:{from:{transform:{translateX:newOffset}, opacity:0}, to:{transform:{translateX:titleLeft}, opacity:1}}, ghost:{to:{transform:{translateX:oldOffset}, opacity:0}}};
  }
  return {left:leftAnims, title:titleAnims, titleLeft:titleLeft};
}, animate:function(element, config, callback) {
  var me = this, animation;
  element.setLeft(0);
  config = Ext.apply(config, {element:element, easing:'ease-in-out', duration:me.getAnimation().duration || 250, preserveEndState:true});
  animation = new Ext.fx.Animation(config);
  animation.on('animationend', function() {
    if (callback) {
      callback.call(me);
    }
  }, me);
  Ext.Animator.run(animation);
  me.activeAnimations.push(animation);
}, endAnimation:function() {
  var activeAnimations = this.activeAnimations, animation, i, ln;
  if (activeAnimations) {
    ln = activeAnimations.length;
    for (i = 0; i < ln; i++) {
      animation = activeAnimations[i];
      if (animation.isAnimating) {
        animation.stopAnimation();
      } else {
        animation.destroy();
      }
    }
    this.activeAnimations = [];
  }
}, refreshTitlePosition:function() {
  if (!this.isAnimating) {
    Ext.TitleBar.prototype.refreshTitlePosition.call(this);
  }
}, getBackButtonText:function() {
  var text = this.backButtonStack[this.backButtonStack.length - 2], useTitleForBackButtonText = this.getUseTitleForBackButtonText();
  if (!useTitleForBackButtonText) {
    if (text) {
      text = this.getDefaultBackButtonText();
    }
  }
  return text;
}, getTitleText:function() {
  return this.backButtonStack[this.backButtonStack.length - 1];
}, beforePop:function(count) {
  count--;
  for (var i = 0; i < count; i++) {
    this.backButtonStack.pop();
  }
}, doSetHidden:function(hidden) {
  if (!hidden) {
    this.element.setStyle({position:'relative', top:'auto', left:'auto', width:'auto'});
  } else {
    this.element.setStyle({position:'absolute', top:'-1000px', left:'-1000px', width:this.element.getWidth() + 'px'});
  }
}, createProxy:function(element) {
  var ghost, x, y, left, width;
  ghost = element.dom.cloneNode(true);
  ghost.id = element.id + '-proxy';
  element.getParent().dom.appendChild(ghost);
  ghost = Ext.get(ghost);
  x = element.getX();
  y = element.getY();
  left = element.getLeft();
  width = element.getWidth();
  ghost.setStyle('position', 'absolute');
  ghost.setX(x);
  ghost.setY(y);
  ghost.setHeight(element.getHeight());
  ghost.setWidth(width);
  return {x:x, y:y, left:left, width:width, ghost:ghost};
}}, 1, 0, ['component', 'container', 'titlebar'], {'component':true, 'container':true, 'titlebar':true}, 0, 0, [Ext.navigation, 'Bar'], 0);
Ext.cmd.derive('Ext.navigation.View', Ext.Container, {alternateClassName:'Ext.NavigationView', config:{baseCls:'x-navigationview', navigationBar:{docked:'top'}, defaultBackButtonText:'Back', useTitleForBackButtonText:false, layout:{type:'card', animation:{duration:300, easing:'ease-out', type:'slide', direction:'left'}}}, platformConfig:[{theme:['Blackberry', 'Blackberry103'], navigationBar:{splitNavigation:true}}], initialize:function() {
  var me = this, navBar = me.getNavigationBar();
  if (navBar) {
    navBar.on({back:me.onBackButtonTap, scope:me});
    me.relayEvents(navBar, 'rightbuttontap');
    me.relayEvents(me, {add:'push', remove:'pop'});
  }
}, applyLayout:function(config) {
  config = config || {};
  return config;
}, onBackButtonTap:function() {
  this.pop();
  this.fireEvent('back', this);
}, push:function(view) {
  return this.add(view);
}, pop:function(count) {
  if (this.beforePop(count)) {
    return this.doPop();
  }
}, beforePop:function(count) {
  var me = this, innerItems = me.getInnerItems();
  if (Ext.isString(count) || Ext.isObject(count)) {
    var last = innerItems.length - 1, i;
    for (i = last; i >= 0; i--) {
      if (Ext.isString(count) && Ext.ComponentQuery.is(innerItems[i], count) || Ext.isObject(count) && count == innerItems[i]) {
        count = last - i;
        break;
      }
    }
    if (!Ext.isNumber(count)) {
      return false;
    }
  }
  var ln = innerItems.length, toRemove;
  if (!Ext.isNumber(count) || count < 1) {
    count = 1;
  }
  count = Math.min(count, ln - 1);
  if (count) {
    me.getNavigationBar().beforePop(count);
    toRemove = innerItems.splice(-count, count - 1);
    for (i = 0; i < toRemove.length; i++) {
      this.remove(toRemove[i]);
    }
    return true;
  }
  return false;
}, doPop:function() {
  var me = this, innerItems = this.getInnerItems();
  me.remove(innerItems[innerItems.length - 1]);
  if (innerItems.length < 3 && this.$backButton) {
    this.$backButton.hide();
  }
  if (this.$titleContainer) {
    var item = innerItems[innerItems.length - 2];
    this.$titleContainer.setTitle(item.getTitle ? item.getTitle() : item.config.title);
  }
  return this.getActiveItem();
}, getPreviousItem:function() {
  var innerItems = this.getInnerItems();
  return innerItems[innerItems.length - 2];
}, updateUseTitleForBackButtonText:function(useTitleForBackButtonText) {
  var navigationBar = this.getNavigationBar();
  if (navigationBar) {
    navigationBar.setUseTitleForBackButtonText(useTitleForBackButtonText);
  }
}, updateDefaultBackButtonText:function(defaultBackButtonText) {
  var navigationBar = this.getNavigationBar();
  if (navigationBar) {
    navigationBar.setDefaultBackButtonText(defaultBackButtonText);
  }
}, onBackButtonContainerAdd:function(toolbar, item) {
  item.on({scope:this, show:this.refreshBackButtonContainer, hide:this.refreshBackButtonContainer});
  this.refreshBackButtonContainer();
}, onBackButtonContainerRemove:function(toolbar, item) {
  item.un({scope:this, show:this.refreshBackButtonContainer, hide:this.refreshBackButtonContainer});
  this.refreshBackButtonContainer();
}, refreshBackButtonContainer:function() {
  if (!this.$backButtonContainer) {
    return;
  }
  var i = 0, backButtonContainer = this.$backButtonContainer, items = backButtonContainer.items, item;
  for (; i < items.length; i++) {
    item = items.get(i);
    if (!item.isHidden()) {
      this.$backButtonContainer.show();
      return;
    }
  }
  this.$backButtonContainer.hide();
}, applyNavigationBar:function(config) {
  var me = this;
  if (!config) {
    config = {hidden:true, docked:'top'};
  }
  if (config.title) {
    delete config.title;
  }
  config.view = this;
  config.useTitleForBackButtonText = this.getUseTitleForBackButtonText();
  if (config.splitNavigation) {
    this.$titleContainer = this.add({docked:'top', xtype:'titlebar', ui:'light', title:this.$currentTitle || ''});
    var containerConfig = config.splitNavigation === true ? {} : config.splitNavigation;
    this.$backButtonContainer = this.add({xtype:'toolbar', docked:'bottom', hidden:true});
    this.$backButtonContainer.on({scope:me, add:me.onBackButtonContainerAdd, remove:me.onBackButtonContainerRemove});
    this.$backButton = this.$backButtonContainer.add({xtype:'button', text:'Back', hidden:true, ui:'back'});
    if (config.items) {
      this.$backButtonContainer.add(config.items);
    }
    if (containerConfig.items) {
      this.$titleContainer.add(containerConfig.items);
    }
    this.$backButton.on({scope:this, tap:this.onBackButtonTap});
    config = {hidden:true, docked:'top'};
  }
  return Ext.factory(config, Ext.navigation.Bar, this.getNavigationBar());
}, updateNavigationBar:function(newNavigationBar, oldNavigationBar) {
  if (oldNavigationBar) {
    this.remove(oldNavigationBar, true);
  }
  if (newNavigationBar) {
    this.add(newNavigationBar);
  }
}, applyActiveItem:function(activeItem, currentActiveItem) {
  var me = this, innerItems = me.getInnerItems();
  me.getItems();
  if (!me.initialized) {
    activeItem = innerItems.length - 1;
  }
  return Ext.Container.prototype.applyActiveItem.call(this, activeItem, currentActiveItem);
}, doResetActiveItem:function(innerIndex) {
  var me = this, innerItems = me.getInnerItems(), animation = me.getLayout().getAnimation();
  if (innerIndex > 0) {
    if (animation && animation.isAnimation) {
      animation.setReverse(true);
    }
    me.setActiveItem(innerIndex - 1);
    me.getNavigationBar().onViewRemove(me, innerItems[innerIndex], innerIndex);
  }
}, doRemove:function() {
  var animation = this.getLayout().getAnimation();
  if (animation && animation.isAnimation) {
    animation.setReverse(false);
  }
  Ext.Container.prototype.doRemove.apply(this, arguments);
}, onItemAdd:function(item, index) {
  if (item && item.getDocked() && item.config.title === true) {
    this.$titleContainer = item;
  }
  this.doItemLayoutAdd(item, index);
  var navigaitonBar = this.getInitialConfig().navigationBar;
  if (!this.isItemsInitializing && item.isInnerItem()) {
    this.setActiveItem(item);
    if (navigaitonBar) {
      this.getNavigationBar().onViewAdd(this, item, index);
    }
    if (this.$backButtonContainer) {
      this.$backButton.show();
    }
  }
  if (item && item.isInnerItem()) {
    this.updateTitleContainerTitle(item.getTitle ? item.getTitle() : item.config.title);
  }
  if (this.initialized) {
    this.fireEvent('add', this, item, index);
  }
}, updateTitleContainerTitle:function(title) {
  if (this.$titleContainer) {
    this.$titleContainer.setTitle(title);
  } else {
    this.$currentTitle = title;
  }
}, reset:function() {
  return this.pop(this.getInnerItems().length);
}}, 0, ['navigationview'], ['component', 'container', 'navigationview'], {'component':true, 'container':true, 'navigationview':true}, ['widget.navigationview'], 0, [Ext.navigation, 'View', Ext, 'NavigationView'], 0);
Ext.cmd.derive('Ext.plugin.PullRefresh', Ext.Component, {config:{width:'100%', list:null, pullText:'Pull down to refresh...', releaseText:'Release to refresh...', loadingText:'Loading...', loadedText:'Loaded.', lastUpdatedText:'Last Updated:\x26nbsp;', scrollerAutoRefresh:false, autoSnapBack:true, snappingAnimationDuration:300, lastUpdatedDateFormat:'m/d/Y h:iA', overpullSnapBackDuration:300, pullTpl:['\x3cdiv class\x3d"x-list-pullrefresh-arrow"\x3e\x3c/div\x3e', '\x3cdiv class\x3d"x-loading-spinner"\x3e', 
'\x3cspan class\x3d"x-loading-top"\x3e\x3c/span\x3e', '\x3cspan class\x3d"x-loading-right"\x3e\x3c/span\x3e', '\x3cspan class\x3d"x-loading-bottom"\x3e\x3c/span\x3e', '\x3cspan class\x3d"x-loading-left"\x3e\x3c/span\x3e', '\x3c/div\x3e', '\x3cdiv class\x3d"x-list-pullrefresh-wrap"\x3e', '\x3ch3 class\x3d"x-list-pullrefresh-message"\x3e{message}\x3c/h3\x3e', '\x3cdiv class\x3d"x-list-pullrefresh-updated"\x3e{updated}\x3c/div\x3e', '\x3c/div\x3e'].join(''), translatable:true}, $state:'pull', getState:function() {
  return this.$state;
}, setState:function(value) {
  this.$state = value;
  this.updateView();
}, $isSnappingBack:false, getIsSnappingBack:function() {
  return this.$isSnappingBack;
}, setIsSnappingBack:function(value) {
  this.$isSnappingBack = value;
}, init:function(list) {
  var me = this;
  me.setList(list);
  me.initScrollable();
}, getElementConfig:function() {
  return {reference:'element', classList:['x-unsized'], children:[{reference:'innerElement', className:'x-list-pullrefresh'}]};
}, initScrollable:function() {
  var me = this, list = me.getList(), scrollable = list.getScrollable(), scroller;
  if (!scrollable) {
    return;
  }
  scroller = scrollable.getScroller();
  scroller.setAutoRefresh(this.getScrollerAutoRefresh());
  me.lastUpdated = new Date;
  list.insert(0, me);
  scroller.on({scroll:me.onScrollChange, scope:me});
  this.updateView();
}, applyPullTpl:function(config) {
  if (config instanceof Ext.XTemplate) {
    return config;
  } else {
    return new Ext.XTemplate(config);
  }
}, updateList:function(newList, oldList) {
  var me = this;
  if (newList && newList != oldList) {
    newList.on({order:'after', scrollablechange:me.initScrollable, scope:me});
  } else {
    if (oldList) {
      oldList.un({order:'after', scrollablechange:me.initScrollable, scope:me});
    }
  }
}, getPullHeight:function() {
  return this.innerElement.getHeight();
}, fetchLatest:function() {
  var store = this.getList().getStore(), proxy = store.getProxy(), operation;
  operation = Ext.create('Ext.data.Operation', {page:1, start:0, model:store.getModel(), limit:store.getPageSize(), action:'read', sorters:store.getSorters(), filters:store.getRemoteFilter() ? store.getFilters() : []});
  proxy.read(operation, this.onLatestFetched, this);
}, onLatestFetched:function(operation) {
  var store = this.getList().getStore(), oldRecords = store.getData(), newRecords = operation.getRecords(), length = newRecords.length, toInsert = [], newRecord, oldRecord, i;
  for (i = 0; i < length; i++) {
    newRecord = newRecords[i];
    oldRecord = oldRecords.getByKey(newRecord.getId());
    if (oldRecord) {
      oldRecord.set(newRecord.getData());
    } else {
      toInsert.push(newRecord);
    }
    oldRecord = undefined;
  }
  store.insert(0, toInsert);
  this.setState('loaded');
  this.fireEvent('latestfetched', this, toInsert);
  if (this.getAutoSnapBack()) {
    this.snapBack();
  }
}, snapBack:function(force) {
  if (this.getState() !== 'loaded' && force !== true) {
    return;
  }
  var list = this.getList(), scroller = list.getScrollable().getScroller();
  scroller.refresh();
  scroller.minPosition.y = 0;
  scroller.on({scrollend:this.onSnapBackEnd, single:true, scope:this});
  this.setIsSnappingBack(true);
  scroller.scrollTo(null, 0, {duration:this.getSnappingAnimationDuration()});
}, onSnapBackEnd:function() {
  this.setState('pull');
  this.setIsSnappingBack(false);
}, onScrollChange:function(scroller, x, y) {
  if (y <= 0) {
    var pullHeight = this.getPullHeight(), isSnappingBack = this.getIsSnappingBack();
    if (this.getState() === 'loaded' && !isSnappingBack) {
      this.snapBack();
    }
    if (this.getState() !== 'loading' && this.getState() !== 'loaded') {
      if (-y >= pullHeight + 10) {
        this.setState('release');
        scroller.getContainer().onBefore({dragend:'onScrollerDragEnd', single:true, scope:this});
      } else {
        if (this.getState() === 'release' && -y < pullHeight + 10) {
          this.setState('pull');
          scroller.getContainer().unBefore({dragend:'onScrollerDragEnd', single:true, scope:this});
        }
      }
    }
    this.getTranslatable().translate(0, -y);
  }
}, onScrollerDragEnd:function() {
  if (this.getState() !== 'loading') {
    var list = this.getList(), scroller = list.getScrollable().getScroller(), translateable = scroller.getTranslatable();
    this.setState('loading');
    translateable.setEasingY({duration:this.getOverpullSnapBackDuration()});
    scroller.minPosition.y = -this.getPullHeight();
    scroller.on({scrollend:'fetchLatest', single:true, scope:this});
  }
}, updateView:function() {
  var state = this.getState(), lastUpdatedText = this.getLastUpdatedText() + Ext.util.Format.date(this.lastUpdated, this.getLastUpdatedDateFormat()), templateConfig = {state:state, updated:lastUpdatedText}, stateFn = state.charAt(0).toUpperCase() + state.slice(1).toLowerCase(), fn = 'get' + stateFn + 'Text';
  if (this[fn] && Ext.isFunction(this[fn])) {
    templateConfig.message = this[fn].call(this);
  }
  this.innerElement.removeCls(['loaded', 'loading', 'release', 'pull'], 'x-list-pullrefresh');
  this.innerElement.addCls(this.getState(), 'x-list-pullrefresh');
  this.getPullTpl().overwrite(this.innerElement, templateConfig);
}}, 0, 0, ['component'], {'component':true}, ['plugin.pullrefresh'], 0, [Ext.plugin, 'PullRefresh'], function() {
  Ext.deprecateClassMethod(this, 'setPullRefreshText', 'setPullText');
  Ext.deprecateClassMethod(this, 'setReleaseRefreshText', 'setReleaseText');
  this.override({constructor:function(config) {
    if (config) {
      if (config.hasOwnProperty('pullReleaseText')) {
        config.releaseText = config.pullReleaseText;
        delete config.pullReleaseText;
      }
      if (config.hasOwnProperty('pullRefreshText')) {
        config.pullText = config.pullRefreshText;
        delete config.pullRefreshText;
      }
    }
    this.callParent([config]);
  }});
});
Ext.cmd.derive('Ext.tab.Tab', Ext.Button, {alternateClassName:'Ext.Tab', isTab:true, config:{baseCls:'x-tab', pressedCls:'x-tab-pressed', activeCls:'x-tab-active', active:false, title:'\x26nbsp;'}, updateIconCls:function(newCls, oldCls) {
  Ext.Button.prototype.updateIconCls.call(this, newCls, oldCls);
  if (oldCls) {
    this.removeCls('x-tab-icon');
  }
  if (newCls) {
    this.addCls('x-tab-icon');
  }
}, updateTitle:function(title) {
  this.setText(title);
}, updateActive:function(active, oldActive) {
  var activeCls = this.getActiveCls();
  if (active && !oldActive) {
    this.element.addCls(activeCls);
    this.fireEvent('activate', this);
  } else {
    if (oldActive) {
      this.element.removeCls(activeCls);
      this.fireEvent('deactivate', this);
    }
  }
}}, 0, ['tab'], ['component', 'button', 'tab'], {'component':true, 'button':true, 'tab':true}, ['widget.tab'], 0, [Ext.tab, 'Tab', Ext, 'Tab'], function() {
  this.override({activate:function() {
    this.setActive(true);
  }, deactivate:function() {
    this.setActive(false);
  }});
});
Ext.cmd.derive('Ext.tab.Bar', Ext.Toolbar, {alternateClassName:'Ext.TabBar', config:{baseCls:'x-tabbar', defaultType:'tab', layout:{type:'hbox', align:'middle'}}, eventedConfig:{activeTab:null}, platformConfig:[{theme:['Blackberry', 'Blackberry103', 'CupertinoClassic', 'MountainView'], defaults:{flex:1}}], initialize:function() {
  var me = this;
  Ext.Toolbar.prototype.initialize.call(this);
  me.on({tap:'onTabTap', delegate:'\x3e tab', scope:me});
}, onTabTap:function(tab) {
  this.setActiveTab(tab);
}, applyActiveTab:function(newActiveTab, oldActiveTab) {
  if (!newActiveTab && newActiveTab !== 0) {
    return;
  }
  var newTabInstance = this.parseActiveTab(newActiveTab);
  if (!newTabInstance) {
    return;
  }
  return newTabInstance;
}, doSetDocked:function(newDocked) {
  var layout = this.getLayout(), initialConfig = this.getInitialConfig(), pack;
  if (!initialConfig.layout || !initialConfig.layout.pack) {
    pack = newDocked == 'bottom' ? 'center' : 'left';
    if (layout.isLayout) {
      layout.setPack(pack);
    } else {
      layout.pack = layout && layout.pack ? layout.pack : pack;
    }
  }
  Ext.Toolbar.prototype.doSetDocked.apply(this, arguments);
}, doSetActiveTab:function(newTab, oldTab) {
  if (newTab) {
    newTab.setActive(true);
  }
  if (oldTab && oldTab.parent) {
    oldTab.setActive(false);
  }
}, parseActiveTab:function(tab) {
  if (typeof tab == 'number') {
    return this.getItems().items[tab];
  } else {
    if (typeof tab == 'string') {
      tab = Ext.getCmp(tab);
    }
  }
  return tab;
}}, 0, ['tabbar'], ['component', 'container', 'toolbar', 'tabbar'], {'component':true, 'container':true, 'toolbar':true, 'tabbar':true}, ['widget.tabbar'], 0, [Ext.tab, 'Bar', Ext, 'TabBar'], 0);
Ext.cmd.derive('Ext.tab.Panel', Ext.Container, {alternateClassName:'Ext.TabPanel', config:{ui:'dark', tabBar:true, tabBarPosition:'top', layout:{type:'card', animation:{type:'slide', direction:'left'}}, cls:'x-tabpanel'}, initialize:function() {
  Ext.Container.prototype.initialize.call(this);
  this.on({order:'before', activetabchange:'doTabChange', delegate:'\x3e tabbar', scope:this});
  this.on({disabledchange:'onItemDisabledChange', delegate:'\x3e component', scope:this});
}, platformConfig:[{theme:['Blackberry', 'Blackberry103'], tabBarPosition:'bottom'}], applyScrollable:function() {
  return false;
}, updateUi:function(newUi, oldUi) {
  Ext.Container.prototype.updateUi.apply(this, arguments);
  if (this.initialized) {
    this.getTabBar().setUi(newUi);
  }
}, doSetActiveItem:function(newActiveItem, oldActiveItem) {
  if (newActiveItem) {
    var items = this.getInnerItems(), oldIndex = items.indexOf(oldActiveItem), newIndex = items.indexOf(newActiveItem), reverse = oldIndex > newIndex, animation = this.getLayout().getAnimation(), tabBar = this.getTabBar(), oldTab = tabBar.parseActiveTab(oldIndex), newTab = tabBar.parseActiveTab(newIndex);
    if (animation && animation.setReverse) {
      animation.setReverse(reverse);
    }
    Ext.Container.prototype.doSetActiveItem.apply(this, arguments);
    if (newIndex != -1) {
      this.forcedChange = true;
      tabBar.setActiveTab(newIndex);
      this.forcedChange = false;
      if (oldTab) {
        oldTab.setActive(false);
      }
      if (newTab) {
        newTab.setActive(true);
      }
    }
  }
}, doTabChange:function(tabBar, newTab) {
  var oldActiveItem = this.getActiveItem(), newActiveItem;
  this.setActiveItem(tabBar.indexOf(newTab));
  newActiveItem = this.getActiveItem();
  return this.forcedChange || oldActiveItem !== newActiveItem;
}, applyTabBar:function(config) {
  if (config === true) {
    config = {};
  }
  if (config) {
    Ext.applyIf(config, {ui:this.getUi(), docked:this.getTabBarPosition()});
  }
  return Ext.factory(config, Ext.tab.Bar, this.getTabBar());
}, updateTabBar:function(newTabBar) {
  if (newTabBar) {
    this.add(newTabBar);
    this.setTabBarPosition(newTabBar.getDocked());
  }
}, updateTabBarPosition:function(position) {
  var tabBar = this.getTabBar();
  if (tabBar) {
    tabBar.setDocked(position);
  }
}, onItemAdd:function(card) {
  var me = this;
  if (!card.isInnerItem()) {
    return Ext.Container.prototype.onItemAdd.apply(this, arguments);
  }
  var tabBar = me.getTabBar(), initialConfig = card.getInitialConfig(), tabConfig = initialConfig.tab || {}, tabTitle = card.getTitle ? card.getTitle() : initialConfig.title, tabIconCls = card.getIconCls ? card.getIconCls() : initialConfig.iconCls, tabHidden = card.getHidden ? card.getHidden() : initialConfig.hidden, tabDisabled = card.getDisabled ? card.getDisabled() : initialConfig.disabled, tabBadgeText = card.getBadgeText ? card.getBadgeText() : initialConfig.badgeText, innerItems = me.getInnerItems(), 
  index = innerItems.indexOf(card), tabs = tabBar.getItems(), activeTab = tabBar.getActiveTab(), currentTabInstance = tabs.length >= innerItems.length && tabs.getAt(index), tabInstance;
  if (tabTitle && !tabConfig.title) {
    tabConfig.title = tabTitle;
  }
  if (tabIconCls && !tabConfig.iconCls) {
    tabConfig.iconCls = tabIconCls;
  }
  if (tabHidden && !tabConfig.hidden) {
    tabConfig.hidden = tabHidden;
  }
  if (tabDisabled && !tabConfig.disabled) {
    tabConfig.disabled = tabDisabled;
  }
  if (tabBadgeText && !tabConfig.badgeText) {
    tabConfig.badgeText = tabBadgeText;
  }
  tabInstance = Ext.factory(tabConfig, Ext.tab.Tab, currentTabInstance);
  if (!currentTabInstance) {
    tabBar.insert(index, tabInstance);
  }
  card.tab = tabInstance;
  Ext.Container.prototype.onItemAdd.apply(this, arguments);
  if (!activeTab && activeTab !== 0) {
    tabBar.setActiveTab(tabBar.getActiveItem());
  }
}, onItemDisabledChange:function(item, newDisabled) {
  if (item && item.tab) {
    item.tab.setDisabled(newDisabled);
  }
}, onItemRemove:function(item, index) {
  this.getTabBar().remove(item.tab, this.getAutoDestroy());
  Ext.Container.prototype.onItemRemove.apply(this, arguments);
}}, 0, ['tabpanel'], ['component', 'container', 'tabpanel'], {'component':true, 'container':true, 'tabpanel':true}, ['widget.tabpanel'], 0, [Ext.tab, 'Panel', Ext, 'TabPanel'], function() {
});
Ext.cmd.derive('Ext.util.paintmonitor.OverflowChange', Ext.util.paintmonitor.Abstract, {eventName:Ext.browser.is.Firefox ? 'overflow' : 'overflowchanged', monitorClass:'overflowchange', onElementPainted:function(e) {
  this.getCallback().apply(this.getScope(), this.getArgs());
}}, 0, 0, 0, 0, 0, 0, [Ext.util.paintmonitor, 'OverflowChange'], 0);
Ext.cmd.derive('Ext.viewport.Default', Ext.Container, {PORTRAIT:'portrait', LANDSCAPE:'landscape', config:{autoMaximize:false, autoBlurInput:true, preventPanning:true, preventZooming:false, autoRender:true, layout:'card', width:'100%', height:'100%', useBodyElement:true, menus:{}, orientation:null}, getElementConfig:function() {
  var cfg = Ext.Container.prototype.getElementConfig.apply(this, arguments);
  if (!Ext.feature.has.MatchMedia) {
    cfg.children.unshift({reference:'orientationElement', className:'x-orientation-inspector'});
  }
  return cfg;
}, isReady:false, isViewport:true, isMaximizing:false, id:'ext-viewport', isInputRegex:/^(input|textarea|select|a)$/i, isInteractiveWebComponentRegEx:/^(audio|video)$/i, focusedElement:null, fullscreenItemCls:'x-fullscreen', constructor:function(config) {
  var bind = Ext.Function.bind;
  this.doPreventPanning = bind(this.doPreventPanning, this);
  this.doPreventZooming = bind(this.doPreventZooming, this);
  this.doBlurInput = bind(this.doBlurInput, this);
  this.maximizeOnEvents = ['ready', 'orientationchange'];
  window.devicePixelRatio = window.devicePixelRatio || 1;
  Ext.Container.prototype.constructor.call(this, config);
  this.windowWidth = this.getWindowWidth();
  this.windowHeight = this.getWindowHeight();
  this.windowOuterHeight = this.getWindowOuterHeight();
  if (!this.stretchHeights) {
    this.stretchHeights = {};
  }
  if (Ext.feature.has.OrientationChange) {
    this.addWindowListener('orientationchange', bind(this.onOrientationChange, this));
  } else {
    this.addWindowListener('resize', bind(this.onResize, this));
  }
  document.addEventListener('focus', bind(this.onElementFocus, this), true);
  document.addEventListener('blur', bind(this.onElementBlur, this), true);
  Ext.onDocumentReady(this.onDomReady, this);
  this.on('ready', this.onReady, this, {single:true});
  this.getEventDispatcher().addListener('component', '*', 'fullscreen', 'onItemFullscreenChange', this);
  return this;
}, onDomReady:function() {
  this.isReady = true;
  this.updateSize();
  this.fireEvent('ready', this);
}, onReady:function() {
  if (this.getAutoRender()) {
    this.render();
  }
  if (Ext.browser.name == 'ChromeiOS') {
    this.setHeight('-webkit-calc(100% - ' + (window.outerHeight - window.innerHeight) / 2 + 'px)');
  }
}, onElementFocus:function(e) {
  this.focusedElement = e.target;
}, onElementBlur:function() {
  this.focusedElement = null;
}, render:function() {
  if (!this.rendered) {
    var body = Ext.getBody(), clsPrefix = 'x-', classList = [], osEnv = Ext.os, osName = osEnv.name.toLowerCase(), browserName = Ext.browser.name.toLowerCase(), osMajorVersion = osEnv.version.getMajor();
    this.renderTo(body);
    classList.push(clsPrefix + osEnv.deviceType.toLowerCase());
    if (osEnv.is.iPad) {
      classList.push(clsPrefix + 'ipad');
    }
    classList.push(clsPrefix + osName);
    classList.push(clsPrefix + browserName);
    if (osMajorVersion) {
      classList.push(clsPrefix + osName + '-' + osMajorVersion);
    }
    if (osEnv.is.BlackBerry) {
      classList.push(clsPrefix + 'bb');
      if (Ext.browser.userAgent.match(/Kbd/gi)) {
        classList.push(clsPrefix + 'bb-keyboard');
      }
    }
    if (Ext.browser.is.WebKit) {
      classList.push(clsPrefix + 'webkit');
    }
    if (Ext.browser.is.Standalone) {
      classList.push(clsPrefix + 'standalone');
    }
    if (Ext.browser.is.AndroidStock) {
      classList.push(clsPrefix + 'android-stock');
    }
    if (Ext.browser.is.GoogleGlass) {
      classList.push(clsPrefix + 'google-glass');
    }
    this.setOrientation(this.determineOrientation());
    classList.push(clsPrefix + this.getOrientation());
    body.addCls(classList);
  }
}, applyAutoBlurInput:function(autoBlurInput) {
  var touchstart = Ext.feature.has.Touch ? 'touchstart' : 'mousedown';
  if (autoBlurInput) {
    this.addWindowListener(touchstart, this.doBlurInput, false);
  } else {
    this.removeWindowListener(touchstart, this.doBlurInput, false);
  }
  return autoBlurInput;
}, applyAutoMaximize:function(autoMaximize) {
  if (Ext.browser.is.WebView) {
    autoMaximize = false;
  }
  if (autoMaximize) {
    this.on('ready', 'doAutoMaximizeOnReady', this, {single:true});
    this.on('orientationchange', 'doAutoMaximizeOnOrientationChange', this);
  } else {
    this.un('ready', 'doAutoMaximizeOnReady', this);
    this.un('orientationchange', 'doAutoMaximizeOnOrientationChange', this);
  }
  return autoMaximize;
}, applyPreventPanning:function(preventPanning) {
  if (preventPanning) {
    this.addWindowListener('touchmove', this.doPreventPanning, false);
  } else {
    this.removeWindowListener('touchmove', this.doPreventPanning, false);
  }
  return preventPanning;
}, applyPreventZooming:function(preventZooming) {
  var touchstart = Ext.feature.has.Touch ? 'touchstart' : 'mousedown';
  if (preventZooming) {
    this.addWindowListener(touchstart, this.doPreventZooming, false);
  } else {
    this.removeWindowListener(touchstart, this.doPreventZooming, false);
  }
  return preventZooming;
}, doAutoMaximizeOnReady:function() {
  var controller = arguments[arguments.length - 1];
  controller.pause();
  this.isMaximizing = true;
  this.on('maximize', function() {
    this.isMaximizing = false;
    this.updateSize();
    controller.resume();
    this.fireEvent('ready', this);
  }, this, {single:true});
  this.maximize();
}, doAutoMaximizeOnOrientationChange:function() {
  var controller = arguments[arguments.length - 1], firingArguments = controller.firingArguments;
  controller.pause();
  this.isMaximizing = true;
  this.on('maximize', function() {
    this.isMaximizing = false;
    this.updateSize();
    firingArguments[2] = this.windowWidth;
    firingArguments[3] = this.windowHeight;
    controller.resume();
  }, this, {single:true});
  this.maximize();
}, doBlurInput:function(e) {
  var target = e.target, focusedElement = this.focusedElement;
  if (focusedElement && focusedElement.nodeName.toUpperCase() != 'BODY' && !this.isInputRegex.test(target.tagName)) {
    delete this.focusedElement;
    focusedElement.blur();
  }
}, doPreventPanning:function(e) {
  var target = e.target, touch;
  if (this.isInteractiveWebComponentRegEx.test(target.tagName) && e.touches && e.touches.length > 0) {
    touch = e.touches[0];
    if (touch && touch.target && this.isInputRegex.test(touch.target.tagName)) {
      return;
    }
  }
  if (target && target.nodeType === 1 && !this.isInputRegex.test(target.tagName)) {
    e.preventDefault();
  }
}, doPreventZooming:function(e) {
  if ('button' in e && e.button !== 0) {
    return;
  }
  var target = e.target, touch;
  if (this.isInteractiveWebComponentRegEx.test(target.tagName) && e.touches && e.touches.length > 0) {
    touch = e.touches[0];
    if (touch && touch.target && this.isInputRegex.test(touch.target.tagName)) {
      return;
    }
  }
  if (target && target.nodeType === 1 && !this.isInputRegex.test(target.tagName)) {
    e.preventDefault();
  }
}, addWindowListener:function(eventName, fn, capturing) {
  window.addEventListener(eventName, fn, Boolean(capturing));
}, removeWindowListener:function(eventName, fn, capturing) {
  window.removeEventListener(eventName, fn, Boolean(capturing));
}, doAddListener:function(eventName, fn, scope, options) {
  if (eventName === 'ready' && this.isReady && !this.isMaximizing) {
    fn.call(scope);
    return this;
  }
  return Ext.Container.prototype.doAddListener.apply(this, arguments);
}, determineOrientation:function() {
  if (Ext.feature.has.Orientation) {
    var nativeOrientation = this.getWindowOrientation();
    if (Math.abs(nativeOrientation) === 90 || nativeOrientation === 270) {
      return this.LANDSCAPE;
    } else {
      return this.PORTRAIT;
    }
  } else {
    if (Ext.feature.has.MatchMedia) {
      return window.matchMedia('(orientation : landscape)').matches ? this.LANDSCAPE : this.PORTRAIT;
    } else {
      if (this.orientationElement) {
        return this.orientationElement.getStyle('content');
      }
    }
  }
}, updateOrientation:function(newValue, oldValue) {
  if (oldValue) {
    this.fireOrientationChangeEvent(newValue, oldValue);
  }
}, onOrientationChange:function() {
  this.setOrientation(this.determineOrientation());
}, onResize:function() {
  this.updateSize();
  this.setOrientation(this.determineOrientation());
}, fireOrientationChangeEvent:function(newOrientation, oldOrientation) {
  var clsPrefix = 'x-';
  Ext.getBody().replaceCls(clsPrefix + oldOrientation, clsPrefix + newOrientation);
  this.updateSize();
  this.fireEvent('orientationchange', this, newOrientation, this.windowWidth, this.windowHeight);
}, updateSize:function(width, height) {
  this.windowWidth = width !== undefined ? width : this.getWindowWidth();
  this.windowHeight = height !== undefined ? height : this.getWindowHeight();
  return this;
}, maximize:function() {
  this.fireMaximizeEvent();
}, fireMaximizeEvent:function() {
  this.updateSize();
  this.fireEvent('maximize', this);
}, doSetHeight:function(height) {
  Ext.getBody().setHeight(height);
  Ext.Container.prototype.doSetHeight.apply(this, arguments);
}, doSetWidth:function(width) {
  Ext.getBody().setWidth(width);
  Ext.Container.prototype.doSetWidth.apply(this, arguments);
}, scrollToTop:function() {
  window.scrollTo(0, -1);
}, getWindowWidth:function() {
  return window.innerWidth;
}, getWindowHeight:function() {
  return window.innerHeight;
}, getWindowOuterHeight:function() {
  return window.outerHeight;
}, getWindowOrientation:function() {
  return window.orientation;
}, getSize:function() {
  return {width:this.windowWidth, height:this.windowHeight};
}, onItemFullscreenChange:function(item) {
  item.addCls(this.fullscreenItemCls);
  this.add(item);
}, waitUntil:function(condition, onSatisfied, onTimeout, delay, timeoutDuration) {
  if (!delay) {
    delay = 50;
  }
  if (!timeoutDuration) {
    timeoutDuration = 2000;
  }
  var scope = this, elapse = 0;
  setTimeout(function repeat() {
    elapse += delay;
    if (condition.call(scope) === true) {
      if (onSatisfied) {
        onSatisfied.call(scope);
      }
    } else {
      if (elapse >= timeoutDuration) {
        if (onTimeout) {
          onTimeout.call(scope);
        }
      } else {
        setTimeout(repeat, delay);
      }
    }
  }, delay);
}, setMenu:function(menu, config) {
  var me = this;
  config = config || {};
  if (Ext.os.is.iOS && !this.hasiOSOrientationFix) {
    this.hasiOSOrientationFix = true;
    this.on('orientationchange', function() {
      window.scrollTo(0, 0);
    }, this);
  }
  if (!menu) {
    return;
  }
  if (!config.side) {
    return;
  }
  if (['left', 'right', 'top', 'bottom'].indexOf(config.side) == -1) {
    return;
  }
  var menus = me.getMenus();
  if (!menus) {
    menus = {};
  }
  if (!me.addedSwipeListener) {
    me.addedSwipeListener = true;
    me.element.on({tap:me.onTap, swipestart:me.onSwipeStart, edgeswipestart:me.onEdgeSwipeStart, edgeswipe:me.onEdgeSwipe, edgeswipeend:me.onEdgeSwipeEnd, scope:me});
    if (window.blackberry) {
      var toggleMenu = function() {
        var menus = me.getMenus(), menu = menus['top'];
        if (!menu) {
          return;
        }
        if (menu.isHidden()) {
          me.showMenu('top');
        } else {
          me.hideMenu('top');
        }
      };
      if (blackberry.app && blackberry.app.event && blackberry.app.event.onSwipeDown) {
        blackberry.app.event.onSwipeDown(toggleMenu);
      } else {
        if (blackberry.event && blackberry.event.addEventListener) {
          blackberry.event.addEventListener('swipedown', toggleMenu);
        }
      }
    }
  }
  menus[config.side] = menu;
  menu.$reveal = Boolean(config.reveal);
  menu.$cover = config.cover !== false && !menu.$reveal;
  menu.$side = config.side;
  me.fixMenuSize(menu, config.side);
  if (config.side == 'left') {
    menu.setLeft(0);
    menu.setRight(null);
    menu.setTop(0);
    menu.setBottom(0);
  } else {
    if (config.side == 'right') {
      menu.setLeft(null);
      menu.setRight(0);
      menu.setTop(0);
      menu.setBottom(0);
    } else {
      if (config.side == 'top') {
        menu.setLeft(0);
        menu.setRight(0);
        menu.setTop(0);
        menu.setBottom(null);
      } else {
        if (config.side == 'bottom') {
          menu.setLeft(0);
          menu.setRight(0);
          menu.setTop(null);
          menu.setBottom(0);
        }
      }
    }
  }
  me.setMenus(menus);
}, removeMenu:function(side) {
  var menus = this.getMenus() || {}, menu = menus[side];
  if (menu) {
    this.hideMenu(side);
  }
  delete menus[side];
  this.setMenus(menus);
}, fixMenuSize:function(menu, side) {
  if (side == 'top' || side == 'bottom') {
    menu.setWidth('100%');
  } else {
    if (side == 'left' || side == 'right') {
      menu.setHeight('100%');
    }
  }
}, showMenu:function(side) {
  var menus = this.getMenus(), menu = menus[side], before, after, viewportBefore, viewportAfter;
  if (!menu || menu.isAnimating) {
    return;
  }
  this.hideOtherMenus(side);
  before = {translateX:0, translateY:0};
  after = {translateX:0, translateY:0};
  viewportBefore = {translateX:0, translateY:0};
  viewportAfter = {translateX:0, translateY:0};
  if (menu.$reveal) {
    Ext.getBody().insertFirst(menu.element);
  } else {
    Ext.Viewport.add(menu);
  }
  menu.show();
  menu.addCls('x-' + side);
  var size = side == 'left' || side == 'right' ? menu.element.getWidth() : menu.element.getHeight();
  if (side == 'left') {
    before.translateX = -size;
    viewportAfter.translateX = size;
  } else {
    if (side == 'right') {
      before.translateX = size;
      viewportAfter.translateX = -size;
    } else {
      if (side == 'top') {
        before.translateY = -size;
        viewportAfter.translateY = size;
      } else {
        if (side == 'bottom') {
          before.translateY = size;
          viewportAfter.translateY = -size;
        }
      }
    }
  }
  if (menu.$reveal) {
    if (Ext.browser.getPreferredTranslationMethod() != 'scrollposition') {
      menu.translate(0, 0);
    }
  } else {
    menu.translate(before.translateX, before.translateY);
  }
  if (menu.$cover) {
    menu.getTranslatable().on('animationend', function() {
      menu.isAnimating = false;
    }, this, {single:true});
    menu.translate(after.translateX, after.translateY, {preserveEndState:true, duration:200});
  } else {
    this.translate(viewportBefore.translateX, viewportBefore.translateY);
    this.getTranslatable().on('animationend', function() {
      menu.isAnimating = false;
    }, this, {single:true});
    this.translate(viewportAfter.translateX, viewportAfter.translateY, {preserveEndState:true, duration:200});
  }
  menu.isAnimating = true;
}, hideMenu:function(side, animate) {
  var menus = this.getMenus(), menu = menus[side], after, viewportAfter, size;
  animate = animate === false ? false : true;
  if (!menu || (menu.isHidden() || menu.isAnimating)) {
    return;
  }
  after = {translateX:0, translateY:0};
  viewportAfter = {translateX:0, translateY:0};
  size = side == 'left' || side == 'right' ? menu.element.getWidth() : menu.element.getHeight();
  if (side == 'left') {
    after.translateX = -size;
  } else {
    if (side == 'right') {
      after.translateX = size;
    } else {
      if (side == 'top') {
        after.translateY = -size;
      } else {
        if (side == 'bottom') {
          after.translateY = size;
        }
      }
    }
  }
  if (menu.$cover) {
    if (animate) {
      menu.getTranslatable().on('animationend', function() {
        menu.isAnimating = false;
        menu.hide();
      }, this, {single:true});
      menu.translate(after.translateX, after.translateY, {preserveEndState:true, duration:200});
    } else {
      menu.translate(after.translateX, after.translateY);
      menu.hide();
    }
  } else {
    if (animate) {
      this.getTranslatable().on('animationend', function() {
        menu.isAnimating = false;
        menu.hide();
      }, this, {single:true});
      this.translate(viewportAfter.translateX, viewportAfter.translateY, {preserveEndState:true, duration:200});
    } else {
      this.translate(viewportAfter.translateX, viewportAfter.translateY);
      menu.hide();
    }
  }
}, hideAllMenus:function(animation) {
  var menus = this.getMenus();
  for (var side in menus) {
    this.hideMenu(side, animation);
  }
}, hideOtherMenus:function(side, animation) {
  var menus = this.getMenus();
  for (var menu in menus) {
    if (side != menu) {
      this.hideMenu(menu, animation);
    }
  }
}, toggleMenu:function(side) {
  var menus = this.getMenus(), menu;
  if (menus[side]) {
    menu = menus[side];
    if (menu.isHidden()) {
      this.showMenu(side);
    } else {
      this.hideMenu(side);
    }
  }
}, sideForDirection:function(direction) {
  if (direction == 'left') {
    return 'right';
  } else {
    if (direction == 'right') {
      return 'left';
    } else {
      if (direction == 'up') {
        return 'bottom';
      } else {
        if (direction == 'down') {
          return 'top';
        }
      }
    }
  }
}, sideForSwipeDirection:function(direction) {
  if (direction == 'up') {
    return 'top';
  } else {
    if (direction == 'down') {
      return 'bottom';
    }
  }
  return direction;
}, onTap:function(e) {
}, onSwipeStart:function(e) {
  var side = this.sideForSwipeDirection(e.direction);
  this.hideMenu(side);
}, onEdgeSwipeStart:function(e) {
  var side = this.sideForDirection(e.direction), menus = this.getMenus(), menu = menus[side], menuSide, checkMenu;
  if (!menu || !menu.isHidden()) {
    return;
  }
  for (menuSide in menus) {
    checkMenu = menus[menuSide];
    if (checkMenu.isHidden() !== false) {
      return;
    }
  }
  this.$swiping = true;
  this.hideAllMenus(false);
  if (menu.$reveal) {
    Ext.getBody().insertFirst(menu.element);
  } else {
    Ext.Viewport.add(menu);
  }
  menu.show();
  var size = side == 'left' || side == 'right' ? menu.element.getWidth() : menu.element.getHeight(), after, viewportAfter;
  after = {translateX:0, translateY:0};
  viewportAfter = {translateX:0, translateY:0};
  if (side == 'left') {
    after.translateX = -size;
  } else {
    if (side == 'right') {
      after.translateX = size;
    } else {
      if (side == 'top') {
        after.translateY = -size;
      } else {
        if (side == 'bottom') {
          after.translateY = size;
        }
      }
    }
  }
  var transformStyleName = 'webkitTransform' in document.createElement('div').style ? 'webkitTransform' : 'transform', setTransform = menu.element.dom.style[transformStyleName];
  if (setTransform) {
    menu.element.dom.style[transformStyleName] = '';
  }
  if (menu.$reveal) {
    if (Ext.browser.getPreferredTranslationMethod() != 'scrollposition') {
      menu.translate(0, 0);
    }
  } else {
    menu.translate(after.translateX, after.translateY);
  }
  if (!menu.$cover) {
    if (setTransform) {
      this.innerElement.dom.style[transformStyleName] = '';
    }
    this.translate(viewportAfter.translateX, viewportAfter.translateY);
  }
}, onEdgeSwipe:function(e) {
  var side = this.sideForDirection(e.direction), menu = this.getMenus()[side];
  if (!menu || !this.$swiping) {
    return;
  }
  var size = side == 'left' || side == 'right' ? menu.element.getWidth() : menu.element.getHeight(), after, viewportAfter, movement = Math.min(e.distance - size, 0), viewportMovement = Math.min(e.distance, size);
  after = {translateX:0, translateY:0};
  viewportAfter = {translateX:0, translateY:0};
  if (side == 'left') {
    after.translateX = movement;
    viewportAfter.translateX = viewportMovement;
  } else {
    if (side == 'right') {
      after.translateX = -movement;
      viewportAfter.translateX = -viewportMovement;
    } else {
      if (side == 'top') {
        after.translateY = movement;
        viewportAfter.translateY = viewportMovement;
      } else {
        if (side == 'bottom') {
          after.translateY = -movement;
          viewportAfter.translateY = -viewportMovement;
        }
      }
    }
  }
  if (menu.$cover) {
    menu.translate(after.translateX, after.translateY);
  } else {
    this.translate(viewportAfter.translateX, viewportAfter.translateY);
  }
}, onEdgeSwipeEnd:function(e) {
  var side = this.sideForDirection(e.direction), menu = this.getMenus()[side], shouldRevert = false;
  if (!menu) {
    return;
  }
  var size = side == 'left' || side == 'right' ? menu.element.getWidth() : menu.element.getHeight(), velocity = e.flick ? e.flick.velocity : 0;
  if (side == 'right') {
    if (velocity.x > 0) {
      shouldRevert = true;
    }
  } else {
    if (side == 'left') {
      if (velocity.x < 0) {
        shouldRevert = true;
      }
    } else {
      if (side == 'top') {
        if (velocity.y < 0) {
          shouldRevert = true;
        }
      } else {
        if (side == 'bottom') {
          if (velocity.y > 0) {
            shouldRevert = true;
          }
        }
      }
    }
  }
  var movement = shouldRevert ? size : 0, viewportMovement = shouldRevert ? 0 : -size, after, viewportAfter;
  after = {translateX:0, translateY:0};
  viewportAfter = {translateX:0, translateY:0};
  if (side == 'left') {
    after.translateX = -movement;
    viewportAfter.translateX = -viewportMovement;
  } else {
    if (side == 'right') {
      after.translateX = movement;
      viewportAfter.translateX = viewportMovement;
    } else {
      if (side == 'top') {
        after.translateY = -movement;
        viewportAfter.translateY = -viewportMovement;
      } else {
        if (side == 'bottom') {
          after.translateY = movement;
          viewportAfter.translateY = viewportMovement;
        }
      }
    }
  }
  if (menu.$cover) {
    menu.getTranslatable().on('animationend', function() {
      if (shouldRevert) {
        menu.hide();
      }
    }, this, {single:true});
    menu.translate(after.translateX, after.translateY, {preserveEndState:true, duration:200});
  } else {
    this.getTranslatable().on('animationend', function() {
      if (shouldRevert) {
        menu.hide();
      }
    }, this, {single:true});
    this.translate(viewportAfter.translateX, viewportAfter.translateY, {preserveEndState:true, duration:200});
  }
  this.$swiping = false;
}}, 1, ['viewport'], ['component', 'container', 'viewport'], {'component':true, 'container':true, 'viewport':true}, ['widget.viewport'], 0, [Ext.viewport, 'Default'], 0);
Ext.cmd.derive('Ext.viewport.AndroidStock', Ext.viewport.Default, {alternateClassName:['Ext.viewport.Android'], config:{translatable:{translationMethod:'csstransform'}}, constructor:function() {
  this.on('orientationchange', 'hideKeyboardIfNeeded', this, {prepend:true});
  Ext.viewport.Default.prototype.constructor.apply(this, arguments);
}, getWindowWidth:function() {
  return this.element.getWidth();
}, getWindowHeight:function() {
  return this.element.getHeight();
}, getDummyInput:function() {
  var input = this.dummyInput, focusedElement = this.focusedElement, box = Ext.fly(focusedElement).getPageBox();
  if (!input) {
    this.dummyInput = input = document.createElement('input');
    input.style.position = 'absolute';
    input.style.opacity = '0';
    input.style.pointerEvents = 'none';
    document.body.appendChild(input);
  }
  input.style.left = box.left + 'px';
  input.style.top = box.top + 'px';
  input.style.display = '';
  return input;
}, doBlurInput:function(e) {
  var target = e.target, focusedElement = this.focusedElement, dummy;
  if (focusedElement && !this.isInputRegex.test(target.tagName)) {
    dummy = this.getDummyInput();
    delete this.focusedElement;
    dummy.focus();
    setTimeout(function() {
      dummy.style.display = 'none';
    }, 100);
  }
}, hideKeyboardIfNeeded:function() {
  var eventController = arguments[arguments.length - 1], focusedElement = this.focusedElement;
  if (focusedElement) {
    delete this.focusedElement;
    eventController.pause();
    if (Ext.os.version.lt('4')) {
      focusedElement.style.display = 'none';
    } else {
      focusedElement.blur();
    }
    setTimeout(function() {
      focusedElement.style.display = '';
      eventController.resume();
    }, 1000);
  }
}, getActualWindowOuterHeight:function() {
  return Math.round(this.getWindowOuterHeight() / window.devicePixelRatio);
}, maximize:function() {
  var stretchHeights = this.stretchHeights, orientation = this.getOrientation(), height;
  height = stretchHeights[orientation];
  if (!height) {
    stretchHeights[orientation] = height = this.getActualWindowOuterHeight();
  }
  if (!this.addressBarHeight) {
    this.addressBarHeight = height - this.getWindowHeight();
  }
  this.setHeight(height);
  var isHeightMaximized = Ext.Function.bind(this.isHeightMaximized, this, [height]);
  this.scrollToTop();
  this.waitUntil(isHeightMaximized, this.fireMaximizeEvent, this.fireMaximizeEvent);
}, isHeightMaximized:function(height) {
  this.scrollToTop();
  return this.getWindowHeight() === height;
}, doPreventZooming:function(e) {
  if ('button' in e && e.button !== 0) {
    return;
  }
  var target = e.target;
  if (target && target.nodeType === 1 && !this.isInputRegex.test(target.tagName) && !this.focusedElement) {
    e.preventDefault();
  }
}}, 1, 0, ['component', 'container', 'viewport'], {'component':true, 'container':true, 'viewport':true}, 0, 0, [Ext.viewport, 'AndroidStock', Ext.viewport, 'Android'], function() {
  if (!Ext.os.is.Android) {
    return;
  }
  var version = Ext.os.version, userAgent = Ext.browser.userAgent, isBuggy = /(htc|desire|incredible|ADR6300)/i.test(userAgent) && version.lt('2.3');
  if (isBuggy) {
    this.override({constructor:function(config) {
      if (!config) {
        config = {};
      }
      config.autoMaximize = false;
      this.watchDogTick = Ext.Function.bind(this.watchDogTick, this);
      setInterval(this.watchDogTick, 1000);
      return this.callParent([config]);
    }, watchDogTick:function() {
      this.watchDogLastTick = Ext.Date.now();
    }, doPreventPanning:function() {
      var now = Ext.Date.now(), lastTick = this.watchDogLastTick, deltaTime = now - lastTick;
      if (deltaTime >= 2000) {
        return;
      }
      return this.callParent(arguments);
    }, doPreventZooming:function() {
      var now = Ext.Date.now(), lastTick = this.watchDogLastTick, deltaTime = now - lastTick;
      if (deltaTime >= 2000) {
        return;
      }
      return this.callParent(arguments);
    }});
  }
  if (version.match('2')) {
    this.override({onReady:function() {
      this.addWindowListener('resize', Ext.Function.bind(this.onWindowResize, this));
      this.callParent(arguments);
    }, scrollToTop:function() {
      document.body.scrollTop = 100;
    }, onWindowResize:function() {
      var oldWidth = this.windowWidth, oldHeight = this.windowHeight, width = this.getWindowWidth(), height = this.getWindowHeight();
      if (this.getAutoMaximize() && !this.isMaximizing && !this.orientationChanging && window.scrollY === 0 && oldWidth === width && height < oldHeight && (height >= oldHeight - this.addressBarHeight || !this.focusedElement)) {
        this.scrollToTop();
      }
    }});
  } else {
    if (version.gtEq('3.1')) {
      this.override({isHeightMaximized:function(height) {
        this.scrollToTop();
        return this.getWindowHeight() === height - 1;
      }});
    } else {
      if (version.match('3')) {
        this.override({isHeightMaximized:function() {
          this.scrollToTop();
          return true;
        }});
      }
    }
  }
  if (version.gtEq('4')) {
    this.override({doBlurInput:Ext.emptyFn});
  }
});
Ext.cmd.derive('Ext.viewport.Ios', Ext.viewport.Default, {isFullscreen:function() {
  return this.isHomeScreen();
}, isHomeScreen:function() {
  return window.navigator.standalone === true;
}, constructor:function() {
  Ext.viewport.Default.prototype.constructor.apply(this, arguments);
  if (this.getAutoMaximize() && !this.isFullscreen()) {
    this.addWindowListener('touchstart', Ext.Function.bind(this.onTouchStart, this));
  }
}, maximize:function() {
  if (this.isFullscreen()) {
    return Ext.viewport.Default.prototype.maximize.call(this);
  }
  var stretchHeights = this.stretchHeights, orientation = this.getOrientation(), currentHeight = this.getWindowHeight(), height = stretchHeights[orientation];
  if (window.scrollY > 0) {
    this.scrollToTop();
    if (!height) {
      stretchHeights[orientation] = height = this.getWindowHeight();
    }
    this.setHeight(height);
    this.fireMaximizeEvent();
  } else {
    if (!height) {
      height = this.getScreenHeight();
    }
    this.setHeight(height);
    this.waitUntil(function() {
      this.scrollToTop();
      return currentHeight !== this.getWindowHeight();
    }, function() {
      if (!stretchHeights[orientation]) {
        height = stretchHeights[orientation] = this.getWindowHeight();
        this.setHeight(height);
      }
      this.fireMaximizeEvent();
    }, function() {
      height = stretchHeights[orientation] = this.getWindowHeight();
      this.setHeight(height);
      this.fireMaximizeEvent();
    }, 50, 1000);
  }
}, getScreenHeight:function() {
  var orientation = this.getOrientation();
  return window.screen[orientation === this.PORTRAIT ? 'height' : 'width'];
}, onElementFocus:function() {
  if (this.getAutoMaximize() && !this.isFullscreen()) {
    clearTimeout(this.scrollToTopTimer);
  }
  Ext.viewport.Default.prototype.onElementFocus.apply(this, arguments);
}, onElementBlur:function() {
  if (this.getAutoMaximize() && !this.isFullscreen()) {
    this.scrollToTopTimer = setTimeout(this.scrollToTop, 500);
  }
  Ext.viewport.Default.prototype.onElementBlur.apply(this, arguments);
}, onTouchStart:function() {
  if (this.focusedElement === null) {
    this.scrollToTop();
  }
}, scrollToTop:function() {
  window.scrollTo(0, 0);
}}, 1, 0, ['component', 'container', 'viewport'], {'component':true, 'container':true, 'viewport':true}, 0, 0, [Ext.viewport, 'Ios'], function() {
  if (!Ext.os.is.iOS) {
    return;
  }
  if (Ext.os.version.lt('3.2')) {
    this.override({constructor:function() {
      var stretchHeights = this.stretchHeights = {};
      stretchHeights[this.PORTRAIT] = 416;
      stretchHeights[this.LANDSCAPE] = 268;
      return this.callOverridden(arguments);
    }});
  }
  if (Ext.os.version.lt('5')) {
    this.override({fieldMaskClsTest:'-field-mask', doPreventZooming:function(e) {
      var target = e.target;
      if (target && target.nodeType === 1 && !this.isInputRegex.test(target.tagName) && target.className.indexOf(this.fieldMaskClsTest) == -1) {
        e.preventDefault();
      }
    }});
  }
  if (Ext.os.is.iPad) {
    this.override({isFullscreen:function() {
      return true;
    }});
  }
  if (Ext.os.version.gtEq('7')) {
    if (Ext.os.deviceType === 'Tablet' || !Ext.browser.is.Safari || window.navigator.standalone) {
      this.override({constructor:function() {
        var stretchHeights = {}, stretchWidths = {}, orientation = this.determineOrientation(), screenHeight = window.screen.height, screenWidth = window.screen.width, menuHeight = orientation === this.PORTRAIT ? screenHeight - window.innerHeight : screenWidth - window.innerHeight;
        stretchHeights[this.PORTRAIT] = screenHeight - menuHeight;
        stretchHeights[this.LANDSCAPE] = screenWidth - menuHeight;
        stretchWidths[this.PORTRAIT] = screenWidth;
        stretchWidths[this.LANDSCAPE] = screenHeight;
        this.stretchHeights = stretchHeights;
        this.stretchWidths = stretchWidths;
        this.callOverridden(arguments);
        this.on('ready', this.setViewportSizeToAbsolute, this);
        this.on('orientationchange', this.setViewportSizeToAbsolute, this);
      }, getWindowHeight:function() {
        var orientation = this.getOrientation();
        return this.stretchHeights[orientation];
      }, getWindowWidth:function() {
        var orientation = this.getOrientation();
        return this.stretchWidths[orientation];
      }, setViewportSizeToAbsolute:function() {
        this.setWidth(this.getWindowWidth());
        this.setHeight(this.getWindowHeight());
      }});
    }
    if (Ext.os.deviceType === 'Tablet') {
      this.override({constructor:function() {
        this.callOverridden(arguments);
        window.addEventListener('scroll', function() {
          if (window.scrollX !== 0) {
            window.scrollTo(0, window.scrollY);
          }
        }, false);
      }, setViewportSizeToAbsolute:function() {
        window.scrollTo(0, 0);
        this.callOverridden(arguments);
      }, onElementBlur:function() {
        this.callOverridden(arguments);
        if (window.scrollY !== 0) {
          window.scrollTo(0, 0);
        }
      }});
    }
  }
});
Ext.cmd.derive('Ext.viewport.WindowsPhone', Ext.viewport.Default, {alternateClassName:'Ext.viewport.WP', config:{translatable:{translationMethod:'csstransform'}}, initialize:function() {
  var preventSelection = function(e) {
    var srcElement = e.srcElement.nodeName.toUpperCase(), selectableElements = ['INPUT', 'TEXTAREA'];
    if (selectableElements.indexOf(srcElement) == -1) {
      return false;
    }
  };
  document.body.addEventListener('onselectstart', preventSelection);
  Ext.viewport.Default.prototype.initialize.apply(this, arguments);
}}, 0, 0, ['component', 'container', 'viewport'], {'component':true, 'container':true, 'viewport':true}, 0, 0, [Ext.viewport, 'WindowsPhone', Ext.viewport, 'WP'], 0);
Ext.cmd.derive('Ext.viewport.Viewport', Ext.Base, {constructor:function(config) {
  var osName = Ext.os.name, viewportName, viewport;
  switch(osName) {
    case 'Android':
      viewportName = Ext.browser.name == 'ChromeMobile' ? 'Default' : 'AndroidStock';
      break;
    case 'iOS':
      viewportName = 'Ios';
      break;
    case 'Windows':
      viewportName = Ext.browser.name == 'IE' ? 'WindowsPhone' : 'Default';
      break;
    case 'WindowsPhone':
      viewportName = 'WindowsPhone';
      break;
    default:
      viewportName = 'Default';
      break;
  }
  viewport = Ext.create('Ext.viewport.' + viewportName, config);
  return viewport;
}}, 1, 0, 0, 0, 0, 0, [Ext.viewport, 'Viewport'], 0);
Ext.cmd.derive('Xedu.CommonUtils', Ext.Base, {singleton:true, ns:'Xedu', checkServiceError:function(response) {
  if (response && response.errorInfo) {
    var msg = 'The following errors occured! Please check your input! \x3cbr /\x3e\x3cbr /\x3e';
    if (response.errorInfo.errors) {
      for (var i = 0; i < response.errorInfo.errors.length; i++) {
        msg += response.errorInfo.errors[i].errorMsg + '\x3cbr /\x3e\x3cbr /\x3e';
      }
    } else {
    }
    Ext.Msg.alert('Errors', msg, Ext.emptyFn);
  } else {
    if (response && (response.status || response.msg) && isNaN(response.status)) {
      console.log('response status \x3d ' + response.status + ', msg\x3d ' + response.msg);
    } else {
      this._checkHTTPOperation(response);
    }
  }
  return true;
}, _checkHTTPOperation:function(resp) {
  if (!resp) {
    return;
  }
  if (resp.status) {
    var showMsg = '';
    var showTitle = 'ERROR';
    var showIconCls = 'error-generic-icon-cls';
    switch(resp.status) {
      case 200:
        break;
      case 401:
        showMsg = 'Sorry! You do not have sufficient privileges to access this feature! \x3cbr/\x3e \x3cbr/\x3ePlease contact your administrator if you think this is an error! ';
        showTitle = 'UNAUTHORIZED';
        showIconCls = 'error-unauth-icon-cls';
        break;
      case 404:
        showMsg = 'Sorry! The server could not be reached! Please try after sometime or contact support! ';
        showTitle = 'Server error!';
        showIconCls = 'error-unauth-icon-cls';
        break;
      case 405:
        showMsg = 'Sorry! This operation is not valid! Please check again! ';
        showTitle = 'NOT ALLOWED';
        showIconCls = 'error-unauth-icon-cls';
        break;
      case 503:
        showMsg = 'Sorry! The server is currently unavailable to process your request! \x3cbr /\x3e Please try again or contact support! ';
        showTitle = 'Server maintainence';
        showIconCls = 'error-unauth-icon-cls';
        break;
      default:
        showMsg = 'Sorry! An exception occured while trying to perform this operation , reason \x3d ' + resp.status + '\x3cbr /\x3e\x3cbr /\x3e Please contact support for further assistance';
    }
    Ext.Msg.alert(showTitle, showMsg, Ext.emptyFn);
  }
}, showOverlay:function(showPanel, options) {
  var scope = this;
  var widthOpt = '65%';
  var heightOpt = '80%';
  var closable = false;
  var cls = '';
  var showByItemEl = null;
  var modal = true;
  var showHeader = false;
  var titleOpt = '';
  var callBackFunction = Ext.emptyFn;
  var callBackScope = null;
  var closeActionFn = null;
  if (typeof options != 'undefined') {
    if (typeof options.width != 'undefined') {
      widthOpt = options.width;
    }
    if (typeof options.height != 'undefined') {
      heightOpt = options.height;
    }
    if (typeof options.closable != 'undefined') {
      closable = options.closable;
      showHeader = options.closable;
    }
    if (typeof options.cls != 'undefined') {
      cls = options.cls;
    }
    if (typeof options.modal != 'undefined') {
      modal = options.modal;
    }
    if (typeof options.showBy != 'undefined') {
      showByItemEl = options.showBy;
    }
    if (typeof options.title != 'undefined') {
      titleOpt = options.title;
    }
    if (options.callme) {
      callBackFunction = options.callme;
      if (options.callmeScope) {
        callBackScope = options.callmeScope;
      } else {
        console.error('callmeScope is missing!  Please provide a callback scope');
      }
    }
    if (options.closeActionFn) {
      closeActionFn = options.closeActionFn;
      if (options.callbackScope) {
        callBackScope = options.callbackScope;
      } else {
        console.error('callbackScope is missing!  Please provide a callback scope, if you have a closeActionFn is taken');
      }
    }
  } else {
  }
  try {
    if (scope.overlay) {
      scope.overlay.destroy();
    }
  } catch (e$13) {
    console.log(e$13);
  }
  scope.overlay = Ext.Viewport.add({xtype:'panel', layout:'fit', itemId:'overlay-id', modal:true, autoDestroy:true, hideOnMaskTap:false, showBy:showByItemEl, showAnimation:{type:'popIn', duration:250, easing:'ease-out'}, hideAnimation:{type:'popOut', duration:250, easing:'ease-out'}, centered:true, width:Ext.filterPlatform('ie10') ? '100%' : Ext.os.deviceType == 'Phone' ? 260 : widthOpt, height:Ext.filterPlatform('ie10') ? '30%' : Ext.os.deviceType == 'Phone' ? 220 : heightOpt, items:[{docked:'top', 
  xtype:'toolbar', title:titleOpt, items:[{xtype:'button', text:'close', handler:function(but, action, eOpts) {
    Xedu.CommonUtils.closeOverlay(scope);
  }}]}], listeners:{hide:function() {
    if (closeActionFn && typeof closeActionFn === 'function') {
      console.log('overlay destroyed....calling back closeActionFn');
      closeActionFn(callBackScope);
    }
  }}, scrollable:true});
  scope.overlay.show();
  var addPanel = Ext.create(showPanel.xtype, showPanel);
  scope.overlay.add(addPanel);
  addPanel.show();
}, showOverlay2:function(showPanel, showByEl) {
  try {
    if (this.overlay) {
      this.overlay.destroy();
    }
  } catch (e$14) {
    console.log(e$14);
  }
  this.overlay = Ext.Viewport.add(showPanel);
  if (showByEl) {
    this.overlay.showBy(showByEl);
  } else {
    this.overlay.show();
  }
}, closeOverlay:function(scope) {
  if (scope.overlay) {
    scope.overlay.hide();
  }
}, getLoggedInUserId:function() {
  var cntrller = Xedu.app.getController('Main');
  if (cntrller.getLoggedInUser()) {
    return cntrller.getLoggedInUser();
  } else {
    return null;
  }
}, getSessionInfo:function() {
  var cntrller = Xedu.app.getController('Main');
  if (cntrller.getSessionInfo()) {
    return cntrller.getSessionInfo();
  } else {
    return null;
  }
}, checkUserHasRole:function(role) {
  var cntrller = Xedu.app.getController('Main');
  var sessionInfo = cntrller.getSessionInfo();
  if (!sessionInfo) {
    return false;
  }
  if (sessionInfo.userrole.indexOf(role) > 0) {
    return true;
  } else {
    false;
  }
}, filterStore:function(searchOnlist, searchvalue) {
  searchOnlist.getStore().clearFilter();
  searchOnlist.getStore().filter(function(rec) {
    var searchOnString = '';
    var recData = rec.getData();
    for (var val in recData) {
      searchOnString += ' ' + recData[val];
    }
    searchOnString = searchOnString.toLowerCase();
    searchvalue = searchvalue.toLowerCase();
    if (searchOnString.indexOf(searchvalue) > -1) {
      return true;
    } else {
      return false;
    }
  });
}, sendSocketEvent:function(event) {
  var cntrller = Xedu.app.getController('Main');
  if (cntrller.wsConn == null) {
    console.log('socket connection not available ! So reconnecting.....');
  } else {
    console.log('sending event message....' + Ext.JSON.encode(event.getData()));
    cntrller.wsConn.send(Ext.JSON.encode(event.getData()));
  }
}, sendStompSocketEvent:function(queue, event) {
  var cntrller = Xedu.app.getController('Main');
  if (cntrller.stompClient == null) {
    console.error('stomp client connection not available ! So reconnecting.....');
    Ext.Msg.alert('App upgraded', 'Application will now be reloaded to apply the latest fixes!', function() {
      window.location.reload();
    });
  } else {
    cntrller.stompClient.send('/veda' + queue, {}, Ext.JSON.encode(event.getData()));
  }
}, broadCastEventIfPresenter:function(event) {
  var cntrller = Xedu.app.getController('Main');
  try {
    var queue = cntrller.getPresenterTopicEndpoint();
    if (queue != null && queue != '') {
      if (cntrller.stompClient == null) {
        console.error('stomp client connection not available ! So reconnecting.....');
        Ext.Msg.alert('App upgraded', 'Application will now be reloaded to apply the latest fixes!', function() {
          window.location.reload();
        });
      } else {
        cntrller.stompClient.send('/veda' + queue, {}, Ext.JSON.encode(event.getData()));
      }
    }
  } catch (e$15) {
    Ext.Msg.alert('Exception code#CU-BCEP-1999', 'Reason \x3d ' + e$15);
  }
}, subscribeToStompQueue:function(queue, callbackFn) {
  try {
    var cntrller = Xedu.app.getController('Main');
    var stompClient = cntrller.stompClient;
    if (stompClient == null) {
      console.error('stomp client connection not available ! So reconnecting.....');
      Ext.Msg.alert('App upgraded', 'Application will now be reloaded to apply the latest fixes!', function() {
        window.location.reload();
      });
    } else {
      console.log('subscribing to the queue ....' + queue);
      return stompClient.subscribe(queue, callbackFn);
    }
  } catch (e$16) {
    Ext.Msg.alert('Exception code#CU-STSQ-1999', 'Reason \x3d ' + e$16);
  }
}, unsubscribeToStompQueue:function(id, callbackFn) {
  var stompClient = Xedu.app.getController('Main').stompClient;
  try {
    if (stompClient == null) {
      console.error('stomp client connection not available ! So reconnecting.....');
      Ext.Msg.alert('App upgraded', 'Application will now be reloaded to apply the latest fixes!', function() {
        window.location.reload();
      });
    } else {
      console.log('subscribing to the queue ....' + queue);
      stompClient.unsubscribe(queue, callbackFn);
    }
  } catch (e$17) {
    Ext.Msg.alert('Exception code#CU-USTSQ-1999', 'Reason \x3d ' + e$17);
  }
}, showInDebugPanel:function(debugMsg) {
  var debugPanel = Ext.ComponentQuery.query('#debugpanelid')[0];
  if (!debugPanel) {
    return;
  }
  if (debugPanel.isHidden()) {
    return;
  }
  var store = debugPanel.getStore();
  store.insert(0, {dt:new Date, msg:debugMsg});
}}, 0, 0, 0, 0, ['CommonUtils'], 0, [Xedu, 'CommonUtils'], 0);
Ext.cmd.derive('Xedu.Config', Ext.Base, {singleton:true, AppConfigs:null, ns:'Xedu', REST_SERVICES_APP_CONTEXT_ROOT:'/veda', SOCKET_SERVICE:'/io/', SPRING_SOCKET_SERVICE:'/hello/', EVENT_SESSION_SOCKET_SERVER:'/veda-eventsession-wsocket', EVENT_SESSION_START_API:'/api/eventsessions/start', EVENT_SESSION_JOIN_API:'/api/eventsessions/join', EVENT_SESSION_FULL_DETAILS:'/api/eventsessions/details/', AUTH_SERVICE:'/api/auth/login', AUTH_FORGOT_PASSWORD_SERVICE:'/api/auth/forgotpassword', AUTH_USER_SERVICE:'/api/auth/user', 
AUTH_USER_LOGOUT:'/api/auth/logoff', COURSE_SEARCH:'/api/course/search', COURSE_API:'/api/course/', CHAPTERS_SEARCH:'/api/chapter/search', CHAPTER_API:'/api/chapter/', TOPIC_API:'/api/topic/', TOPICS_SEARCH:'/api/topic/search', SLIDES_LIST_SEARCH_BY_TOPIC:'/api/slides/topic/', SLIDE_IMAGE_THUMB:'/api/slides/image/thumb/', SLIDE_IMAGE_LARGE:'/api/slides/image/large/', SLIDE_CONTENT_UPLOAD:'/uploadslides', SLIDE_GENERATE:'/api/slides/generate/{topicid}/{uploadedfileid}', CONFIG_SECTIONS:'/api/config', 
CONFIG_UPDATE_SERVICE:'/api/config', CONFIG_SECTIONS_KEYVAL:'/api/config/keyval', USER_SEARCH_SERVICE:'/api/user/search', USER_SERVICE:'/api/user', CHG_PASSWORD_SERVICE:'/api/auth/updatepassword', UPLOAD_PROFILE_IMAGE_SERVICE:'/upload_profile_image', PROFILE_IMAGE_THUMB_SERVICE:'/api/user/image/large/', ALLOWED_ACTIONS_API:'/api/user/allowedactions/{recordType}/{recordId}', CLASSROOM_API:'/api/classroom/', CLASSROOM_SEARCH:'/api/classroom/search', ENROLLMENT_API:'/api/enrollment/', CLASSROOM_ENROLLED_STUDENTS_SEARCH:'/api/enrollment/search', 
STUDENT_ENROLLED_CLASSES_SEARCH:'/api/enrollment/search', EVENT_SCHEDULE_API:'/api/eventschedule', CLASSROOM_SCHEDULE_SEARCH:'/api/eventschedule/search', STUDENT_SCHEDULE_SEARCH:'/api/eventschedule/search', EVENT_SESSION_SCHEDULE_DETAILS:'/api/eventschedule/session/', disable_security:false, getUrl:function(serv) {
  if (!serv) {
    return '';
  }
  var protocol = window.location.protocol.indexOf('https:') === 0 ? 'https' : 'http';
  if (serv.indexOf('/io') > -1) {
    protocol = window.location.protocol.indexOf('https:') === 0 ? 'wss' : 'ws';
  }
  if (serv.indexOf('ws:/') > -1) {
    protocol = window.location.protocol.indexOf('https:') === 0 ? 'wss' : 'ws';
    serv = serv.replace('ws:/', '');
  }
  if (serv.indexOf('https://') > -1 || serv.indexOf('http://') > -1 || serv.indexOf('ws://') > -1 || serv.indexOf('wss://') > -1) {
    return serv;
  } else {
    if (serv.indexOf('.com') > -1) {
      return protocol + '://' + serv;
    } else {
      return protocol + '://' + window.location.host + this.REST_SERVICES_APP_CONTEXT_ROOT + serv;
    }
  }
}, getAppConfigs:function() {
  return this.appConfigs;
}, setAppConfigs:function(acfgs) {
  this.appConfigs = acfgs;
}, loadAppConfigs:function() {
  console.log('loading app configs');
  var me = this;
  var authUrl = Xedu.Config.getUrl(Xedu.Config.CONFIG_SECTIONS_KEYVAL);
  Ext.Ajax.request({url:authUrl, method:'GET', scope:this, callback:function(response, success, operation) {
    var respObj = null;
    if (operation.responseText && operation.responseText != '' && operation.responseText.indexOf('\x3chtml\x3e') == -1) {
      try {
        respObj = Ext.JSON.decode(operation.responseText);
      } catch (e$18) {
        console.log(e$18);
      }
    }
    if (respObj != null) {
      me.setAppConfigs(respObj);
    }
  }});
}, getConfigValue:function(cfgkey) {
  var configs = this.getAppConfigs();
  return configs[cfgkey];
}}, 0, 0, 0, 0, ['Config'], 0, [Xedu, 'Config'], 0);
Ext.cmd.derive('Xedu.store.SlidesListStore', Ext.data.Store, {require:['Xedu.Config', 'Ext.data.proxy.Rest'], config:{fields:[{name:'recordId', type:'string'}, {name:'recordTitle', type:'string'}, {name:'recordSubtitle', type:'string'}], pageSize:10, remoteSort:false, autoLoad:false, proxy:{type:'rest', url:Xedu.Config.getUrl(Xedu.Config.SLIDES_LIST_SEARCH_BY_TOPIC), reader:{type:'json', rootProperty:'hits', totalProperty:'totalHits', idProperty:'recordId'}, filterParam:'name'}}}, 0, 0, 0, 0, ['store.slides-list-store'], 
0, [Xedu.store, 'SlidesListStore'], 0);
Ext.cmd.derive('Xedu.view.slides.SlidesList', Ext.Panel, {config:{layout:'vbox', title:'Slides', topicid:null, scrollable:true, autoDestroy:true, callbackScope:null, callbackOnSelect:null, closeOnSelect:false, hideTitlebar:false, items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'Slides', layout:{type:'hbox', pack:'right'}, defaults:{ui:'plain'}, items:[{xtype:'button', iconCls:'add', handler:function(but, action, eOpts) {
  this.up('slides-list-panel').topicContentUpload();
}}]}, {xtype:'searchfield', placeHolder:'search slides...', align:'center', ui:'dark', height:50, listeners:{keyup:function(el, e, eOpts) {
  Xedu.CommonUtils.filterStore(this.up('slides-list-panel').down('list'), el.getValue());
}}}, {xtype:'list', flex:1, itemId:'slides-list-panel-id', title:'Slides', scrollable:true, autoDestroy:true, store:{type:'slides-list-store'}, plugins:[{xclass:'Ext.plugin.PullRefresh', pullText:'Pull down to refresh the list!'}], itemTpl:['\x3cdiv style\x3d"vertical-align:middle; text-align:center;width:100%;height:100%"\x3e', '\t\t\t\x3cimg src\x3d"' + Xedu.Config.getUrl(Xedu.Config.SLIDE_IMAGE_THUMB) + '{recordId}" /\x3e\x3cbr /\x3e', '\t\t\t\x3cspan style\x3d"color:gray"\x3eTitle: \x3c/span\x3e{recordTitle}, ', 
'\x3c/div\x3e'], listeners:{show:function(thisView, opts) {
  if (thisView.getTopicid() != '') {
    thisView.up('slides-list-panel').loadslideslist(thisView.getTopicid());
  }
}, itemsingletap:function(scope, index, target, record) {
  var slidesListPanel = scope.up('slides-list-panel');
  slidesListPanel.showSlideOnFullView(scope, index, target, record);
  var event = Ext.create('Xedu.model.EventModel', {});
  event.set('type', 'ACTION');
  event.set('to', Ext.JSON.decode("['all']"));
  event.set('msg', "{'route':'topic/" + slidesListPanel.getTopicid() + '/slide/' + record.getData().recordId + "'}");
  Xedu.CommonUtils.broadCastEventIfPresenter(event);
}}}], listeners:{show:function(thisView, opts) {
  thisView.down('titlebar').setHidden(thisView.getHideTitlebar());
  thisView.loadslideslist(thisView.getTopicid());
}}}, loadslideslist:function(id) {
  if (id) {
    this.topicid = id;
  } else {
  }
  console.log('showing...slides from loadslideslist ');
  var thisView = this;
  thisView.setMasked({msg:'Loading slides...'});
  var slideListStore = thisView.down('list').getStore();
  var topicid = thisView.getTopicid();
  slideListStore.getProxy().setUrl(Xedu.Config.getUrl(Xedu.Config.SLIDES_LIST_SEARCH_BY_TOPIC) + topicid);
  slideListStore.load({callback:function(records, operation, success) {
    thisView.setMasked(false);
    thisView.showSlideById();
  }});
}, showSlideOnFullView:function(scope, index, target, record) {
  console.log('showing slide id \x3d ' + record.data.id);
  var fullView = this.up('slides-main-view').down('slides-fullview-list');
  fullView.addSlide(record);
}, showSlideById:function(slideid) {
  var fullView = this.up('slides-main-view');
  if (fullView.getSlideid() && fullView.getSlideid() != '') {
    var slideList = this.down('list');
    var slideStore = slideList.getStore();
    console.log('setting active slide item \x3d ' + fullView.getSlideid());
    var record = slideStore.getById(fullView.getSlideid());
    this.showSlideOnFullView(this, null, null, record);
  }
}, reload:function() {
  this.down('list').getStore().load();
}, topicContentUpload:function() {
  var topicIdParam = this.getTopicid();
  var me = this;
  var newContentUploadFormPanel = {xtype:'Xedu.view.slides.ContentUpload', topicid:topicIdParam};
  Xedu.CommonUtils.showOverlay(newContentUploadFormPanel, {title:'Upload Topic Slides', width:500, height:400, callme:me.reloadSlidesList, callmeScope:me});
}}, 0, ['slides-list-panel'], ['component', 'container', 'panel', 'slides-list-panel'], {'component':true, 'container':true, 'panel':true, 'slides-list-panel':true}, ['widget.slides-list-panel'], 0, [Xedu.view.slides, 'SlidesList'], 0);
Ext.cmd.derive('Xedu.model.SearchHitModel', Ext.data.Model, {config:{fields:[{name:'recordId', type:'string'}, {name:'recordTitle', type:'string'}, {name:'recordSubtitle', type:'string'}]}}, 0, 0, 0, 0, 0, 0, [Xedu.model, 'SearchHitModel'], 0);
Ext.cmd.derive('Xedu.ux.Transform', Ext.Base, {config:{}, m:[1, 0, 0, 0, 0, 0], reset:function() {
  this.m = [1, 0, 0, 1, 0, 0];
}, clone:function() {
  var k = new Ext.create('Xedu.ux.Transform');
  for (var i = 0; i < this.m.length; i++) {
    k.m[i] = this.m[i];
  }
  return k;
}, multiply:function(matrix) {
  var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
  var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];
  var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
  var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];
  var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
  var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];
  this.m[0] = m11;
  this.m[1] = m12;
  this.m[2] = m21;
  this.m[3] = m22;
  this.m[4] = dx;
  this.m[5] = dy;
}, invert:function() {
  var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
  var m0 = this.m[3] * d;
  var m1 = -this.m[1] * d;
  var m2 = -this.m[2] * d;
  var m3 = this.m[0] * d;
  var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
  var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
  this.m[0] = m0;
  this.m[1] = m1;
  this.m[2] = m2;
  this.m[3] = m3;
  this.m[4] = m4;
  this.m[5] = m5;
}, rotate:function(rad) {
  var c = Math.cos(rad);
  var s = Math.sin(rad);
  var m11 = this.m[0] * c + this.m[2] * s;
  var m12 = this.m[1] * c + this.m[3] * s;
  var m21 = this.m[0] * -s + this.m[2] * c;
  var m22 = this.m[1] * -s + this.m[3] * c;
  this.m[0] = m11;
  this.m[1] = m12;
  this.m[2] = m21;
  this.m[3] = m22;
}, translate:function(x, y) {
  this.m[4] += this.m[0] * x + this.m[2] * y;
  this.m[5] += this.m[1] * x + this.m[3] * y;
}, scale:function(sx, sy) {
  this.m[0] *= sx;
  this.m[1] *= sx;
  this.m[2] *= sy;
  this.m[3] *= sy;
}, transformPoint:function(px, py) {
  var x = px;
  var y = py;
  px = x * this.m[0] + y * this.m[2] + this.m[4];
  py = x * this.m[1] + y * this.m[3] + this.m[5];
  return [px, py];
}}, 0, 0, 0, 0, 0, 0, [Xedu.ux, 'Transform'], 0);
Ext.cmd.derive('Xedu.ux.PinchZoomImage', Ext.Container, {config:{src:null, isFrozen:false, scaleFactor:1.1, useMouseWheelEvent:true, styleHtmlContent:true, layout:'fit', html:'\x3ccanvas style\x3d"position:absolute;top:0px;left:0px;width:100%;height:100%;"/\x3e', listeners:{scope:this, painted:function(cmp) {
  cmp.redraw();
}, doubletap:{fn:function(e, el, obj) {
  if (this.getIsFrozen()) {
    return;
  }
  this.redraw();
}, element:'element', delegate:'canvas'}, dragstart:{fn:function(e, el, obj) {
  if (this.getIsFrozen()) {
    return;
  }
  this.lastX = e.pageX;
  this.lastY = e.pageY;
  document.body.style.mozUserSelect = document.body.style.webkitUserSelect = document.body.style.userSelect = 'none';
  this.dragStart = this.ctx.transformedPoint(this.lastX, this.lastY);
  this.dragged = false;
}, element:'element', delegate:'canvas'}, dragend:{fn:function(e, el, obj) {
  this.dragged = false;
  if (this.getIsFrozen()) {
    return;
  }
  this.lastX = e.pageX;
  this.lastY = e.pageY;
  this.dragStart = null;
}, element:'element', delegate:'canvas'}, drag:{fn:function(e, el, obj) {
  if (this.getIsFrozen()) {
    return;
  }
  this.lastX = e.pageX;
  this.lastY = e.pageY;
  if (this.dragStart && this.isScaled) {
    var pt = this.ctx.transformedPoint(this.lastX, this.lastY);
    this.ctx.translate(pt.x - this.dragStart.x, pt.y - this.dragStart.y);
    this.draw();
  }
  this.lastX = e.offsetX || e.pageX - this.canvas.offsetLeft;
  this.lastY = e.offsetY || e.pageY - this.canvas.offsetTop;
}, element:'element', delegate:'canvas'}, pinchstart:{fn:function(e, el, obj) {
  if (this.getIsFrozen()) {
    return;
  }
  this.lastX = e.pageX;
  this.lastY = e.pageY;
  this.dragged = false;
}, element:'element', delegate:'canvas'}, pinchend:{fn:function(e, el, obj) {
  if (this.getIsFrozen()) {
    return;
  }
  this.lastX = e.pageX;
  this.lastY = e.pageY;
  dragged = false;
}, element:'element', delegate:'canvas'}, pinch:{fn:function(e, el, obj) {
  if (this.getIsFrozen()) {
    return;
  }
  this.zoom(e.scale - 1);
  this.dragged = true;
}, element:'element', delegate:'canvas'}}}, lastX:0, lastY:0, image:null, canvas:null, ctx:null, srcWidth:null, srcHeight:null, destWidth:null, destHeight:null, ratioWidth:null, ratioHeight:null, canvasWidth:null, canvasHeight:null, isScaled:false, applySrc:function(value) {
  if (value != null && value != '') {
    var img = this.getImage();
    img.src = value;
  }
  return value;
}, getImage:function() {
  if (this.image == null) {
    this.image = new Image;
    this.image.onload = function(m) {
      return function() {
        m.onLoadImage();
      };
    }(this);
    this.image.onerror = this.onErrorImage;
    this.image.onabor = this.onAbortImage;
  }
  return this.image;
}, resetCanvas:function() {
  if (this.canvas != null) {
    this.isScaled = false;
    this.zoomValue = 0;
    this.ctx.reset();
    this.canvas.width = this.element.getWidth();
    this.canvas.height = this.element.getHeight();
    this.lastX = this.canvasWidth / 2;
    this.lastY = this.canvasHeight / 2;
  }
}, handleScroll:function(evt) {
  if (!this.getUseMouseWheelEvent()) {
    return;
  }
  var delta = evt.wheelDelta ? evt.wheelDelta / 40 : evt.detail ? -evt.detail : 0;
  if (delta) {
    this.zoom(delta);
  }
  return evt.preventDefault() && false;
}, trackTransforms:function(ctx) {
  var xform = Ext.create('Xedu.ux.Transform');
  ctx.getTransform = function() {
    return xform;
  };
  var savedTransforms = [];
  var save = ctx.save;
  ctx.save = function() {
    savedTransforms.push(xform.translate(0, 0));
    return save.call(ctx);
  };
  var restore = ctx.restore;
  ctx.restore = function() {
    xform = savedTransforms.pop();
    return restore.call(ctx);
  };
  var translate = ctx.translate;
  ctx.translate = function(dx, dy) {
    xform.translate(dx, dy);
    return translate.call(ctx, dx, dy);
  };
  ctx.reset = function(dx, dy) {
    xform.reset();
  };
  var scale = ctx.scale;
  ctx.scale = function(sx, sy) {
    xform.scale(sx, sy);
    return scale.call(ctx, sx, sy);
  };
  var pt = {x:0, y:0};
  var setTransform = ctx.setTransform;
  ctx.transformedPoint = function(x, y) {
    var xform2 = xform.clone();
    xform2.invert();
    var pt2 = xform2.transformPoint(x, y);
    var newPt = {x:pt2[0], y:pt2[1]};
    return newPt;
  };
}, zoom:function(zValue) {
  if (this.zoomValue + zValue < 0) {
    return;
  }
  this.isScaled = true;
  this.zoomValue += zValue;
  var pt = this.ctx.transformedPoint(this.lastX, this.lastY);
  this.ctx.translate(pt.x, pt.y);
  var factor = Math.pow(this.getScaleFactor(), zValue / 2);
  this.ctx.scale(factor, factor);
  this.ctx.translate(-pt.x, -pt.y);
  this.draw();
}, redraw:function() {
  this.resetCanvas();
  this.draw();
}, draw:function() {
  if (this.image.complete == true && this.ctx != null) {
    var p1 = this.ctx.transformedPoint(0, 0);
    var p2 = this.ctx.transformedPoint(this.canvas.width, this.canvas.height);
    this.ctx.clearRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
    this.srcWidth = this.image.width;
    this.srcHeight = this.image.height;
    this.destWidth = this.canvas.width;
    this.destHeight = this.canvas.height;
    this.ratioWidth = this.srcWidth / this.destWidth;
    this.ratioHeight = this.srcHeight / this.destHeight;
    if (this.ratioWidth > this.ratioHeight) {
      this.destHeight = this.srcHeight / this.ratioWidth;
    } else {
      this.destWidth = this.srcWidth / this.ratioHeight;
    }
    this.srcX = 0;
    this.srcY = 0;
    this.destX = (this.canvas.width - this.destWidth) / 2;
    this.destY = (this.canvas.height - this.destHeight) / 2;
    this.ctx.drawImage(this.image, this.srcX, this.srcY, this.srcWidth, this.srcHeight, this.destX, this.destY, this.destWidth, this.destHeight);
  }
}, onLoadImage:function() {
  this.initCanvas();
  this.redraw();
}, onErrorImage:function() {
}, onAbortImage:function() {
}, initCanvas:function() {
  this.canvas = Ext.DomQuery.select('canvas', this.element.dom)[0];
  this.ctx = this.canvas.getContext('2d');
  this.trackTransforms(this.ctx);
  this.canvas.addEventListener('mousewheel', function(m) {
    return function(evt) {
      m.handleScroll(evt);
    };
  }(this), false);
  this.resetCanvas();
}}, 0, ['pinchzoomimage'], ['component', 'container', 'pinchzoomimage'], {'component':true, 'container':true, 'pinchzoomimage':true}, ['widget.pinchzoomimage'], 0, [Xedu.ux, 'PinchZoomImage'], 0);
Ext.cmd.derive('Xedu.view.slides.SlidesFullView', Xedu.ux.PinchZoomImage, {config:{itemId:'slides-fullview', background:'black', title:'Topic', courseid:null, topicid:null, scrollable:true, autoScroll:true, autoDestroy:true}, addSlide:function(slideRecord) {
  var titlebar = this.parent.down('titlebar');
  if (titlebar) {
    titlebar.setTitle(slideRecord.data.recordTitle);
  }
  this.setSrc(Xedu.Config.getUrl(Xedu.Config.SLIDE_IMAGE_LARGE) + slideRecord.data.recordId);
}, showSlideById:function(slideid) {
  var record = Ext.create('SearchHitModel', {'recordId':slideid, 'recordTitle':'', 'recordSubtitle':''});
  this.addSlide(record);
}}, 0, ['slides-fullview'], ['component', 'container', 'pinchzoomimage', 'slides-fullview'], {'component':true, 'container':true, 'pinchzoomimage':true, 'slides-fullview':true}, ['widget.slides-fullview'], 0, [Xedu.view.slides, 'SlidesFullView'], 0);
Ext.cmd.derive('Xedu.view.slides.FreeDrawComponent', Ext.draw.Component, {config:{bodyStyle:'background-color:transparent', frame:false, border:false, sprite:null, list:[], old1:[0, 0], old2:[0, 0], event:null, listeners:{element:'element', initialize:function(scope, eOpts) {
}, 'drag':function(e) {
  this.drawDrag(e);
  this.broadCastDrawEvent('ACTION_DRAW', e);
}, 'touchstart':function(e) {
  this.drawStart(e);
  this.broadCastDrawEvent('ACTION_DRAW_START', e);
}, 'dragend':function(e) {
  this.drawEnd();
  this.broadCastDrawEvent('ACTION_DRAW_END', {});
}}}, broadCastDrawEvent:function(eventType, msg) {
  console.log('sending draw event type \x3d' + eventType);
  event = Ext.create('Xedu.model.EventModel', {});
  event.set('type', eventType);
  event.set('to', Ext.JSON.decode("['all']"));
  event.set('msg', Ext.JSON.encode(msg));
  Xedu.CommonUtils.broadCastEventIfPresenter(event);
}, onResize:function() {
  var size = this.element.getSize();
  this.getSurface().setRegion([0, 0, size.width, size.height]);
  this.getSurface('overlay').setRegion([0, 0, size.width, size.height]);
  this.renderFrame();
}, clearAll:function() {
  this.getSurface().destroy();
  this.getSurface('overlay').destroy();
  this.renderFrame();
}, undo:function() {
  var surface = this.getSurface();
  var items = surface.getItems();
  console.log('items on surface \x3d ' + items.length);
  surface.remove(items[items.length - 1]);
  this.renderFrame();
}, smoothenList:function(points) {
  if (points.length < 3) {
    return ['M', points[0], points[1]];
  }
  var dx = [], dy = [], result = ['M'], i, ln = points.length;
  for (i = 0; i < ln; i += 2) {
    dx.push(points[i]);
    dy.push(points[i + 1]);
  }
  dx = Ext.draw.Draw.spline(dx);
  dy = Ext.draw.Draw.spline(dy);
  result.push(dx[0], dy[0], 'C');
  for (i = 1, ln = dx.length; i < ln; i++) {
    result.push(dx[i], dy[i]);
  }
  return result;
}, drawDrag:function(e) {
  var sprite = this.getSprite();
  var list = this.getList();
  if (sprite) {
    var me = this, p = e.touches[0].point, xy = me.element.getXY(), x = p.x - xy[0], y = p.y - xy[1], dx = this.lastEventX - x, dy = this.lastEventY - y, D = 40;
    if (dx * dx + dy * dy < D * D) {
      list.push(p.x - xy[0], p.y - xy[1]);
    } else {
      if (list.length > 1) {
        list.length -= 2;
      }
      list.push(this.lastEventX = p.x - xy[0], this.lastEventY = p.y - xy[1]);
      list.push(this.lastEventX + 1, this.lastEventY + 1);
    }
    var path = this.smoothenList(list);
    sprite.setAttributes({path:path});
    if (Ext.os.is.Android) {
      Ext.draw.Animator.schedule(function() {
        this.getSurface('overlay').renderFrame();
      }, me);
    } else {
      me.getSurface('overlay').renderFrame();
    }
  }
}, drawEnd:function() {
  var sprite = this.getSprite();
  var list = this.getList();
  var cmp = this;
  cmp.getSurface().add({type:'path', path:sprite.attr.path, lineWidth:sprite.attr.lineWidth, lineCap:'round', lineJoin:'round', strokeStyle:sprite.attr.strokeStyle});
  cmp.getSurface().setDirty(true);
  cmp.getSurface().renderFrame();
  sprite.destroy();
  cmp.getSurface('overlay').renderFrame();
  this.setSprite(null);
}, drawStart:function(e, noOffset) {
  var sprite = this.getSprite();
  var list = this.getList();
  if (!sprite) {
    var cmp = this;
    var p0 = cmp.element.getXY();
    if (noOffset) {
      var p = [p0[0], p0[1]];
    } else {
      var p = [e.pageX - p0[0], e.pageY - p0[1]];
    }
    list = [p[0], p[1], p[0], p[1]];
    console.log('element cordinates \x3d ' + Ext.JSON.encode(p0) + ' , page corordinates \x3d ' + Ext.JSON.encode(p));
    this.lastEventX = p[0];
    this.lastEventY = p[1];
    cmp.getSurface('overlay').element.setStyle({zIndex:1});
    var spriteconfig = {type:'path', path:['M', list[0], list[1], 'L', list[0] + 1.0E-5, list[1] + 1.0E-5], lineWidth:30 * Math.random() + 10, lineCap:'round', lineJoin:'round', strokeStyle:new Ext.draw.Color(Math.random() * 127 + 128, Math.random() * 127 + 128, Math.random() * 127 + 128)};
    sprite = cmp.getSurface('overlay').add(spriteconfig);
    old1 = old2 = p;
    cmp.getSurface('overlay').renderFrame();
    this.setSprite(sprite);
    this.setList(list);
    console.log('drawing started !');
    var event = Ext.create('Xedu.model.EventModel', {});
    event.set('type', 'ACTION_DRAW_START');
    event.set('to', Ext.JSON.decode("['all']"));
    event.set('msg', Ext.JSON.encode(e));
    Xedu.CommonUtils.broadCastEventIfPresenter(event);
  }
}}, 0, ['slide-draw-component'], ['component', 'container', 'draw', 'slide-draw-component'], {'component':true, 'container':true, 'draw':true, 'slide-draw-component':true}, ['widget.slide-draw-component'], 0, [Xedu.view.slides, 'FreeDrawComponent'], 0);
Ext.cmd.derive('Xedu.view.slides.SlidesFullViewList', Ext.dataview.List, {config:{itemId:'slides-fullview-list-id', background:'black', title:'Topic', courseid:null, topicid:null, scrollable:true, autoScroll:true, autoDestroy:true, store:{type:'slides-list-store'}, itemTpl:['\x3cdiv style\x3d"vertical-align:middle; text-align:center;background-color:black;width:100%;height:100%"\x3e', '\t\t\t\x3cimg style\x3d"max-height:100%; max-width:100%;" src\x3d"' + Xedu.Config.getUrl(Xedu.Config.SLIDE_IMAGE_LARGE) + 
'{recordId}" /\x3e\x3cbr /\x3e', '\x3c/div\x3e'], listeners:{itemsingletap:function(scope, index, target, record) {
  console.log('tapped');
  var courseId = scope.getCourseid();
  var topicid = scope.getTopicid();
  alert('tapped on slide \x3d' + record.id + 'topicid \x3d' + topicid + ', courseid \x3d ' + courseid);
}}}, addSlide:function(slideRecord) {
  var titlebar = this.parent.down('titlebar');
  if (titlebar) {
    titlebar.setTitle(slideRecord.data.recordTitle);
  }
  this.getStore().removeAll();
  this.getStore().add(slideRecord);
}, showSlideById:function(slideid) {
  console.log('showing slide ' + slideid);
  var record = Ext.create('Xedu.model.SearchHitModel', {'recordId':slideid, 'recordTitle':'', 'recordSubtitle':''});
  this.addSlide(record);
}}, 0, ['slides-fullview-list'], ['component', 'container', 'dataview', 'list', 'slides-fullview-list'], {'component':true, 'container':true, 'dataview':true, 'list':true, 'slides-fullview-list':true}, ['widget.slides-fullview-list'], 0, [Xedu.view.slides, 'SlidesFullViewList'], 0);
Ext.cmd.derive('Xedu.model.SlideModel', Ext.data.Model, {config:{fields:[{name:'id', type:'string'}, {name:'name', type:'string'}, {name:'title', type:'string'}, {name:'subTitle', type:'string'}, {name:'description', type:'string'}]}}, 0, 0, 0, 0, 0, 0, [Xedu.model, 'SlideModel'], 0);
Ext.cmd.derive('Xedu.model.TopicModel', Ext.data.Model, {config:{fields:[{name:'id', type:'string'}, {name:'name', type:'string'}, {name:'title', type:'string'}, {name:'subTitle', type:'string'}, {name:'description', type:'string'}], hasMany:[{name:'slides', model:'SlideModel'}]}}, 0, 0, 0, 0, 0, 0, [Xedu.model, 'TopicModel'], 0);
Ext.cmd.derive('Xedu.model.ChapterModel', Ext.data.Model, {config:{fields:[{name:'id', type:'string'}, {name:'name', type:'string'}, {name:'title', type:'string'}, {name:'subTitle', type:'string'}, {name:'description', type:'string'}], hasMany:[{name:'topics', model:'TopicModel'}]}}, 0, 0, 0, 0, 0, 0, [Xedu.model, 'ChapterModel'], 0);
Ext.cmd.derive('Xedu.store.ChaptersStore', Ext.data.Store, {require:['Xedu.Config', 'Xedu.model.ChapterModel', 'Ext.data.proxy.Rest'], config:{model:'Xedu.model.ChapterModel', remoteSort:false, autoLoad:false, proxy:{type:'rest', url:Xedu.Config.getUrl(Xedu.Config.COURSE_API), reader:{type:'json', rootProperty:'course.chapters'}}}}, 0, 0, 0, 0, ['store.chapters-store'], 0, [Xedu.store, 'ChaptersStore'], 0);
Ext.cmd.derive('Xedu.view.chapter.ChapterEditForm', Ext.form.Panel, {config:{fullscreen:false, autoDestroy:true, courseid:null, scrollable:true, layout:{type:'vbox'}, items:[{xtype:'fieldset', flex:2, layout:{type:'vbox', pack:'start'}, defaults:{labelAlign:'top'}, items:[{xtype:'textfield', name:'id', label:'ID'}, {xtype:'textfield', name:'courseid', itemId:'courseid-field', label:'CourseID'}, {xtype:'textfield', name:'name', label:'Name'}, {xtype:'textfield', name:'title', label:'Title'}, {xtype:'textfield', 
name:'subTitle', label:'Sub Title'}]}, {xtype:'fieldset', layout:'fit', flex:1, items:[{xtype:'textareafield', label:'Description', labelAlign:'top', name:'description'}]}, {docked:'bottom', xtype:'toolbar', ui:'dark', title:'', layout:{type:'hbox', pack:'center'}, items:[{xtype:'button', ui:'confirm', text:'Save', itemId:'saveChangesButton', handler:function(but, action, eOpts) {
  this.up('chapter-edit-form').updateChapter();
}}, {xtype:'button', ui:'decline', text:'Delete', hidden:true, itemId:'deleteChangesButton', handler:function(but, action, eOpts) {
  this.up('chapter-edit-form').deleteChapter();
}}]}], listeners:{show:function(thisView) {
}}}, setCourseid:function(courseid) {
  this.courseid = courseid;
  console.log('setting in chapter edit form courseid \x3d ' + courseid);
  this.down('#courseid-field').setValue(courseid);
}, loadChapter:function(id) {
  var chapterDetailsForm = this;
  var fields = chapterDetailsForm.getFields();
  console.log('Loading chapter id \x3d' + id);
  var progressIndicator = Ext.create('Ext.ProgressIndicator');
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.CHAPTER_API) + id, method:'GET', progress:progressIndicator, headers:{'Content-Type':'application/json'}, success:function(response, conn, options, eOpts) {
    var result = Ext.JSON.decode(response.responseText);
    var chapterRecord = Ext.create('Xedu.model.ChapterModel', result.chapter);
    chapterDetailsForm.setRecord(chapterRecord);
    chapterDetailsForm.down('#deleteChangesButton').setHidden(false);
  }, failure:function(conn, response, options, eOpts) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, updateChapter:function() {
  var chapterForm = this;
  var fields = chapterForm.getFields();
  var id = fields['id'].getValue();
  var restUrl = Xedu.Config.getUrl(Xedu.Config.CHAPTER_API);
  var restMethod = 'POST';
  if (id && id != '') {
    restMethod = 'PUT';
    restUrl = restUrl + id;
  }
  var progressIndicator = Ext.create('Ext.ProgressIndicator');
  chapterForm.submit({url:restUrl, method:restMethod, progress:progressIndicator, success:function(form, response) {
    var maincntrller = Xedu.app.getController('Main');
    Ext.Viewport.setMasked(false);
    Xedu.CommonUtils.checkServiceError(response);
    if (response.status == 'SUCCESS') {
      Ext.Msg.alert('SUCCESS', response.msg);
      var chapterlistpanel = Ext.ComponentQuery.query('chapters-list-panel list');
      chapterForm.reset();
      if (chapterlistpanel && chapterlistpanel[0]) {
        chapterlistpanel[0].getStore().load();
      }
    } else {
    }
  }, failure:function(form, response) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, deleteChapter:function() {
  var chapterDetailsForm = this;
  var fields = chapterDetailsForm.getFields();
  var id = fields['id'].getValue();
  if (id && id != '') {
    Ext.Msg.alert('Not allowed', 'Delete operation not available');
  }
  var chapterName = fields['title'].getValue() + ' ' + fields['subTitle'].getValue();
  Ext.Msg.confirm('Delete Chapter?', 'Are you sure you want to delete the chapter \x3cbr /\x3eid:' + id + '\x3cbr /\x3e Name:' + chapterName, function(btn) {
    if (btn == 'yes') {
      var progressIndicator = Ext.create('Ext.ProgressIndicator');
      chapterDetailsForm.submit({url:Xedu.Config.getUrl(Xedu.Config.CHAPTER_API) + id, method:'DELETE', progress:progressIndicator, success:function(form, response, data) {
        Ext.Msg.alert(response.status, response.msg);
        var configListPanel = Ext.ComponentQuery.query('chapters-list-panel list');
        if (configListPanel && configListPanel[0]) {
          configListPanel[0].getStore().load();
        }
      }, failure:function(el, resp, p) {
        Xedu.CommonUtils.checkServiceError(resp);
      }});
    }
  });
}}, 0, ['chapter-edit-form'], ['component', 'container', 'panel', 'formpanel', 'chapter-edit-form'], {'component':true, 'container':true, 'panel':true, 'formpanel':true, 'chapter-edit-form':true}, ['widget.chapter-edit-form'], 0, [Xedu.view.chapter, 'ChapterEditForm'], 0);
Ext.cmd.derive('Xedu.view.chapter.ChaptersList', Ext.Panel, {config:{title:'Chapters', layout:'vbox', courseid:null, callbackScope:null, callbackOnSelect:null, closeOnSelect:false, hideTitlebar:false, items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'Chapters', layout:{type:'hbox', pack:'right'}, defaults:{ui:'plain'}, items:[{xtype:'button', iconCls:'add', handler:function(but, action, eOpts) {
  this.up('chapters-list-panel').createNewChapter();
}}]}, {xtype:'searchfield', name:'searchchapters', placeHolder:'search chapters..', align:'center', ui:'dark', height:50, listeners:{keyup:function(el, e, eOpts) {
  Xedu.CommonUtils.filterStore(this.up('chapters-list-panel').down('list'), el.getValue());
}}}, {xtype:'list', flex:1, itemId:'chapter-list-panel-id', title:'Chapters', scrollable:true, autoDestroy:true, store:{type:'chapters-store'}, plugins:[{xclass:'Ext.plugin.PullRefresh', pullText:'Pull down to refresh the list!'}], itemTpl:['\x3cdiv\x3e', '\t\t\t\x3cspan style\x3d"color:gray"\x3eNo:\x3c/span\x3e {id} ', '\t\t\t\x3cspan style\x3d"color:gray"\x3eTitle: \x3c/span\x3e{name}, ', '\x3c/div\x3e'], listeners:{itemsingletap:function(scope, index, target, record) {
  console.log('tapped');
  scope.up('chapters-list-panel').chapterSelected(record);
}}}], listeners:{show:function(thisView, opts) {
  thisView.down('titlebar').setHidden(thisView.getHideTitlebar());
}}}, chapterSelected:function(record) {
  if (this.getCallbackOnSelect()) {
    this.handleCallback(record.data.id);
  } else {
    Xedu.app.getController('Main').redirectTo('view/chapter/' + record.data.id + '/topics');
  }
}, handleCallback:function(param) {
  console.log('handling callback for chapters... ');
  var callbck = this.getCallbackOnSelect();
  var callScope = this.getCallbackScope();
  if (typeof callbck == 'function') {
    if (!callScope) {
      console.error('Missing scope inside callbackConfig ');
    } else {
      callbck.apply(callScope, [param]);
    }
  }
  if (this.getCloseOnSelect()) {
    this.hide();
  }
}, loadChapters:function(courseid) {
  this.setCourseid(courseid);
  var chaptersList = this.down('list');
  var restUrl = Xedu.Config.getUrl(Xedu.Config.COURSE_API) + courseid;
  var chaptersStore = chaptersList.getStore();
  chaptersStore.getProxy().setUrl(restUrl);
  chaptersStore.load({callback:function(records, options, success) {
    console.log(records.length);
  }});
}, createNewChapter:function() {
  var courseidParam = this.getCourseid();
  var newChapterEditForm = {xtype:'Xedu.view.chapter.ChapterEditForm', courseid:courseidParam};
  Xedu.CommonUtils.showOverlay(newChapterEditForm, {title:'Create New Chapter'});
}}, 0, ['chapters-list-panel'], ['component', 'container', 'panel', 'chapters-list-panel'], {'component':true, 'container':true, 'panel':true, 'chapters-list-panel':true}, ['widget.chapters-list-panel'], 0, [Xedu.view.chapter, 'ChaptersList'], 0);
Ext.cmd.derive('Xedu.store.TopicsStore', Ext.data.Store, {require:['Xedu.Config', 'Ext.data.proxy.Rest'], config:{model:'Xedu.model.TopicModel', remoteSort:false, autoLoad:false, proxy:{type:'rest', url:Xedu.Config.getUrl(Xedu.Config.CHAPTER_API), reader:{type:'json', rootProperty:'chapter.topics'}}}}, 0, 0, 0, 0, ['store.topics-store'], 0, [Xedu.store, 'TopicsStore'], 0);
Ext.cmd.derive('Xedu.view.topic.TopicEditForm', Ext.form.Panel, {config:{fullscreen:false, autoDestroy:true, chapterid:null, scrollable:true, layout:{type:'vbox'}, items:[{xtype:'fieldset', flex:2, layout:{type:'vbox', pack:'start'}, defaults:{labelAlign:'top'}, items:[{xtype:'textfield', name:'id', label:'ID'}, {xtype:'textfield', name:'chapterid', itemId:'chapterid-field', label:'ChapterID'}, {xtype:'textfield', name:'name', label:'Name'}, {xtype:'textfield', name:'title', label:'Title'}, {xtype:'textfield', 
name:'subTitle', label:'Sub Title'}]}, {xtype:'fieldset', layout:'fit', flex:1, items:[{xtype:'textareafield', label:'Description', labelAlign:'top', name:'description'}]}, {docked:'bottom', xtype:'toolbar', ui:'dark', title:'', layout:{type:'hbox', pack:'center'}, items:[{xtype:'button', ui:'confirm', text:'Save', itemId:'saveChangesButton', handler:function(but, action, eOpts) {
  this.up('topic-edit-form').updateTopic();
}}, {xtype:'button', ui:'decline', text:'Delete', hidden:true, itemId:'deleteChangesButton', handler:function(but, action, eOpts) {
  this.up('topic-edit-form').deleteTopic();
}}]}], listeners:{show:function(thisView) {
}}}, setChapterid:function(chapterid) {
  this.chapterid = chapterid;
  console.log('setting in topic edit form chapterid \x3d ' + chapterid);
  this.down('#chapterid-field').setValue(chapterid);
}, loadTopic:function(id) {
  var topicDetailsForm = this;
  var fields = topicDetailsForm.getFields();
  console.log('Loading topic id \x3d' + id);
  var progressIndicator = Ext.create('Ext.ProgressIndicator');
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.TOPIC_API) + id, method:'GET', progress:progressIndicator, headers:{'Content-Type':'application/json'}, success:function(response, conn, options, eOpts) {
    var result = Ext.JSON.decode(response.responseText);
    var topicRecord = Ext.create('Xedu.model.TopicModel', result.topic);
    topicDetailsForm.setRecord(topicRecord);
    topicDetailsForm.down('#deleteChangesButton').setHidden(false);
  }, failure:function(conn, response, options, eOpts) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, updateTopic:function() {
  var topicForm = this;
  var fields = topicForm.getFields();
  var id = fields['id'].getValue();
  var restUrl = Xedu.Config.getUrl(Xedu.Config.TOPIC_API);
  var restMethod = 'POST';
  if (id && id != '') {
    restMethod = 'PUT';
    restUrl = restUrl + id;
  }
  var progressIndicator = Ext.create('Ext.ProgressIndicator');
  topicForm.submit({url:restUrl, method:restMethod, progress:progressIndicator, success:function(form, response) {
    var maincntrller = Xedu.app.getController('Main');
    Ext.Viewport.setMasked(false);
    Xedu.CommonUtils.checkServiceError(response);
    if (response.status == 'SUCCESS') {
      Ext.Msg.alert('SUCCESS', response.msg);
      var topiclistpanel = Ext.ComponentQuery.query('topics-list-panel list');
      topicForm.reset();
      if (topiclistpanel && topiclistpanel[0]) {
        topiclistpanel[0].getStore().load();
      }
    } else {
    }
  }, failure:function(form, response) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, deleteTopic:function() {
  var topicDetailsForm = this;
  var fields = topicDetailsForm.getFields();
  var id = fields['id'].getValue();
  if (id && id != '') {
    Ext.Msg.alert('Not allowed', 'Delete operation not available');
  }
  var topicName = fields['title'].getValue() + ' ' + fields['subTitle'].getValue();
  Ext.Msg.confirm('Delete Topic?', 'Are you sure you want to delete the topic \x3cbr /\x3eid:' + id + '\x3cbr /\x3e Name:' + topicName, function(btn) {
    if (btn == 'yes') {
      var progressIndicator = Ext.create('Ext.ProgressIndicator');
      topicDetailsForm.submit({url:Xedu.Config.getUrl(Xedu.Config.TOPIC_API) + id, method:'DELETE', progress:progressIndicator, success:function(form, response, data) {
        Ext.Msg.alert(response.status, response.msg);
        var configListPanel = Ext.ComponentQuery.query('topics-list-panel list');
        if (configListPanel && configListPanel[0]) {
          configListPanel[0].getStore().load();
        }
      }, failure:function(el, resp, p) {
        Xedu.CommonUtils.checkServiceError(resp);
      }});
    }
  });
}}, 0, ['topic-edit-form'], ['component', 'container', 'panel', 'formpanel', 'topic-edit-form'], {'component':true, 'container':true, 'panel':true, 'formpanel':true, 'topic-edit-form':true}, ['widget.topic-edit-form'], 0, [Xedu.view.topic, 'TopicEditForm'], 0);
Ext.cmd.derive('Xedu.view.topic.TopicsList', Ext.Panel, {config:{title:'Topics', layout:'vbox', chapterid:null, callbackScope:null, callbackOnSelect:null, closeOnSelect:false, hideTitlebar:false, items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'Topics', layout:{type:'hbox', pack:'right'}, defaults:{ui:'plain'}, items:[{xtype:'button', iconCls:'add', handler:function(but, action, eOpts) {
  this.up('topics-list-panel').createNewTopic();
}}]}, {xtype:'searchfield', placeHolder:'Search ...', align:'center', ui:'dark', height:50, listeners:{keyup:function(el, e, eOpts) {
  Xedu.CommonUtils.filterStore(this.up('topics-list-panel').down('list'), el.getValue());
}}}, {xtype:'list', flex:1, itemId:'topics-list-panel-id', scrollable:true, autoDestroy:true, store:{type:'topics-store'}, plugins:[{xclass:'Ext.plugin.PullRefresh', pullText:'Pull down to refresh the list!'}], itemTpl:['\x3cdiv\x3e', '\t\t\t\x3cspan style\x3d"color:gray"\x3eNo:\x3c/span\x3e {id} ', '\t\t\t\x3cspan style\x3d"color:gray"\x3eTitle: \x3c/span\x3e{name}, ', '\x3c/div\x3e'], listeners:{show:function(thisView, opts) {
  thisView.up('topics-list-panel').loadTopics(thisView.getChapterid());
}, itemsingletap:function(scope, index, target, record) {
  console.log('tapped');
  scope.up('topics-list-panel').topicSelected(record);
}}}], listeners:{show:function(thisView, opts) {
  thisView.down('titlebar').setHidden(thisView.getHideTitlebar());
  thisView.loadTopics(thisView.getChapterid());
}}}, topicSelected:function(record) {
  if (this.getCallbackOnSelect()) {
    this.handleCallback(record.data.id);
  } else {
    Xedu.app.getController('Main').redirectTo('view/topic/' + record.data.id);
  }
}, handleCallback:function(param) {
  console.log('handling callback for topic... ');
  var callbck = this.getCallbackOnSelect();
  var callScope = this.getCallbackScope();
  if (typeof callbck == 'function') {
    if (!callScope) {
      console.error('Missing scope inside callbackConfig ');
    } else {
      callbck.apply(callScope, [param]);
    }
  }
  if (this.getCloseOnSelect()) {
    this.hide();
  }
}, loadTopics:function(chapterid) {
  this.setChapterid(chapterid);
  var chaptersList = this.down('list');
  var restUrl = Xedu.Config.getUrl(Xedu.Config.CHAPTER_API) + chapterid;
  var topicsStore = chaptersList.getStore();
  topicsStore.getProxy().setUrl(restUrl);
  topicsStore.load({callback:function(records, options, success) {
    console.log(records.length);
  }});
}, createNewTopic:function() {
  var chapteridParam = this.getChapterid();
  var newTopicEditFormPanel = {xtype:'Xedu.view.topic.TopicEditForm', chapterid:chapteridParam};
  Xedu.CommonUtils.showOverlay(newTopicEditFormPanel, {title:'Create New Topic'});
}}, 0, ['topics-list-panel'], ['component', 'container', 'panel', 'topics-list-panel'], {'component':true, 'container':true, 'panel':true, 'topics-list-panel':true}, ['widget.topics-list-panel'], 0, [Xedu.view.topic, 'TopicsList'], 0);
Ext.cmd.derive('Xedu.view.slides.SlidesMain', Ext.Container, {config:{title:'Slides Contents', fullscreen:false, layout:'hbox', courseid:null, topicid:null, slideid:null, classroomSessionMode:false, editMode:false, presenterMode:false, autoDestroy:true, defaults:{flex:1}, items:[{xtype:'container', itemId:'course-contents-selection-panel', hidden:true, layout:'card', items:[{docked:'top', xtype:'titlebar', ui:'dark', title:'Chapters', layout:{pack:'right'}, defaults:{ui:'plain'}, items:[{xtype:'button', 
ui:'back', align:'left', hidden:true, itemId:'backButton', handler:function(but, action, eOpts) {
  var cc = but.up('#course-contents-selection-panel');
  var titlebar = cc.down('titlebar');
  var activeItem = cc.getActiveItem();
  if (activeItem.xtype == 'topics-list-panel') {
    cc.setActiveItem(0);
    titlebar.setTitle('Chapters');
    but.hide();
  } else {
    if (activeItem.xtype == 'slides-list-panel') {
      cc.setActiveItem(1);
      but.setText('Chapters');
      titlebar.setTitle('Topics');
    }
  }
}}]}, {xtype:'chapters-list-panel', callbackScope:this, hideTitlebar:true, callbackOnSelect:function(id) {
  Ext.ComponentQuery.query('slides-main-view')[0].switchCards({'chapterid':id});
}}, {xtype:'topics-list-panel', callbackScope:this, hideTitlebar:true, callbackOnSelect:function(id) {
  Ext.ComponentQuery.query('slides-main-view')[0].switchCards({'topicid':id});
}, flex:1}, {xtype:'slides-list-panel', flex:1}]}, {xtype:'container', layout:'fit', flex:4, items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'', layout:{pack:'right'}, defaults:{ui:'plain'}, items:[{xtype:'button', iconCls:'compose', itemId:'whiteboardButton', handler:function(but) {
  var slidesfullview = Ext.ComponentQuery.query('slides-fullview-list')[0];
  slidesfullview.getStore().removeAll();
}}, {xtype:'button', iconCls:'refresh', itemId:'undoButton', handler:function() {
  var draw = Ext.ComponentQuery.query('slide-draw-component')[0];
  draw.undo();
}}]}, {xtype:'slides-fullview-list'}, {xtype:'slide-draw-component', itemId:'free-paint', top:0, left:0, width:Ext.Viewport.getWindowWidth(), height:Ext.Viewport.getWindowHeight()}]}], listeners:{show:'updatePanelView'}}, updatePanelView:function(thisView, opts) {
  console.log('on show function!!!!');
  thisView.loadCourseChaptersList();
  thisView.loadSlide();
  if (!this.getPresenterMode() || !this.classroomSessionMode) {
    thisView.down('#course-contents-selection-panel').show();
  }
}, switchCards:function(opt) {
  var courseContentsCards = this.down('#course-contents-selection-panel');
  var bckButton = courseContentsCards.down('#backButton');
  var titleBar = courseContentsCards.down('titlebar');
  bckButton.setHidden(false);
  if (opt.chapterid) {
    this.down('topics-list-panel').setChapterid(opt.chapterid);
    courseContentsCards.setActiveItem('topics-list-panel');
    bckButton.setText('Chapters');
    titleBar.setTitle('Topics');
  } else {
    if (opt.topicid) {
      this.down('slides-list-panel').setTopicid(opt.topicid);
      courseContentsCards.setActiveItem('slides-list-panel');
      bckButton.setText('Topics');
      titleBar.setTitle('Slides');
    }
  }
}, loadCourseChaptersList:function() {
  if (this.getCourseid() == null && this.getTopicid() == null) {
    return;
  }
  var courseContentsPanel = this.down('#course-contents-selection-panel');
  courseContentsPanel.show();
  if (this.getCourseid() != null) {
    var chaptersListPanel = courseContentsPanel.down('chapters-list-panel');
    chaptersListPanel.loadChapters(this.getCourseid());
  } else {
    if (this.getTopicid() != null) {
      var slidesListPanel = courseContentsPanel.down('slides-list-panel');
      courseContentsPanel.down('titlebar').hide();
      slidesListPanel.setTopicid(this.getTopicid());
      courseContentsPanel.setActiveItem(slidesListPanel);
      if (this.getSlideid() && this.getSlideid() != '') {
        console.log('setting the slide id \x3d ' + this.getSlideid());
      }
    }
  }
}, topicContentUpload:function() {
  var topicIdParam = this.getTopicid();
  var me = this;
  var newContentUploadFormPanel = {xtype:'Xedu.view.slides.ContentUpload', topicid:topicIdParam};
  Xedu.CommonUtils.showOverlay(newContentUploadFormPanel, {title:'Upload Topic Slides', width:500, height:400, callme:me.reloadSlidesList, callmeScope:me});
}, reloadSlidesList:function(scope) {
  if (scope && scope.down('slides-list-panel')) {
    console.log('reloading slides');
    scope.down('slides-list-panel').reload();
  }
}, loadSlide:function() {
  console.log('showing slide id \x3d ' + this.getSlideid());
  this.down('slides-fullview-list').showSlideById(this.getSlideid());
}}, 0, ['slides-main-view'], ['component', 'container', 'slides-main-view'], {'component':true, 'container':true, 'slides-main-view':true}, ['widget.slides-main-view'], 0, [Xedu.view.slides, 'SlidesMain'], 0);
Ext.cmd.derive('Xedu.store.ConfigSectionsStore', Ext.data.Store, {require:['Xedu.Config', 'Ext.data.proxy.Rest'], config:{fields:[{name:'id', type:'string'}, {name:'sectionName', type:'string'}, {name:'configGroups', type:'auto'}, {name:'allowedRoles', type:'auto'}], pageSize:10, remoteSort:false, autoLoad:true, proxy:{type:'rest', url:Xedu.Config.getUrl(Xedu.Config.CONFIG_SECTIONS), reader:{type:'json', rootProperty:'sections'}, filterParam:'name'}}}, 0, 0, 0, 0, ['store.config-sections-store'], 
0, [Xedu.store, 'ConfigSectionsStore'], 0);
Ext.cmd.derive('Xedu.view.config.ConfigSectionsList', Ext.dataview.List, {config:{itemId:'config-sections-list-panel-id', title:'Config', scrollable:true, autoDestroy:true, store:{type:'config-sections-store'}, plugins:[{xclass:'Ext.plugin.PullRefresh', pullText:'Pull down to refresh the list!'}], itemTpl:['\x3cdiv\x3e', '\t\t\t\x3cspan style\x3d"color:blue"\x3e {sectionName} \x3c/span\x3e', '\x3c/div\x3e'], onItemDisclosure:function(record, btn, index) {
  this.showSectionDetails(record);
}, listeners:{itemsingletap:function(scope, index, target, record) {
  this.showSectionDetails(record);
}, show:function(thisView) {
  console.log('showing config list');
  thisView.select(0);
}}}, showSectionDetails:function(record) {
  var HeightOfField = 50;
  var configGroupFormPanel = Ext.ComponentQuery.query('#config-group-form')[0];
  configGroupFormPanel.removeAll(true);
  var configGroupsData = record.get('configGroups');
  var formtitlebar = configGroupFormPanel.down('titlebar');
  formtitlebar.setTitle(record.data.sectionName);
  for (var i = 0; i < configGroupsData.length; i++) {
    var configGrp = configGroupsData[i];
    var configFieldSet = Ext.create('Ext.form.FieldSet', {itemId:'fieldset-' + configGrp.id, title:configGrp.configGroupName, instructions:configGrp.footerNote, layout:{type:'vbox', pack:'start'}});
    for (var cfg = 0; cfg < configGrp.configs.length; cfg++) {
      var config = configGrp.configs[cfg];
      var configTextField = Ext.create('Ext.field.Text', {name:config.id, label:config.id, value:config.configValue, height:HeightOfField});
      var fieldSetHeight = cfg * HeightOfField + HeightOfField + 100;
      console.log('height \x3d ' + fieldSetHeight);
      configFieldSet.setHeight(fieldSetHeight);
      configFieldSet.add(configTextField);
    }
    console.log(' adding fieldset \x3d ' + configGrp.configGroupName);
    configGroupFormPanel.add(configFieldSet);
  }
}}, 0, ['config-sections-list-panel'], ['component', 'container', 'dataview', 'list', 'config-sections-list-panel'], {'component':true, 'container':true, 'dataview':true, 'list':true, 'config-sections-list-panel':true}, ['widget.config-sections-list-panel'], 0, [Xedu.view.config, 'ConfigSectionsList'], 0);
Ext.cmd.derive('Xedu.view.config.ConfigMain', Ext.Container, {config:{title:'Settings', fullscreen:true, layout:{type:'hbox', align:'stretch', pack:'start'}, topicid:null, courseid:null, chapterid:null, autoDestroy:true, defaults:{flex:1}, items:[{xtype:'container', layout:'fit', flex:1, items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'', layout:{pack:'right'}, defaults:{ui:'plain'}}, {xtype:'config-sections-list-panel', flex:1}]}, {xtype:'container', flex:4, layout:'fit', items:[{xtype:'formpanel', 
itemId:'config-group-form', flex:1, height:'100%', layout:{type:'fit', pack:'start'}, scrollable:{direction:'vertical', directionLock:false}, items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'', layout:{pack:'right'}, defaults:{ui:'plain'}, items:[]}, {docked:'bottom', xtype:'toolbar', ui:'dark', title:'', layout:{pack:'center'}, defaults:{ui:'plain'}, items:[{xtype:'button', ui:'confirm', text:'Save', itemId:'saveChangesButton', handler:function(but, action, eOpts) {
  var configFormSub = Ext.ComponentQuery.query('#config-group-form')[0];
  Ext.Viewport.mask({msg:'Updating configuration...Please wait!'});
  configFormSub.submit({url:Xedu.Config.getUrl(Xedu.Config.CONFIG_SECTIONS), method:'POST', success:function(form, response, data1) {
    var maincntrller = Xedu.app.getController('Main');
    Ext.Viewport.setMasked(false);
    if (response.status == 'SUCCESS') {
      Ext.Msg.alert('Success', 'Configuration updated successfully!', Ext.emptyFn);
      var configListPanel = Ext.ComponentQuery.query('config-sections-list-panel');
      if (configListPanel && configListPanel[0]) {
        configListPanel[0].getStore().load();
      }
    } else {
      Ext.Msg.alert('Failed', response.msg, Ext.emptyFn);
    }
  }, failure:function(response) {
    Ext.Viewport.setMasked(false);
    Ext.Msg.alert('Exception', 'Server failed to respond! Please try again or contact support!', Ext.emptyFn);
  }});
}}]}]}]}], listeners:{show:function(thisView, opts) {
  console.log('showing config main');
}}}}, 0, ['config-main-view'], ['component', 'container', 'config-main-view'], {'component':true, 'container':true, 'config-main-view':true}, ['widget.config-main-view'], 0, [Xedu.view.config, 'ConfigMain'], 0);
Ext.cmd.derive('Xedu.view.slides.ContentUpload', Ext.form.Panel, {config:{title:'Upload Slides', height:400, topicid:null, scrollable:true, layout:{type:'fit', pack:'start', align:'center'}, items:[{xtype:'container', itemId:'formcontainer-id', hidden:false, height:400, items:[{xtype:'fieldset', title:'Content Upload', items:[{xtype:'textfield', label:'topic id', name:'topicid', allowNull:false, required:true, itemId:'topicid-field'}, {xtype:'filefield', label:'Upload slides:', name:'slidecontent', 
allowNull:false, required:true, accept:'pptx'}]}, {xtype:'button', itemId:'uploadSlideButton', formBind:true, ui:'confirm', text:'Upload', width:'20%', handler:function(but) {
  Ext.ComponentQuery.query('content-upload')[0].uploadFile();
}}]}, {xtype:'container', itemId:'processing-container-id', hidden:true, layout:{type:'vbox', pack:'center', align:'center'}, items:[{xtype:'image', width:300, height:300, src:'resources/loading/processing.gif'}, {label:'Processing...', flex:1}]}]}, setTopicid:function(topicid) {
  this.topicid = topicid;
  console.log('setting topic edit form topicid \x3d ' + topicid);
  this.down('#topicid-field').setValue(topicid);
}, getTopicid:function() {
  return this.topicid;
}, uploadFile:function() {
  var me = this;
  var progressIndicator = Ext.create('Ext.ProgressIndicator');
  var uploadApiUrl = Xedu.Config.getUrl(Xedu.Config.SLIDE_CONTENT_UPLOAD);
  this.submit({url:uploadApiUrl, method:'POST', scope:this, progress:progressIndicator, xhr2:true, waitMsg:'Uploading your file...', success:function(form, response) {
    Xedu.CommonUtils.checkServiceError(response);
    if (response.status == 'SUCCESS') {
      Ext.Msg.alert('SUCCESS', 'File successfully saved for processing \x3cbr\x3e Proceeding to file processing\x3cbr /\x3e This may take some time depending on your file size', function() {
        me.down('#processing-container-id').setHidden(false);
        me.down('#formcontainer-id').setHidden(true);
        me.processFile(response.fileid);
      });
    } else {
    }
  }, failure:function(form, response) {
    Xedu.CommonUtils.checkServiceError(response);
  }});
}, processFile:function(fileid) {
  var me = this;
  var uploadApiUrl = Xedu.Config.getUrl(Xedu.Config.SLIDE_GENERATE);
  uploadApiUrl = uploadApiUrl.replace('{topicid}', this.getTopicid());
  uploadApiUrl = uploadApiUrl.replace('{uploadedfileid}', fileid);
  Ext.Ajax.request({url:uploadApiUrl, method:'GET', scope:this, xhr2:true, waitMsg:'Processing your file...', success:function(resp, el, form) {
    var response = Ext.JSON.decode(resp.responseText);
    Xedu.CommonUtils.checkServiceError(response);
    if (response.status == 'SUCCESS') {
      Xedu.CommonUtils.closeOverlay();
      Ext.Msg.alert('SUCCESS', 'File successfully processed', function() {
      });
    } else {
    }
  }, failure:function(resp) {
    var response = Ext.JSON.decode(resp.responseText);
    Xedu.CommonUtils.checkServiceError(response);
    Xedu.CommonUtils.closeOverlay();
  }});
}}, 0, ['content-upload'], ['component', 'container', 'panel', 'formpanel', 'content-upload'], {'component':true, 'container':true, 'panel':true, 'formpanel':true, 'content-upload':true}, ['widget.content-upload'], 0, [Xedu.view.slides, 'ContentUpload'], 0);
Ext.cmd.derive('Xedu.store.SearchStore', Ext.data.Store, {require:['Xedu.Config', 'Ext.data.proxy.Rest'], config:{fields:[{name:'recordId', type:'string'}, {name:'recordTitle', type:'string'}, {name:'recordSubtitle', type:'string'}], pageSize:10, remoteSort:false, autoLoad:false, proxy:{type:'rest', reader:{type:'json', idProperty:'recordId', rootProperty:'hits', totalProperty:'totalHits'}, filterParam:'name'}}}, 0, 0, 0, 0, ['store.search-store'], 0, [Xedu.store, 'SearchStore'], 0);
Ext.cmd.derive('Xedu.view.users.UsersList2', Ext.Panel, {config:{itemId:'users-list-panel-id', title:'Users', scrollable:true, autoDestroy:true, callbackScope:null, callbackOnSelect:null, layout:{type:'vbox', pack:'start'}, items:[{xtype:'searchfield', placeHolder:'Search Users..', align:'center', ui:'dark', height:50, listeners:{keyup:function(el, e, eOpts) {
  this.up('users-list-panel').searchRecords(el.getValue());
}}}, {xtype:'list', flex:7, store:{type:'search-store'}, plugins:[{xclass:'Ext.plugin.PullRefresh', pullText:'Pull down to refresh the list!', loadingText:'Loading users..'}], itemTpl:['\x3ctable\x3e', '\t\x3ctr\x3e', '\t\t\x3ctd width\x3d"100"\x3e', '\t\t\t\x3cdiv\x3e', '\t\t\t\t\x3cimg src\x3d"resources/icons/user_profile2x64.png" /\x3e', '\t\t\t\x3c/div\x3e', '\t\t\x3c/td\x3e', '\t\t\x3ctd\x3e', '\t\t\t\x3cdiv\x3e', '\t\t\t\t\x3cb\x3e{recordTitle}\x3c/b\x3e {recordSubtitle}', '\t\t\t\x3c/div\x3e', 
'\t\t\x3c/td\x3e', '\t\x3c/tr\x3e', '\x3c/table\x3e'], onItemDisclosure:function(record, btn, index) {
}, listeners:{show:function(thisView, opts) {
  thisView.up('users-list-panel').loadUsers();
}, select:function(scope, record, index, target) {
  console.log('select details....');
  scope.up('users-list-panel').showUserDetails(record);
}}}]}, searchRecords:function(searchvalue) {
  var userslist = this.down('list');
  userslist.getStore().clearFilter();
  userslist.getStore().filter(function(rec) {
    var searchOnString = '';
    var recData = rec.getData();
    for (var val in recData) {
      searchOnString += ' ' + recData[val];
    }
    if (searchOnString.indexOf(searchvalue) > -1) {
      return true;
    } else {
      return false;
    }
  });
}, showUserDetails:function(record) {
  if (this.getCallbackOnSelect()) {
    this.handleCallback(record.data.id);
  } else {
    if (Ext.ComponentQuery.query('user-details-view') && Ext.ComponentQuery.query('user-details-view')[0]) {
      var userDetailsFormPanel = Ext.ComponentQuery.query('user-details-view')[0];
      userDetailsFormPanel.loadUserDetails(record.data.id);
    }
  }
}, handleCallback:function(param) {
  console.log('handling callback... ');
  var callbck = this.getCallbackOnSelect();
  var scope = this.getCallbackScope();
  if (callbck) {
    if (!scope) {
      console.error('Missing scope inside callbackConfig ');
    } else {
      scope.onUserSelect(param);
    }
  }
}, loadUsers:function() {
  console.log('loading users from DB ');
  var thisView = this;
  thisView.setMasked({msg:'Loading users...'});
  var userListPanel = this.down('list');
  var userDetailsPanel = this.down('list');
  var usersListStore = userListPanel.getStore();
  usersListStore.getProxy().setUrl(Xedu.Config.getUrl(Xedu.Config.USER_SEARCH_SERVICE));
  usersListStore.load({callback:function(records, operation, success) {
    thisView.setMasked(false);
    if (Ext.ComponentQuery.query('user-details-view') && Ext.ComponentQuery.query('user-details-view')[0]) {
      userListPanel.select(0);
    }
  }});
}}, 0, ['users-list-panel'], ['component', 'container', 'panel', 'users-list-panel'], {'component':true, 'container':true, 'panel':true, 'users-list-panel':true}, ['widget.users-list-panel'], 0, [Xedu.view.users, 'UsersList2'], 0);
Ext.cmd.derive('Xedu.view.users.UsersList', Ext.Panel, {config:{itemId:'users-list-panel-id', title:'Users', scrollable:true, autoDestroy:true, autoSelect:false, callbackScope:null, callbackOnSelect:null, closeOnSelect:true, layout:{type:'vbox', pack:'start'}, items:[{xtype:'searchfield', placeHolder:'Search Users..', align:'center', ui:'dark', height:50, listeners:{keyup:function(el, e, eOpts) {
  this.up('users-list-panel').searchRecords(el.getValue());
}}}, {xtype:'list', flex:7, store:{type:'search-store'}, plugins:[{xclass:'Ext.plugin.PullRefresh', pullText:'Pull down to refresh the list!', loadingText:'Loading users..'}], itemTpl:['\x3ctable\x3e', '\t\x3ctr\x3e', '\t\t\x3ctd width\x3d"100"\x3e', '\t\t\t\x3cdiv\x3e', '\t\t\t\t\x3cimg src\x3d"resources/icons/user_profile2x64.png" /\x3e', '\t\t\t\x3c/div\x3e', '\t\t\x3c/td\x3e', '\t\t\x3ctd\x3e', '\t\t\t\x3cdiv\x3e', '\t\t\t\t\x3cb\x3e{recordTitle}\x3c/b\x3e {recordSubTitle}', '\t\t\t\x3c/div\x3e', 
'\t\t\x3c/td\x3e', '\t\x3c/tr\x3e', '\x3c/table\x3e'], onItemDisclosure:function(record, btn, index) {
}, listeners:{show:function(thisView, opts) {
  thisView.up('users-list-panel').loadUsers();
}, select:function(scope, record, index, target) {
  console.log('select details....');
  scope.up('users-list-panel').userSelected(record);
}}}], listeners:{show:function(thisView) {
  console.log('showing user list panel....');
  thisView.down('list').show();
}}}, searchRecords:function(searchvalue) {
  var userslist = this.down('list');
  userslist.getStore().clearFilter();
  userslist.getStore().filter(function(rec) {
    var searchOnString = '';
    var recData = rec.getData();
    for (var val in recData) {
      searchOnString += ' ' + recData[val];
    }
    if (searchOnString.indexOf(searchvalue) > -1) {
      return true;
    } else {
      return false;
    }
  });
}, userSelected:function(record) {
  if (this.getCallbackOnSelect()) {
    this.handleCallback(record.data.id);
  } else {
    if (Ext.ComponentQuery.query('user-details-view') && Ext.ComponentQuery.query('user-details-view')[0]) {
      var userDetailsFormPanel = Ext.ComponentQuery.query('user-details-view')[0];
      userDetailsFormPanel.loadUserDetails(record.data.id);
    }
  }
}, handleCallback:function(param) {
  console.log('handling callback... ');
  var callbck = this.getCallbackOnSelect();
  var scope = this.getCallbackScope();
  if (typeof callbck == 'function') {
    if (!scope) {
      console.error('Missing scope inside callbackConfig ');
    } else {
      callbck.apply(scope, [param]);
    }
  }
  if (this.getCloseOnSelect()) {
    this.hide();
  }
}, loadUsers:function() {
  console.log('loading users from DB ');
  var thisView = this;
  thisView.setMasked({msg:'Loading users...'});
  var userListPanel = this.down('list');
  var userDetailsPanel = this.down('list');
  var usersListStore = userListPanel.getStore();
  usersListStore.getProxy().setUrl(Xedu.Config.getUrl(Xedu.Config.USER_SEARCH_SERVICE));
  usersListStore.load({callback:function(records, operation, success) {
    thisView.setMasked(false);
    console.log('auto record select \x3d ' + thisView.getAutoSelect());
    if (thisView.getAutoSelect()) {
      userListPanel.select(0);
    }
  }});
}, updateList:function() {
  var listPanel = this.down('list');
  listPanel.getStore().load();
}}, 0, ['users-list-panel'], ['component', 'container', 'panel', 'users-list-panel'], {'component':true, 'container':true, 'panel':true, 'users-list-panel':true}, ['widget.users-list-panel'], 0, [Xedu.view.users, 'UsersList'], 0);
Ext.cmd.derive('Xedu.model.UserModel', Ext.data.Model, {config:{fields:[{name:'id', type:'string'}, {name:'userRecordId', type:'string'}, {name:'userId', type:'string'}, {name:'emailId', type:'string'}, {name:'userPswd', type:'string'}, {name:'userRoles', type:'string'}, {name:'firstName', type:'string'}, {name:'middleName', type:'string'}, {name:'lastName', type:'string'}, {name:'addressLine1', type:'string'}, {name:'addressLine2', type:'string'}, {name:'city', type:'string'}, {name:'state', type:'string'}, 
{name:'postalcode', type:'string'}, {name:'country', type:'string'}, {name:'cellphone', type:'string'}, {name:'okToText', type:'string'}, {name:'landlinephone', type:'string'}, {name:'officephone', type:'string'}, {name:'officephoneExt', type:'string'}, {name:'updatedBy', type:'string'}, {name:'lastUpdatedDateTime', type:'date'}], proxy:{type:'rest', url:Xedu.Config.getUrl(Xedu.Config.USER_SERVICE), reader:{type:'json', idProperty:'id', rootProperty:'user'}}}}, 0, 0, 0, 0, 0, 0, [Xedu.model, 'UserModel'], 
0);
Ext.cmd.derive('Xedu.model.ClassroomModel', Ext.data.Model, {config:{fields:[{name:'id', type:'string'}, {name:'courseRecordId', type:'string'}, {name:'name', type:'string'}, {name:'title', type:'string'}, {name:'subTitle', type:'string'}, {name:'description', type:'string'}, {name:'enrolledStudents', type:'auto'}], proxy:{type:'rest', url:Xedu.Config.getUrl(Xedu.Config.CLASSROOM_API), reader:{type:'json', idProperty:'id', rootProperty:'classroom'}}}}, 0, 0, 0, 0, 0, 0, [Xedu.model, 'ClassroomModel'], 
0);
Ext.cmd.derive('Xedu.model.EnrollmentModel', Ext.data.Model, {config:{fields:[{name:'id', type:'string'}, {name:'classroomid', type:'string'}, {name:'userRecordId', type:'string'}, {name:'enrolledOn', type:'date'}, {name:'verifiedBy', type:'string'}, {name:'updatedBy', type:'string'}, {name:'startDate', type:'date'}, {name:'endDate', type:'date'}, {name:'enrollStatus', type:'string'}, {name:'lastUpdatedDateTime', type:'date'}, {name:'student', model:'Xedu.model.UserModel'}, {name:'classroom', model:'Xedu.model.ClassroomModel'}], 
proxy:{type:'rest', url:Xedu.Config.getUrl(Xedu.Config.ENROLLMENT_API), reader:{type:'json', idProperty:'id', rootProperty:'enrollment'}}}}, 0, 0, 0, 0, 0, 0, [Xedu.model, 'EnrollmentModel'], 0);
Ext.cmd.derive('Xedu.view.users.UserDetailsPreview', Ext.Panel, {config:{fullscreen:false, autoDestroy:true, scrollable:true, userid:null, layout:{type:'vbox', pack:'center', align:'stretch'}, init:function() {
  this.callParent(arguments);
  console.log('initialized');
}, items:[{xtype:'image', autoDestroy:true, itemId:'user-profile-image-id', src:'resources/icons/user_profilex128.png', flex:1}, {xtype:'dataview', autoDestroy:true, flex:4, store:{model:'Xedu.model.UserModel'}, itemTpl:['\x3ch1\x3e\x3cb\x3eName:\x3c/b\x3e {lastName},{firstName}\x3c/h1\x3e', '\x3cp\x3e\x3cb\x3euserId :\x3c/b\x3e {userId}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3eemailId :\x3c/b\x3e {emailId}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3euserPswd :\x3c/b\x3e {userPswd}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3euserrole :\x3c/b\x3e {userrole}\x3c/p\x3e', 
'\x3cp\x3e\x3cb\x3efirstName :\x3c/b\x3e {firstName}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3emiddleName :\x3c/b\x3e {middleName}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3elastName :\x3c/b\x3e {lastName}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3eAddress :\x3c/b\x3e {addressLine1} {addressLine2}, {city} {state} {country} - {postalcode}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3ecell phone :\x3c/b\x3e {cellphone} \x3cb\x3eRecieveText :\x3c/b\x3e {okToText}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3eHome Phone :\x3c/b\x3e {landlinephone}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3eOffice phone :\x3c/b\x3e {officephone} - Ext: {officephoneExt} \x3c/p\x3e', 
'\x3cp\x3e\x3cb\x3eLast updated by :\x3c/b\x3e {updatedBy} \x3cb\x3eon:\x3c/b\x3e {lastUpdatedDateTime}\x3c/p\x3e']}], listeners:{show:function(thisView) {
  thisView.loadUserDetails();
}}}, loadUserDetails:function() {
  me = this;
  console.log('about to load user id \x3d' + this.getUserid());
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.USER_SERVICE) + '/' + me.getUserid(), method:'GET', headers:{'Content-Type':'application/json'}, success:function(response, conn, options, eOpts) {
    var result = Ext.JSON.decode(response.responseText);
    var userRecord = Ext.create('Xedu.model.UserModel', result.user);
    var userImageInfoRecord = Ext.create('Xedu.model.UserImageInfoModel', result.profileImageInfo);
    me.setUserImageInfoDetails(result.profileImageInfo);
    me.setUserDetails(userRecord);
  }, failure:function(conn, response, options, eOpts) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, setUserImageInfoDetails:function(userImageInfo, refreshImage) {
  if (userImageInfo && userImageInfo.imageid) {
    var imageUrl = Xedu.Config.getUrl(Xedu.Config.PROFILE_IMAGE_THUMB_SERVICE + userImageInfo.imageid);
    if (refreshImage) {
      imageUrl = imageUrl + '?dc\x3d' + (new Date).getTime();
    }
    this.down('#user-profile-image-id').setSrc(imageUrl);
  } else {
    this.down('#user-profile-image-id').setSrc('resources/icons/user_profilex128.png');
  }
}, setUserDetails:function(userRecord) {
  this.down('dataview').setRecord(userRecord);
}, clearPanel:function() {
  this.reset();
  this.down('#user-profile-image-id').setSrc('resources/icons/user_profilex128.png');
}, removeAllItems:function() {
  console.log('removing all items');
  this.down('dataview').destroy();
}}, 0, ['user-details-preview'], ['component', 'container', 'panel', 'user-details-preview'], {'component':true, 'container':true, 'panel':true, 'user-details-preview':true}, ['widget.user-details-preview'], 0, [Xedu.view.users, 'UserDetailsPreview'], 0);
Ext.cmd.derive('Xedu.view.classroom.ClassroomEditForm', Ext.form.Panel, {config:{fullscreen:false, autoDestroy:true, scrollable:true, previewOnly:true, layout:{type:'vbox', pack:'start'}, items:[{xtype:'dataview', itemId:'preview-classroom-details-id', autoDestroy:true, hidden:true, flex:1, store:{model:'Xedu.model.ClassroomModel'}, itemTpl:['\x3ch1\x3e\x3cb\x3eid:\x3c/b\x3e {lastName},{id}\x3c/h1\x3e', '\x3cp\x3e\x3cb\x3ecourse id :\x3c/b\x3e {courseRecordId}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3ename :\x3c/b\x3e {name}\x3c/p\x3e', 
'\x3cp\x3e\x3cb\x3etitle :\x3c/b\x3e {title}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3esubTitle :\x3c/b\x3e {subTitle}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3edescription :\x3c/b\x3e {description}\x3c/p\x3e']}, {xtype:'container', flex:1, itemId:'classroom-form-container-id', layout:{type:'vbox'}, items:[{xtype:'fieldset', height:170, layout:{type:'vbox', pack:'start'}, defaults:{height:50}, items:[{xtype:'textfield', name:'id', label:'ID', hidden:true}, {xtype:'textfield', name:'name', label:'Name'}, {xtype:'textfield', 
name:'title', label:'Title'}, {xtype:'textfield', name:'subTitle', label:'Sub Title'}]}, {xtype:'fieldset', layout:'fit', height:60, items:[{xtype:'textfield', name:'courseRecordId', itemId:'course-record-id-field-id', label:'Course Id', placeHolder:'Please select course', listeners:{focus:function(el, event, eOpts) {
  Xedu.CommonUtils.showOverlay2({xtype:'courses-list-panel', title:'Select student', width:'35%', height:'50%', modal:true, autoDestroy:true, hideOnMaskTap:true, callbackScope:el, callbackOnSelect:function(id) {
    el.setValue(id);
  }}, el);
}}}]}, {xtype:'fieldset', layout:'fit', flex:1, items:[{xtype:'textareafield', label:'Description', labelAlign:'top', name:'description'}]}]}, {docked:'bottom', xtype:'toolbar', ui:'dark', title:'', layout:{type:'hbox', pack:'center'}, items:[{xtype:'button', ui:'decline', text:'Edit', itemId:'editFormButton', handler:function(but, action, eOpts) {
  this.up('classroom-edit-form').togglePreviewAndEdit(true);
}}, {xtype:'button', ui:'light', text:'Cancel Edit', itemId:'cancelEditFormButton', hidden:true, handler:function(but, action, eOpts) {
  this.up('classroom-edit-form').togglePreviewAndEdit(false);
}}, {xtype:'button', ui:'confirm', text:'Save', itemId:'saveChangesButton', hidden:true, handler:function(but, action, eOpts) {
  this.up('classroom-edit-form').updateClassroom();
}}, {xtype:'button', ui:'decline', text:'Delete', hidden:true, itemId:'deleteChangesButton', handler:function(but, action, eOpts) {
  this.up('classroom-edit-form').deleteClassroom();
}}]}], listeners:{show:function() {
}}}, togglePreviewAndEdit:function(showEdit) {
  console.log('showing only preview \x3d' + this.getPreviewOnly());
  if (!showEdit) {
    this.down('#preview-classroom-details-id').setHidden(false);
    this.down('#classroom-form-container-id').setHidden(true);
    this.down('#cancelEditFormButton').setHidden(true);
    this.down('#editFormButton').setHidden(false);
    this.down('#saveChangesButton').setHidden(true);
  } else {
    this.down('#preview-classroom-details-id').setHidden(true);
    this.down('#classroom-form-container-id').setHidden(false);
    this.down('#cancelEditFormButton').setHidden(false);
    this.down('#editFormButton').setHidden(true);
    this.down('#saveChangesButton').setHidden(false);
  }
}, loadClassroom:function(id) {
  var classroomDetailsForm = this;
  var fields = classroomDetailsForm.getFields();
  var previewPanel = this.down('dataview');
  this.togglePreviewAndEdit();
  console.log('Loading classroom id \x3d' + id);
  var progressIndicator = Ext.create('Ext.ProgressIndicator');
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.CLASSROOM_API) + id, method:'GET', progress:progressIndicator, headers:{'Content-Type':'application/json'}, success:function(response, conn, options, eOpts) {
    var result = Ext.JSON.decode(response.responseText);
    var classroomRecord = Ext.create('Xedu.model.ClassroomModel', result.classroom);
    classroomDetailsForm.setRecord(classroomRecord);
    classroomDetailsForm.down('#deleteChangesButton').setHidden(false);
    previewPanel.setRecord(classroomRecord);
  }, failure:function(conn, response, options, eOpts) {
    Xedu.CommonUtils.checkServiceError(response);
  }});
}, updateClassroom:function() {
  var classroomForm = this;
  var fields = classroomForm.getFields();
  var id = fields['id'].getValue();
  var restUrl = Xedu.Config.getUrl(Xedu.Config.CLASSROOM_API);
  var restMethod = 'POST';
  if (id && id != '') {
    restMethod = 'PUT';
    restUrl = restUrl + id;
  }
  var progressIndicator = Ext.create('Ext.ProgressIndicator');
  classroomForm.submit({url:restUrl, method:restMethod, progress:progressIndicator, success:function(form, response) {
    var maincntrller = Xedu.app.getController('Main');
    Ext.Viewport.setMasked(false);
    Xedu.CommonUtils.checkServiceError(response);
    if (response.status == 'SUCCESS') {
      Ext.Msg.alert('SUCCESS', response.msg);
      var classroomlistpanel = Ext.ComponentQuery.query('classrooms-list-panel list');
      if (classroomlistpanel && classroomlistpanel[0]) {
        classroomlistpanel[0].getStore().load();
      }
    } else {
    }
  }, failure:function(form, response) {
    Xedu.CommonUtils.checkServiceError(response);
  }});
}, deleteClassroom:function() {
  var classroomDetailsForm = this;
  var fields = classroomDetailsForm.getFields();
  var id = fields['id'].getValue();
  if (id && id != '') {
    Ext.Msg.alert('Not allowed', 'Delete operation not available');
  }
  var classroomName = fields['title'].getValue() + ' ' + fields['subTitle'].getValue();
  Ext.Msg.confirm('Delete Classroom?', 'Are you sure you want to delete the classroom \x3cbr /\x3eid:' + id + '\x3cbr /\x3e Name:' + classroomName, function(btn) {
    if (btn == 'yes') {
      var progressIndicator = Ext.create('Ext.ProgressIndicator');
      classroomDetailsForm.submit({url:Xedu.Config.getUrl(Xedu.Config.CLASSROOM_API) + id, method:'DELETE', progress:progressIndicator, success:function(form, response, data) {
        Ext.Msg.alert(response.status, response.msg);
        var configListPanel = Ext.ComponentQuery.query('classrooms-list-panel list');
        if (configListPanel && configListPanel[0]) {
          configListPanel[0].getStore().load();
        }
      }, failure:function(el, resp, p) {
        Xedu.CommonUtils.checkServiceError(resp);
      }});
    }
  });
}}, 0, ['classroom-edit-form'], ['component', 'container', 'panel', 'formpanel', 'classroom-edit-form'], {'component':true, 'container':true, 'panel':true, 'formpanel':true, 'classroom-edit-form':true}, ['widget.classroom-edit-form'], 0, [Xedu.view.classroom, 'ClassroomEditForm'], 0);
Ext.cmd.derive('Xedu.field.DateTextField', Ext.field.Text, {setValue:function(value) {
  if (this.config.dateFormat && value) {
    console.log('setting the date format \x3d' + this.config.dateFormat);
    if (Ext.isDate(value)) {
      value = Ext.Date.format(value, this.config.dateFormat);
    } else {
      var d = new Date(value);
      value = Ext.Date.format(d, this.config.dateFormat);
    }
  }
  Ext.field.Text.prototype.setValue.apply(this, arguments);
}}, 0, ['datetextfield'], ['component', 'field', 'textfield', 'datetextfield'], {'component':true, 'field':true, 'textfield':true, 'datetextfield':true}, ['widget.datetextfield'], 0, [Xedu.field, 'DateTextField'], 0);
Ext.cmd.derive('Xedu.view.classroom.EnrollmentEditForm', Ext.form.Panel, {config:{fullscreen:false, autoDestroy:true, scrollable:true, title:'Enroll a new Student', enrollmentid:null, classroomid:null, userRecordId:null, showPreview:false, layout:{type:'fit'}, items:[{xtype:'container', flex:1, height:'100%', itemId:'enrollment-form-container-id', layout:{type:'vbox', pack:'start'}, items:[{xtype:'fieldset', height:200, layout:{type:'vbox', pack:'start'}, defaults:{labelAlign:'left', flex:1}, items:[{xtype:'textfield', 
name:'id', itemId:'enrollmentid-field-id', label:'Enroll ID'}, {xtype:'textfield', name:'classroomid', itemId:'classroomid-field-id', label:'Class ID', placeHolder:'Please select the class'}, {xtype:'textfield', name:'userRecordId', itemId:'user-record-id-field-id', label:'User Record Id', placeHolder:'Please select the user', listeners:{focus:function(el, event, eOpts) {
  Xedu.CommonUtils.showOverlay2({xtype:'users-list-panel', title:'Select student', width:'35%', height:'50%', modal:true, autoDestroy:true, hideOnMaskTap:true, callbackScope:el, callbackOnSelect:function(id) {
    el.setValue(id);
  }}, el);
}}}, {xtype:'datetextfield', name:'enrolledOn', itemId:'enrolledondate-field-id', dateFormat:'Y-m-d', label:'Enroll Date (YYYY-MM-DD)', placeHolder:'YYYY-MM-DD', value:new Date}]}, {xtype:'fieldset', height:50, layout:{type:'vbox', pack:'start'}, defaults:{labelAlign:'top', flex:1}, items:[{xtype:'selectfield', label:'Status', labelAlign:'left', name:'enrollStatus', autoSelect:false, placeHolder:'Please select the status', options:[{text:'ACTIVE', value:'ACTIVE'}, {text:'SUSPENDED', value:'SUSPENDED'}, 
{text:'CLOSED', value:'CLOSED'}]}]}]}, {docked:'bottom', xtype:'toolbar', ui:'dark', title:'', layout:{type:'hbox', pack:'center'}, items:[{xtype:'button', ui:'confirm', text:'Save', itemId:'enrollUserbutton', handler:function(but, action, eOpts) {
  this.up('enrollment-edit-form').updateEnrollment();
}}, {xtype:'button', ui:'decline', text:'Delete', hidden:true, itemId:'editEnrollButton', handler:function(but, action, eOpts) {
  this.up('enrollment-edit-form').deleteEnrollment();
}}]}], listeners:{show:function(thisView) {
  console.log('showing enrollment edit form');
  thisView.setDataToForm();
}}}, setDataToForm:function() {
  this.down('#enrollmentid-field-id').setValue(this.getEnrollmentid());
  this.down('#classroomid-field-id').setValue(this.getClassroomid());
  if (this.getUserRecordId() != 'new') {
    this.down('#user-record-id-field-id').setValue(this.getUserRecordId());
  }
  this.loadEnrollmentDetails();
}, loadEnrollmentDetails:function() {
  console.log('about to load enrollment info id \x3d' + this.getEnrollmentid());
  if (this.getEnrollmentid() == null || this.getEnrollmentid() == '') {
    return;
  }
  me = this;
  this.setMasked({msg:'Loading enrollment details...'});
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.ENROLLMENT_API) + me.getEnrollmentid(), method:'GET', headers:{'Content-Type':'application/json'}, success:function(response, conn, options, eOpts) {
    me.setMasked(false);
    var result = Ext.JSON.decode(response.responseText);
    var enrollmentRecord = Ext.create('Xedu.model.EnrollmentModel', result.enrollment);
    me.setRecord(enrollmentRecord);
  }, failure:function(conn, response, options, eOpts) {
    this.setMasked(false);
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, updateEnrollment:function() {
  var enrollmentForm = this;
  var fields = enrollmentForm.getFields();
  var id = fields['id'].getValue();
  var restUrl = Xedu.Config.getUrl(Xedu.Config.ENROLLMENT_API);
  var restMethod = 'POST';
  if (id && id != '') {
    restMethod = 'PUT';
    restUrl = restUrl + id;
  }
  this.setMasked({msg:'Updating enrollment details...'});
  enrollmentForm.submit({url:restUrl, method:restMethod, success:function(form, response) {
    this.setMasked(false);
    var maincntrller = Xedu.app.getController('Main');
    Xedu.CommonUtils.checkServiceError(response);
    if (response.status == 'SUCCESS') {
      me.setMasked(false);
      Ext.Msg.alert('SUCCESS', response.msg);
      var enrollmentlistpanel = Ext.ComponentQuery.query('enrollments-list-panel list');
      var enrollmentRecord = Ext.create('Xedu.model.EnrollmentModel', response.enrollment);
      me.setRecord(enrollmentRecord);
      if (enrollmentlistpanel && enrollmentlistpanel[0]) {
        enrollmentlistpanel[0].getStore().load();
      }
    } else {
    }
  }, failure:function(form, response) {
    Xedu.CommonUtils.checkServiceError(response);
  }});
}, deleteEnrollment:function() {
  var enrollmentDetailsForm = this;
  var fields = enrollmentDetailsForm.getFields();
  var id = fields['id'].getValue();
  if (id && id != '') {
    Ext.Msg.alert('Not allowed', 'Delete operation not available');
  }
  var enrollmentName = fields['title'].getValue() + ' ' + fields['subTitle'].getValue();
  Ext.Msg.confirm('Delete Enrollment?', 'Are you sure you want to delete the enrollment \x3cbr /\x3eid:' + id + '\x3cbr /\x3e Name:' + enrollmentName, function(btn) {
    if (btn == 'yes') {
      var progressIndicator = Ext.create('Ext.ProgressIndicator');
      enrollmentDetailsForm.submit({url:Xedu.Config.getUrl(Xedu.Config.CLASSROOM_API) + id, method:'DELETE', progress:progressIndicator, success:function(form, response, data) {
        Ext.Msg.alert(response.status, response.msg);
        var configListPanel = Ext.ComponentQuery.query('enrollments-list-panel list');
        if (configListPanel && configListPanel[0]) {
          configListPanel[0].getStore().load();
        }
      }, failure:function(el, resp, p) {
        Xedu.CommonUtils.checkServiceError(resp);
      }});
    }
  });
}}, 0, ['enrollment-edit-form'], ['component', 'container', 'panel', 'formpanel', 'enrollment-edit-form'], {'component':true, 'container':true, 'panel':true, 'formpanel':true, 'enrollment-edit-form':true}, ['widget.enrollment-edit-form'], 0, [Xedu.view.classroom, 'EnrollmentEditForm'], 0);
Ext.cmd.derive('Xedu.view.classroom.EnrollmentDetailsPreview', Ext.Panel, {config:{fullscreen:false, autoDestroy:true, scrollable:true, title:'', enrollmentid:null, layout:{type:'fit', pack:'center', align:'stretch'}, init:function() {
  this.callParent(arguments);
  console.log('initialized');
}, items:[{docked:'bottom', xtype:'toolbar', ui:'dark', title:'', layout:{type:'hbox', pack:'center'}, items:[{xtype:'button', ui:'decline', text:'Edit', itemId:'unEnrollButton', handler:function(but, action, eOpts) {
  this.up('enrollment-details-preview').editEnrollment();
}}, {xtype:'button', ui:'decline', text:'Delete', itemId:'deleteEnrollButton', handler:function(but, action, eOpts) {
  this.up('enrollment-details-preview').deleteEnrollment();
}}]}, {xtype:'dataview', flex:1, autoDestroy:true, scrollable:true, store:{model:'Xedu.model.EnrollmentModel'}, itemTpl:['\x3ch1\x3e\x3cb\x3eid:\x3c/b\x3e {id}\x3c/h1\x3e', '\x3cp\x3e\x3cb\x3eclassroom id :\x3c/b\x3e {classroomid}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3eenrolled on :\x3c/b\x3e {enrolledOn}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3everified by :\x3c/b\x3e {verifiedBy}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3eupdated by :\x3c/b\x3e {updatedBy}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3estart date :\x3c/b\x3e {startDate}\x3c/p\x3e', 
'\x3cp\x3e\x3cb\x3eend date :\x3c/b\x3e {endDate}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3estatus :\x3c/b\x3e {enrollStatus}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3eLast updated by :\x3c/b\x3e {updatedBy} \x3cb\x3eon:\x3c/b\x3e {lastUpdatedDateTime}\x3c/p\x3e', '\x3ch1\x3eSTUDENT INFO:\x3c/h1\x3e', '\x3ch1\x3e---------------------------------------------------------------------------\x3c/h1\x3e', '\x3ctpl for\x3d"student" \x3e', '\t\t\x3ch1\x3e\x3cb\x3eid:\x3c/b\x3e {id}\x3c/h1\x3e', '\t\t\x3cp\x3e\x3cb\x3euserId :\x3c/b\x3e {userId}\x3c/p\x3e', 
'\t\t\x3cp\x3e\x3cb\x3eemailId :\x3c/b\x3e {emailId}\x3c/p\x3e', '\t\t\x3cp\x3e\x3cb\x3euserPswd :\x3c/b\x3e {userPswd}\x3c/p\x3e', '\t\t\x3cp\x3e\x3cb\x3euserrole :\x3c/b\x3e {userrole}\x3c/p\x3e', '\t\t\x3cp\x3e\x3cb\x3efirstName :\x3c/b\x3e {firstName}\x3c/p\x3e', '\t\t\x3cp\x3e\x3cb\x3emiddleName :\x3c/b\x3e {middleName}\x3c/p\x3e', '\t\t\x3cp\x3e\x3cb\x3elastName :\x3c/b\x3e {lastName}\x3c/p\x3e', '\t\t\x3cp\x3e\x3cb\x3eAddress :\x3c/b\x3e {addressLine1} {addressLine2}, {city} {state} {country} - {postalcode}\x3c/p\x3e', 
'\t\t\x3cp\x3e\x3cb\x3ecell phone :\x3c/b\x3e {cellphone} \x3cb\x3eRecieveText :\x3c/b\x3e {okToText}\x3c/p\x3e', '\t\t\x3cp\x3e\x3cb\x3eHome Phone :\x3c/b\x3e {landlinephone}\x3c/p\x3e', '\t\t\x3cp\x3e\x3cb\x3eOffice phone :\x3c/b\x3e {officephone} - Ext: {officephoneExt} \x3c/p\x3e', '\t\t\x3cp\x3e\x3cb\x3eLast updated by :\x3c/b\x3e {updatedBy} \x3cb\x3eon:\x3c/b\x3e {lastUpdatedDateTime}\x3c/p\x3e', '\x3c/tpl\x3e', '\x3ch1\x3eCLASSROOM INFO:\x3c/h1\x3e', '\x3ch1\x3e---------------------------------------------------------------------------\x3c/h1\x3e', 
'\x3ctpl for\x3d"classroom" \x3e', '\t\t\x3ch1\x3e\x3cb\x3eid:\x3c/b\x3e {id}\x3c/h1\x3e', '\t\t\x3cp\x3e\x3cb\x3ename :\x3c/b\x3e {name}\x3c/p\x3e', '\t\t\x3cp\x3e\x3cb\x3etitle :\x3c/b\x3e {title}\x3c/p\x3e', '\t\t\x3cp\x3e\x3cb\x3esubTitle :\x3c/b\x3e {subTitle}\x3c/p\x3e', '\t\t\x3cp\x3e\x3cb\x3edescription :\x3c/b\x3e {description}\x3c/p\x3e', '\x3c/tpl\x3e']}], listeners:{show:function(thisView) {
  thisView.loadEnrollmentDetails();
}}}, loadEnrollmentDetails:function() {
  me = this;
  console.log('about to load enrollment info id \x3d' + this.getEnrollmentid());
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.ENROLLMENT_API) + me.getEnrollmentid(), method:'GET', headers:{'Content-Type':'application/json'}, success:function(response, conn, options, eOpts) {
    var result = Ext.JSON.decode(response.responseText);
    var enrollmentRecord = Ext.create('Xedu.model.EnrollmentModel', result.enrollment);
    me.setEnrollmentRecord(enrollmentRecord.copy());
  }, failure:function(conn, response, options, eOpts) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, setEnrollmentRecord:function(enrollmentRecord) {
  this.down('dataview').setRecord(enrollmentRecord);
}, setUserDetails:function(userRecord) {
  this.down('user-details-preview').down('dataview').setRecord(userRecord);
}, editEnrollment:function() {
  var id = this.getEnrollmentid();
  this.hide();
  if (id && id != '') {
    Xedu.app.getController('Main').redirectTo('edit/enrollment/' + id);
  } else {
    Ext.Msg.alert('Not allowed', 'Operation not available!');
  }
}, deleteEnrollment:function() {
  var id = this.getEnrollmentid();
  if (id && id != '') {
    Ext.Msg.alert('Not allowed', 'Operation not available!');
  }
  var me = this;
  var progressIndicator = Ext.create('Ext.ProgressIndicator');
  Ext.Msg.confirm('Delete enrollment?', 'Are you sure you want to remove user from classroom?', function(btn) {
    if (btn == 'yes') {
      var progressIndicator = Ext.create('Ext.ProgressIndicator');
      Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.ENROLLMENT_API) + id, method:'DELETE', progress:progressIndicator, success:function(resp) {
        var response = Ext.JSON.decode(resp.responseText);
        Ext.Msg.alert(response.status, response.msg, function() {
          var enrolledStudentsListPanel = Ext.ComponentQuery.query('enrolled-students-list-panel list');
          if (enrolledStudentsListPanel && enrolledStudentsListPanel[0]) {
            enrolledStudentsListPanel[0].getStore().load();
          }
          me.down('#unEnrollButton').setHidden(true);
          me.down('#deleteEnrollButton').setHidden(true);
          me.close();
        });
      }, failure:function(el, resp, p) {
        Xedu.CommonUtils.checkServiceError(resp);
      }});
    }
  });
}, setClassroomDetails:function(classroomRecord) {
  this.down('classroom-edit-form').down('dataview').setRecord(classroomRecord);
}}, 0, ['enrollment-details-preview'], ['component', 'container', 'panel', 'enrollment-details-preview'], {'component':true, 'container':true, 'panel':true, 'enrollment-details-preview':true}, ['widget.enrollment-details-preview'], 0, [Xedu.view.classroom, 'EnrollmentDetailsPreview'], 0);
Ext.cmd.derive('Xedu.view.users.UserEnrolledClassesList', Ext.Panel, {config:{layout:{type:'vbox'}, userid:null, editMode:false, items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'Enrolled Classes', layout:{type:'hbox', pack:'right', align:'stretch'}, defaults:{ui:'plain'}, items:[{xtype:'button', iconCls:'add', align:'right', handler:function(but, action, eOpts) {
  this.up('user-enrolled-classes-list').createNewClassroom();
}}]}, {xtype:'searchfield', placeHolder:'search classes..', align:'center', ui:'neutral', height:50, listeners:{keyup:function(el, e, eOpts) {
  Xedu.CommonUtils.filterStore(this.up('user-enrolled-classes-list').down('list'), el.getValue());
}}}, {xtype:'list', flex:1, itemId:'user-enrolled-classes-list-id', title:'Enrolled Students', scrollable:true, autoDestroy:true, store:{type:'search-store'}, plugins:[{xclass:'Ext.plugin.PullRefresh', pullText:'Pull down to refresh the list!'}], itemTpl:['\x3cdiv\x3e', '\t\t\t\x3cspan style\x3d"color:gray"\x3eTitle: \x3c/span\x3e{recordTitle}, ', '\x3c/div\x3e', '\x3cdiv\x3e', '\t\t\t\x3cspan style\x3d"color:gray"\x3e{recordSubTitle} \x3c/span\x3e ', '\x3c/div\x3e'], listeners:{itemsingletap:function(scope, 
index, target, record) {
  console.log('tapped class');
  scope.up('user-enrolled-classes-list').viewEnrollmentInfo(record, target);
}}}]}, loadEnrolledClasses:function() {
  var thisView = this;
  console.log('Loading enrolled classes...');
  thisView.setMasked({msg:'Loading classrooms...'});
  var classroomListStore = thisView.down('list').getStore();
  classroomListStore.getProxy().setUrl(Xedu.Config.getUrl(Xedu.Config.STUDENT_ENROLLED_CLASSES_SEARCH));
  classroomListStore.setParams({'urecid':this.getUserid()});
  classroomListStore.load({callback:function(records, operation, success) {
    thisView.setMasked(false);
  }});
}, joinClassroomSession:function(record) {
  Xedu.app.getController('Main').redirectTo('join/classroom/session/' + record.data.recordId);
}, viewEnrollmentInfo:function(record, target) {
  Xedu.CommonUtils.showOverlay2({xtype:'enrollment-details-preview', enrollmentid:record.data.id, title:record.data.title, modal:true, autoDestroy:true, hideOnMaskTap:true, width:'50%', height:'65%', title:'Enrollment Info'}, target);
}, unEnrollFromClass:function(enrollid) {
  thisView.setMasked({msg:'Un-enrolling user \x3d ' + this.getUserid() + '... Please wait'});
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.CLASSROOM_ENROLLED_STUDENTS_API) + '/' + enrollid, method:'GET', headers:{'Content-Type':'application/json'}, success:function(response, conn, options, eOpts) {
    var result = Ext.JSON.decode(response.responseText);
    var userRecord = Ext.create('Xedu.model.UserModel', result.user);
    var userImageInfoRecord = Ext.create('Xedu.model.UserImageInfoModel', result.profileImageInfo);
    userDetailsFormPanel.setRecord(userRecord);
    userEnrolledClassesPanel.setUserid(result.user.userId);
    userEnrolledClassesPanel.loadEnrolledClasses();
    if (userDetailsHeaderFormPanel) {
      userDetailsHeaderFormPanel.setUserImageInfoDetails(result.profileImageInfo);
      userDetailsHeaderFormPanel.setUserDetails(userRecord);
    }
  }, failure:function(conn, response, options, eOpts) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}}, 0, ['user-enrolled-classes-list'], ['component', 'container', 'panel', 'user-enrolled-classes-list'], {'component':true, 'container':true, 'panel':true, 'user-enrolled-classes-list':true}, ['widget.user-enrolled-classes-list'], 0, [Xedu.view.users, 'UserEnrolledClassesList'], 0);
Ext.cmd.derive('Xedu.ux.field.MultiSelect', Ext.field.Select, {config:{delimiter:',', mode:'MULTI', doneButton:true}, applyDoneButton:function(config) {
  if (config) {
    if (Ext.isBoolean(config)) {
      config = {};
    }
    if (typeof config == 'string') {
      config = {text:config};
    }
    Ext.applyIf(config, {text:'Done', ui:'action', height:'20px', margin:'5px auto 0px auto', width:'50%', docked:'bottom', listeners:{tap:this.onButtonTap, scope:this}});
  }
  return Ext.factory(config, 'Ext.Button', this.getDoneButton());
}, getTabletPicker:function() {
  var me = this, config = me.getDefaultTabletPickerConfig(), listMode = me.getMode();
  if (!me.listPanel) {
    me.listPanel = Ext.create('Ext.Panel', Ext.apply({left:0, top:0, modal:true, cls:'x-select-overlay', layout:'fit', hideOnMaskTap:true, width:Ext.os.is.Phone ? '14em' : '18em', height:Ext.os.is.BlackBerry && Ext.os.version.getMajor() === 10 ? '12em' : Ext.os.is.Phone ? '12.5em' : '22em', items:[{xtype:'list', mode:listMode, store:me.getStore(), itemTpl:'\x3cspan class\x3d"x-list-label"\x3e{' + me.getDisplayField() + ':htmlEncode}\x3c/span\x3e'}]}, config));
    if (listMode === 'SINGLE') {
      me.listPanel.down('list').on('itemtap', me.onListTap, me);
    } else {
      me.listPanel.add(this.getDoneButton());
    }
  }
  return me.listPanel;
}, onListTap:function(list, index, target, record) {
  this.setValue(record);
  Ext.field.Select.prototype.onListTap.call(this);
}, onButtonTap:function() {
  var records = this.listPanel.down('list').getSelection();
  this.setValue(records);
  this.superclass.onListTap.call(this);
}, applyValue:function(value) {
  this.getOptions();
  return this.getValueFromRecords(value, this.getValueField());
}, updateValue:function(newValue, oldValue) {
  var me = this, value = me.convertValue(newValue, me.getValueField(), me.getDisplayField());
  value = value.join(me.getDelimiter());
  me.superclass.superclass.updateValue.call(me, [value]);
}, convertValue:function(value, fieldIn, fieldOut) {
  var delimiter = this.getDelimiter(), store = this.getStore(), i = 0, out = [], len, item;
  if (value) {
    if (delimiter && Ext.isString(value)) {
      value = value.split(delimiter);
    } else {
      if (!Ext.isArray(value)) {
        value = [value];
      }
    }
    for (len = value.length; i < len; ++i) {
      item = store.findRecord(fieldIn, value[i]);
      if (item) {
        out.push(item.get(fieldOut));
      }
    }
  }
  return out;
}, getValueFromRecords:function(value) {
  var delimiter = this.getDelimiter(), valueField = this.getValueField(), i = 0, out = [], len, item;
  if (value) {
    if (delimiter && Ext.isString(value)) {
      value = value.split(delimiter);
    } else {
      if (!Ext.isArray(value)) {
        value = [value];
      }
    }
    for (len = value.length; i < len; ++i) {
      item = value[i];
      if (item && item.isModel) {
        out.push(item.get(valueField));
      }
    }
    out = Ext.Array.unique(out);
  }
  return out.length > 0 ? out : value;
}, getRecordsFromValue:function(value) {
  var records = [], all = this.getStore().getRange(), valueField = this.getValueField(), i = 0, allLen = all.length, rec, j, valueLen;
  if (value) {
    for (valueLen = value.length; i < valueLen; ++i) {
      for (j = 0; j < allLen; ++j) {
        rec = all[j];
        if (rec.get(valueField) == value[i]) {
          records.push(rec);
          break;
        }
      }
    }
  }
  return records;
}, getSelection:function() {
  return this.listPanel.down('list').getSelection();
}, getValue:function() {
  return this._value;
}, onChange:function(component, newValue, oldValue) {
  var me = this, old = me.convertValue(oldValue, me.getDisplayField(), me.getValueField());
  me.fireEvent('change', me, me.getValue(), old);
}, showPicker:function() {
  var me = this, store = this.getStore();
  if (!store || store.getCount() === 0) {
    return;
  }
  if (me.getReadOnly()) {
    return;
  }
  me.isFocused = true;
  var listPanel = me.getTabletPicker(), list = listPanel.down('list'), index, records, value = me.getValue();
  if (!listPanel.getParent()) {
    Ext.Viewport.add(listPanel);
  }
  if (value) {
    records = me.getRecordsFromValue(value);
    list.select(records, null, true);
  } else {
    list.deselectAll();
  }
  listPanel.showBy(me.getComponent(), Ext.os.is.BlackBerry && Ext.os.version.getMajor() === 10 ? 't-b' : null);
}, onStoreDataChanged:function(store) {
  var me = this, initialConfig = me.getInitialConfig(), value = me.getValue();
  if (value || value === 0) {
    me.updateValue(me.applyValue(value));
  }
  if (me.getValue() === null) {
    if (initialConfig.hasOwnProperty('value')) {
      me.setValue(initialConfig.value);
    }
    if (me.getValue() === null && me.getAutoSelect()) {
      if (store.getCount() > 0) {
        me.setValue(store.getAt(1));
      }
    }
  }
}}, 0, ['multiselectfield'], ['component', 'field', 'textfield', 'selectfield', 'multiselectfield'], {'component':true, 'field':true, 'textfield':true, 'selectfield':true, 'multiselectfield':true}, ['widget.multiselectfield'], 0, [Xedu.ux.field, 'MultiSelect'], 0);
Ext.cmd.derive('Xedu.store.UserRolesStore', Ext.data.Store, {require:['Xedu.Config', 'Ext.data.proxy.Rest'], config:{fields:[{name:'text', value:'string'}, {name:'value', value:'string'}], data:[{text:'ADMIN', value:'ADMIN'}, {text:'PARENT', value:'PARENT'}, {text:'STUDENT', value:'STUDENT'}, {text:'PRINCIPAL', value:'PRINCIPAL'}, {text:'TEACHER', value:'TEACHER'}]}}, 0, 0, 0, 0, ['store.user-roles-store'], 0, [Xedu.store, 'UserRolesStore'], 0);
Ext.cmd.derive('Xedu.model.UserImageInfoModel', Ext.data.Model, {config:{fields:[{name:'imageid', type:'string'}, {name:'lastUpdatedDateTime', type:'date'}, {name:'userId', type:'string'}, {name:'userImageType', type:'string'}], proxy:{type:'rest', url:Xedu.Config.getUrl(Xedu.Config.USER_SERVICE), reader:{type:'json', idProperty:'id', rootProperty:'user'}}}}, 0, 0, 0, 0, 0, 0, [Xedu.model, 'UserImageInfoModel'], 0);
Ext.cmd.derive('Xedu.view.users.UserDetailsView', Ext.TabPanel, {config:{fullscreen:false, autoDestroy:true, plain:true, ui:'neutral', scrollable:true, userid:null, defaults:{styleHtmlContent:true}, items:[{docked:'bottom', xtype:'toolbar', ui:'dark', title:'', layout:{type:'hbox', pack:'center'}, items:[{xtype:'button', ui:'confirm', text:'Save', itemId:'saveChangesButton', handler:function(but, action, eOpts) {
  Ext.ComponentQuery.query('user-details-view')[0].submitNewUser();
}}, {xtype:'button', ui:'decline', text:'Delete', itemId:'deleteChangesButton', handler:function(but, action, eOpts) {
  Ext.ComponentQuery.query('user-details-view')[0].deleteUser();
}}]}, {xtype:'user-enrolled-classes-list', title:'Enrolled Classes'}, {xtype:'panel', title:'user details', layout:{type:'fit'}, scrollable:true, items:[{xtype:'formpanel', title:'Personal Details', itemId:'user-personal-info-details-form', scrollable:true, layout:{type:'vbox'}, items:[{xtype:'fieldset', title:'User Login', instructions:'User ', layout:'fit', items:[{xtype:'textfield', name:'id', label:'id'}, {xtype:'textfield', name:'userId', label:'User ID'}, {xtype:'textfield', name:'emailId', 
label:'Email ID'}, {xtype:'multiselectfield', label:'Roles', name:'userRoles', valueField:'text', dataField:'value', autoSelect:false, store:{type:'user-roles-store'}}, {xtype:'textfield', label:'Last Updated By', name:'updatedBy'}, {xtype:'datepickerfield', label:'Last Updated On', name:'lastUpdatedDateTime'}]}, {xtype:'fieldset', title:'About You', layout:'fit', instructions:'User name/dob', items:[{xtype:'textfield', name:'firstName', label:'First Name'}, {xtype:'textfield', name:'middleName', 
label:'Middle Name'}, {xtype:'textfield', name:'lastName', label:'Last Name'}]}, {xtype:'fieldset', title:'Address', layout:'fit', instructions:'User contact address', items:[{xtype:'textfield', name:'addressLine1', label:'Street Line 1 '}, {xtype:'textfield', name:'addressLine2', label:'Street Line 2 '}, {xtype:'textfield', name:'city', label:'City'}, {xtype:'textfield', name:'state', label:'State'}, {xtype:'textfield', name:'country', label:'Country'}, {xtype:'textfield', name:'postalcode', label:'Postal Code'}]}, 
{xtype:'fieldset', title:'Contact Info', layout:'fit', instructions:'Contact Info', items:[{xtype:'textfield', name:'cellphone', label:'Cell phone '}, {xtype:'togglefield', name:'okToText', label:'Recieve Text Alerts?'}, {xtype:'textfield', name:'landlinephone', label:'Land phone'}, {xtype:'textfield', name:'officephone', label:'Office phone'}, {xtype:'textfield', name:'officephoneExt', label:'Office phone Ext'}]}]}]}]}, loadUserDetails:function(id) {
  var userDetailsFormPanel = this.down('formpanel');
  var userDetailsHeaderFormPanel = Ext.ComponentQuery.query('user-details-header-view')[0];
  var userEnrolledClassesPanel = this.down('user-enrolled-classes-list');
  userDetailsFormPanel.setMasked({msg:'Loading user details...'});
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.USER_SERVICE) + '/' + id, method:'GET', headers:{'Content-Type':'application/json'}, success:function(response, conn, options, eOpts) {
    userDetailsFormPanel.setMasked(false);
    var result = Ext.JSON.decode(response.responseText);
    var userRecord = Ext.create('Xedu.model.UserModel', result.user);
    var userImageInfoRecord = Ext.create('Xedu.model.UserImageInfoModel', result.profileImageInfo);
    console.log(userRecord.getData().userRoles);
    userDetailsFormPanel.setRecord(userRecord);
    userEnrolledClassesPanel.setUserid(result.user.id);
    userEnrolledClassesPanel.loadEnrolledClasses();
    if (userDetailsHeaderFormPanel) {
      userDetailsHeaderFormPanel.setUserImageInfoDetails(result.profileImageInfo);
      userDetailsHeaderFormPanel.setUserDetails(userRecord);
    }
  }, failure:function(conn, response, options, eOpts) {
    userDetailsFormPanel.setMasked(false);
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, createNewUserForm:function() {
  var userDetailsFormPanel = this.down('formpanel');
  userDetailsFormPanel.reset();
  var userDetailsHeaderPanel = this.up('user-mgmt-main-view').down('user-details-header-view').clearPanel();
}, submitNewUser:function() {
  var userDetailsFrom = Ext.ComponentQuery.query('#user-personal-info-details-form')[0];
  var fields = userDetailsFrom.getFields();
  var me = this;
  var id = fields['id'].getValue();
  var restUrl = Xedu.Config.getUrl(Xedu.Config.USER_SERVICE);
  var restMethod = 'POST';
  if (id && id != '') {
    restMethod = 'PUT';
    restUrl = restUrl + '/' + id;
  }
  userDetailsFrom.setMasked({msg:'Updating user...Please wait!'});
  userDetailsFrom.submit({url:restUrl, method:restMethod, success:function(form, response, data) {
    var maincntrller = Xedu.app.getController('Main');
    userDetailsFrom.setMasked(false);
    Xedu.CommonUtils.checkServiceError(response);
    if (response.status == 'SUCCESS') {
      Ext.Msg.alert('Success', response.msg, Ext.emptyFn);
      var listPanel = Ext.ComponentQuery.query('users-list-panel');
      if (listPanel) {
        listPanel.updateList();
      }
      me.loadUserDetails(response.user.id);
    } else {
    }
  }, failure:function(el, resp, p) {
    Ext.Viewport.setMasked(false);
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, deleteUser:function() {
  var userDetailsFrom = Ext.ComponentQuery.query('#user-personal-info-details-form')[0];
  var fields = userDetailsFrom.getFields();
  var id = fields['id'].getValue();
  var fullname = fields['firstName'].getValue() + ' ' + fields['lastName'].getValue();
  Ext.Msg.confirm('Delete User?', 'Are you sure you want to delete record \x3cbr /\x3eid:' + id + '\x3cbr /\x3e Name:' + fullname, function(btn) {
    if (btn == 'yes') {
      Ext.Viewport.mask({msg:'Deleting user...Please wait!'});
      userDetailsFrom.submit({url:Xedu.Config.getUrl(Xedu.Config.USER_SERVICE) + '/' + id, method:'DELETE', success:function(form, response, data) {
        var maincntrller = Xedu.app.getController('Main');
        Ext.Viewport.setMasked(false);
        Xedu.CommonUtils.checkServiceError(response);
        Ext.Msg.alert(response.status, response.msg, Ext.emptyFn);
        var listPanel = Ext.ComponentQuery.query('users-list-panel');
        if (listPanel) {
          listPanel.updateList();
        }
      }, failure:function(el, resp, p) {
        Ext.Viewport.setMasked(false);
        Xedu.CommonUtils.checkServiceError(resp);
      }});
    }
  });
}}, 0, ['user-details-view'], ['component', 'container', 'tabpanel', 'user-details-view'], {'component':true, 'container':true, 'tabpanel':true, 'user-details-view':true}, ['widget.user-details-view'], 0, [Xedu.view.users, 'UserDetailsView'], 0);
Ext.cmd.derive('Xedu.view.users.UserDetailsHeader', Ext.form.Panel, {config:{fullscreen:false, autoDestroy:true, scrollable:false, layout:{type:'hbox'}, items:[{xtype:'fieldset', layout:'vbox', items:[{xtype:'textfield', name:'userId', hidden:true, flex:1}, {xtype:'textfield', name:'imageid', itemId:'imageid', hidden:true, flex:1}, {xtype:'image', itemId:'user-profile-image-id', src:'resources/icons/user_profilex128.png', flex:3}, {xtype:'filefield', name:'userimage', accept:'image', flex:1, listeners:{change:function(el, 
newValue, oldValue, eOpts) {
  el.up('user-details-header-view').uploadPicture();
}}}]}, {xtype:'fieldset', layout:'hbox', flex:1, items:[{xtype:'textfield', name:'firstName'}, {xtype:'textfield', name:'middleName'}, {xtype:'textfield', name:'lastName'}]}]}, uploadPicture:function() {
  var uploadForm = this;
  var me = this;
  var progressIndicator = Ext.create('Ext.ProgressIndicator');
  uploadForm.submit({url:Xedu.Config.getUrl(Xedu.Config.UPLOAD_PROFILE_IMAGE_SERVICE), method:'POST', xhr2:true, progress:progressIndicator, success:function(form, response) {
    var maincntrller = Xedu.app.getController('Main');
    Ext.Viewport.setMasked(false);
    Xedu.CommonUtils.checkServiceError(response);
    if (response.status == 'SUCCESS') {
      me.setUserImageInfoDetails(response.userImageInfo, true);
    } else {
    }
  }, failure:function(form, response) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, setUserImageInfoDetails:function(userImageInfo, refreshImage) {
  if (userImageInfo && userImageInfo.imageid) {
    var imageUrl = Xedu.Config.getUrl(Xedu.Config.PROFILE_IMAGE_THUMB_SERVICE + userImageInfo.imageid);
    if (refreshImage) {
      imageUrl = imageUrl + '?dc\x3d' + (new Date).getTime();
    }
    this.down('#user-profile-image-id').setSrc(imageUrl);
    this.down('#imageid').setValue(userImageInfo.imageid);
  } else {
    this.down('#user-profile-image-id').setSrc('resources/icons/user_profilex128.png');
    this.down('#imageid').setValue('');
  }
}, setUserDetails:function(userRecord) {
  this.setRecord(userRecord);
}, clearPanel:function() {
  this.reset();
  this.down('#user-profile-image-id').setSrc('resources/icons/user_profilex128.png');
}}, 0, ['user-details-header-view'], ['component', 'container', 'panel', 'formpanel', 'user-details-header-view'], {'component':true, 'container':true, 'panel':true, 'formpanel':true, 'user-details-header-view':true}, ['widget.user-details-header-view'], 0, [Xedu.view.users, 'UserDetailsHeader'], 0);
Ext.cmd.derive('Xedu.view.users.UserMgmtMain', Ext.Container, {config:{title:'User Management', fullscreen:false, layout:'hbox', autoDestroy:true, defaults:{flex:1}, items:[{xtype:'container', layout:'fit', flex:1, items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'', layout:{pack:'right'}, defaults:{ui:'plain'}, items:[{xtype:'button', iconCls:'user', handler:function(but, action, eOpts) {
  this.up('user-mgmt-main-view').down('user-details-view').createNewUserForm();
}}]}, {xtype:'users-list-panel', autoSelect:true}]}, {xtype:'container', flex:4, layout:'vbox', items:[{xtype:'user-details-header-view', height:200}, {xtype:'user-details-view', flex:1, height:'100%'}]}], listeners:{show:function(thisView, opts) {
  var usersList = thisView.down('users-list-panel');
  usersList.loadUsers();
}}}}, 0, ['user-mgmt-main-view'], ['component', 'container', 'user-mgmt-main-view'], {'component':true, 'container':true, 'user-mgmt-main-view':true}, ['widget.user-mgmt-main-view'], 0, [Xedu.view.users, 'UserMgmtMain'], 0);
Ext.cmd.derive('Xedu.model.CourseModel', Ext.data.Model, {config:{fields:[{name:'id', type:'string'}, {name:'name', type:'string'}, {name:'title', type:'string'}, {name:'subTitle', type:'string'}, {name:'description', type:'string'}, {name:'chapters', type:'auto'}], hasMany:[{name:'chapters', model:'ChapterModel'}], proxy:{type:'rest', url:Xedu.Config.getUrl(Xedu.Config.COURSE_API), reader:{type:'json', idProperty:'id', rootProperty:'course'}}}}, 0, 0, 0, 0, 0, 0, [Xedu.model, 'CourseModel'], 0);
Ext.cmd.derive('Xedu.view.course.CourseEditForm', Ext.form.Panel, {config:{fullscreen:false, autoDestroy:true, scrollable:true, layout:{type:'vbox'}, items:[{xtype:'fieldset', flex:2, layout:{type:'vbox', pack:'start'}, defaults:{labelAlign:'top'}, items:[{xtype:'textfield', name:'id', label:'ID'}, {xtype:'textfield', name:'name', label:'Name'}, {xtype:'textfield', name:'title', label:'Title'}, {xtype:'textfield', name:'subTitle', label:'Sub Title'}]}, {xtype:'fieldset', layout:'fit', flex:1, items:[{xtype:'textareafield', 
label:'Description', labelAlign:'top', name:'description'}]}, {docked:'bottom', xtype:'toolbar', ui:'dark', title:'', layout:{type:'hbox', pack:'center'}, items:[{xtype:'button', ui:'confirm', text:'Save', itemId:'saveChangesButton', handler:function(but, action, eOpts) {
  this.up('course-edit-form').updateCourse();
}}, {xtype:'button', ui:'decline', text:'Delete', hidden:true, itemId:'deleteChangesButton', handler:function(but, action, eOpts) {
  this.up('course-edit-form').deleteCourse();
}}]}], listeners:{show:function() {
}}}, loadCourse:function(id) {
  var courseDetailsForm = this;
  var fields = courseDetailsForm.getFields();
  console.log('Loading course id \x3d' + id);
  var progressIndicator = Ext.create('Ext.ProgressIndicator');
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.COURSE_API) + id, method:'GET', progress:progressIndicator, headers:{'Content-Type':'application/json'}, success:function(response, conn, options, eOpts) {
    var result = Ext.JSON.decode(response.responseText);
    var courseRecord = Ext.create('Xedu.model.CourseModel', result.course);
    courseDetailsForm.setRecord(courseRecord);
    if (courseDetailsForm.down('#deleteChangesButton')) {
      courseDetailsForm.down('#deleteChangesButton').setHidden(false);
    }
  }, failure:function(conn, response, options, eOpts) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, updateCourse:function() {
  var courseForm = this;
  var fields = courseForm.getFields();
  var id = fields['id'].getValue();
  var restUrl = Xedu.Config.getUrl(Xedu.Config.COURSE_API);
  var restMethod = 'POST';
  if (id && id != '') {
    restMethod = 'PUT';
    restUrl = restUrl + id;
  }
  var progressIndicator = Ext.create('Ext.ProgressIndicator');
  courseForm.submit({url:restUrl, method:restMethod, progress:progressIndicator, success:function(form, response) {
    var maincntrller = Xedu.app.getController('Main');
    Ext.Viewport.setMasked(false);
    Xedu.CommonUtils.checkServiceError(response);
    if (response.status == 'SUCCESS') {
      Ext.Msg.alert('SUCCESS', response.msg);
      var courselistpanel = Ext.ComponentQuery.query('courses-list-panel list');
      courseForm.reset();
      if (courselistpanel && courselistpanel[0]) {
        courselistpanel[0].getStore().load();
      }
    } else {
    }
  }, failure:function(form, response) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, deleteCourse:function() {
  var courseDetailsForm = this;
  var fields = courseDetailsForm.getFields();
  var id = fields['id'].getValue();
  if (id && id != '') {
    Ext.Msg.alert('Not allowed', 'Delete operation not available');
  }
  var courseName = fields['title'].getValue() + ' ' + fields['subTitle'].getValue();
  Ext.Msg.confirm('Delete Course?', 'Are you sure you want to delete the course \x3cbr /\x3eid:' + id + '\x3cbr /\x3e Name:' + courseName, function(btn) {
    if (btn == 'yes') {
      var progressIndicator = Ext.create('Ext.ProgressIndicator');
      courseDetailsForm.submit({url:Xedu.Config.getUrl(Xedu.Config.COURSE_API) + id, method:'DELETE', progress:progressIndicator, success:function(form, response, data) {
        Ext.Msg.alert(response.status, response.msg);
        var configListPanel = Ext.ComponentQuery.query('courses-list-panel list');
        if (configListPanel && configListPanel[0]) {
          configListPanel[0].getStore().load();
        }
      }, failure:function(el, resp, p) {
        Xedu.CommonUtils.checkServiceError(resp);
      }});
    }
  });
}}, 0, ['course-edit-form'], ['component', 'container', 'panel', 'formpanel', 'course-edit-form'], {'component':true, 'container':true, 'panel':true, 'formpanel':true, 'course-edit-form':true}, ['widget.course-edit-form'], 0, [Xedu.view.course, 'CourseEditForm'], 0);
Ext.cmd.derive('Xedu.view.course.CourseMgmtMain', Ext.Container, {config:{title:'Course Management', fullscreen:false, layout:'hbox', courseid:null, autoDestroy:true, defaults:{flex:1}, items:[{xtype:'container', layout:'fit', flex:1, items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'', layout:{pack:'right'}, defaults:{ui:'plain'}, items:[{xtype:'button', iconCls:'add', handler:function(but, action, eOpts) {
}}]}, {xtype:'course-edit-form', flex:1}]}, {xtype:'tabpanel', flex:4, items:[{xtype:'chapters-list-panel', title:'Chapters'}]}], listeners:{show:function(thisView, opts) {
  var chaptersList = thisView.down('chapters-list-panel');
  var courseEditForm = thisView.down('course-edit-form');
  chaptersList.setCourseid(thisView.getCourseid());
  courseEditForm.loadCourse(thisView.getCourseid());
  chaptersList.loadChapters(thisView.getCourseid());
}}}}, 0, ['course-mgmt-main-view'], ['component', 'container', 'course-mgmt-main-view'], {'component':true, 'container':true, 'course-mgmt-main-view':true}, ['widget.course-mgmt-main-view'], 0, [Xedu.view.course, 'CourseMgmtMain'], 0);
Ext.cmd.derive('Xedu.view.ChangePassword', Ext.Panel, {config:{title:'Change Password', itemId:'change-password-form-panel-id', authToken:null, layout:{type:'fit', pack:'center', align:'stretch'}, items:[{xtype:'formpanel', layout:{type:'vbox', pack:'center'}, scrollable:true, items:[{xtype:'label', html:'', itemId:'msgLabel', hidden:true, hideAnimation:'fadeOut', showAnimation:'fadeIn', style:'color:#990000;margin:5px 0px;'}, {xtype:'fieldset', title:'Change Password', itemId:'change-password-fieldset-id', 
items:[{xtype:'passwordfield', label:'Auth Token', itemId:'pswd-chg-authtoken-id', name:'pswdChgAuthToken', required:true}, {xtype:'passwordfield', placeHolder:'Password', label:'New Password', itemId:'new-password-id', name:'newpswd', required:true}, {xtype:'passwordfield', placeHolder:'Password', label:'Confirm Password', itemId:'new-password-confirm-id', name:'newpswdconfirm', required:true}]}, {xtype:'panel', title:'', layout:{pack:'center', type:'hbox'}, items:[{xtype:'button', itemId:'chgPswdButton', 
hidden:false, ui:'confirm', text:'Change Password', width:'20%', handler:function(btn) {
  this.up('change-pswd-view').changePassword();
}}]}]}]}, setAuthToken:function(token) {
  console.log('setting token \x3d ' + token);
  this.authToken = token;
  this.down('#pswd-chg-authtoken-id').setValue(token);
}, showMessage:function(status, msg) {
  var label = this.down('#msgLabel');
  label.setHtml(status + ' - ' + msg);
  label.setHidden(false);
}, changePassword:function() {
  var me = this;
  var chgPasswordForm = this.down('formpanel');
  var authUrl = Xedu.Config.getUrl(Xedu.Config.CHG_PASSWORD_SERVICE);
  Ext.Viewport.setMasked(true);
  chgPasswordForm.submit({url:authUrl, success:function(form, response) {
    Ext.Viewport.setMasked(false);
    var cntrller = Xedu.app.getController('Main');
    if (response.status == 'SUCCESS') {
      Ext.Msg.alert(response.status, response.msg, function() {
        cntrller.getMainViewNavigation().reset();
        cntrller.redirectTo('view/Login');
      });
    } else {
      Xedu.CommonUtils.checkServiceError(response);
      me.showMessage(response.status, response.msg);
    }
  }, failure:function(form, response) {
    Ext.Viewport.setMasked(false);
    Xedu.CommonUtils.checkServiceError(response);
    me.showMessage(response.status, response.msg);
  }});
}}, 0, ['change-pswd-view'], ['component', 'container', 'panel', 'change-pswd-view'], {'component':true, 'container':true, 'panel':true, 'change-pswd-view':true}, ['widget.change-pswd-view'], 0, [Xedu.view, 'ChangePassword'], 0);
Ext.cmd.derive('Xedu.view.users.StudentDashBoard', Ext.Container, {config:{title:'My DashBoard', fullscreen:false, layout:{type:'hbox', pack:'start', align:'stretch'}, autoDestroy:true, defaults:{flex:1}, items:[{xtype:'user-enrolled-classes-list'}], listeners:{show:function(thisView, opts) {
  console.log('showing student dashboard...');
  thisView.reloadStudentDashBoard();
}}}, reloadStudentDashBoard:function() {
  if (Xedu.CommonUtils.getLoggedInUserId()) {
    var usersEnrolledClassesList = this.down('user-enrolled-classes-list');
    usersEnrolledClassesList.setUserid(Xedu.CommonUtils.getLoggedInUserId().id);
    usersEnrolledClassesList.loadEnrolledClasses();
  }
}}, 0, ['student-dashboard-view'], ['component', 'container', 'student-dashboard-view'], {'component':true, 'container':true, 'student-dashboard-view':true}, ['widget.student-dashboard-view'], 0, [Xedu.view.users, 'StudentDashBoard'], 0);
Ext.cmd.derive('Xedu.store.AllowedActionsStore', Ext.data.Store, {require:['Xedu.Config', 'Ext.data.proxy.Rest'], config:{fields:[{name:'link', type:'string'}, {name:'type', type:'string'}], remoteSort:false, autoLoad:false, proxy:{type:'rest', url:Xedu.Config.getUrl(Xedu.Config.ALLOWED_ACTIONS_API), reader:{type:'json', idProperty:'type', rootProperty:'actions'}, filterParam:'recordType'}}}, 0, 0, 0, 0, ['store.allowed-actions-store'], 0, [Xedu.store, 'AllowedActionsStore'], 0);
Ext.cmd.derive('Xedu.view.users.AllowedActionsMenu', Ext.Panel, {config:{fullscreen:true, recordType:null, recordId:null, callbackScope:null, callbackOnSelect:null, closeOnSelect:true, layout:{type:'vbox', pack:'start'}, items:[{xtype:'list', itemId:'allowed-actions-list-id', scrollable:true, flex:1, autoDestroy:true, store:{type:'allowed-actions-store'}, itemTpl:['\x3cdiv\x3e', '\t\t\x3cspan class\x3d"x-button-icon x-shown compose"\x3e\x3c/span\x3e', '\t\t\x3cspan\x3e{type}\x3c/span\x3e', '\x3c/div\x3e'], 
listeners:{itemsingletap:function(scope, index, target, record) {
  console.log('tapped on action id \x3d ' + record.data.id);
  scope.up('allowed-actions-menu').actionSelected(record);
}}}], listeners:{show:function(thisView) {
  thisView.loadActions();
}}}, loadActions:function() {
  console.log('Loading actions for record id \x3d' + this.recordId + ' type \x3d ' + this.recordType);
  var progressIndicator = Ext.create('Ext.ProgressIndicator');
  var me = this;
  var apiurl = Xedu.Config.getUrl(Xedu.Config.ALLOWED_ACTIONS_API);
  apiurl = apiurl.replace('{recordType}', this.getRecordType());
  apiurl = apiurl.replace('{recordId}', this.getRecordId());
  me.down('list').getStore().getProxy().setUrl(apiurl);
  me.down('list').getStore().load();
}, actionSelected:function(record) {
  if (this.getCallbackOnSelect()) {
    console.log('about to handle call back');
    this.handleCallback(record);
  } else {
    Xedu.app.getController('Main').redirectTo(record.data.link);
  }
}, handleCallback:function(record) {
  console.log('handling callback for action menu selection... ');
  var callbck = this.getCallbackOnSelect();
  var scope = this.getCallbackScope();
  if (typeof callbck == 'function') {
    if (!scope) {
      console.error('Missing scope inside callbackConfig ');
    } else {
      callbck.apply(scope, [record]);
    }
  }
  if (this.getCloseOnSelect()) {
    this.hide();
  }
}}, 0, ['allowed-actions-menu'], ['component', 'container', 'panel', 'allowed-actions-menu'], {'component':true, 'container':true, 'panel':true, 'allowed-actions-menu':true}, ['widget.allowed-actions-menu'], 0, [Xedu.view.users, 'AllowedActionsMenu'], 0);
Ext.cmd.derive('Xedu.model.EventScheduleModel', Ext.data.Model, {config:{fields:[{name:'id', type:'string'}, {name:'eventStartDate', type:'date'}, {name:'classroomid', type:'string'}, {name:'eventEndDate', type:'date'}, {name:'eventType', type:'string'}, {name:'eventStatus', type:'string'}, {name:'eventTitle', type:'string'}, {name:'eventSessionId', type:'string'}, {name:'eventDescription', type:'string'}, {name:'lastUpdatedDateTime', type:'string'}, {name:'updatedBy', type:'string'}], proxy:{type:'rest', 
url:Xedu.Config.getUrl(Xedu.Config.EVENT_SCHEDULE_API), reader:{type:'json', idProperty:'id', rootProperty:'eventSchedule'}}}}, 0, 0, 0, 0, 0, 0, [Xedu.model, 'EventScheduleModel'], 0);
Ext.cmd.derive('Xedu.ux.picker.DateTime', Ext.picker.Picker, {alternateClassName:'Xedu.ux.DateTimePicker', config:{yearFrom:1980, yearTo:(new Date).getFullYear(), monthText:Ext.os.deviceType.toLowerCase() == 'phone' ? 'M' : 'Month', dayText:Ext.os.deviceType.toLowerCase() == 'phone' ? 'j' : 'Day', yearText:Ext.os.deviceType.toLowerCase() == 'phone' ? 'Y' : 'Year', hourText:Ext.os.deviceType.toLowerCase() == 'phone' ? 'H' : 'Hour', minuteText:Ext.os.deviceType.toLowerCase() == 'phone' ? 'i' : 'Minute', 
ampmText:Ext.os.deviceType.toLowerCase() == 'phone' ? 'A' : 'AM/PM', slotOrder:['month', 'day', 'year', 'hour', 'minute', 'ampm'], minuteInterval:15, ampm:false}, initialize:function() {
  Ext.picker.Picker.prototype.initialize.call(this);
  this.on({scope:this, delegate:'\x3e slot', slotpick:this.onSlotPick});
}, setValue:function(value, animated) {
  if (Ext.isDate(value)) {
    ampm = 'AM';
    currentHours = hour = value.getHours();
    if (this.getAmpm()) {
      if (currentHours > 12) {
        ampm = 'PM';
        hour -= 12;
      } else {
        if (currentHours == 12) {
          ampm = 'PM';
        } else {
          if (currentHours == 0) {
            hour = 12;
          }
        }
      }
    }
    value = {day:value.getDate(), month:value.getMonth() + 1, year:value.getFullYear(), hour:hour, minute:value.getMinutes(), ampm:ampm};
  }
  (arguments.callee.$previous || Ext.picker.Picker.prototype.setValue).call(this, value, animated);
}, getValue:function() {
  var values = {}, daysInMonth, day, hour, minute, items = this.getItems().items, ln = items.length, item, i;
  for (i = 0; i < ln; i++) {
    item = items[i];
    if (item instanceof Ext.picker.Slot) {
      values[item.getName()] = item.getValue();
    }
  }
  daysInMonth = this.getDaysInMonth(values.month, values.year);
  day = Math.min(values.day, daysInMonth), hour = values.hour, minute = values.minute;
  var yearval = isNaN(values.year) ? (new Date).getFullYear() : values.year, monthval = isNaN(values.month) ? (new Date).getMonth() : values.month - 1, dayval = isNaN(day) ? (new Date).getDate() : day, hourval = isNaN(hour) ? (new Date).getHours() : hour, minuteval = isNaN(minute) ? (new Date).getMinutes() : minute;
  if (values.ampm && values.ampm == 'PM' && hourval < 12) {
    hourval = hourval + 12;
  }
  if (values.ampm && values.ampm == 'AM' && hourval == 12) {
    hourval = 0;
  }
  return new Date(yearval, monthval, dayval, hourval, minuteval);
}, updateYearFrom:function() {
  if (this.initialized) {
    this.createSlots();
  }
}, updateYearTo:function() {
  if (this.initialized) {
    this.createSlots();
  }
}, updateMonthText:function(newMonthText, oldMonthText) {
  var innerItems = this.getInnerItems, ln = innerItems.length, item, i;
  if (this.initialized) {
    for (i = 0; i < ln; i++) {
      item = innerItems[i];
      if (typeof item.title == 'string' && item.title == oldMonthText || item.title.html == oldMonthText) {
        item.setTitle(newMonthText);
      }
    }
  }
}, updateDayText:function(newDayText, oldDayText) {
  var innerItems = this.getInnerItems, ln = innerItems.length, item, i;
  if (this.initialized) {
    for (i = 0; i < ln; i++) {
      item = innerItems[i];
      if (typeof item.title == 'string' && item.title == oldDayText || item.title.html == oldDayText) {
        item.setTitle(newDayText);
      }
    }
  }
}, updateYearText:function(yearText) {
  var innerItems = this.getInnerItems, ln = innerItems.length, item, i;
  if (this.initialized) {
    for (i = 0; i < ln; i++) {
      item = innerItems[i];
      if (item.title == this.yearText) {
        item.setTitle(yearText);
      }
    }
  }
}, constructor:function() {
  Ext.picker.Picker.prototype.constructor.apply(this, arguments);
  this.createSlots();
}, createSlots:function() {
  var me = this, slotOrder = this.getSlotOrder(), yearsFrom = me.getYearFrom(), yearsTo = me.getYearTo(), years = [], days = [], months = [], hours = [], minutes = [], ampm = [], ln, tmp, i, daysInMonth;
  if (!this.getAmpm()) {
    var index = slotOrder.indexOf('ampm');
    if (index >= 0) {
      slotOrder.splice(index);
    }
  }
  if (yearsFrom > yearsTo) {
    tmp = yearsFrom;
    yearsFrom = yearsTo;
    yearsTo = tmp;
  }
  for (i = yearsFrom; i <= yearsTo; i++) {
    years.push({text:i, value:i});
  }
  daysInMonth = this.getDaysInMonth(1, (new Date).getFullYear());
  for (i = 0; i < daysInMonth; i++) {
    days.push({text:i + 1, value:i + 1});
  }
  for (i = 0, ln = Ext.Date.monthNames.length; i < ln; i++) {
    months.push({text:Ext.os.deviceType.toLowerCase() == 'phone' ? Ext.Date.monthNames[i].substring(0, 3) : Ext.Date.monthNames[i], value:i + 1});
  }
  var hourLimit = this.getAmpm() ? 12 : 23;
  var hourStart = this.getAmpm() ? 1 : 0;
  for (i = hourStart; i <= hourLimit; i++) {
    hours.push({text:this.pad2(i), value:i});
  }
  for (i = 0; i < 60; i += this.getMinuteInterval()) {
    minutes.push({text:this.pad2(i), value:i});
  }
  ampm.push({text:'AM', value:'AM'}, {text:'PM', value:'PM'});
  var slots = [];
  slotOrder.forEach(function(item) {
    slots.push(this.createSlot(item, days, months, years, hours, minutes, ampm));
  }, this);
  me.setSlots(slots);
}, createSlot:function(name, days, months, years, hours, minutes, ampm) {
  switch(name) {
    case 'year':
      return {name:'year', align:Ext.os.deviceType.toLowerCase() == 'phone' ? 'left' : 'center', data:years, title:this.getYearText(), flex:Ext.os.deviceType.toLowerCase() == 'phone' ? 1.3 : 3};
    case 'month':
      return {name:name, align:Ext.os.deviceType.toLowerCase() == 'phone' ? 'left' : 'right', data:months, title:this.getMonthText(), flex:Ext.os.deviceType.toLowerCase() == 'phone' ? 1.2 : 4};
    case 'day':
      return {name:'day', align:Ext.os.deviceType.toLowerCase() == 'phone' ? 'left' : 'center', data:days, title:this.getDayText(), flex:Ext.os.deviceType.toLowerCase() == 'phone' ? 0.9 : 2};
    case 'hour':
      return {name:'hour', align:Ext.os.deviceType.toLowerCase() == 'phone' ? 'left' : 'center', data:hours, title:this.getHourText(), flex:Ext.os.deviceType.toLowerCase() == 'phone' ? 0.9 : 2};
    case 'minute':
      return {name:'minute', align:Ext.os.deviceType.toLowerCase() == 'phone' ? 'left' : 'center', data:minutes, title:this.getMinuteText(), flex:Ext.os.deviceType.toLowerCase() == 'phone' ? 0.9 : 2};
    case 'ampm':
      return {name:'ampm', align:Ext.os.deviceType.toLowerCase() == 'phone' ? 'left' : 'center', data:ampm, title:this.getAmpmText(), flex:Ext.os.deviceType.toLowerCase() == 'phone' ? 1.1 : 2};
  }
}, onSlotPick:function(pickedSlot, oldValue, htmlNode, eOpts) {
  var pickedValue = pickedSlot.getStore().getAt(pickedSlot.selectedIndex).get(pickedSlot.getValueField());
  pickedSlot.setValue(pickedValue);
  if (pickedSlot.getName() === 'month' || pickedSlot.getName() === 'year') {
    this.repopulateDaySlot();
  }
}, repopulateDaySlot:function() {
  var slot = this.getDaySlot(), days = [], month = this.getSlotByName('month').getValue(), year = this.getSlotByName('year').getValue(), daysInMonth;
  daysInMonth = this.getDaysInMonth(month, year);
  for (i = 0; i < daysInMonth; i++) {
    days.push({text:i + 1, value:i + 1});
  }
  if (slot.getData().length == days.length) {
    return;
  }
  slot.setData(days);
}, getSlotByName:function(name) {
  return this.down('pickerslot[name\x3d' + name + ']');
}, getDaySlot:function() {
  return this.getSlotByName('day');
}, getDaysInMonth:function(month, year) {
  var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  return month == 2 && this.isLeapYear(year) ? 29 : daysInMonth[month - 1];
}, isLeapYear:function(year) {
  return !!((year & 3) === 0 && (year % 100 || year % 400 === 0 && year));
}, pad2:function(number) {
  return (number < 10 ? '0' : '') + number;
}}, 1, ['datetimepicker'], ['component', 'container', 'panel', 'sheet', 'picker', 'datetimepicker'], {'component':true, 'container':true, 'panel':true, 'sheet':true, 'picker':true, 'datetimepicker':true}, ['widget.datetimepicker'], 0, [Xedu.ux.picker, 'DateTime', Xedu.ux, 'DateTimePicker'], 0);
Ext.cmd.derive('Xedu.ux.field.DateTimePicker', Ext.field.Text, {alternateClassName:'Ext.form.DateTimePicker', config:{ui:'select', picker:true, clearIcon:false, destroyPickerOnHide:false, dateTimeFormat:'m/d/Y h:i:A', component:{useMask:true}}, initialize:function() {
  Ext.field.Text.prototype.initialize.call(this);
  this.getComponent().on({scope:this, masktap:'onMaskTap'});
  this.getComponent().input.dom.disabled = true;
}, syncEmptyCls:Ext.emptyFn, applyValue:function(value) {
  if (!Ext.isDate(value) && !Ext.isObject(value)) {
    value = null;
  }
  if (Ext.isObject(value)) {
    value = new Date(value.year, value.month - 1, value.day, value.hour, value.minute);
  }
  return value;
}, updateValue:function(newValue) {
  var picker = this._picker;
  if (picker && picker.isPicker) {
    picker.setValue(newValue);
  }
  if (newValue !== null) {
    this.getComponent().setValue(Ext.Date.format(newValue, this.getDateTimeFormat() || Ext.util.Format.defaultDateFormat));
  } else {
    this.getComponent().setValue('');
  }
  if (this._picker && this._picker instanceof Xedu.ux.picker.DateTime) {
    this._picker.setValue(newValue);
  }
}, updateDateFormat:function(newDateFormat, oldDateFormat) {
  var value = this.getValue();
  if (newDateFormat != oldDateFormat && Ext.isDate(value) && this._picker && this._picker instanceof Xedu.ux.picker.DateTime) {
    this.getComponent().setValue(Ext.Date.format(value, newDateFormat || Ext.util.Format.defaultDateFormat));
  }
}, getValue:function() {
  if (this._picker && this._picker instanceof Xedu.ux.picker.DateTime) {
    return this._picker.getValue();
  }
  return this._value;
}, getFormattedValue:function(format) {
  var value = this.getValue();
  console.log(this.getDateTimeFormat(), 'format');
  return Ext.isDate(value) ? Ext.Date.format(value, format || this.getDateTimeFormat() || Ext.util.Format.defaultDateFormat) : value;
}, applyPicker:function(picker, pickerInstance) {
  if (pickerInstance && pickerInstance.isPicker) {
    picker = pickerInstance.setConfig(picker);
  }
  return picker;
}, getPicker:function() {
  var picker = this._picker, value = this.getValue();
  if (picker && !picker.isPicker) {
    picker = Ext.factory(picker, Xedu.ux.picker.DateTime);
    picker.on({scope:this, cancel:'onPickerCancel', change:'onPickerChange', hide:'onPickerHide'});
    if (value !== null) {
      picker.setValue(value);
    }
    Ext.Viewport.add(picker);
    this._picker = picker;
  }
  return picker;
}, onMaskTap:function() {
  if (this.getDisabled()) {
    return false;
  }
  if (this.getReadOnly()) {
    return false;
  }
  this.getPicker().show();
  return false;
}, onPickerCancel:function(picker, options) {
  this._picker = this._picker.config;
  picker.destroy();
  return true;
}, onPickerChange:function(picker, value) {
  var me = this;
  me.setValue(value);
  me.fireEvent('change', me, me.getValue());
}, onPickerHide:function() {
  var picker = this.getPicker();
  if (this.getDestroyPickerOnHide() && picker) {
    picker.destroy();
    this._picker = true;
  }
}, reset:function() {
  this.setValue(this.originalValue);
}, destroy:function() {
  var picker = this.getPicker();
  if (picker && picker.isPicker) {
    picker.destroy();
  }
  Ext.field.Text.prototype.destroy.apply(this, arguments);
}}, 0, ['datetimepickerfield'], ['component', 'field', 'textfield', 'datetimepickerfield'], {'component':true, 'field':true, 'textfield':true, 'datetimepickerfield':true}, ['widget.datetimepickerfield'], 0, [Xedu.ux.field, 'DateTimePicker', Ext.form, 'DateTimePicker'], 0);
Ext.cmd.derive('Xedu.view.schedule.ScheduleDetailsPreview', Ext.form.Panel, {config:{title:'Edit Schedule', fullscreen:false, autoDestroy:true, showEdit:false, scrollable:true, classroomid:null, scheduleRecord:null, eventScheduleId:null, layout:{type:'fit', pack:'center', align:'stretch'}, init:function() {
  this.callParent(arguments);
  console.log('initialized');
}, items:[{docked:'top', xtype:'toolbar', title:'Update Schedule', height:50}, {docked:'bottom', xtype:'toolbar', ui:'dark', title:'', height:75, layout:{type:'hbox', pack:'center'}, items:[{xtype:'button', ui:'decline', text:'Edit', itemId:'edit-schedule-button', handler:function(but, action, eOpts) {
  this.up('schedule-details-preview').editSchedule();
}}, {xtype:'button', ui:'decline', text:'Delete', itemId:'delete-schedule-button', handler:function(but, action, eOpts) {
  this.up('schedule-details-preview').deleteSchedule();
}}, {xtype:'button', ui:'confirm', text:'Save', itemId:'save-schedule-button', handler:function(but, action, eOpts) {
  this.up('schedule-details-preview').submitNewOrUpdateEvent();
}}, {xtype:'button', ui:'back', text:'Cancel', itemId:'cancel-schedule-button', handler:function(but, action, eOpts) {
  this.up('schedule-details-preview').cancelEditSchedule();
}}, {xtype:'button', text:'Close', itemId:'close-schedule-button', handler:function(but, action, eOpts) {
  this.up('schedule-details-preview').hide();
}}, {xtype:'button', ui:'confirm', text:'Join', itemId:'join-schedule-button', handler:function(but, action, eOpts) {
  this.up('schedule-details-preview').joinSession();
}}, {xtype:'button', ui:'confirm', text:'Start', itemId:'start-schedule-button', handler:function(but, action, eOpts) {
  this.up('schedule-details-preview').startSession();
}}]}, {xtype:'dataview', itemId:'preview-panel-id', autoDestroy:true, flex:1, store:{model:'Xedu.model.EventScheduleModel'}, itemTpl:['\x3ch1\x3e\x3cb\x3eSchedule id:\x3c/b\x3e {id}\x3c/h1\x3e', '\x3ch2\x3e\x3cb\x3eClass room id:\x3c/b\x3e {classroomid}\x3c/h2\x3e', '\x3cp\x3e\x3cb\x3eStart date :\x3c/b\x3e {eventStartDate}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3eEnd date :\x3c/b\x3e {eventEndDate}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3eEvent Type :\x3c/b\x3e {eventType}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3eStatus :\x3c/b\x3e {eventStatus}\x3c/p\x3e', 
'\x3cp\x3e\x3cb\x3eTitle :\x3c/b\x3e {eventTitle}\x3c/p\x3e', '\x3cp\x3e\x3cb\x3eDesc :\x3c/b\x3e {eventDesc}\x3c/p\x3e']}, {xtype:'container', flex:1, hidden:true, itemId:'schedule-form-container-id', layout:{type:'vbox'}, items:[{xtype:'fieldset', layout:'fit', height:50, items:[{xtype:'textfield', label:'Event ID', labelAlign:'left', name:'id'}, {xtype:'selectfield', label:'Event Type', name:'eventType', autoSelect:true, options:[{text:'CLASSROOM SESSION', value:'CLASSROOM'}, {text:'ASSIGNMENT', 
value:'ASSIGNMENT'}, {text:'QUIZ', value:'QUIZ'}]}]}, {xtype:'fieldset', layout:'vbox', height:150, items:[{xtype:'textfield', label:'Title', labelAlign:'left', name:'eventTitle', placeHolder:'Please provide title...'}, {xtype:'textfield', name:'classroomid', itemId:'classroomid-field-id', label:'Classroom'}, {xtype:'selectfield', label:'Event Status', name:'eventStatus', autoSelect:true, options:[{text:'NOT STARTED', value:'NOT_STARTED'}, {text:'PAUSED', value:'PAUSED'}, {text:'COMPLETED', value:'COMPLETED'}, 
{text:'CANCELLED', value:'CANCELLED'}, {text:'RE-SCHEDULED', value:'RE_SCHEDULED'}]}]}, {xtype:'fieldset', layout:{type:'vbox'}, height:100, items:[{xtype:'textfield', labelAlign:'left', hidden:true, itemId:'eventStartDateId', name:'eventStartDate'}, {xtype:'textfield', labelAlign:'left', hidden:true, itemId:'eventEndDateId', name:'eventEndDate'}, {xtype:'datetimepickerfield', name:'eventStartDateUnFormatted', itemId:'eventStartDateUnFormattedId', label:'Start Date/Time', dateTimeFormat:'Y-m-d H:i', 
height:50, picker:{yearFrom:2010, yearTo:(new Date).getFullYear() + 2, minuteInterval:15, ampm:true, slotOrder:['year', 'month', 'day', 'hour', 'minute', 'ampm']}, listeners:{change:function(datepicker) {
  this.up('schedule-details-preview').down('#eventStartDateId').setValue(datepicker.getFormattedValue());
}}}, {xtype:'datetimepickerfield', name:'eventEndDateUnFormatted', itemId:'eventEndDateUnFormattedId', label:'End Date/Time', dateTimeFormat:'Y-m-d H:i', height:50, picker:{yearFrom:2010, yearTo:(new Date).getFullYear() + 2, minuteInterval:15, ampm:true, slotOrder:['year', 'month', 'day', 'hour', 'minute', 'ampm']}, listeners:{change:function(datepicker) {
  this.up('schedule-details-preview').down('#eventEndDateId').setValue(datepicker.getFormattedValue());
}}}]}, {xtype:'fieldset', layout:'fit', flex:1, items:[{xtype:'textareafield', label:'Remarks', labelAlign:'top', placeHolder:'Add additional information about the event.', name:'eventDescription'}]}]}], listeners:{show:function(thisView) {
  thisView.loadDetails();
}}}, joinSession:function() {
  var me = this;
  var schRec = this.getScheduleRecord();
  if (!schRec || !schRec.data || schRec.data.eventSessionId == null) {
    Ext.Msg.alert('Invalid', 'The session did not start yet!', Ext.emptyFn);
    return;
  }
  var progressIndicator = Ext.create('Ext.ProgressIndicator', {loadingText:'Loading session information...'});
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.EVENT_SESSION_JOIN_API) + '/' + schRec.data.eventSessionId, method:'GET', scope:this, progress:progressIndicator, success:function(resp) {
    var response = Ext.JSON.decode(resp.responseText);
    if (response.errorInfo && response.errorInfo.errors && response.errorInfo.errors.length > 0) {
      Xedu.CommonUtils.checkServiceError(response);
    } else {
      var event = Ext.create('Xedu.model.EventModel', {});
      event.set('type', 'ACTION_SESSION_JOIN');
      event.set('msg', 'successfully joined session \x3d ' + response.eventSession.eventSessionId);
      event.set('id', response.eventSession.eventSessionId);
      me.subscribeToSessionEvents(response.eventSession, event);
    }
  }, failure:function(el, resp, p) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, subscribeToSessionEvents:function(eventSession, event) {
  var cntrller = Xedu.app.getController('Main');
  var id = eventSession.eventSessionId;
  var sessionEndpoint = '/topic/sessionmessages/' + id;
  if (cntrller.getActiveSessionSubscription()) {
    cntrller.getActiveSessionSubscription().unsubscribe();
  }
  var subscription = Xedu.CommonUtils.subscribeToStompQueue(sessionEndpoint, function(msg) {
    console.log('+++++++++++++++ RECIEVED on ', msg);
    var stompMsg = Ext.JSON.decode(msg.body);
    Xedu.CommonUtils.showInDebugPanel(msg);
    switch(stompMsg.type) {
      case 'ACTION_FAILED':
        Ext.Msg.alert('Error', stompMsg.msg, Ext.emptyFn);
        break;
      case 'ACTION_SESSION_JOIN':
        Ext.Msg.alert('Joined', stompMsg.msg, Ext.emptyFn);
        break;
      default:
        break;
    }
    if (stompMsg.from != cntrller.getLoggedInUser().userId) {
      switch(stompMsg.type) {
        case 'ACTION_DRAW':
          var canvas = Ext.ComponentQuery.query('slide-draw-component');
          if (canvas && canvas[0]) {
            var e = Ext.JSON.decode(stompMsg.msg);
            canvas[0].drawDrag(e, true);
          }
          break;
        case 'ACTION_DRAW_START':
          var canvas = Ext.ComponentQuery.query('slide-draw-component');
          if (canvas && canvas[0]) {
            var e = Ext.JSON.decode(stompMsg.msg);
            canvas[0].drawStart(e, true);
          }
          break;
        case 'ACTION_DRAW_END':
          var canvas = Ext.ComponentQuery.query('slide-draw-component');
          if (canvas && canvas[0]) {
            canvas[0].drawEnd(e, true);
          }
          break;
        case 'ACTION':
          {
            var actionMsg = Ext.JSON.decode(stompMsg.msg);
            Xedu.app.getController('Main').redirectTo('view/' + actionMsg.route);
          }
      }
    } else {
      console.log('message from ' + stompMsg.from);
    }
  });
  cntrller.setActiveSessionSubscription(subscription);
  if (eventSession.presenter) {
    cntrller.setPresenterTopicEndpoint(sessionEndpoint);
  } else {
    cntrller.setPresenterTopicEndpoint(null);
  }
  if (event != null) {
    Xedu.CommonUtils.sendStompSocketEvent('/topic/sessionmessages/' + id, event);
  }
  if (eventSession.presenter) {
    console.log('joining as a presenter...');
    cntrller.redirectTo('view/join/classroom/session/' + id);
  } else {
    console.log('joining as a presenter...');
    cntrller.redirectTo('view/join/participants/session/' + id);
  }
}, startSession:function() {
  var me = this;
  var progressIndicator = Ext.create('Ext.ProgressIndicator', {loadingText:'Checking user session...'});
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.EVENT_SESSION_START_API) + '/' + this.getEventScheduleId(), method:'GET', progress:progressIndicator, success:function(resp) {
    var response = Ext.JSON.decode(resp.responseText);
    if (response.errorInfo && response.errorInfo.errors && response.errorInfo.errors.length > 0) {
      Xedu.CommonUtils.checkServiceError(response);
    } else {
      var event = Ext.create('Xedu.model.EventModel', {});
      event.set('type', 'ACTION_SESSION_START');
      event.set('msg', 'joinging session \x3d\x3d\x3d  ' + me.getEventScheduleId());
      event.set('id', me.getEventScheduleId());
      me.subscribeToSessionEvents(response.eventSession, event);
    }
  }, failure:function(el, resp, p) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, loadDetails:function() {
  me = this;
  this.down('#classroomid-field-id').setValue(this.getClassroomid());
  if (this.getEventScheduleId() == '' || this.getEventScheduleId() == null || this.getShowEdit()) {
    this.toggleEditMode(true);
    return;
  } else {
    this.toggleEditMode(false);
  }
  console.log('about to load schedule id \x3d' + this.getEventScheduleId());
  var progressIndicator = Ext.create('Ext.ProgressIndicator', {loadingText:'Loading schedule details preview...'});
  this.setMasked({msg:'Loading schedule...'});
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.EVENT_SCHEDULE_API) + '/' + me.getEventScheduleId(), method:'GET', headers:{'Content-Type':'application/json'}, success:function(response, conn, options, eOpts) {
    me.setMasked(false);
    try {
      var result = Ext.JSON.decode(response.responseText);
      var record = Ext.create('Xedu.model.EventScheduleModel', result.eventSchedule);
      me.setScheduleRecord(record);
      me.setDetails();
    } catch (e$19) {
      console.error(e$19);
    }
  }, failure:function(conn, response, options, eOpts) {
    me.setMasked(false), Xedu.CommonUtils.checkServiceError(resp);
  }});
}, setDetails:function() {
  this.down('dataview').setRecord(this.getScheduleRecord());
  this.setRecord(this.getScheduleRecord());
  this.down('#eventStartDateUnFormattedId').setValue(this.getScheduleRecord().data.eventStartDate);
  this.down('#eventEndDateUnFormattedId').setValue(this.getScheduleRecord().data.eventEndDate);
}, removeAllItems:function() {
  console.log('removing all items');
  this.down('dataview').destroy();
}, editSchedule:function() {
  this.toggleEditMode(true);
  var id = this.getEventScheduleId();
}, cancelEditSchedule:function() {
  this.toggleEditMode(false);
  var id = this.getEventScheduleId();
}, toggleEditMode:function(showEdit) {
  if (showEdit) {
    this.down('#schedule-form-container-id').setHidden(false);
    this.down('#preview-panel-id').setHidden(true);
    this.down('#edit-schedule-button').setHidden(true);
    this.down('#cancel-schedule-button').setHidden(false);
    this.down('#save-schedule-button').setHidden(false);
  } else {
    this.down('#schedule-form-container-id').setHidden(true);
    this.down('#preview-panel-id').setHidden(false);
    this.down('#edit-schedule-button').setHidden(false);
    this.down('#cancel-schedule-button').setHidden(true);
    this.down('#save-schedule-button').setHidden(true);
  }
}, submitNewOrUpdateEvent:function() {
  var eventDetailsFrom = this;
  var fields = eventDetailsFrom.getFields();
  var me = this;
  var id = fields['id'].getValue();
  var restUrl = Xedu.Config.getUrl(Xedu.Config.EVENT_SCHEDULE_API);
  var restMethod = 'POST';
  var msg = 'Adding new event...';
  if (id && id != '') {
    restMethod = 'PUT';
    restUrl = restUrl + '/' + id;
    msg = 'Updating event id \x3d ' + id + ' ...';
  }
  var progressIndicator = Ext.create('Ext.ProgressIndicator', {loadingText:msg});
  eventDetailsFrom.submit({url:restUrl, method:restMethod, progress:progressIndicator, success:function(form, response, data) {
    var maincntrller = Xedu.app.getController('Main');
    Xedu.CommonUtils.checkServiceError(response);
    if (response.status == 'SUCCESS') {
      Ext.Msg.alert('Success', response.msg, Ext.emptyFn);
      me.toggleEditMode(false);
      me.refreshAllEventLists();
    } else {
    }
  }, failure:function(el, resp, p) {
    Xedu.CommonUtils.checkServiceError(resp);
    me.toggleEditMode(true);
  }});
}, deleteSchedule:function() {
  var id = this.getEventScheduleId();
  if (id && id != '') {
    Ext.Msg.alert('Not allowed', 'Operation not available!');
  }
  var previewPanel = this;
  var progressIndicator = Ext.create('Ext.ProgressIndicator');
  Ext.Msg.confirm('Delete schedule?', 'Are you sure you want to delete this schedule?', function(btn) {
    if (btn == 'yes') {
      var progressIndicator = Ext.create('Ext.ProgressIndicator');
      Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.EVENT_SCHEDULE_API) + '/' + id, method:'DELETE', progress:progressIndicator, success:function(resp) {
        var response = Ext.JSON.decode(resp.responseText);
        Ext.Msg.alert(response.status, response.msg, function() {
          previewPanel.down('#edit-schedule-button').setHidden(true);
          previewPanel.down('#delete-schedule-button').setHidden(true);
          return true;
        });
      }, failure:function(el, resp, p) {
        Xedu.CommonUtils.checkServiceError(resp);
      }});
      previewPanel.hide();
    }
    return true;
  });
}, refreshAllEventLists:function() {
  var listPanels = Ext.ComponentQuery.query('classroom-schedule-list-panel');
  if (listPanels) {
    for (var i = 0; i < listPanels.length; i++) {
      listPanels[i].refreshStore();
    }
  }
}}, 0, ['schedule-details-preview'], ['component', 'container', 'panel', 'formpanel', 'schedule-details-preview'], {'component':true, 'container':true, 'panel':true, 'formpanel':true, 'schedule-details-preview':true}, ['widget.schedule-details-preview'], 0, [Xedu.view.schedule, 'ScheduleDetailsPreview'], 0);
Ext.cmd.derive('Xedu.view.schedule.UserScheduleList', Ext.Panel, {config:{layout:'fit', userid:null, items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'User Schedule', layout:{type:'hbox', pack:'right'}, defaults:{ui:'plain'}, items:[]}, {xtype:'list', itemId:'user-schedule-list-panel-id', title:'My Schedule', scrollable:true, autoDestroy:true, store:{type:'search-store', autoLoad:false}, plugins:[{xclass:'Ext.plugin.PullRefresh', pullText:'Pull down to refresh the list!', refreshFn:function() {
  scope.up('user-schedule-list-panel').loadSchedule();
}}], itemTpl:['\t\t\x3cdiv\x3e', '\t\t\t\x3cdiv\x3e', '\t\t\t\t\x3cspan style\x3d"color:gray"\x3eTitle: \x3c/span\x3e{recordTitle}, ', '\t\t\t\t\x3cspan style\x3d"color:gray"\x3e{recordSubTitle} \x3c/span\x3e ', '\t\t\t\x3c/div\x3e', '\t\t\x3c/div\x3e'], listeners:{itemsingletap:function(scope, index, target, record) {
  console.log('tapped schedule');
  Xedu.app.getController('Main').redirectTo('view/eventschedule/edit/' + record.data.recordId);
}}}], listeners:{show:function(thisView, opts) {
  thisView.loadSchedule();
}}}, loadSchedule:function() {
  var thisView = this;
  console.log('Loading schedule...');
  thisView.setMasked({msg:'Loading schedule for userrecid \x3d ...' + Xedu.CommonUtils.getLoggedInUserId().id});
  var listStore = thisView.down('list').getStore();
  listStore.getProxy().setUrl(Xedu.Config.getUrl(Xedu.Config.CLASSROOM_SCHEDULE_SEARCH));
  listStore.setParams({'urecid':this.getUserid()});
  listStore.load({callback:function(records, operation, success) {
    thisView.setMasked(false);
  }});
}, viewScheduleInfo:function(record, target) {
  Xedu.CommonUtils.showOverlay2({xtype:'schedule-details-preview', eventScheduleId:record.data.id, title:record.data.title, centered:true, modal:true, autoDestroy:true, hideOnMaskTap:true, width:'50%', height:'85%', title:'Event Details'}, null);
}, addNewSchedule:function() {
  var clsid = this.getClassroomid();
  Xedu.CommonUtils.showOverlay2({xtype:'schedule-details-preview', eventScheduleId:'', classroomid:clsid, centered:true, modal:true, autoDestroy:true, hideOnMaskTap:true, width:'50%', height:'85%'}, null);
}, refreshStore:function() {
  var listStore = this.down('list').getStore();
  if (listStore) {
    listStore.getProxy().setUrl(Xedu.Config.getUrl(Xedu.Config.CLASSROOM_SCHEDULE_SEARCH));
    listStore.setParams({'urecid':this.getUserid()});
    listStore.load();
  }
}}, 0, ['user-schedule-list-panel'], ['component', 'container', 'panel', 'user-schedule-list-panel'], {'component':true, 'container':true, 'panel':true, 'user-schedule-list-panel':true}, ['widget.user-schedule-list-panel'], 0, [Xedu.view.schedule, 'UserScheduleList'], 0);
Ext.cmd.derive('Xedu.view.users.UserDashBoard', Ext.Container, {config:{title:'My DashBoard', fullscreen:false, layout:{type:'hbox', pack:'start', align:'stretch'}, autoDestroy:true, defaults:{flex:1}, items:[{xtype:'user-enrolled-classes-list'}, {xtype:'user-schedule-list-panel'}, {xtype:'panel', html:'\x3cp\x3e wow look ...lots of free space...'}], listeners:{show:function(thisView, opts) {
  console.log('loading dashboard...');
  thisView.reloadDashBoard();
}}}, reloadDashBoard:function() {
  if (Xedu.CommonUtils.getLoggedInUserId()) {
    console.log('loading dashboard info for user \x3d ' + Xedu.CommonUtils.getLoggedInUserId().id);
    var usersEnrolledClassesList = this.down('user-enrolled-classes-list');
    if (usersEnrolledClassesList) {
      usersEnrolledClassesList.setUserid(Xedu.CommonUtils.getLoggedInUserId().id);
      usersEnrolledClassesList.loadEnrolledClasses();
    }
    var usersScheduleList = this.down('user-schedule-list-panel');
    if (usersScheduleList) {
      usersScheduleList.setUserid(Xedu.CommonUtils.getLoggedInUserId().id);
      usersScheduleList.loadSchedule();
    }
  }
}}, 0, ['user-dashboard-view'], ['component', 'container', 'user-dashboard-view'], {'component':true, 'container':true, 'user-dashboard-view':true}, ['widget.user-dashboard-view'], 0, [Xedu.view.users, 'UserDashBoard'], 0);
Ext.cmd.derive('Xedu.view.Home', Ext.Panel, {config:{title:'Home', fullscreen:false, layout:{type:'vbox', pack:'center', align:'stretch'}, defaults:{flex:1}, items:[{xtype:'list', itemId:'debugpanelid', docked:'bottom', height:100, hidden:false, emptyText:'No Data Loaded', store:{fields:['dt', 'msg']}, itemTpl:'\x3cspan\x3e{dt}\x3c/span\x3e\x3cspan\x3e{msg}\x3c/span\x3e'}, {xtype:'user-dashboard-view', flex:1}], listeners:{show:function() {
  this.down('user-dashboard-view').show();
}}}, reloadData:function() {
  var dashboard = this.down('user-dashboard-view');
  dashboard.reloadDashBoard();
}}, 0, ['home'], ['component', 'container', 'panel', 'home'], {'component':true, 'container':true, 'panel':true, 'home':true}, ['widget.home'], 0, [Xedu.view, 'Home'], 0);
Ext.cmd.derive('Xedu.model.EventModel', Ext.data.Model, {config:{fields:[{name:'id', type:'string'}, {name:'type', type:'string'}, {name:'msg', type:'string'}, {name:'from', type:'string'}, {name:'to', type:'auto'}, {name:'data', type:'auto'}]}}, 0, 0, 0, 0, 0, 0, [Xedu.model, 'EventModel'], 0);
Ext.cmd.derive('Xedu.view.session.SessionParticipantsView', Ext.Container, {config:{title:'Meeting Session', fullscreen:false, height:'100%', layout:'fit', eventSessionId:null, autoDestroy:true, defaults:{flex:1}, items:[{xtype:'panel', layout:'fit', bodyStyle:'background-color:yellow', items:[{xtype:'slides-fullview-list'}]}, {xtype:'slide-draw-component', itemId:'free-paint', hidden:false, top:0, left:0, width:Ext.Viewport.getWindowWidth(), height:Ext.Viewport.getWindowHeight()}], listeners:{show:function(thisView, 
opts) {
  thisView.loadSessionInformation();
}}}, loadSessionInformation:function() {
  if (this.getEventSessionId() == null) {
    Ext.Msg.alert('Invalid Session!', 'No event session id information found!', Ext.emptyFn);
    return;
  }
  var me = this;
  var progressIndicator = Ext.create('Ext.ProgressIndicator', {msg:'Verifying session participant ... '});
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.EVENT_SESSION_FULL_DETAILS) + this.getEventSessionId(), method:'GET', progress:progressIndicator, headers:{'Content-Type':'application/json'}, success:function(response, conn, options, eOpts) {
    var result = Ext.JSON.decode(response.responseText);
    console.log('Event schedule \x3d ' + result.eventSchedule.eventTitle);
    var slidesMainView = me.down('slides-fullview-list');
    slidesMainView.setHidden(true);
    slidesMainView.setTitle(result.eventSchedule.eventTitle);
    me.subscribeToSessionEvents(result.eventSession);
  }, failure:function(conn, response, options, eOpts) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, subscribeToSessionEvents:function(eventSession) {
  var cntrller = Xedu.app.getController('Main');
  var id = eventSession.eventSessionId;
  var sessionEndpoint = '/topic/sessionmessages/' + id;
  var me = this;
  if (cntrller.getActiveSessionSubscription()) {
    cntrller.getActiveSessionSubscription().unsubscribe();
  }
  var subscription = Xedu.CommonUtils.subscribeToStompQueue(sessionEndpoint, function(msg) {
    console.log('+++++++++++++++ RECIEVED on ', msg);
    var stompMsg = Ext.JSON.decode(msg.body);
    Xedu.CommonUtils.showInDebugPanel(msg);
    switch(stompMsg.type) {
      case 'ACTION_FAILED':
        Ext.Msg.alert('Error', stompMsg.msg, Ext.emptyFn);
        break;
      case 'ACTION_SESSION_JOIN':
        Ext.Msg.alert('Joined', stompMsg.msg, Ext.emptyFn);
        break;
      default:
        break;
    }
    if (stompMsg.from != cntrller.getLoggedInUser().userId) {
      var views = Ext.ComponentQuery.query('session-participants-view');
      if (views == null) {
        return;
      }
      var participantView = views[0];
      switch(stompMsg.type) {
        case 'ACTION_DRAW':
          var canvas = participantView.down('slide-draw-component');
          if (canvas) {
            var e = Ext.JSON.decode(stompMsg.msg);
            canvas.drawDrag(e, true);
          }
          break;
        case 'ACTION_DRAW_START':
          var canvas = participantView.down('slide-draw-component');
          if (canvas) {
            var e = Ext.JSON.decode(stompMsg.msg);
            canvas.drawStart(e, true);
          }
          break;
        case 'ACTION_DRAW_END':
          var canvas = participantView.down('slide-draw-component');
          if (canvas) {
            canvas.drawEnd(e, true);
          }
          break;
        case 'ACTION':
          {
            var actionMsg = Ext.JSON.decode(stompMsg.msg);
            var slideFullView = participantView.down('slides-fullview-list');
            var routesplit = actionMsg.route.split('/');
            var slideId = routesplit[3];
            var topicId = routesplit[1];
            slideFullView.setHidden(false);
            slideFullView.setTopicid(topicId);
            slideFullView.showSlideById(slideId);
          }
      }
    } else {
      console.log('message from ' + stompMsg.from);
    }
  });
  cntrller.setActiveSessionSubscription(subscription);
}}, 0, ['session-participants-view'], ['component', 'container', 'session-participants-view'], {'component':true, 'container':true, 'session-participants-view':true}, ['widget.session-participants-view'], 0, [Xedu.view.session, 'SessionParticipantsView'], 0);
Ext.cmd.derive('Xedu.view.classroom.ClassroomsList', Ext.Panel, {config:{layout:'vbox', items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'Classrooms', layout:{type:'hbox', pack:'right'}, defaults:{ui:'plain'}, items:[{xtype:'button', iconCls:'add', handler:function(but, action, eOpts) {
  this.up('classrooms-list-panel').createNewClassroom();
}}]}, {xtype:'searchfield', name:'searchclasses', placeHolder:'search classes..', align:'center', ui:'dark', height:50, listeners:{keyup:function(el, e, eOpts) {
  Xedu.CommonUtils.filterStore(this.up('classrooms-list-panel').down('list'), el.getValue());
}}}, {xtype:'list', flex:1, itemId:'classrooms-list-panel-id', title:'Classrooms', scrollable:true, autoDestroy:true, store:{type:'search-store'}, plugins:[{xclass:'Ext.plugin.PullRefresh', pullText:'Pull down to refresh the list!'}], itemTpl:['\x3cdiv\x3e', '\t\t\t\x3cspan style\x3d"color:gray"\x3eNo:\x3c/span\x3e {recordId} ', '\t\t\t\x3cspan style\x3d"color:gray"\x3eTitle: \x3c/span\x3e{recordTitle}, ', '\x3c/div\x3e'], listeners:{itemsingletap:function(scope, index, target, record) {
  console.log('tapped');
  Xedu.app.getController('Main').redirectTo('view/classroom/' + record.data.recordId + '/main');
}}}], listeners:{show:function(thisView, opts) {
  thisView.loadClassrooms();
}}}, loadClassrooms:function() {
  var thisView = this;
  console.log('Loading chapters for classrooms');
  thisView.setMasked({msg:'Loading classrooms...'});
  var classroomListStore = thisView.down('list').getStore();
  classroomListStore.getProxy().setUrl(Xedu.Config.getUrl(Xedu.Config.CLASSROOM_SEARCH));
  classroomListStore.load({callback:function(records, operation, success) {
    thisView.setMasked(false);
  }});
}, createNewClassroom:function() {
  Xedu.CommonUtils.showOverlay({xtype:'Xedu.view.classroom.ClassroomEditForm'}, {title:'Create New Classroom'});
}}, 0, ['classrooms-list-panel'], ['component', 'container', 'panel', 'classrooms-list-panel'], {'component':true, 'container':true, 'panel':true, 'classrooms-list-panel':true}, ['widget.classrooms-list-panel'], 0, [Xedu.view.classroom, 'ClassroomsList'], 0);
Ext.cmd.derive('Xedu.view.users.UserSelection', Ext.Container, {config:{title:'Select User', fullscreen:false, layout:{type:'card', animation:{type:'slide', direction:'left'}}, userSelectionMode:false, selectedUserId:null, autoDestroy:true, defaults:{flex:1}, items:[{docked:'top', xtype:'toolbar', ui:'light', title:'', layout:{pack:'left'}, items:[{xtype:'button', ui:'back', text:'Back', hidden:true, handler:function(but, action, eOpts) {
  this.up('user-selection-view').setActiveItem(0);
  this.up('user-selection-view').showBackButton(false);
}}]}, {xtype:'users-list-panel', listeners:{show:function(thisView) {
  var paneltitlebar = thisView.up('titlebar');
  console.log('setting callback handler for userslist');
  var userSelectionPanel = thisView.up('user-selection-view');
  thisView.setCallbackScope(userSelectionPanel);
  thisView.setCallbackOnSelect(userSelectionPanel.onUserSelect);
}}}, {xtype:'container', layout:{type:'hbox'}, items:[{docked:'bottom', xtype:'toolbar', ui:'dark', title:'', layout:{type:'hbox', pack:'center'}, items:[{xtype:'button', ui:'decline', text:'Remove user', itemId:'unEnrollButton', handler:function(but, action, eOpts) {
  this.up('enrollment-details-preview').unEnrollFromClass();
}}]}, {xtype:'user-details-preview', flex:1}, {xtype:'enrollment-edit-form', flex:3}]}], listeners:{show:function(thisView) {
  thisView.down('users-list-panel').loadUsers();
}}}, onUserSelect:function(id) {
  console.log('selected user \x3d' + id);
  var previewUserPanel = this.down('user-details-preview');
  previewUserPanel.setUserid(id);
  this.setActiveItem(1);
  this.showBackButton(true);
}, showBackButton:function(show) {
  this.down('toolbar').down('button[@ui\x3d"back"]').setHidden(!show);
}}, 0, ['user-selection-view'], ['component', 'container', 'user-selection-view'], {'component':true, 'container':true, 'user-selection-view':true}, ['widget.user-selection-view'], 0, [Xedu.view.users, 'UserSelection'], 0);
Ext.cmd.derive('Xedu.view.classroom.EnrolledStudentsList', Ext.Panel, {config:{layout:'vbox', classroomid:null, items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'Enrolled students', layout:{type:'hbox', pack:'right'}, defaults:{ui:'plain'}, items:[{xtype:'button', iconCls:'add', handler:function(but, action, eOpts) {
  this.up('enrolled-students-list-panel').addNewUser();
}}]}, {xtype:'searchfield', placeHolder:'Search ...', align:'center', ui:'dark', height:50, listeners:{keyup:function(el, e, eOpts) {
  Xedu.CommonUtils.filterStore(this.up('enrolled-students-list-panel').down('list'), el.getValue());
}}}, {xtype:'list', flex:1, itemId:'enrolled-students-list-panel-id', title:'Enrolled Students', scrollable:true, autoDestroy:true, store:{type:'search-store', autoLoad:false}, plugins:[{xclass:'Ext.plugin.PullRefresh', pullText:'Pull down to refresh the list!', refreshFn:function() {
  scope.up('enrolled-students-list-panel').loadEnrolledStudents();
}}], itemTpl:['\t\t\x3cdiv\x3e', '\t\t\t\x3cdiv\x3e', '\t\t\t\t\x3cspan style\x3d"color:gray"\x3eTitle: \x3c/span\x3e{recordTitle}, ', '\t\t\t\t\x3cspan style\x3d"color:gray"\x3e{recordSubTitle} \x3c/span\x3e ', '\t\t\t\x3c/div\x3e', '\t\t\x3c/div\x3e'], listeners:{itemsingletap:function(scope, index, target, record) {
  console.log('tapped student');
  scope.up('enrolled-students-list-panel').viewEnrollmentInfo(record, target);
}}}], listeners:{show:function(thisView, opts) {
  thisView.loadEnrolledStudents();
}}}, loadEnrolledStudents:function() {
  var thisView = this;
  console.log('Loading enrolled students...');
  thisView.setMasked({msg:'Loading classrooms...'});
  var classroomListStore = thisView.down('list').getStore();
  classroomListStore.getProxy().setUrl(Xedu.Config.getUrl(Xedu.Config.CLASSROOM_ENROLLED_STUDENTS_SEARCH) + '?classroomid\x3d' + this.getClassroomid());
  classroomListStore.load({callback:function(records, operation, success) {
    thisView.setMasked(false);
  }});
}, viewEnrollmentInfo:function(record, target) {
  Xedu.CommonUtils.showOverlay2({xtype:'enrollment-details-preview', enrollmentid:record.data.id, title:record.data.title, modal:true, autoDestroy:true, hideOnMaskTap:true, width:'50%', height:'65%', title:'Enrollment Info'}, target);
}, addNewUser:function() {
  Xedu.app.getController('Main').redirectTo('view/enrollment/user/new/classroom/' + this.getClassroomid());
}}, 0, ['enrolled-students-list-panel'], ['component', 'container', 'panel', 'enrolled-students-list-panel'], {'component':true, 'container':true, 'panel':true, 'enrolled-students-list-panel':true}, ['widget.enrolled-students-list-panel'], 0, [Xedu.view.classroom, 'EnrolledStudentsList'], 0);
Ext.cmd.derive('Xedu.view.schedule.ClassScheduleList', Ext.Panel, {config:{layout:'fit', classroomid:null, items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'Classroom Schedule', layout:{type:'hbox', pack:'right'}, defaults:{ui:'plain'}, items:[{xtype:'button', iconCls:'add', handler:function(but, action, eOpts) {
  this.up('classroom-schedule-list-panel').addNewSchedule();
}}]}, {xtype:'list', itemId:'classroom-schedule-list-panel-id', title:'Classroom Schedule', scrollable:true, autoDestroy:true, store:{type:'search-store', autoLoad:false}, plugins:[{xclass:'Ext.plugin.PullRefresh', pullText:'Pull down to refresh the list!', refreshFn:function() {
  scope.up('classroom-schedule-list-panel').loadSchedule();
}}], itemTpl:['\t\t\x3cdiv\x3e', '\t\t\t\x3cdiv\x3e', '\t\t\t\t\x3cspan style\x3d"color:gray"\x3eTitle: \x3c/span\x3e{recordTitle}, ', '\t\t\t\t\x3cspan style\x3d"color:gray"\x3e{recordSubTitle} \x3c/span\x3e ', '\t\t\t\x3c/div\x3e', '\t\t\x3c/div\x3e'], listeners:{itemsingletap:function(scope, index, target, record) {
  console.log('tapped schedule');
  scope.up('classroom-schedule-list-panel').viewScheduleInfo(record, target);
}}}], listeners:{show:function(thisView, opts) {
  thisView.loadSchedule();
}}}, loadSchedule:function() {
  var thisView = this;
  console.log('Loading schedule...');
  thisView.setMasked({msg:'Loading schedule...'});
  var listStore = thisView.down('list').getStore();
  listStore.getProxy().setUrl(Xedu.Config.getUrl(Xedu.Config.CLASSROOM_SCHEDULE_SEARCH) + '?classroomid\x3d' + this.getClassroomid());
  listStore.load({callback:function(records, operation, success) {
    thisView.setMasked(false);
  }});
}, viewScheduleInfo:function(record, target) {
  Xedu.CommonUtils.showOverlay2({xtype:'schedule-details-preview', eventScheduleId:record.data.id, title:record.data.title, centered:true, modal:true, autoDestroy:true, hideOnMaskTap:true, width:'50%', height:'85%', title:'Event Details'}, null);
}, addNewSchedule:function() {
  var clsid = this.getClassroomid();
  Xedu.CommonUtils.showOverlay2({xtype:'schedule-details-preview', eventScheduleId:'', classroomid:clsid, centered:true, modal:true, autoDestroy:true, hideOnMaskTap:true, width:'50%', height:'85%'}, null);
}, refreshStore:function() {
  var listStore = this.down('list').getStore();
  if (listStore) {
    listStore.getProxy().setUrl(Xedu.Config.getUrl(Xedu.Config.CLASSROOM_SCHEDULE_SEARCH) + '?classroomid\x3d' + this.getClassroomid());
    listStore.load();
  }
}}, 0, ['classroom-schedule-list-panel'], ['component', 'container', 'panel', 'classroom-schedule-list-panel'], {'component':true, 'container':true, 'panel':true, 'classroom-schedule-list-panel':true}, ['widget.classroom-schedule-list-panel'], 0, [Xedu.view.schedule, 'ClassScheduleList'], 0);
Ext.cmd.derive('Xedu.view.classroom.ClassroomMgmtMain', Ext.Container, {config:{title:'Classroom Management', fullscreen:false, layout:'fit', classroomid:null, autoDestroy:true, defaults:{flex:1}, items:[{xtype:'tabpanel', flex:4, items:[{title:'Classroom Info', xtype:'container', layout:'fit', flex:1, items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'', layout:{pack:'right'}, defaults:{ui:'plain'}, items:[{xtype:'button', iconCls:'add', handler:function(but, action, eOpts) {
}}]}, {xtype:'classroom-edit-form', flex:1}]}, {xtype:'enrolled-students-list-panel', title:'Enrolled Students'}, {xtype:'classroom-schedule-list-panel', title:'Schedule'}, {xtype:'panel', title:'Classroom Progress'}]}], listeners:{show:function(thisView, opts) {
  var classroomEditForm = thisView.down('classroom-edit-form');
  var enrolledStudentsList = thisView.down('enrolled-students-list-panel');
  enrolledStudentsList.setClassroomid(thisView.getClassroomid());
  enrolledStudentsList.loadEnrolledStudents();
  var scheduleList = thisView.down('classroom-schedule-list-panel');
  scheduleList.setClassroomid(thisView.getClassroomid());
  classroomEditForm.loadClassroom(thisView.getClassroomid());
}}}}, 0, ['classroom-mgmt-main-view'], ['component', 'container', 'classroom-mgmt-main-view'], {'component':true, 'container':true, 'classroom-mgmt-main-view':true}, ['widget.classroom-mgmt-main-view'], 0, [Xedu.view.classroom, 'ClassroomMgmtMain'], 0);
Ext.cmd.derive('Xedu.view.classroom.ClassroomInSession', Ext.Container, {config:{title:'Classroom In Session', fullscreen:false, layout:'fit', eventSessionId:null, autoDestroy:true, defaults:{flex:1}, items:[{xtype:'tabpanel', items:[{xtype:'slides-main-view', classroomSessionMode:true, title:'Classroom Progress'}, {xtype:'enrolled-students-list-panel', title:'Enrolled Students'}]}, {xtype:'slides-fullview', title:'Classroom Progress', hidden:true}], listeners:{show:function(thisView, opts) {
  thisView.loadClassroomCourseContents();
}}}, loadClassroomCourseContents:function() {
  if (this.getEventSessionId() == null) {
    Ext.Msg.alert('Invalid Session!', 'No event session id information found!', Ext.emptyFn);
    return;
  }
  var me = this;
  var progressIndicator = Ext.create('Ext.ProgressIndicator', {msg:'Loading event session information'});
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.EVENT_SESSION_FULL_DETAILS) + this.getEventSessionId(), method:'GET', progress:progressIndicator, headers:{'Content-Type':'application/json'}, success:function(response, conn, options, eOpts) {
    var result = Ext.JSON.decode(response.responseText);
    var eventRecord = Ext.create('Xedu.model.EventScheduleModel', result.eventSchedule);
    var slidesMainView = me.down('slides-main-view');
    slidesMainView.setCourseid(result.classroom.courseRecordId);
    slidesMainView.setPresenterMode(result.eventSession.presenter);
    slidesMainView.loadCourseChaptersList();
    me.loadClassroomEnrolledStudents(result.classroom.id);
  }, failure:function(conn, response, options, eOpts) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, loadClassroomEnrolledStudents:function(classroomid) {
  var enrolledStudentsList = this.down('enrolled-students-list-panel');
  enrolledStudentsList.setClassroomid(classroomid);
  enrolledStudentsList.loadEnrolledStudents();
}}, 0, ['classroom-in-session-view'], ['component', 'container', 'classroom-in-session-view'], {'component':true, 'container':true, 'classroom-in-session-view':true}, ['widget.classroom-in-session-view'], 0, [Xedu.view.classroom, 'ClassroomInSession'], 0);
Ext.cmd.derive('Xedu.controller.Main', Ext.app.Controller, {config:{loggedInUser:null, sessionInfo:null, wsConn:null, stompClient:null, saveAction:null, activeSessionSubscription:null, presenterTopicEndpoint:false, before:{showView:'authenticate', showHome:'authenticate'}, refs:{mainViewNavigation:'mainview', loginView:'loginview'}, routes:{'home':'showHome', 'view/:id':'showView', 'config':'showConfig', 'logoff':'logout', 'update/password/:token':'chgPassword', 'view/classroom/list':'showClassrooms', 
'view/classroom/:id/main':'showClassroomMgmt', 'view/join/classroom/session/:eventsessionid':'showClassroomInSession', 'view/join/participants/session/:eventsessionid':'showSessionForParticipants', 'view/manage/users':'showUserMgmt', 'view/user/:id':'showUserDetails', 'view/course/list':'showCourses', 'view/course/:id/main':'showCourseMgmt', 'view/course/:id/chapters':'showChapters', 'view/chapter/:chpid/topics':'showTopics', 'view/topic/:topicid':'showSlides', 'view/topic/:topicid/slide/:slideid':'showSlideFullView', 
'view/course/:cid/chapter/:chpid/topic/:topicid/upload':'uploadSlides', 'open/:applid':'openApplicationView', 'edit/:applid':'editApplicationInfo', 'search/name/:param':'showSearchResults', 'view/enrollment/user/:userrecordid/classroom/:classid':'showEnrollmentEditForm', 'edit/enrollment/:enrollmentid':'showEnrollmentEditForm', 'view/eventschedule/edit/:id':'showEventScheduleEditForm'}}, authenticate:function(action) {
  console.log(' checking user info....');
  if (this.getLoggedInUser()) {
    var navtoview = Ext.Viewport.down('loginview');
    if (navtoview != null) {
      console.log('about to destroy login view .....');
      Ext.Viewport.remove(navtoview, true);
      Ext.Viewport.setActiveItem(0);
    }
    action.resume();
  } else {
    this.showLogin();
  }
}, verifyLoggedInUser:function(toview, params) {
  console.log('about to verify user ...');
  if (this.getLoggedInUser() == null) {
    this.setSaveAction({'view':toview, 'p':params});
    this.showLogin();
    return false;
  } else {
    console.log(this.getLoggedInUser().id);
    return true;
  }
}, resumeSavedAction:function() {
  console.log('inside resumeSavedAction...');
  var result = this.establishSocketConnection();
  var savedAction = this.getSaveAction();
  if (savedAction && savedAction != '' && savedAction != null) {
    this.redirectToView(savedAction.view, savedAction.p);
  } else {
    console.log('** No action found ...so redirecting to default view home');
    this.redirectTo('home');
  }
}, establishSocketConnection:function() {
  console.log('trying to establish stomp socket connection!!!!');
  var sessionInfo = Xedu.CommonUtils.getSessionInfo();
  var sock = new SockJS(Xedu.Config.getUrl(Xedu.Config.EVENT_SESSION_SOCKET_SERVER));
  this.stompClient = Stomp.over(sock);
  var autoReconnect = true;
  var mainCntrller = this;
  var thisStompClient = this.stompClient;
  this.stompClient.connect(Ext.Ajax._defaultHeaders, function(frame) {
    console.log('Connected: ' + frame);
    Xedu.CommonUtils.showInDebugPanel(frame);
    Xedu.CommonUtils.subscribeToStompQueue('/topic/general_app_message_topic', function(msg) {
      console.log('---------------- RECIEVED generic message', msg);
      var stompMsg = Ext.JSON.decode(msg.body);
      Xedu.CommonUtils.showInDebugPanel(msg);
      switch(stompMsg.type) {
        case 'ACTION_FAILED':
          Ext.Msg.alert('Error#MC-ESC-1000', stompMsg.msg, Ext.emptyFn);
        default:
          Ext.Msg.alert('Error#MC-ESC-1001', stompMsg.msg, Ext.emptyFn);
      }
    });
  }, function(message) {
    Xedu.CommonUtils.showInDebugPanel(message);
    if (message.indexOf('Lost connection') > -1) {
      if (autoReconnect) {
        var task = Ext.create('Ext.util.DelayedTask', function() {
          var cntrller = Xedu.app.getController('Main');
          cntrller.establishSocketConnection();
        });
        console.log('will trying to auto reconnect in 3 secs.....');
        task.delay(3000);
      }
    }
  });
  return true;
}, showHome:function() {
  console.log('about to redirect to home');
  this.resetMainViewNavigation();
  this.getMainViewNavigation().setActiveItem('home');
  Ext.ComponentQuery.query('home')[0].reloadData();
}, showView:function(toview, params) {
  if (!this.verifyLoggedInUser(toview, params)) {
    return;
  }
  console.log('inside showView about to render ' + toview + ' param \x3d ' + params + ' user role \x3d ' + this.getLoggedInUser().userrole);
  var viewClass = 'Xedu.view.' + toview;
  if (params) {
    navtoview = Ext.create(viewClass, params);
  } else {
    navtoview = Ext.create(viewClass);
  }
  this.getMainViewNavigation().push(navtoview);
  this.getMainViewNavigation().setActiveItem(navtoview);
  navtoview.show();
}, showSectionView:function(toViewWithParams, params) {
  console.log('about to process routing for view \x3d ' + toViewWithParams + ', params\x3d' + params);
  var paramdelimiter = toViewWithParams.indexOf(';');
  var viewid = paramdelimiter > -1 ? toViewWithParams.substr(0, paramdelimiter) : toViewWithParams;
  var params = {};
  this.showView(viewid, params);
}, redirectToView:function(toview, params) {
  this.getMainViewNavigation().pop();
  this.showView(toview, params);
}, showLogin:function(params) {
  console.log(' redirecting to login screen....');
  var navtoview = Ext.ComponentQuery.query('loginview');
  if (navtoview != null && navtoview[0] != null) {
    navtoview[0].destroy();
  }
  navtoview = Ext.create('Xedu.view.Login');
  Ext.Viewport.add(navtoview);
  navtoview.show();
}, logout:function() {
  console.log('logging out user');
  this.setLoggedInUser(null);
  this.getMainViewNavigation().removeAll();
  var authUrl = Xedu.Config.getUrl(Xedu.Config.AUTH_USER_LOGOUT);
  Ext.Viewport.mask({msg:'Logging out...'});
  Ext.Ajax.request({url:authUrl, method:'POST', headers:{'Content-Type':'application/json'}, success:function(resp, conn) {
    Ext.Viewport.setMasked(false);
    var response = Ext.JSON.decode(resp.responseText);
    var cntrller = Xedu.app.getController('Main');
    if (response.status == 'SUCCESS') {
      console.log('Logout.....success ');
    } else {
    }
  }, failure:function() {
    Ext.Viewport.setMasked(false);
  }});
  this.resetMainViewNavigation();
  this.showLogin();
}, chgPassword:function(p) {
  console.log('recived p \x3d ' + p);
  var params = {'authToken':p};
  this.showView('ChangePassword', params);
}, showConfig:function() {
  console.log(' showing config screen....');
  this.showView('config.ConfigMain');
}, showEnrollmentEditForm:function(id1, id2) {
  var params = {};
  console.log(' param 1 \x3d ' + id1 + ' param 2 ' + id2);
  if (id2) {
    params = {'userRecordId':id1, 'classroomid':id2};
  } else {
    params = {'enrollmentid':id1};
  }
  this.showView('classroom.EnrollmentEditForm', params);
}, showEventScheduleEditForm:function(id, p) {
  console.log(p);
  var params = {'eventScheduleId':id, 'previewOnly':false};
  this.showView('schedule.ScheduleDetailsPreview', params);
}, showUserMgmt:function(param) {
  this.showView('users.UserMgmtMain', param);
}, showUserDetails:function(param) {
  var params = {'userid':param};
  this.showView('users.UserDetailsView', params);
}, showClassroomMgmt:function(classroomId) {
  var params = {'classroomid':classroomId};
  this.showView('classroom.ClassroomMgmtMain', params);
}, showClassroomInSession:function(eventSessionId) {
  var params = {'eventSessionId':eventSessionId};
  this.showView('classroom.ClassroomInSession', params);
}, showSessionForParticipants:function(eventSessionId) {
  var params = {'eventSessionId':eventSessionId};
  this.showView('session.SessionParticipantsView', params);
}, showClassrooms:function(param) {
  this.showView('classroom.ClassroomsList', param);
}, showCourseMgmt:function(courseId) {
  var params = {'courseid':courseId};
  this.showView('course.CourseMgmtMain', params);
}, showCourses:function(param) {
  this.showView('course.CoursesList', param);
}, showChapters:function(courseId) {
  var params = {'courseid':courseId};
  this.showView('chapter.ChaptersList', params);
}, showTopics:function(chapterId) {
  var params = {'chapterid':chapterId};
  this.showView('topic.TopicsList', params);
}, showSlides:function(topicId, slideId) {
  var params = {'topicid':topicId, 'slideid':slideId};
  this.showView('slides.SlidesMain', params);
}, showSlideFullView:function(topicId, slideId) {
  var params = {'topicid':topicId, 'slideid':slideId, 'classroomSessionMode':true};
  this.redirectToView('slides.SlidesMain', params);
}, uploadSlides:function(courseId, chapterId, topicId) {
  var params = {'courseid':courseId, 'chapterid':chapterId, 'topicid':topicId};
  this.showView('slides.ContentUpload', params);
}, showGlobalMenu:function(button) {
  Ext.Viewport.toggleMenu('right');
}, redirectToUrl:function(el, record) {
  var toUrl = record.get('navUrl');
  this.redirectTo(toUrl);
  Ext.Viewport.toggleMenu('right');
}, resetMainViewNavigation:function() {
  var items = this.getMainViewNavigation().getInnerItems();
  this.getMainViewNavigation().getLayout().setAnimation(false);
  console.log('about to reset items in navigation items \x3d' + items.length);
  for (i = items.length - 1; i > 0; i--) {
    if (items[i].xtype != 'home') {
      console.log('...............removing inner item \x3d' + items[i].xtype);
      this.getMainViewNavigation().removeInnerAt(i);
    } else {
      console.log('reached home...');
    }
  }
  this.getMainViewNavigation().getLayout().setAnimation(true);
}, setAuthorizationHeader:function(token) {
  this.xAuthToken = token;
  Ext.Ajax._defaultHeaders = {'X-Authorization':token};
}}, 0, 0, 0, 0, 0, 0, [Xedu.controller, 'Main'], 0);
Ext.cmd.derive('Xedu.store.CoursesStore', Ext.data.Store, {require:['Xedu.Config', 'Ext.data.proxy.Rest'], config:{fields:[{name:'recordId', type:'string'}, {name:'recordTitle', type:'string'}, {name:'recordSubtitle', type:'string'}], pageSize:10, remoteSort:false, autoLoad:true, proxy:{type:'rest', url:Xedu.Config.getUrl(Xedu.Config.COURSE_SEARCH), reader:{type:'json', idProperty:'recordId', rootProperty:'hits', totalProperty:'totalHits'}, filterParam:'name'}}}, 0, 0, 0, 0, ['store.courses-store'], 
0, [Xedu.store, 'CoursesStore'], 0);
Ext.cmd.derive('Xedu.view.Login', Ext.form.Panel, {config:{title:'Login', itemId:'loginformpanelid', height:'100%', width:'100%', scrollable:true, initiateLogout:false, fullscreen:true, layout:{type:'vbox', pack:'center', align:'center'}, items:[{xtype:'titlebar', title:'Login', docked:'top', height:50}, {xtype:'container', width:'30%', height:'100%', flex:1, items:[{xtype:'label', html:'', itemId:'show-msg', hidden:true, hideAnimation:'fadeOut', showAnimation:'fadeIn', style:'color:#990000;margin:5px 0px;'}, 
{xtype:'fieldset', title:'Login', itemId:'login-fieldset', items:[{xtype:'textfield', placeHolder:'Username', label:'User Name', itemId:'userNameTextField', name:'user', required:true}, {xtype:'passwordfield', placeHolder:'Password', label:'Password', itemId:'passwordTextField', name:'pwd', required:true}]}, {xtype:'container', layout:{pack:'center', type:'vbox', align:'center'}, items:[{xtype:'button', itemId:'logInButton', ui:'confirm', text:'Login', width:'75%', action:'login', handler:function(btn) {
  this.up('loginview').login();
}}, {xtype:'button', itemId:'resetPswdButton', hidden:false, ui:'confirm', text:'Reset Password', width:'75%', handler:function(btn) {
  this.up('loginview').forgotPassword();
}}]}]}], listeners:{show:function(thisView) {
  console.log('showing login view...');
  thisView.checkSession();
}}}, showMessage:function(status, msg) {
  var label = this.down('#show-msg');
  label.setHtml(status + ' - ' + msg);
  label.setHidden(false);
}, checkSession:function() {
  var cntrller = Xedu.app.getController('Main');
  if (cntrller.getLoggedInUser()) {
    return;
  }
  var authUrl = Xedu.Config.getUrl(Xedu.Config.AUTH_USER_SERVICE);
  console.log('about to check for session!!');
  var progressIndicator = Ext.create('Ext.ProgressIndicator', {loadingText:'Checking user session...'});
  Ext.Ajax.request({url:authUrl, method:'GET', progress:progressIndicator, headers:{'Content-Type':'application/json'}, success:function(resp, conn) {
    Ext.Viewport.setMasked(false);
    var response = Ext.JSON.decode(resp.responseText);
    if (response.status == 'SUCCESS') {
      console.log('checking for existing user session info.....success ' + response.userInfo.userId);
      cntrller.setLoggedInUser(response.userInfo);
      cntrller.setSessionInfo(response.sessionInfo);
      Ext.Viewport.removeInnerAt(1);
      Ext.Viewport.setActiveItem(0);
      if (response.sessionInfo && response.userInfo && response.userInfo.changePswd) {
        console.log('redirecting to change password...');
        cntrller.redirectTo('update/password/' + response.sessionInfo.id);
      } else {
        cntrller.resumeSavedAction();
      }
    } else {
    }
  }, failure:function() {
  }});
}, login:function() {
  var me = this;
  var loginForm = Ext.ComponentQuery.query('loginview')[0];
  var authUrl = Xedu.Config.getUrl(Xedu.Config.AUTH_SERVICE);
  var progressIndicator = Ext.create('Ext.ProgressIndicator', {loadingText:'Checking user session...'});
  loginForm.submit({url:authUrl, progress:progressIndicator, success:function(form, response) {
    console.log('login successfull.....');
    Ext.Viewport.setMasked(false);
    var cntrller = Xedu.app.getController('Main');
    if (response.status == 'SUCCESS') {
      cntrller.setLoggedInUser(response.userInfo);
      cntrller.setSessionInfo(response.sessionInfo);
      cntrller.setAuthorizationHeader(response.jwtToken);
      Ext.Viewport.removeInnerAt(1);
      Ext.Viewport.setActiveItem(0);
      Ext.Viewport.setMasked(false);
      console.log('checking change password.....' + response.userInfo.changePswd);
      if (response.sessionInfo && response.userInfo.changePswd) {
        console.log('redirecting to change password...');
        cntrller.redirectTo('update/password/' + response.sessionInfo.id);
      } else {
        cntrller.resumeSavedAction();
      }
    } else {
      me.showMessage(response.status, response.msg);
    }
  }, failure:function(form, response) {
    Ext.Viewport.setMasked(false);
    Xedu.CommonUtils.checkServiceError(response);
    me.showMessage(response.status, response.msg);
  }});
}, forgotPassword:function() {
  var me = this;
  var authUrl = Xedu.Config.getUrl(Xedu.Config.AUTH_FORGOT_PASSWORD_SERVICE);
  Ext.Msg.prompt('Reset Password', 'Please provide your account email address', function(but, val) {
    console.log('resetting password for email \x3d' + val);
    if (but == 'ok') {
      Ext.Viewport.mask({msg:'Resetting your password'});
      var me = this;
      Ext.Ajax.request({url:authUrl, method:'POST', params:{email:val}, callback:function(opts, success, response) {
        Ext.Viewport.setMasked(false);
        Xedu.CommonUtils.checkServiceError(response);
        var srvRespse = Ext.JSON.decode(response.responseText);
        Ext.Msg.alert(srvRespse.status, srvRespse.msg, Ext.emptyFn);
      }});
    }
  });
}}, 0, ['loginview'], ['component', 'container', 'panel', 'formpanel', 'loginview'], {'component':true, 'container':true, 'panel':true, 'formpanel':true, 'loginview':true}, ['widget.loginview'], 0, [Xedu.view, 'Login'], 0);
Ext.cmd.derive('Xedu.view.course.CoursesList', Ext.Panel, {config:{fullscreen:true, title:'Courses', callbackScope:null, callbackOnSelect:null, closeOnSelect:true, layout:{type:'vbox', pack:'start'}, items:[{docked:'top', xtype:'titlebar', ui:'neutral', title:'Courses', layout:{type:'hbox', pack:'right'}, defaults:{ui:'plain'}, items:[{xtype:'button', iconCls:'add', handler:function(but, action, eOpts) {
  this.up('courses-list-panel').createNewCourse();
}}]}, {xtype:'searchfield', name:'searchcourses', placeHolder:'search courses..', align:'center', ui:'dark', height:50, listeners:{keyup:function(el, e, eOpts) {
  this.up('courses-list-panel').searchRecords(el.getValue());
}}}, {xtype:'list', itemId:'courses-list-panel-id', title:'Courses', scrollable:true, flex:1, autoDestroy:true, store:{type:'courses-store'}, plugins:[{xclass:'Ext.plugin.PullRefresh', pullText:'Pull down to refresh the list!'}], itemTpl:['\x3cdiv\x3e', '\t\t\t\x3cspan style\x3d"color:gray"\x3eNo:\x3c/span\x3e {recordId} ', '\t\t\t\x3cspan style\x3d"color:gray"\x3eTitle: \x3c/span\x3e{recordTitle}, ', '\x3c/div\x3e'], listeners:{itemsingletap:function(scope, index, target, record) {
  console.log('tapped');
  scope.up('courses-list-panel').courseSelected(record);
}}}]}, searchRecords:function(searchvalue) {
  Xedu.CommonUtils.filterStore(this.down('list'), searchvalue);
}, loadChapters:function(id) {
  var courseDetailsForm = this;
  console.log('Loading chapters for course id \x3d' + id);
  var progressIndicator = Ext.create('Ext.ProgressIndicator');
  Ext.Ajax.request({url:Xedu.Config.getUrl(Xedu.Config.COURSE_API) + id, method:'GET', progress:progressIndicator, headers:{'Content-Type':'application/json'}, success:function(response, conn, options, eOpts) {
    var result = Ext.JSON.decode(response.responseText);
    this.down('list').getStore().load(result.chapters);
  }, failure:function(conn, response, options, eOpts) {
    Xedu.CommonUtils.checkServiceError(resp);
  }});
}, createNewCourse:function() {
  Xedu.CommonUtils.showOverlay({xtype:'Xedu.view.course.CourseEditForm'}, {title:'Create New Course'});
}, courseSelected:function(record) {
  if (this.getCallbackOnSelect()) {
    console.log('about to handle call back');
    this.handleCallback(record.data.id);
  } else {
    Xedu.app.getController('Main').redirectTo('view/course/' + record.data.recordId + '/main');
  }
}, handleCallback:function(param) {
  console.log('handling callback for courses... ');
  var callbck = this.getCallbackOnSelect();
  var scope = this.getCallbackScope();
  if (typeof callbck == 'function') {
    if (!scope) {
      console.error('Missing scope inside callbackConfig ');
    } else {
      callbck.apply(scope, [param]);
    }
  }
  if (this.getCloseOnSelect()) {
    this.hide();
  }
}}, 0, ['courses-list-panel'], ['component', 'container', 'panel', 'courses-list-panel'], {'component':true, 'container':true, 'panel':true, 'courses-list-panel':true}, ['widget.courses-list-panel'], 0, [Xedu.view.course, 'CoursesList'], 0);
Ext.cmd.derive('Xedu.view.Main', Ext.navigation.View, {config:{itemId:'mainviewid', fullscreen:true, autoDestroy:true, listener:{pop:function(cnt, item) {
  console.log('nav pop listener');
  Ext.Function.defer(function() {
    cnt.remove(item, true);
  }, 100);
}, show:function() {
  console.log('showing main navigation....check for login..');
}}, navigationBar:{items:[{xtype:'searchfield', placeHolder:'Search ..', align:'right', listeners:{action:function(e) {
  var cntrller = Xedu.app.getController('Main');
  cntrller.redirectTo('open/' + e.getValue());
}}}, {xtype:'button', iconCls:'list', iconMask:true, align:'right', itemId:'mainmenubutton', handler:function(button) {
  Ext.Viewport.toggleMenu('right');
}}]}, items:[{xtype:'home', title:'Home'}]}}, 0, ['mainview'], ['component', 'container', 'navigationview', 'mainview'], {'component':true, 'container':true, 'navigationview':true, 'mainview':true}, ['widget.mainview'], 0, [Xedu.view, 'Main'], 0);
Ext.cmd.derive('Xedu.view.main.SideMenu', Ext.Menu, {config:{items:[{text:'Home', iconCls:'home', scope:this, handler:function() {
  Ext.Viewport.hideMenu('right');
  var main = Xedu.app.getController('Main');
  main.redirectTo('home');
}}, {text:'Settings', iconCls:'settings', scope:this, handler:function() {
  Ext.Viewport.hideMenu('right');
  Xedu.app.getController('Main').redirectTo('config');
}}, {text:'Users', iconCls:'user', scope:this, handler:function() {
  Ext.Viewport.hideMenu('right');
  Xedu.app.getController('Main').redirectTo('view/manage/users');
}}, {text:'Classes', iconCls:'search', scope:this, handler:function() {
  Ext.Viewport.hideMenu('right');
  Xedu.app.getController('Main').redirectTo('view/classroom/list');
}}, {text:'Courses', iconCls:'search', scope:this, handler:function() {
  Ext.Viewport.hideMenu('right');
  Xedu.app.getController('Main').redirectTo('view/course/list');
}}, {text:'Search', iconCls:'search', scope:this, handler:function() {
  Ext.Viewport.hideMenu('right');
  Xedu.app.getController('Main').redirectTo('view/SearchInfoFormPanel');
}}, {text:'New Application', iconCls:'compose', scope:this, handler:function() {
  Ext.Viewport.hideMenu('right');
  Xedu.app.getController('Main').redirectTo('view/app_create_update_from_panel');
}}, {xtype:'button', text:'Open Application', iconCls:'bookmarks', scope:this, handler:function() {
  Ext.Viewport.hideMenu('right');
}}, {xtype:'button', text:'Logoff', itemId:'logOffButton', align:'right', handler:function() {
  Ext.Viewport.hideMenu('right');
  Xedu.app.getController('Main').redirectTo('logoff');
}}, {xtype:'button', text:'Show Debug', itemId:'toggleDebugButton', align:'right', handler:function() {
  var debugPanel = Ext.ComponentQuery.query('#debugpanelid')[0];
  console.log('showing debug panel \x3d ' + debugPanel.isHidden());
  if (!debugPanel.isHidden()) {
    debugPanel.getStore().removeAll();
  }
  debugPanel.setHidden(!debugPanel.isHidden());
  Ext.Viewport.hideMenu('right');
}}, {xtype:'button', text:'Reload App', itemId:'reloadAppButton', align:'right', handler:function() {
  location.reload();
}}]}}, 0, 0, ['component', 'container', 'panel', 'sheet', 'menu'], {'component':true, 'container':true, 'panel':true, 'sheet':true, 'menu':true}, 0, 0, [Xedu.view.main, 'SideMenu'], 0);
function _93e485d9004e1197927e4334cb3c53dda2d97003() {
}
function _afdfc7b96f8a9952919388108711a3d9b1d25176() {
}
function _0474114cea6da4e42f4e600e744d5100089a40ed() {
}
function _a6be30a34dcdd6dd9ee4b539ad9101c99a3ec256() {
}
function _f9ba2e747391a14348a1c4c0a8641f85bd4c7a78() {
}
function _1c0ede60dc665659dfafecccb181c57466635e4a() {
}
function _f2c99c02f65f25f0ed2a121b5fa1b7e5a5b6ddad() {
}
function _12d495bb42620dc17930cb0f5dd99e83c158425a() {
}
function _d802828ea23f49e2adb3a0a5838253c174de7fd4() {
}
function _c86db8b583f9bc78db2bebf9cfd7673ea8f7b4ef() {
}
function _c6aa5578c710d4e29f66132ec9715ba94c597ff4() {
}
function _6397ac22df86e95c6c50ea36db75fc653016c59c() {
}
function _2d4bc186f4d4b461e5cdb9f584f6c162ba5442ec() {
}
function _34ab03d65e77e0d8cec923ea1cf0ee7c552f48e5() {
}
function _cafede35948246f4cc1797f04e5ab4f841779ef6() {
}
function _3c35b33da8b675f7c5125e91c7d72cde6ce88cf7() {
}
function _72dc615499b4d65f07c92e3ce2ab0c4f6e5d1b71() {
}
function _d006fdfa260c7990ed879385e592e7330d1561f7() {
}
var mouseWheelHandler = function(e) {
  var e = window.event || e, el = e.target, cmp, offset, scroller, delta, _results = [];
  e.preventDefault();
  while (el !== document.body) {
    if (el && el.className && el.className.indexOf('x-container') >= 0) {
      cmp = Ext.getCmp(el.id);
      if (cmp && typeof cmp.getScrollable == 'function' && cmp.getScrollable()) {
        scroller = cmp.getScrollable().getScroller();
        if (scroller) {
          delta = e.detail ? e.detail * -120 : e.wheelDelta;
          offset = {x:0, y:-delta * 0.5};
          scroller.fireEvent('scrollstart', scroller, scroller.position.x, scroller.position.y, e);
          scroller.scrollBy(offset.x, offset.y);
          scroller.snapToBoundary();
          scroller.fireEvent('scrollend', scroller, scroller.position.x, scroller.position.y - offset.y);
          break;
        }
      }
    }
    _results.push(el = el.parentNode);
  }
  return _results;
};
if (document.addEventListener) {
  document.addEventListener('mousewheel', mouseWheelHandler, false);
  document.addEventListener('DOMMouseScroll', mouseWheelHandler, false);
} else {
  document.attachEvent('onmousewheel', mouseWheelHandler);
}
Ext.application({name:'Xedu', controllers:['Main'], views:['Main'], icon:{57:'resources/icons/Icon.png', 72:'resources/icons/Icon~ipad.png', 114:'resources/icons/Icon@2x.png', 144:'resources/icons/Icon~ipad@2x.png'}, isIconPrecomposed:true, startupImage:{'320x460':'resources/startup/320x460.jpg', '640x920':'resources/startup/640x920.png', '768x1004':'resources/startup/768x1004.png', '748x1024':'resources/startup/748x1024.png', '1536x2008':'resources/startup/1536x2008.png', '1496x2048':'resources/startup/1496x2048.png'}, 
launch:function() {
  Ext.fly('appLoadingIndicator').destroy();
  Ext.Viewport.add(Ext.create('Xedu.view.Main'));
  Ext.Msg.defaultAllowedConfig.showAnimation = false;
  var config = Xedu.Config;
  Ext.Viewport.setMenu(Ext.create('Xedu.view.main.SideMenu'), {side:'right', reveal:true});
  Xedu.Config.loadAppConfigs();
  var routeTo = window.location.hash.substr(1);
  if (routeTo == '') {
    routeTo = 'home';
  }
  var cntrller = Xedu.app.getController('Main');
  cntrller.redirectTo(routeTo);
}, onUpdated:function() {
  Ext.Msg.confirm('Application Update', 'This application has just successfully been updated to the latest version. Reload now?', function(buttonId) {
    if (buttonId === 'yes') {
      window.location.reload();
    }
  });
}});
